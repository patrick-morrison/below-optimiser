<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BelowJS - Drag & Drop Viewer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåä</text></svg>">
    
    <!-- Import map for CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.170.0",
            "belowjs": "./belowjs.js",
            "@gltf-transform/core": "https://esm.sh/@gltf-transform/core@4",
            "@gltf-transform/extensions": "https://esm.sh/@gltf-transform/extensions@4",
            "@gltf-transform/functions": "https://esm.sh/@gltf-transform/functions@4",
            "meshoptimizer": "https://esm.sh/meshoptimizer@0.21.0",
            "ktx2-encoder": "https://esm.sh/ktx2-encoder",
            "ktx2-encoder/gltf-transform": "https://esm.sh/ktx2-encoder/gltf-transform"
        }
    }
    </script>

    <!-- Load Draco encoder (browser build) -->
    <script src="https://unpkg.com/draco3dgltf@1.5.7/draco_encoder_gltf_nodejs.js"></script>
    
    <link rel="stylesheet" href="./belowjs.css">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0f172a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
  /* Drag and drop overlay */
    .drag-drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
  z-index: 2000;
  pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
        
        .drag-drop-overlay.visible {
            opacity: 1;
        }

    .drag-drop-overlay .panel {
      border: 2px dashed #475569;
      border-radius: 16px;
      padding: 28px 32px;
      text-align: center;
      background: rgba(2, 6, 23, 0.35);
      box-shadow: 0 12px 32px rgba(0,0,0,0.45);
      width: min(720px, calc(100% - 80px));
    }
        
  /* (removed unused drag-drop-hint and animation) */
        
        /* Empty state styling */
        .empty-state {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #e2e8f0;
            z-index: 1000;
            pointer-events: none;
        }
        
        .empty-state h2 {
            font-size: 2.5em;
            margin: 0 0 16px 0;
            font-weight: 300;
        }
        
        .empty-state p {
            font-size: 1.2em;
            margin: 8px 0;
            opacity: 0.8;
        }
        
        .file-select-button {
            display: inline-block;
            margin-top: 24px;
            padding: 12px 24px;
            background: rgba(59, 130, 246, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            pointer-events: auto;
            transition: background 0.3s ease;
        }
        
        .file-select-button:hover {
            background: rgba(59, 130, 246, 1);
        }
        
        #fileInput {
            display: none;
        }
        
        /* Loaded state hint */
        .loaded-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.8);
            color: #94a3b8;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loaded-hint.visible {
            opacity: 0.7;
        }

  /* Camera snippet */
    .camera-snippet {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1001;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
            width: 336px;
      pointer-events: auto;
    }
  .camera-snippet .copy-btn {
      background: rgba(59, 130, 246, 0.9);
      color: #ffffff;
      border: none;
      border-radius: 6px;
      font-size: 11px; /* smaller button */
      padding: 4px 8px; /* smaller padding */
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .camera-snippet .copy-btn:hover {
      background: rgba(59, 130, 246, 1);
    }
    /* Compact ghost-style copy button inside card (bottom-right) */
    .camera-snippet .copy-fab {
      position: absolute;
      right: 8px;
      bottom: 8px;
      background: rgba(30, 41, 59, 0.7);
      color: #cbd5e1;
      border: 1px solid #334155;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1;
      padding: 6px 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      cursor: pointer;
      backdrop-filter: saturate(1.2) blur(1px);
    }
    .camera-snippet .copy-fab:hover {
      background: rgba(59, 130, 246, 0.9);
      border-color: #1d4ed8;
      color: #ffffff;
    }
  .camera-snippet pre {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.4;
      color: #e2e8f0;
            white-space: pre;
    overflow-x: auto;
  font-variant-numeric: tabular-nums;
    }

  /* Model stats */
    .model-stats {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1001;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      box-sizing: border-box;
      width: 240px;
      min-width: 220px;
      max-width: 280px;
    }
    .model-stats .row {
      position: relative;
      display: grid;
  grid-template-columns: auto 1fr;
      align-items: center;
      column-gap: 12px;
      font-size: 12px;
      padding: 3px 0;
      padding-right: 20px;
    }
    .model-stats .label { color: #94a3b8; }
  .model-stats .value { color: #e2e8f0; font-variant-numeric: tabular-nums; justify-self: end; }
  .model-stats .value.warn { color: #f59e0b; }
  /* Warning icon shown via inline span */
  .model-stats .value .warn-icon { display: none; margin-right: 6px; }
  .model-stats .value.warn .warn-icon { display: inline; }

  /* Optimise/Download/Swap buttons */
  .model-stats .actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #334155;
  }
  .model-stats .actions.texture-actions {
    flex-direction: row;
  }
  .model-stats .action-btn {
    flex: 1;
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .model-stats .action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .model-stats .action-btn.primary {
    background: rgba(59, 130, 246, 0.9);
    color: #ffffff;
  }
  .model-stats .action-btn.primary:hover:not(:disabled) {
    background: rgba(59, 130, 246, 1);
  }
  .model-stats .action-btn.secondary {
    background: rgba(30, 41, 59, 0.8);
    color: #e2e8f0;
    border: 1px solid #475569;
  }
  .model-stats .action-btn.secondary:hover:not(:disabled) {
    background: rgba(51, 65, 85, 0.9);
  }
  .model-stats .action-btn.success {
    background: rgba(34, 197, 94, 0.9);
    color: #ffffff;
  }
  .model-stats .action-btn.success:hover:not(:disabled) {
    background: rgba(34, 197, 94, 1);
  }
  /* Progress indicator */
  .model-stats .progress-text {
    font-size: 11px;
    color: #94a3b8;
    text-align: center;
    margin-top: 8px;
  }
  /* View indicator */
  .model-stats .view-indicator {
    font-size: 10px;
    color: #60a5fa;
    text-align: center;
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* Optimization loading overlay */
  .optimize-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  .optimize-overlay.visible {
    opacity: 1;
    pointer-events: auto;
  }
  .optimize-overlay .spinner {
    width: 60px;
    height: 60px;
    border: 4px solid #334155;
    border-top-color: #3b82f6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .status-note {
    margin-top: 6px;
    font-size: 11px;
    color: rgba(226, 232, 240, 0.65);
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  .optimize-overlay .status {
    margin-top: 24px;
    font-size: 18px;
    color: #e2e8f0;
    text-align: center;
  }
  .optimize-overlay .step {
    margin-top: 8px;
    font-size: 14px;
    color: #94a3b8;
  }
  .optimize-overlay .warning {
    margin-top: 24px;
    font-size: 12px;
    color: #f59e0b;
    max-width: 300px;
    text-align: center;
    line-height: 1.5;
  }
    </style>
</head>
<body>
  <!-- Drag & Drop viewer -->
    
    <!-- Drag and drop overlay (hidden by default) -->
  <div class="drag-drop-overlay" id="dragOverlay">
    <div class="panel">
      <div class="dd-title">Drop .glb or .gltf files to load</div>
      <div class="dd-sub">For GLTF, include textures and .bin files</div>
    </div>
  </div>
    
    <!-- Empty state when no model loaded -->
  <div class="empty-state" id="emptyState">
    <h2>Below Optimiser</h2>
    <p>Drag & drop a .glb or .gltf file</p>
    <button class="file-select-button" onclick="document.getElementById('fileInput').click()">Choose files</button>
    <input type="file" id="fileInput" accept=".glb,.gltf,.bin,.png,.jpg,.jpeg,.webp" multiple />
  </div>
    
  <!-- Survey/Dive toggle -->
    <div id="modeToggleContainer" style="position: fixed; top: 20px; right: 20px; z-index: 1001;">
        <div class="semantic-toggle">
            <input type="checkbox" id="modeToggleSwitch" class="mode-toggle__switch">
            <div class="toggle-slider-bg"></div>
      <div class="toggle-option left">
        <div class="toggle-icon">üîç</div>
        <div class="toggle-text">Survey</div>
            </div>
            <div class="toggle-option right">
        <div class="toggle-icon">üî¶</div>
        <div class="toggle-text">Dive</div>
            </div>
        </div>
    </div>
    
    <!-- Loaded state hint (hidden by default) -->
  <div class="loaded-hint" id="loadedHint">Drop another model to replace</div>

  <!-- Optimization loading overlay -->
  <div class="optimize-overlay" id="optimizeOverlay">
    <div class="spinner"></div>
    <div class="status">Optimising Model</div>
    <div class="step" id="optimizeStep">Initialising...</div>
    <div class="warning">This may take 1-2 minutes for large models.<br>Please don't close the tab.</div>
  </div>

  <!-- Model stats panel -->
  <div class="model-stats" id="modelStats" aria-live="polite">
  <div class="row"><span class="label">triangles</span><span class="value" id="statTris"><span class="warn-icon">‚ö†</span>‚Äî</span></div>
  <div class="row"><span class="label">disk</span><span class="value" id="statDisk"><span class="warn-icon">‚ö†</span>‚Äî</span></div>
  <div class="row"><span class="label">vram</span><span class="value" id="statVram"><span class="warn-icon">‚ö†</span>‚Äî</span></div>
  <div class="row"><span class="label">draws</span><span class="value" id="statDraws">‚Äî</span></div>
  <div class="actions" id="actionButtons" style="display: none;">
    <button class="action-btn primary" id="optimiseBtn">Optimise</button>
    <button class="action-btn secondary" id="swapBtn" style="display: none;">Swap</button>
    <button class="action-btn success" id="downloadBtn" style="display: none;">Download</button>
  </div>
  <div class="actions texture-actions" id="textureButtons" style="display: none; margin-top: 0; padding-top: 8px;">
    <button class="action-btn secondary" id="downloadTexturesBtn" style="font-size: 11px; padding: 6px 10px;">‚Üì Textures</button>
    <button class="action-btn secondary" id="uploadTexturesBtn" style="font-size: 11px; padding: 6px 10px;">‚Üë Textures</button>
    <input type="file" id="textureInput" accept="image/*" multiple style="display: none;">
  </div>
  <div class="progress-text" id="progressText" style="display: none;"></div>
  <div class="status-note" id="modelStatus" style="display: none;"></div>
  <div class="view-indicator" id="viewIndicator" style="display: none;"></div>
  </div>

  <!-- Camera preset snippet (lower-right) -->
  <div class="camera-snippet" id="cameraSnippet" aria-live="polite">
  <pre id="camCode">desktop: {
  camera: { x: 0, y: 5, z: 10 },
  target: { x: 0, y: 0, z: 0 }
},</pre>
  <button id="copyCamBtn" class="copy-fab" aria-label="Copy snippet" title="Copy">‚ßâ Copy</button>
  </div>

    <script type="module">
        import { ModelViewer } from 'belowjs';
        import { WebIO } from '@gltf-transform/core';
        import { ALL_EXTENSIONS } from '@gltf-transform/extensions';
        import {
          dedup, weld, join, simplify, textureCompress,
          draco
        } from '@gltf-transform/functions';
        import { KHRDracoMeshCompression } from '@gltf-transform/extensions';
        import { MeshoptSimplifier } from 'meshoptimizer';
        import { ktx2 } from 'ktx2-encoder/gltf-transform';

  // Drag & Drop viewer

        // No initial models - starts empty
        const models = {};

        // State for optimization
        let originalArrayBuffer = null;
        let optimizedArrayBuffer = null;
        let isShowingOptimized = false;
        let isOptimizing = false;
        let originalFileName = 'model.glb';
        let hasNewTextures = false;

        // UI elements for optimization
        const actionButtons = document.getElementById('actionButtons');
        const optimiseBtn = document.getElementById('optimiseBtn');
        const swapBtn = document.getElementById('swapBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const textureButtons = document.getElementById('textureButtons');
        const downloadTexturesBtn = document.getElementById('downloadTexturesBtn');
        const uploadTexturesBtn = document.getElementById('uploadTexturesBtn');
        const textureInput = document.getElementById('textureInput');
        const progressText = document.getElementById('progressText');
        const viewIndicator = document.getElementById('viewIndicator');
        const modelStatus = document.getElementById('modelStatus');
        const optimizeOverlay = document.getElementById('optimizeOverlay');
        const optimizeStep = document.getElementById('optimizeStep');

        // Initialize gltf-transform IO
        let io = null;
        let ioReadOnly = null; // Lightweight IO for reading only
        let meshoptSimplifier = null;
        let dracoEncoder = null;

        // Lightweight initialization for read-only operations (texture extraction, etc.)
        async function initReadOnlyIO() {
          if (ioReadOnly) return ioReadOnly;

          // Create a basic WebIO without heavy encoder dependencies
          ioReadOnly = new WebIO().registerExtensions(ALL_EXTENSIONS);
          return ioReadOnly;
        }

        // Full initialization for optimization (includes Draco encoder, meshoptimizer)
        async function initGltfTransform() {
          if (io) return;

          setProgress('Initializing Draco encoder...');
          await new Promise(requestAnimationFrame);
          if (typeof DracoEncoderModule === 'function') {
            // Use the global DracoEncoderModule from draco3dgltf UMD build
            dracoEncoder = await withTimeout(
              Promise.resolve(DracoEncoderModule({
                locateFile: (file) => (file.endsWith('.wasm')
                  ? 'https://unpkg.com/draco3dgltf@1.5.7/' + file
                  : file)
              })),
              60000,
              'Draco encoder init'
            );
          } else {
            throw new Error('Draco encoder not available. Ensure draco3dgltf UMD is loaded.');
          }

          io = new WebIO()
            .registerExtensions([...ALL_EXTENSIONS, KHRDracoMeshCompression])
            .registerDependencies({
              'draco3d.encoder': dracoEncoder
            });

          // Initialize meshoptimizer simplifier
          setProgress('Initializing meshoptimizer...');
          await new Promise(requestAnimationFrame);
          await withTimeout(MeshoptSimplifier.ready, 60000, 'Meshoptimizer init');
          meshoptSimplifier = MeshoptSimplifier;
        }

        function setProgress(text) {
          if (text) {
            progressText.textContent = text;
            progressText.style.display = 'block';
            optimizeStep.textContent = text;
          } else {
            progressText.style.display = 'none';
          }
        }

        function showOptimizeOverlay(show) {
          if (show) {
            optimizeOverlay.classList.add('visible');
          } else {
            optimizeOverlay.classList.remove('visible');
          }
        }

        function updateViewIndicator() {
          if (optimizedArrayBuffer) {
            viewIndicator.textContent = isShowingOptimized ? 'Viewing: Optimised' : 'Viewing: Original';
            viewIndicator.style.display = 'block';
          } else {
            viewIndicator.style.display = 'none';
          }
        }

        function updateModelStatus() {
          const hasOptimized = !!optimizedArrayBuffer;
          let text = '';

          if (hasNewTextures && hasOptimized) {
            text = 'New texture + optimised';
          } else if (hasNewTextures) {
            text = 'New texture';
          } else if (hasOptimized) {
            text = 'Optimised';
          }

          if (text) {
            modelStatus.textContent = text;
            modelStatus.style.display = 'block';
          } else {
            modelStatus.style.display = 'none';
          }

          const hasChanges = hasNewTextures || hasOptimized;
          downloadBtn.style.display = hasModel ? 'block' : 'none';
          downloadBtn.disabled = !hasChanges;
          if (hasOptimized) {
            downloadBtn.textContent = 'Download (Optimised)';
          } else if (hasNewTextures) {
            downloadBtn.textContent = 'Download (Updated)';
          } else {
            downloadBtn.textContent = 'Download';
          }
        }

        function isImageFile(file) {
          return file && file.type && file.type.startsWith('image/');
        }

        function isModelFile(file) {
          if (!file || !file.name) return false;
          const name = file.name.toLowerCase();
          return name.endsWith('.glb') || name.endsWith('.gltf');
        }

        function withTimeout(promise, ms, label) {
          if (!ms) return promise;
          return new Promise((resolve, reject) => {
            const t = setTimeout(() => {
              reject(new Error(`${label} timed out after ${Math.round(ms / 1000)}s`));
            }, ms);
            promise
              .then((result) => {
                clearTimeout(t);
                resolve(result);
              })
              .catch((err) => {
                clearTimeout(t);
                reject(err);
              });
          });
        }

        // The optimization pipeline matching the shell script
        async function optimizeModel(arrayBuffer) {
          await new Promise(requestAnimationFrame);
          await initGltfTransform();

          setProgress('Reading model...');
          const gltfDocument = await io.readBinary(new Uint8Array(arrayBuffer));

          // Get initial stats
          const root = gltfDocument.getRoot();
          let totalTris = 0;
          for (const mesh of root.listMeshes()) {
            for (const prim of mesh.listPrimitives()) {
              const indices = prim.getIndices();
              if (indices) {
                totalTris += indices.getCount() / 3;
              } else {
                const pos = prim.getAttribute('POSITION');
                if (pos) totalTris += pos.getCount() / 3;
              }
            }
          }

          const transforms = [];

          // Simplification pipeline (if needed) - matches shell script lines 139-145
          if (totalTris > 1200000) {
            setProgress(`High polygon count (${Math.round(totalTris).toLocaleString()} tris). Running simplification...`);

            const targetRatio = 1200000 / totalTris;

            // Step 1: Dedup
            transforms.push({
              label: 'Removing duplicates...',
              transform: dedup()
            });

            // Step 2: Weld vertices
            transforms.push({
              label: 'Welding vertices...',
              transform: weld()
            });

            // Step 3: Join meshes with same material (reduces draw calls)
            transforms.push({
              label: 'Joining meshes...',
              transform: join()
            });

            // Step 4: Simplify
            transforms.push({
              label: `Simplifying to ~1.2M triangles (ratio: ${targetRatio.toFixed(3)})...`,
              transform: simplify({
                simplifier: meshoptSimplifier,
                ratio: Math.max(targetRatio, 0.1),
                error: 0.005,
                lockBorder: true
              })
            });
          }

          const hasTextures = root.listTextures().length > 0;

          if (hasTextures) {
            // Step 5: Resize textures to max 4096 (shell script line 315)
            transforms.push({
              label: 'Resizing textures to 4096x4096...',
              transform: textureCompress({
                resize: [4096, 4096]
              })
            });

            // Step 6: KTX2/ETC1S texture compression with quality 64 (shell script line 318)
            transforms.push({
              label: 'Converting textures to KTX2/ETC1S...',
              transform: ktx2({
                isUASTC: false, // ETC1S mode
                enableDebug: true, // Enable debug to see what's happening
                generateMipmap: true,
                quality: 64, // Match shell script quality
                encoderPath: './', // Path to encoder directory
                wasmUrl: './basis_encoder.wasm'
              }),
              timeoutMs: 180000
            });
          }

          // Step 7: Draco compression with 20-bit quantization (shell script lines 322-330)
          transforms.push({
            label: 'Applying 20-bit Draco compression...',
            transform: draco({
              method: 'sequential', // Preserves vertex order (important for multi-texture models)
              encodeSpeed: 0,
              decodeSpeed: 0,
              quantizePosition: 20,
              quantizeNormal: 20,
              quantizeColor: 20,
              quantizeTexcoord: 20,
              quantizeGeneric: 20
            })
          });

          // Apply transforms sequentially to show accurate progress
          for (const step of transforms) {
            setProgress(step.label);
            await new Promise(requestAnimationFrame);
            if (step.timeoutMs) {
              await withTimeout(gltfDocument.transform(step.transform), step.timeoutMs, step.label);
            } else {
              await gltfDocument.transform(step.transform);
            }
          }

          // Write to GLB
          setProgress('Writing GLB...');
          const optimizedGlb = await io.writeBinary(gltfDocument);

          setProgress(null);
          return optimizedGlb.buffer;
        }

        async function runOptimization() {
          if (!originalArrayBuffer || isOptimizing) return;

          isOptimizing = true;
          optimiseBtn.disabled = true;
          optimiseBtn.textContent = 'Optimising...';
          showOptimizeOverlay(true);
          setProgress('Preparing optimization...');
          await new Promise(requestAnimationFrame);
          await new Promise((resolve) => setTimeout(resolve, 0));

          try {
            optimizedArrayBuffer = await optimizeModel(originalArrayBuffer);

            // Show the optimized model
            await loadModelFromArrayBuffer(optimizedArrayBuffer, true);
            isShowingOptimized = true;

            // Update UI
            optimiseBtn.style.display = 'none';
            swapBtn.style.display = 'block';
            downloadBtn.style.display = 'block';
            updateViewIndicator();
            updateModelStatus();

          } catch (err) {
            console.error('Optimization failed:', err);
            alert('Optimization failed: ' + err.message);
            optimiseBtn.textContent = 'Optimise';
            optimiseBtn.disabled = false;
          } finally {
            isOptimizing = false;
            showOptimizeOverlay(false);
          }
        }

        async function swapModel() {
          if (!originalArrayBuffer || !optimizedArrayBuffer) return;

          isShowingOptimized = !isShowingOptimized;
          const buffer = isShowingOptimized ? optimizedArrayBuffer : originalArrayBuffer;
          await loadModelFromArrayBuffer(buffer, false);
          updateViewIndicator();
        }

        function downloadOptimized() {
          const hasOptimized = !!optimizedArrayBuffer;
          const hasUpdated = !!originalArrayBuffer && hasNewTextures;
          if (!hasOptimized && !hasUpdated) return;

          const buffer = hasOptimized ? optimizedArrayBuffer : originalArrayBuffer;
          const blob = new Blob([buffer], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          const baseName = originalFileName.replace(/\.(glb|gltf)$/i, '');
          a.download = hasOptimized ? `${baseName}-optimised.glb` : `${baseName}-edited.glb`;
          a.click();
          URL.revokeObjectURL(url);
        }

        // Event listeners for buttons
        optimiseBtn.addEventListener('click', runOptimization);
        swapBtn.addEventListener('click', swapModel);
        downloadBtn.addEventListener('click', downloadOptimized);

        // Helper to load model from ArrayBuffer
        async function loadModelFromArrayBuffer(arrayBuffer, updateDiskSize = true) {
          const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);

          if (updateDiskSize) {
            lastBlobSize = arrayBuffer.byteLength;
          }

          try {
            if (hasModel) {
              viewer.belowViewer.clearModels();
            }
            await viewer.belowViewer.loadModel(url, { autoFrame: !hasModel });
            hasModel = true;

            updateCameraSnippet();

            // Update stats
            const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
            const stats = collectModelStats(modelRoot);
            updateStatsDisplay(stats);
            updateModelStatus();
          } finally {
            URL.revokeObjectURL(url);
          }
        }

        // Reset optimization state when loading new model
        function resetOptimizationState() {
          originalArrayBuffer = null;
          optimizedArrayBuffer = null;
          isShowingOptimized = false;
          hasNewTextures = false;

          optimiseBtn.textContent = 'Optimise';
          optimiseBtn.disabled = false;
          optimiseBtn.style.display = 'block';
          swapBtn.style.display = 'none';
          downloadBtn.style.display = 'none';
          viewIndicator.style.display = 'none';
          setProgress(null);
          updateModelStatus();
        }

        // Create fullscreen viewer container
        const viewerContainer = document.createElement('div');
        viewerContainer.style.position = 'fixed';
        viewerContainer.style.inset = '0';
        viewerContainer.style.zIndex = '0';
        document.body.appendChild(viewerContainer);

        // Move mode toggle into viewer container for proper layering and fullscreen support
        const modeToggle = document.getElementById('modeToggleContainer');
        if (modeToggle) {
            viewerContainer.appendChild(modeToggle);
        }

  // Configure viewer with dark theme and standalone mode toggle
        const viewer = new ModelViewer(viewerContainer, {
          models: models,
          autoLoadFirst: false,
          showDiveToggle: false,
          enableVR: true,
          enableVRAudio: false,
          enableFullscreen: true,
          enableScreenshot: true,
          showInfo: false,
          showLoadingIndicator: true,
          // No initial model - starts empty
          viewerConfig: {
            scene: {
              background: { type: 'color', value: '#0f172a' }
            }
          }
        });

        const dragOverlay = document.getElementById('dragOverlay');
        const emptyState = document.getElementById('emptyState');
        const loadedHint = document.getElementById('loadedHint');
        const fileInput = document.getElementById('fileInput');
        const cameraSnippet = document.getElementById('cameraSnippet');
        const camCode = document.getElementById('camCode');
        const copyCamBtn = document.getElementById('copyCamBtn');
  const statTris = document.getElementById('statTris');
  const statDisk = document.getElementById('statDisk');
  const statVram = document.getElementById('statVram');
  const statDraws = document.getElementById('statDraws');
        let dragCounter = 0;
        let hasModel = false;
        let lastBlobSize = null; // bytes

  // Format a number to 2 decimals, keep trailing zeros to avoid width changes
  const fmt = (n) => Number(n).toFixed(2);
        const fmtInt = (n) => new Intl.NumberFormat().format(n|0);
        const fmtBytes = (bytes) => {
          if (bytes == null) return '‚Äî';
          const units = ['B','KB','MB','GB'];
          let i = 0; let v = bytes;
          while (v >= 1000 && i < units.length-1) { v /= 1000; i++; }
          return `${v.toFixed(1)} ${units[i]}`;
        };

        function vramForTexture(tex) {
          // Exact path for KTX2 compressed textures loaded via KTX2Loader
          const img = tex?.image;
          // three.js KTX2 loader uses CompressedTexture with mipmaps on the texture
          if ((tex?.isCompressedTexture || Array.isArray(tex?.mipmaps)) && tex.mipmaps && tex.mipmaps.length > 0) {
            let bytes = 0;
            for (const level of tex.mipmaps) {
              if (level?.data?.byteLength) bytes += level.data.byteLength;
            }
            return { bytes, exact: true };
          }
          // Non-compressed textures: estimate
          try {
            const w = img?.width || tex.source?.data?.width || img?.videoWidth || 0;
            const h = img?.height || tex.source?.data?.height || img?.videoHeight || 0;
            if (!w || !h) return { bytes: 0, exact: false };
            const base = w * h * 4;
            const mipOverhead = 1.33;
            return { bytes: Math.round(base * mipOverhead), exact: false };
          } catch { return { bytes: 0, exact: false }; }
        }

        function collectModelStats(root) {
          let tris = 0;
          let meshes = 0;
          let textures = new Set();
          let vramGeom = 0;
          let vramTex = 0;
          let texExactCount = 0;
          let draws = 0;

          root.traverse((obj) => {
            if (obj.isMesh) {
              meshes++;
              const geom = obj.geometry;
              if (geom) {
                // Triangle count
                const index = geom.index;
                if (index) {
                  tris += index.count / 3;
                } else if (geom.attributes?.position) {
                  tris += geom.attributes.position.count / 3;
                }
                // VRAM for geometry: sum unique underlying arrays (avoid double counting interleaved/shared buffers)
                const seenArrays = new Set();
                const addArray = (arr) => {
                  if (!arr) return;
                  if (!seenArrays.has(arr)) {
                    seenArrays.add(arr);
                    vramGeom += arr.byteLength || 0;
                  }
                };
                for (const key in geom.attributes) {
                  const attr = geom.attributes[key];
                  if (!attr) continue;
                  // InterleavedBufferAttribute stores data on attr.data.array
                  if (attr.isInterleavedBufferAttribute) {
                    addArray(attr.data && attr.data.array);
                  } else {
                    addArray(attr.array);
                  }
                }
                if (geom.index) {
                  addArray(geom.index.array);
                }
              }
              // Materials -> textures
              const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
              mats.forEach((m) => {
                if (!m) return;
                for (const prop in m) {
                  const val = m[prop];
                  if (val && val.isTexture) textures.add(val);
                }
              });
              // Draw calls: for non-instanced meshes, one draw per geometry group (or 1 if none)
              const groupCount = (geom && geom.groups && geom.groups.length) ? geom.groups.length : 1;
              draws += groupCount;
            }
          });

          // VRAM for textures (exact for compressed KTX2)
          textures.forEach((t) => {
            const { bytes, exact } = vramForTexture(t);
            vramTex += bytes;
            if (exact) texExactCount++;
          });

          return { tris: Math.round(tris), meshes, textures: textures.size, vramGeom, vramTex, texExactCount, draws };
        }

        function updateStatsDisplay({ tris, vramGeom, vramTex, draws }) {
          const totalVRAM = vramGeom + vramTex;
          statVram.textContent = fmtBytes(totalVRAM);
          statDisk.textContent = lastBlobSize != null ? fmtBytes(lastBlobSize) : '‚Äî';
          statDraws.textContent = fmtInt(draws);
          statTris.textContent = fmtInt(tris);

          // Thresholds
          const TRI_LIMIT = 1_500_000;
          const DISK_LIMIT = 100 * 1000 * 1000; // 100 MB (decimal)
          const VRAM_LIMIT = 400 * 1000 * 1000; // 400 MB (decimal)

          // Helpers to set warning state
          const setWarn = (elValue, isWarn) => {
            if (isWarn) elValue.classList.add('warn');
            else elValue.classList.remove('warn');
          };

          setWarn(statTris, tris > TRI_LIMIT);
          setWarn(statDisk, (lastBlobSize ?? 0) > DISK_LIMIT);
          setWarn(statVram, totalVRAM > VRAM_LIMIT);
        }

        // Build the desktop camera/target snippet string
        function buildDesktopSnippet() {
          const camera = viewer?.belowViewer?.cameraManager?.getCamera?.();
          const controls = viewer?.belowViewer?.cameraManager?.getControls?.();
          if (!camera || !controls) return `desktop: {\n  camera: { x: 0, y: 5, z: 10 },\n  target: { x: 0, y: 0, z: 0 }\n},`;
          const cx = fmt(camera.position.x);
          const cy = fmt(camera.position.y);
          const cz = fmt(camera.position.z);
          const tx = fmt(controls.target.x);
          const ty = fmt(controls.target.y);
          const tz = fmt(controls.target.z);
          return `desktop: {\n  camera: { x: ${cx}, y: ${cy}, z: ${cz} },\n  target: { x: ${tx}, y: ${ty}, z: ${tz} }\n},`;
        }

        // Update the UI with current camera values
        function updateCameraSnippet() {
          camCode.textContent = buildDesktopSnippet();
        }

        // Copy to clipboard handler
        async function doCopy(text) {
          try {
            await navigator.clipboard.writeText(text);
          } catch (e) {
            const ta = document.createElement('textarea');
            ta.value = text;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
          }
          // Feedback
          cameraSnippet.style.boxShadow = '0 0 0 2px rgba(59,130,246,0.45), 0 8px 24px rgba(0,0,0,0.35)';
          const prev = copyCamBtn.textContent;
          copyCamBtn.textContent = 'Copied';
          setTimeout(() => {
            copyCamBtn.textContent = prev;
            cameraSnippet.style.boxShadow = '0 8px 24px rgba(0,0,0,0.35)';
          }, 900);
        }

        copyCamBtn.addEventListener('click', async () => {
          await doCopy(camCode.textContent);
        });

  // Copy is handled via the button

        // Handle file input selection
        fileInput.addEventListener('change', async (e) => {
          if (e.target.files.length > 0) {
            await loadModelFile(e.target.files);
          }
        });

        // Texture management functions
        async function downloadTextures() {
          if (!originalArrayBuffer) return;

          showOptimizeOverlay(true);
          setProgress('Extracting textures...');

          try {
            const readIO = await initReadOnlyIO();
            const gltfDocument = await readIO.readBinary(new Uint8Array(originalArrayBuffer));
            const root = gltfDocument.getRoot();
            const textures = root.listTextures();

            if (textures.length === 0) {
              alert('No textures found in model');
              return;
            }

            // Create a zip-like download with all textures
            for (let i = 0; i < textures.length; i++) {
              const texture = textures[i];
              const image = texture.getImage();
              if (!image) continue;

              const mimeType = texture.getMimeType() || 'image/png';
              const ext = mimeType.split('/')[1] || 'png';
              const name = texture.getName() || `texture_${i}`;

              const blob = new Blob([image], { type: mimeType });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `${name}.${ext}`;
              a.click();
              URL.revokeObjectURL(url);

              await new Promise(r => setTimeout(r, 100)); // Delay between downloads
            }
          } catch (err) {
            console.error('Failed to extract textures:', err);
            alert('Failed to extract textures: ' + err.message);
          } finally {
            showOptimizeOverlay(false);
          }
        }

        async function uploadTextures() {
          textureInput.click();
        }

        async function applyUploadedTextures(files) {
          if (!originalArrayBuffer || files.length === 0) return;

          showOptimizeOverlay(true);
          setProgress('Applying new textures...');

          try {
            const readIO = await initReadOnlyIO();
            const gltfDocument = await readIO.readBinary(new Uint8Array(originalArrayBuffer));
            const root = gltfDocument.getRoot();
            const textures = root.listTextures();
            const materials = root.listMaterials();
            const unmatchedFiles = [];

            // Match uploaded files to textures by name
            for (const file of files) {
              const fileName = file.name.replace(/\.[^.]+$/, ''); // Remove extension
              const texture = textures.find(t => t.getName() === fileName);

              if (texture) {
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                texture.setImage(uint8Array);
                texture.setMimeType(file.type);
                setProgress(`Updated texture: ${fileName}`);
              } else {
                unmatchedFiles.push(file);
              }
            }

            // If no matching texture, assume new texture
            if (unmatchedFiles.length > 0) {
              const availableMaterials = materials.slice();
              const onlyOneNew = unmatchedFiles.length === 1;

              for (const file of unmatchedFiles) {
                const fileName = file.name.replace(/\.[^.]+$/, '');
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                const mimeType = file.type || 'image/png';

                const newTexture = gltfDocument.createTexture(fileName);
                newTexture.setImage(uint8Array);
                newTexture.setMimeType(mimeType);

                if (availableMaterials.length > 0) {
                  const targetMat = availableMaterials.shift();
                  targetMat.setBaseColorTexture(newTexture);
                  setProgress(`Added texture to material: ${targetMat.getName() || 'Material'}`);
                } else if (onlyOneNew && materials.length > 0) {
                  // Fallback: apply to all materials if only one new texture is provided
                  materials.forEach((mat) => mat.setBaseColorTexture(newTexture));
                  setProgress('Applied new texture to all materials');
                }
              }
            }

            // Write updated model back to originalArrayBuffer
            const updatedGlb = await readIO.writeBinary(gltfDocument);
            originalArrayBuffer = updatedGlb.buffer;
            hasNewTextures = true;

            // If we're viewing optimized, invalidate it
            if (optimizedArrayBuffer) {
              optimizedArrayBuffer = null;
              isShowingOptimized = false;
              optimiseBtn.style.display = 'block';
              swapBtn.style.display = 'none';
              downloadBtn.style.display = 'none';
              updateViewIndicator();
            }

            updateModelStatus();

            // Reload the model
            await loadModelFromArrayBuffer(originalArrayBuffer, true);

          } catch (err) {
            console.error('Failed to apply textures:', err);
            alert('Failed to apply textures: ' + err.message);
          } finally {
            showOptimizeOverlay(false);
          }
        }

        // Event listeners for texture buttons
        downloadTexturesBtn.addEventListener('click', downloadTextures);
        uploadTexturesBtn.addEventListener('click', uploadTextures);
        textureInput.addEventListener('change', async (e) => {
          if (e.target.files.length > 0) {
            await applyUploadedTextures(e.target.files);
          }
        });

        // Function to load model file(s) and update UI state
        // Supports: single GLB, single GLTF, or GLTF + associated files
        async function loadModelFile(files) {
          // Handle FileList or single File
          const fileList = files instanceof FileList ? Array.from(files) : [files];

          if (fileList.length === 0) return;

          // Find the main model file
          const mainFile = fileList.find(f =>
            f.name.toLowerCase().endsWith('.glb') ||
            f.name.toLowerCase().endsWith('.gltf')
          );

          if (!mainFile) {
            alert('Please select a .glb or .gltf file');
            return;
          }

          // Reset optimization state for new model
          resetOptimizationState();
          originalFileName = mainFile.name;

          // Show loading overlay
          showOptimizeOverlay(true);
          setProgress('Loading model...');

          try {
            let arrayBuffer;

            if (mainFile.name.toLowerCase().endsWith('.glb')) {
              // Direct GLB load - no gltf-transform needed!
              arrayBuffer = await mainFile.arrayBuffer();
            } else {
              // GLTF with associated files - need gltf-transform to convert to GLB
              const readIO = await initReadOnlyIO();
              setProgress('Reading GLTF...');

              // Build resource map from associated files
              const resources = {};
              for (const file of fileList) {
                if (file !== mainFile) {
                  const buffer = await file.arrayBuffer();
                  resources[file.name] = new Uint8Array(buffer);
                }
              }

              // Read the GLTF JSON
              const gltfText = await mainFile.text();
              const gltfJson = JSON.parse(gltfText);

              // Use WebIO to read the GLTF with resources
              const jsonDoc = { json: gltfJson, resources };
              const gltfDocument = await readIO.readJSON(jsonDoc);

              // Convert to GLB
              setProgress('Converting to GLB...');
              const glbData = await readIO.writeBinary(gltfDocument);
              arrayBuffer = glbData.buffer;

              setProgress(null);
            }

            // Store original for optimization
            originalArrayBuffer = arrayBuffer;
            lastBlobSize = arrayBuffer.byteLength;

            // Load into viewer
            const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);

            try {
              if (hasModel) {
                viewer.belowViewer.clearModels();
              }
              await viewer.belowViewer.loadModel(url, { autoFrame: true });

              // Hide empty state and show loaded hint
              emptyState.style.display = 'none';
              loadedHint.classList.add('visible');
              hasModel = true;

              // Show action buttons
              actionButtons.style.display = 'flex';
              textureButtons.style.display = 'flex';

              updateCameraSnippet();

              // Compute and show stats
              const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
              const stats = collectModelStats(modelRoot);
              updateStatsDisplay(stats);
            } finally {
              URL.revokeObjectURL(url);
            }
          } catch (err) {
            console.error('Failed to load model:', err);
            alert('Failed to load the model: ' + err.message);
          } finally {
            showOptimizeOverlay(false);
          }
        }

        // Show overlay when dragging files over the page
        window.addEventListener('dragenter', (e) => {
          e.preventDefault();
          dragCounter++;
          dragOverlay.classList.add('visible');
        });

        window.addEventListener('dragover', (e) => {
          e.preventDefault();
        });

        // Hide overlay when dragging away
        window.addEventListener('dragleave', (e) => {
          e.preventDefault();
          dragCounter--;
          if (dragCounter === 0) {
            dragOverlay.classList.remove('visible');
          }
        });

        // Handle file drop with validation and error handling
        window.addEventListener('drop', async (e) => {
          e.preventDefault();
          dragCounter = 0;
          dragOverlay.classList.remove('visible');

          if (e.dataTransfer.files.length === 0) return;

          const files = Array.from(e.dataTransfer.files);
          const modelFiles = files.filter(isModelFile);
          const imageFiles = files.filter(isImageFile);

          if (modelFiles.length > 0) {
            await loadModelFile(e.dataTransfer.files);
            return;
          }

          if (imageFiles.length > 0) {
            if (!originalArrayBuffer) {
              alert('Load a model before dropping textures.');
              return;
            }
            await applyUploadedTextures(imageFiles);
          }
        });

        // Subscribe to camera changes to keep snippet live-updated
        if (viewer?.belowViewer?.on) {
          viewer.belowViewer.on('camera-change', updateCameraSnippet);
        }

        // Initial update
        updateCameraSnippet();

        // Periodically refresh stats (in case textures finish loading later)
        setInterval(() => {
          if (!hasModel) return;
          const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
          const stats = collectModelStats(modelRoot);
          updateStatsDisplay(stats);
        }, 2000);
    </script>
</body>
</html>
