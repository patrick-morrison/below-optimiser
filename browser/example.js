function e(e) {
    const t = Object.create(null);
    for (const n of e.split(","))
        t[n] = 1;
    return e => e in t
}
!function() {
    const e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
            t(e);
        new MutationObserver(e => {
            for (const n of e)
                if ("childList" === n.type)
                    for (const e of n.addedNodes)
                        "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
        }).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function t(e) {
        if (e.ep)
            return;
        e.ep = !0;
        const t = function(e) {
            const t = {};
            return e.integrity && (t.integrity = e.integrity), e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy), "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin", t
        }(e);
        fetch(e.href, t)
    }
}();
const t = {},
    n = [],
    r = () => {},
    o = () => !1,
    i = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    a = e => e.startsWith("onUpdate:"),
    s = Object.assign,
    l = (e, t) => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    },
    c = Object.prototype.hasOwnProperty,
    u = (e, t) => c.call(e, t),
    d = Array.isArray,
    p = e => "[object Map]" === v(e),
    h = e => "[object Set]" === v(e),
    f = e => "function" == typeof e,
    g = e => "string" == typeof e,
    m = e => "symbol" == typeof e,
    b = e => null !== e && "object" == typeof e,
    A = e => (b(e) || f(e)) && f(e.then) && f(e.catch),
    y = Object.prototype.toString,
    v = e => y.call(e),
    _ = e => "[object Object]" === v(e),
    x = e => g(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
    w = e(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    C = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n))
    },
    E = /-\w/g,
    S = C(e => e.replace(E, e => e.slice(1).toUpperCase())),
    I = /\B([A-Z])/g,
    T = C(e => e.replace(I, "-$1").toLowerCase()),
    M = C(e => e.charAt(0).toUpperCase() + e.slice(1)),
    R = C(e => e ? `on${M(e)}` : ""),
    B = (e, t) => !Object.is(e, t),
    k = (e, ...t) => {
        for (let n = 0; n < e.length; n++)
            e[n](...t)
    },
    D = (e, t, n, r=!1) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            writable: r,
            value: n
        })
    },
    P = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    };
let O;
const L = () => O || (O = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
function N(e) {
    if (d(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                o = g(r) ? Q(r) : N(r);
            if (o)
                for (const e in o)
                    t[e] = o[e]
        }
        return t
    }
    if (g(e) || b(e))
        return e
}
const F = /;(?![^(]*\))/g,
    U = /:([^]+)/,
    z = /\/\*[^]*?\*\//g;
function Q(e) {
    const t = {};
    return e.replace(z, "").split(F).forEach(e => {
        if (e) {
            const n = e.split(U);
            n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
    }), t
}
function G(e) {
    let t = "";
    if (g(e))
        t = e;
    else if (d(e))
        for (let n = 0; n < e.length; n++) {
            const r = G(e[n]);
            r && (t += r + " ")
        }
    else if (b(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function j(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !g(t) && (e.class = G(t)), n && (e.style = N(n)), e
}
const V = e("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
function H(e) {
    return !!e || "" === e
}
const $ = e => !(!e || !0 !== e.__v_isRef),
    W = e => g(e) ? e : null == e ? "" : d(e) || b(e) && (e.toString === y || !f(e.toString)) ? $(e) ? W(e.value) : JSON.stringify(e, K, 2) : String(e),
    K = (e, t) => $(t) ? K(e, t.value) : p(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n], r) => (e[q(t, r) + " =>"] = n, e), {})
    } : h(t) ? {
        [`Set(${t.size})`]: [...t.values()].map(e => q(e))
    } : m(t) ? q(t) : !b(t) || d(t) || _(t) ? t : String(t),
    q = (e, t="") => {
        var n;
        return m(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e
    };
let X,
    Y;
class J {
    constructor(e=!1)
    {
        this.detached = e,
        this._active = !0,
        this._on = 0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = X,
        !e && X && (this.index = (X.scopes || (X.scopes = [])).push(this) - 1)
    }
    get active()
    {
        return this._active
    }
    pause()
    {
        if (this._active) {
            let e,
                t;
            if (this._isPaused = !0, this.scopes)
                for (e = 0, t = this.scopes.length; e < t; e++)
                    this.scopes[e].pause();
            for (e = 0, t = this.effects.length; e < t; e++)
                this.effects[e].pause()
        }
    }
    resume()
    {
        if (this._active && this._isPaused) {
            let e,
                t;
            if (this._isPaused = !1, this.scopes)
                for (e = 0, t = this.scopes.length; e < t; e++)
                    this.scopes[e].resume();
            for (e = 0, t = this.effects.length; e < t; e++)
                this.effects[e].resume()
        }
    }
    run(e)
    {
        if (this._active) {
            const t = X;
            try {
                return X = this, e()
            } finally {
                X = t
            }
        }
    }
    on()
    {
        1 === ++this._on && (this.prevScope = X, X = this)
    }
    off()
    {
        this._on > 0 && 0 === --this._on && (X = this.prevScope, this.prevScope = void 0)
    }
    stop(e)
    {
        if (this._active) {
            let t,
                n;
            for (this._active = !1, t = 0, n = this.effects.length; t < n; t++)
                this.effects[t].stop();
            for (this.effects.length = 0, t = 0, n = this.cleanups.length; t < n; t++)
                this.cleanups[t]();
            if (this.cleanups.length = 0, this.scopes) {
                for (t = 0, n = this.scopes.length; t < n; t++)
                    this.scopes[t].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !e) {
                const e = this.parent.scopes.pop();
                e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index)
            }
            this.parent = void 0
        }
    }
}
const Z = new WeakSet;
class ee {
    constructor(e)
    {
        this.fn = e,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        X && X.active && X.effects.push(this)
    }
    pause()
    {
        this.flags |= 64
    }
    resume()
    {
        64 & this.flags && (this.flags &= -65, Z.has(this) && (Z.delete(this), this.trigger()))
    }
    notify()
    {
        2 & this.flags && !(32 & this.flags) || 8 & this.flags || oe(this)
    }
    run()
    {
        if (!(1 & this.flags))
            return this.fn();
        this.flags |= 2,
        be(this),
        se(this);
        const e = Y,
            t = he;
        Y = this,
        he = !0;
        try {
            return this.fn()
        } finally {
            le(this),
            Y = e,
            he = t,
            this.flags &= -3
        }
    }
    stop()
    {
        if (1 & this.flags) {
            for (let e = this.deps; e; e = e.nextDep)
                de(e);
            this.deps = this.depsTail = void 0,
            be(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger()
    {
        64 & this.flags ? Z.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty()
    {
        ce(this) && this.run()
    }
    get dirty()
    {
        return ce(this)
    }
}
let te,
    ne,
    re = 0;
function oe(e, t=!1) {
    if (e.flags |= 8, t)
        return e.next = ne, void (ne = e);
    e.next = te,
    te = e
}
function ie() {
    re++
}
function ae() {
    if (--re > 0)
        return;
    if (ne) {
        let e = ne;
        for (ne = void 0; e;) {
            const t = e.next;
            e.next = void 0,
            e.flags &= -9,
            e = t
        }
    }
    let e;
    for (; te;) {
        let n = te;
        for (te = void 0; n;) {
            const r = n.next;
            if (n.next = void 0, n.flags &= -9, 1 & n.flags)
                try {
                    n.trigger()
                } catch (t) {
                    e || (e = t)
                }
            n = r
        }
    }
    if (e)
        throw e
}
function se(e) {
    for (let t = e.deps; t; t = t.nextDep)
        t.version = -1,
        t.prevActiveLink = t.dep.activeLink,
        t.dep.activeLink = t
}
function le(e) {
    let t,
        n = e.depsTail,
        r = n;
    for (; r;) {
        const e = r.prevDep;
        -1 === r.version ? (r === n && (n = e), de(r), pe(r)) : t = r,
        r.dep.activeLink = r.prevActiveLink,
        r.prevActiveLink = void 0,
        r = e
    }
    e.deps = t,
    e.depsTail = n
}
function ce(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (ue(t.dep.computed) || t.dep.version !== t.version))
            return !0;
    return !!e._dirty
}
function ue(e) {
    if (4 & e.flags && !(16 & e.flags))
        return;
    if (e.flags &= -17, e.globalVersion === Ae)
        return;
    if (e.globalVersion = Ae, !e.isSSR && 128 & e.flags && (!e.deps && !e._dirty || !ce(e)))
        return;
    e.flags |= 2;
    const t = e.dep,
        n = Y,
        r = he;
    Y = e,
    he = !0;
    try {
        se(e);
        const n = e.fn(e._value);
        (0 === t.version || B(n, e._value)) && (e.flags |= 128, e._value = n, t.version++)
    } catch (o) {
        throw t.version++, o
    } finally {
        Y = n,
        he = r,
        le(e),
        e.flags &= -3
    }
}
function de(e, t=!1) {
    const {dep: n, prevSub: r, nextSub: o} = e;
    if (r && (r.nextSub = o, e.prevSub = void 0), o && (o.prevSub = r, e.nextSub = void 0), n.subs === e && (n.subs = r, !r && n.computed)) {
        n.computed.flags &= -5;
        for (let e = n.computed.deps; e; e = e.nextDep)
            de(e, !0)
    }
    t || --n.sc || !n.map || n.map.delete(n.key)
}
function pe(e) {
    const {prevDep: t, nextDep: n} = e;
    t && (t.nextDep = n, e.prevDep = void 0),
    n && (n.prevDep = t, e.nextDep = void 0)
}
let he = !0;
const fe = [];
function ge() {
    fe.push(he),
    he = !1
}
function me() {
    const e = fe.pop();
    he = void 0 === e || e
}
function be(e) {
    const {cleanup: t} = e;
    if (e.cleanup = void 0, t) {
        const e = Y;
        Y = void 0;
        try {
            t()
        } finally {
            Y = e
        }
    }
}
let Ae = 0;
class ye {
    constructor(e, t)
    {
        this.sub = e,
        this.dep = t,
        this.version = t.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class ve {
    constructor(e)
    {
        this.computed = e,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0,
        this.__v_skip = !0
    }
    track(e)
    {
        if (!Y || !he || Y === this.computed)
            return;
        let t = this.activeLink;
        if (void 0 === t || t.sub !== Y)
            t = this.activeLink = new ye(Y, this),
            Y.deps ? (t.prevDep = Y.depsTail, Y.depsTail.nextDep = t, Y.depsTail = t) : Y.deps = Y.depsTail = t,
            _e(t);
        else if (-1 === t.version && (t.version = this.version, t.nextDep)) {
            const e = t.nextDep;
            e.prevDep = t.prevDep,
            t.prevDep && (t.prevDep.nextDep = e),
            t.prevDep = Y.depsTail,
            t.nextDep = void 0,
            Y.depsTail.nextDep = t,
            Y.depsTail = t,
            Y.deps === t && (Y.deps = e)
        }
        return t
    }
    trigger(e)
    {
        this.version++,
        Ae++,
        this.notify(e)
    }
    notify(e)
    {
        ie();
        try {
            for (let e = this.subs; e; e = e.prevSub)
                e.sub.notify() && e.sub.dep.notify()
        } finally {
            ae()
        }
    }
}
function _e(e) {
    if (e.dep.sc++, 4 & e.sub.flags) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let e = t.deps; e; e = e.nextDep)
                _e(e)
        }
        const n = e.dep.subs;
        n !== e && (e.prevSub = n, n && (n.nextSub = e)),
        e.dep.subs = e
    }
}
const xe = new WeakMap,
    we = Symbol(""),
    Ce = Symbol(""),
    Ee = Symbol("");
function Se(e, t, n) {
    if (he && Y) {
        let t = xe.get(e);
        t || xe.set(e, t = new Map);
        let r = t.get(n);
        r || (t.set(n, r = new ve), r.map = t, r.key = n),
        r.track()
    }
}
function Ie(e, t, n, r, o, i) {
    const a = xe.get(e);
    if (!a)
        return void Ae++;
    const s = e => {
        e && e.trigger()
    };
    if (ie(), "clear" === t)
        a.forEach(s);
    else {
        const o = d(e),
            i = o && x(n);
        if (o && "length" === n) {
            const e = Number(r);
            a.forEach((t, n) => {
                ("length" === n || n === Ee || !m(n) && n >= e) && s(t)
            })
        } else
            switch ((void 0 !== n || a.has(void 0)) && s(a.get(n)), i && s(a.get(Ee)), t) {
            case "add":
                o ? i && s(a.get("length")) : (s(a.get(we)), p(e) && s(a.get(Ce)));
                break;
            case "delete":
                o || (s(a.get(we)), p(e) && s(a.get(Ce)));
                break;
            case "set":
                p(e) && s(a.get(we))
            }
    }
    ae()
}
function Te(e) {
    const t = ut(e);
    return t === e ? t : (Se(t, 0, Ee), lt(e) ? t : t.map(dt))
}
function Me(e) {
    return Se(e = ut(e), 0, Ee), e
}
const Re = {
    __proto__: null,
    [Symbol.iterator]() {
        return Be(this, Symbol.iterator, dt)
    },
    concat(...e) {
        return Te(this).concat(...e.map(e => d(e) ? Te(e) : e))
    },
    entries() {
        return Be(this, "entries", e => (e[1] = dt(e[1]), e))
    },
    every(e, t) {
        return De(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
        return De(this, "filter", e, t, e => e.map(dt), arguments)
    },
    find(e, t) {
        return De(this, "find", e, t, dt, arguments)
    },
    findIndex(e, t) {
        return De(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
        return De(this, "findLast", e, t, dt, arguments)
    },
    findLastIndex(e, t) {
        return De(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
        return De(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
        return Oe(this, "includes", e)
    },
    indexOf(...e) {
        return Oe(this, "indexOf", e)
    },
    join(e) {
        return Te(this).join(e)
    },
    lastIndexOf(...e) {
        return Oe(this, "lastIndexOf", e)
    },
    map(e, t) {
        return De(this, "map", e, t, void 0, arguments)
    },
    pop() {
        return Le(this, "pop")
    },
    push(...e) {
        return Le(this, "push", e)
    },
    reduce(e, ...t) {
        return Pe(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
        return Pe(this, "reduceRight", e, t)
    },
    shift() {
        return Le(this, "shift")
    },
    some(e, t) {
        return De(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
        return Le(this, "splice", e)
    },
    toReversed() {
        return Te(this).toReversed()
    },
    toSorted(e) {
        return Te(this).toSorted(e)
    },
    toSpliced(...e) {
        return Te(this).toSpliced(...e)
    },
    unshift(...e) {
        return Le(this, "unshift", e)
    },
    values() {
        return Be(this, "values", dt)
    }
};
function Be(e, t, n) {
    const r = Me(e),
        o = r[t]();
    return r === e || lt(e) || (o._next = o.next, o.next = () => {
        const e = o._next();
        return e.done || (e.value = n(e.value)), e
    }), o
}
const ke = Array.prototype;
function De(e, t, n, r, o, i) {
    const a = Me(e),
        s = a !== e && !lt(e),
        l = a[t];
    if (l !== ke[t]) {
        const t = l.apply(e, i);
        return s ? dt(t) : t
    }
    let c = n;
    a !== e && (s ? c = function(t, r) {
        return n.call(this, dt(t), r, e)
    } : n.length > 2 && (c = function(t, r) {
        return n.call(this, t, r, e)
    }));
    const u = l.call(a, c, r);
    return s && o ? o(u) : u
}
function Pe(e, t, n, r) {
    const o = Me(e);
    let i = n;
    return o !== e && (lt(e) ? n.length > 3 && (i = function(t, r, o) {
        return n.call(this, t, r, o, e)
    }) : i = function(t, r, o) {
        return n.call(this, t, dt(r), o, e)
    }), o[t](i, ...r)
}
function Oe(e, t, n) {
    const r = ut(e);
    Se(r, 0, Ee);
    const o = r[t](...n);
    return -1 !== o && !1 !== o || !ct(n[0]) ? o : (n[0] = ut(n[0]), r[t](...n))
}
function Le(e, t, n=[]) {
    ge(),
    ie();
    const r = ut(e)[t].apply(e, n);
    return ae(), me(), r
}
const Ne = e("__proto__,__v_isRef,__isVue"),
    Fe = new Set(Object.getOwnPropertyNames(Symbol).filter(e => "arguments" !== e && "caller" !== e).map(e => Symbol[e]).filter(m));
function Ue(e) {
    m(e) || (e = String(e));
    const t = ut(this);
    return Se(t, 0, e), t.hasOwnProperty(e)
}
class ze {
    constructor(e=!1, t=!1)
    {
        this._isReadonly = e,
        this._isShallow = t
    }
    get(e, t, n)
    {
        if ("__v_skip" === t)
            return e.__v_skip;
        const r = this._isReadonly,
            o = this._isShallow;
        if ("__v_isReactive" === t)
            return !r;
        if ("__v_isReadonly" === t)
            return r;
        if ("__v_isShallow" === t)
            return o;
        if ("__v_raw" === t)
            return n === (r ? o ? nt : tt : o ? et : Ze).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
        const i = d(e);
        if (!r) {
            let e;
            if (i && (e = Re[t]))
                return e;
            if ("hasOwnProperty" === t)
                return Ue
        }
        const a = Reflect.get(e, t, ht(e) ? e : n);
        if (m(t) ? Fe.has(t) : Ne(t))
            return a;
        if (r || Se(e, 0, t), o)
            return a;
        if (ht(a)) {
            const e = i && x(t) ? a : a.value;
            return r && b(e) ? ot(e) : e
        }
        return b(a) ? r ? ot(a) : rt(a) : a
    }
}
class Qe extends ze {
    constructor(e=!1)
    {
        super(!1, e)
    }
    set(e, t, n, r)
    {
        let o = e[t];
        if (!this._isShallow) {
            const t = st(o);
            if (lt(n) || st(n) || (o = ut(o), n = ut(n)), !d(e) && ht(o) && !ht(n))
                return t || (o.value = n), !0
        }
        const i = d(e) && x(t) ? Number(t) < e.length : u(e, t),
            a = Reflect.set(e, t, n, ht(e) ? e : r);
        return e === ut(r) && (i ? B(n, o) && Ie(e, "set", t, n) : Ie(e, "add", t, n)), a
    }
    deleteProperty(e, t)
    {
        const n = u(e, t);
        e[t];
        const r = Reflect.deleteProperty(e, t);
        return r && n && Ie(e, "delete", t, void 0), r
    }
    has(e, t)
    {
        const n = Reflect.has(e, t);
        return m(t) && Fe.has(t) || Se(e, 0, t), n
    }
    ownKeys(e)
    {
        return Se(e, 0, d(e) ? "length" : we), Reflect.ownKeys(e)
    }
}
class Ge extends ze {
    constructor(e=!1)
    {
        super(!0, e)
    }
    set(e, t)
    {
        return !0
    }
    deleteProperty(e, t)
    {
        return !0
    }
}
const je = new Qe,
    Ve = new Ge,
    He = new Qe(!0),
    $e = e => e,
    We = e => Reflect.getPrototypeOf(e);
function Ke(e) {
    return function(...t) {
        return "delete" !== e && ("clear" === e ? void 0 : this)
    }
}
function qe(e, t) {
    const n = function(e, t) {
        const n = {
            get(n) {
                const r = this.__v_raw,
                    o = ut(r),
                    i = ut(n);
                e || (B(n, i) && Se(o, 0, n), Se(o, 0, i));
                const {has: a} = We(o),
                    s = t ? $e : e ? pt : dt;
                return a.call(o, n) ? s(r.get(n)) : a.call(o, i) ? s(r.get(i)) : void (r !== o && r.get(n))
            },
            get size() {
                const t = this.__v_raw;
                return !e && Se(ut(t), 0, we), t.size
            },
            has(t) {
                const n = this.__v_raw,
                    r = ut(n),
                    o = ut(t);
                return e || (B(t, o) && Se(r, 0, t), Se(r, 0, o)), t === o ? n.has(t) : n.has(t) || n.has(o)
            },
            forEach(n, r) {
                const o = this,
                    i = o.__v_raw,
                    a = ut(i),
                    s = t ? $e : e ? pt : dt;
                return !e && Se(a, 0, we), i.forEach((e, t) => n.call(r, s(e), s(t), o))
            }
        };
        return s(n, e ? {
            add: Ke("add"),
            set: Ke("set"),
            delete: Ke("delete"),
            clear: Ke("clear")
        } : {
            add(e) {
                t || lt(e) || st(e) || (e = ut(e));
                const n = ut(this);
                return We(n).has.call(n, e) || (n.add(e), Ie(n, "add", e, e)), this
            },
            set(e, n) {
                t || lt(n) || st(n) || (n = ut(n));
                const r = ut(this),
                    {has: o, get: i} = We(r);
                let a = o.call(r, e);
                a || (e = ut(e), a = o.call(r, e));
                const s = i.call(r, e);
                return r.set(e, n), a ? B(n, s) && Ie(r, "set", e, n) : Ie(r, "add", e, n), this
            },
            delete(e) {
                const t = ut(this),
                    {has: n, get: r} = We(t);
                let o = n.call(t, e);
                o || (e = ut(e), o = n.call(t, e)),
                r && r.call(t, e);
                const i = t.delete(e);
                return o && Ie(t, "delete", e, void 0), i
            },
            clear() {
                const e = ut(this),
                    t = 0 !== e.size,
                    n = e.clear();
                return t && Ie(e, "clear", void 0, void 0), n
            }
        }), ["keys", "values", "entries", Symbol.iterator].forEach(r => {
            n[r] = function(e, t, n) {
                return function(...r) {
                    const o = this.__v_raw,
                        i = ut(o),
                        a = p(i),
                        s = "entries" === e || e === Symbol.iterator && a,
                        l = "keys" === e && a,
                        c = o[e](...r),
                        u = n ? $e : t ? pt : dt;
                    return !t && Se(i, 0, l ? Ce : we), {
                        next() {
                            const {value: e, done: t} = c.next();
                            return t ? {
                                value: e,
                                done: t
                            } : {
                                value: s ? [u(e[0]), u(e[1])] : u(e),
                                done: t
                            }
                        },
                        [Symbol.iterator]() {
                            return this
                        }
                    }
                }
            }(r, e, t)
        }), n
    }(e, t);
    return (t, r, o) => "__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(u(n, r) && r in t ? n : t, r, o)
}
const Xe = {
        get: qe(!1, !1)
    },
    Ye = {
        get: qe(!1, !0)
    },
    Je = {
        get: qe(!0, !1)
    },
    Ze = new WeakMap,
    et = new WeakMap,
    tt = new WeakMap,
    nt = new WeakMap;
function rt(e) {
    return st(e) ? e : it(e, !1, je, Xe, Ze)
}
function ot(e) {
    return it(e, !0, Ve, Je, tt)
}
function it(e, t, n, r, o) {
    if (!b(e))
        return e;
    if (e.__v_raw && (!t || !e.__v_isReactive))
        return e;
    const i = (a = e).__v_skip || !Object.isExtensible(a) ? 0 : function(e) {
        switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
        }
    }((e => v(e).slice(8, -1))(a));
    var a;
    if (0 === i)
        return e;
    const s = o.get(e);
    if (s)
        return s;
    const l = new Proxy(e, 2 === i ? r : n);
    return o.set(e, l), l
}
function at(e) {
    return st(e) ? at(e.__v_raw) : !(!e || !e.__v_isReactive)
}
function st(e) {
    return !(!e || !e.__v_isReadonly)
}
function lt(e) {
    return !(!e || !e.__v_isShallow)
}
function ct(e) {
    return !!e && !!e.__v_raw
}
function ut(e) {
    const t = e && e.__v_raw;
    return t ? ut(t) : e
}
const dt = e => b(e) ? rt(e) : e,
    pt = e => b(e) ? ot(e) : e;
function ht(e) {
    return !!e && !0 === e.__v_isRef
}
function ft(e) {
    return ht(t = e) ? t : new gt(t, !1);
    var t
}
class gt {
    constructor(e, t)
    {
        this.dep = new ve,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = t ? e : ut(e),
        this._value = t ? e : dt(e),
        this.__v_isShallow = t
    }
    get value()
    {
        return this.dep.track(), this._value
    }
    set value(e)
    {
        const t = this._rawValue,
            n = this.__v_isShallow || lt(e) || st(e);
        e = n ? e : ut(e),
        B(e, t) && (this._rawValue = e, this._value = n ? e : dt(e), this.dep.trigger())
    }
}
function mt(e) {
    return ht(e) ? e.value : e
}
const bt = {
    get: (e, t, n) => "__v_raw" === t ? e : mt(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const o = e[t];
        return ht(o) && !ht(n) ? (o.value = n, !0) : Reflect.set(e, t, n, r)
    }
};
function At(e) {
    return at(e) ? e : new Proxy(e, bt)
}
class yt {
    constructor(e, t, n)
    {
        this.fn = e,
        this.setter = t,
        this._value = void 0,
        this.dep = new ve(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = Ae - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !t,
        this.isSSR = n
    }
    notify()
    {
        if (this.flags |= 16, !(8 & this.flags) && Y !== this)
            return oe(this, !0), !0
    }
    get value()
    {
        const e = this.dep.track();
        return ue(this), e && (e.version = this.dep.version), this._value
    }
    set value(e)
    {
        this.setter && this.setter(e)
    }
}
const vt = {},
    _t = new WeakMap;
let xt;
function wt(e, t=1 / 0, n) {
    if (t <= 0 || !b(e) || e.__v_skip)
        return e;
    if (((n = n || new Map).get(e) || 0) >= t)
        return e;
    if (n.set(e, t), t--, ht(e))
        wt(e.value, t, n);
    else if (d(e))
        for (let r = 0; r < e.length; r++)
            wt(e[r], t, n);
    else if (h(e) || p(e))
        e.forEach(e => {
            wt(e, t, n)
        });
    else if (_(e)) {
        for (const r in e)
            wt(e[r], t, n);
        for (const r of Object.getOwnPropertySymbols(e))
            Object.prototype.propertyIsEnumerable.call(e, r) && wt(e[r], t, n)
    }
    return e
}
function Ct(e, t, n, r) {
    try {
        return r ? e(...r) : e()
    } catch (o) {
        St(o, t, n)
    }
}
function Et(e, t, n, r) {
    if (f(e)) {
        const o = Ct(e, t, n, r);
        return o && A(o) && o.catch(e => {
            St(e, t, n)
        }), o
    }
    if (d(e)) {
        const o = [];
        for (let i = 0; i < e.length; i++)
            o.push(Et(e[i], t, n, r));
        return o
    }
}
function St(e, n, r, o=!0) {
    n && n.vnode;
    const {errorHandler: i, throwUnhandledErrorInProduction: a} = n && n.appContext.config || t;
    if (n) {
        let t = n.parent;
        const o = n.proxy,
            a = `https://vuejs.org/error-reference/#runtime-${r}`;
        for (; t;) {
            const n = t.ec;
            if (n)
                for (let t = 0; t < n.length; t++)
                    if (!1 === n[t](e, o, a))
                        return;
            t = t.parent
        }
        if (i)
            return ge(), Ct(i, null, 10, [e, o, a]), void me()
    }
    !function(e, t, n, r=!0, o=!1) {
        if (o)
            throw e
    }(e, 0, 0, o, a)
}
const It = [];
let Tt = -1;
const Mt = [];
let Rt = null,
    Bt = 0;
const kt = Promise.resolve();
let Dt = null;
function Pt(e) {
    const t = Dt || kt;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function Ot(e) {
    if (!(1 & e.flags)) {
        const t = Ut(e),
            n = It[It.length - 1];
        !n || !(2 & e.flags) && t >= Ut(n) ? It.push(e) : It.splice(function(e) {
            let t = Tt + 1,
                n = It.length;
            for (; t < n;) {
                const r = t + n >>> 1,
                    o = It[r],
                    i = Ut(o);
                i < e || i === e && 2 & o.flags ? t = r + 1 : n = r
            }
            return t
        }(t), 0, e),
        e.flags |= 1,
        Lt()
    }
}
function Lt() {
    Dt || (Dt = kt.then(zt))
}
function Nt(e, t, n=Tt + 1) {
    for (; n < It.length; n++) {
        const t = It[n];
        if (t && 2 & t.flags) {
            if (e && t.id !== e.uid)
                continue;
            It.splice(n, 1),
            n--,
            4 & t.flags && (t.flags &= -2),
            t(),
            4 & t.flags || (t.flags &= -2)
        }
    }
}
function Ft(e) {
    if (Mt.length) {
        const e = [...new Set(Mt)].sort((e, t) => Ut(e) - Ut(t));
        if (Mt.length = 0, Rt)
            return void Rt.push(...e);
        for (Rt = e, Bt = 0; Bt < Rt.length; Bt++) {
            const e = Rt[Bt];
            4 & e.flags && (e.flags &= -2),
            8 & e.flags || e(),
            e.flags &= -2
        }
        Rt = null,
        Bt = 0
    }
}
const Ut = e => null == e.id ? 2 & e.flags ? -1 : 1 / 0 : e.id;
function zt(e) {
    try {
        for (Tt = 0; Tt < It.length; Tt++) {
            const e = It[Tt];
            !e || 8 & e.flags || (4 & e.flags && (e.flags &= -2), Ct(e, e.i, e.i ? 15 : 14), 4 & e.flags || (e.flags &= -2))
        }
    } finally {
        for (; Tt < It.length; Tt++) {
            const e = It[Tt];
            e && (e.flags &= -2)
        }
        Tt = -1,
        It.length = 0,
        Ft(),
        Dt = null,
        (It.length || Mt.length) && zt()
    }
}
let Qt = null,
    Gt = null;
function jt(e) {
    const t = Qt;
    return Qt = e, Gt = e && e.type.__scopeId || null, t
}
function Vt(e, t=Qt, n) {
    if (!t)
        return e;
    if (e._n)
        return e;
    const r = (...n) => {
        r._d && ho(-1);
        const o = jt(t);
        let i;
        try {
            i = e(...n)
        } finally {
            jt(o),
            r._d && ho(1)
        }
        return i
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}
function Ht(e, n) {
    if (null === Qt)
        return e;
    const r = Vo(Qt),
        o = e.dirs || (e.dirs = []);
    for (let i = 0; i < n.length; i++) {
        let [e, a, s, l=t] = n[i];
        e && (f(e) && (e = {
            mounted: e,
            updated: e
        }), e.deep && wt(a), o.push({
            dir: e,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: s,
            modifiers: l
        }))
    }
    return e
}
function $t(e, t, n, r) {
    const o = e.dirs,
        i = t && t.dirs;
    for (let a = 0; a < o.length; a++) {
        const s = o[a];
        i && (s.oldValue = i[a].value);
        let l = s.dir[r];
        l && (ge(), Et(l, n, 8, [e.el, s, e, t]), me())
    }
}
const Wt = Symbol("_vte"),
    Kt = e => e.__isTeleport,
    qt = e => e && (e.disabled || "" === e.disabled),
    Xt = e => e && (e.defer || "" === e.defer),
    Yt = e => "undefined" != typeof SVGElement && e instanceof SVGElement,
    Jt = e => "function" == typeof MathMLElement && e instanceof MathMLElement,
    Zt = (e, t) => {
        const n = e && e.to;
        return g(n) ? t ? t(n) : null : n
    },
    en = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, r, o, i, a, s, l, c) {
            const {mc: u, pc: d, pbc: p, o: {insert: h, querySelector: f, createText: g, createComment: m}} = c,
                b = qt(t.props);
            let {shapeFlag: A, children: y, dynamicChildren: v} = t;
            if (null == e) {
                const e = t.el = g(""),
                    c = t.anchor = g("");
                h(e, n, r),
                h(c, n, r);
                const d = (e, t) => {
                        16 & A && u(y, e, t, o, i, a, s, l)
                    },
                    p = () => {
                        const e = t.target = Zt(t.props, f),
                            n = on(e, t, g, h);
                        e && ("svg" !== a && Yt(e) ? a = "svg" : "mathml" !== a && Jt(e) && (a = "mathml"), o && o.isCE && (o.ce._teleportTargets || (o.ce._teleportTargets = new Set)).add(e), b || (d(e, n), rn(t, !1)))
                    };
                b && (d(n, c), rn(t, !0)),
                Xt(t.props) ? (t.el.__isMounted = !1, Or(() => {
                    p(),
                    delete t.el.__isMounted
                }, i)) : p()
            } else {
                if (Xt(t.props) && !1 === e.el.__isMounted)
                    return void Or(() => {
                        en.process(e, t, n, r, o, i, a, s, l, c)
                    }, i);
                t.el = e.el,
                t.targetStart = e.targetStart;
                const u = t.anchor = e.anchor,
                    h = t.target = e.target,
                    g = t.targetAnchor = e.targetAnchor,
                    m = qt(e.props),
                    A = m ? n : h,
                    y = m ? u : g;
                if ("svg" === a || Yt(h) ? a = "svg" : ("mathml" === a || Jt(h)) && (a = "mathml"), v ? (p(e.dynamicChildren, v, A, o, i, a, s), Ur(e, t, !0)) : l || d(e, t, A, y, o, i, a, s, !1), b)
                    m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : tn(t, n, u, c, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const e = t.target = Zt(t.props, f);
                    e && tn(t, e, null, c, 0)
                } else
                    m && tn(t, h, g, c, 1);
                rn(t, b)
            }
        },
        remove(e, t, n, {um: r, o: {remove: o}}, i) {
            const {shapeFlag: a, children: s, anchor: l, targetStart: c, targetAnchor: u, target: d, props: p} = e;
            if (d && (o(c), o(u)), i && o(l), 16 & a) {
                const e = i || !qt(p);
                for (let o = 0; o < s.length; o++) {
                    const i = s[o];
                    r(i, t, n, e, !!i.dynamicChildren)
                }
            }
        },
        move: tn,
        hydrate: function(e, t, n, r, o, i, {o: {nextSibling: a, parentNode: s, querySelector: l, insert: c, createText: u}}, d) {
            function p(e, t, l, c) {
                t.anchor = d(a(e), t, s(e), n, r, o, i),
                t.targetStart = l,
                t.targetAnchor = c
            }
            const h = t.target = Zt(t.props, l),
                f = qt(t.props);
            if (h) {
                const s = h._lpa || h.firstChild;
                if (16 & t.shapeFlag)
                    if (f)
                        p(e, t, s, s && a(s));
                    else {
                        t.anchor = a(e);
                        let l = s;
                        for (; l;) {
                            if (l && 8 === l.nodeType)
                                if ("teleport start anchor" === l.data)
                                    t.targetStart = l;
                                else if ("teleport anchor" === l.data) {
                                    t.targetAnchor = l,
                                    h._lpa = t.targetAnchor && a(t.targetAnchor);
                                    break
                                }
                            l = a(l)
                        }
                        t.targetAnchor || on(h, t, u, c),
                        d(s && a(s), t, h, n, r, o, i)
                    }
                rn(t, f)
            } else
                f && 16 & t.shapeFlag && p(e, t, e, a(e));
            return t.anchor && a(t.anchor)
        }
    };
function tn(e, t, n, {o: {insert: r}, m: o}, i=2) {
    0 === i && r(e.targetAnchor, t, n);
    const {el: a, anchor: s, shapeFlag: l, children: c, props: u} = e,
        d = 2 === i;
    if (d && r(a, t, n), (!d || qt(u)) && 16 & l)
        for (let p = 0; p < c.length; p++)
            o(c[p], t, n, 2);
    d && r(s, t, n)
}
const nn = en;
function rn(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let r,
            o;
        for (t ? (r = e.el, o = e.anchor) : (r = e.targetStart, o = e.targetAnchor); r && r !== o;)
            1 === r.nodeType && r.setAttribute("data-v-owner", n.uid),
            r = r.nextSibling;
        n.ut()
    }
}
function on(e, t, n, r) {
    const o = t.targetStart = n(""),
        i = t.targetAnchor = n("");
    return o[Wt] = i, e && (r(o, e), r(i, e)), i
}
const an = Symbol("_leaveCb"),
    sn = Symbol("_enterCb"),
    ln = [Function, Array],
    cn = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: ln,
        onEnter: ln,
        onAfterEnter: ln,
        onEnterCancelled: ln,
        onBeforeLeave: ln,
        onLeave: ln,
        onAfterLeave: ln,
        onLeaveCancelled: ln,
        onBeforeAppear: ln,
        onAppear: ln,
        onAfterAppear: ln,
        onAppearCancelled: ln
    },
    un = e => {
        const t = e.subTree;
        return t.component ? un(t.component) : t
    };
function dn(e) {
    let t = e[0];
    if (e.length > 1)
        for (const n of e)
            if (n.type !== ao) {
                t = n;
                break
            }
    return t
}
const pn = {
    name: "BaseTransition",
    props: cn,
    setup(e, {slots: t}) {
        const n = Po(),
            r = function() {
                const e = {
                    isMounted: !1,
                    isLeaving: !1,
                    isUnmounting: !1,
                    leavingVNodes: new Map
                };
                return Dn(() => {
                    e.isMounted = !0
                }), Ln(() => {
                    e.isUnmounting = !0
                }), e
            }();
        return () => {
            const o = t.default && An(t.default(), !0);
            if (!o || !o.length)
                return;
            const i = dn(o),
                a = ut(e),
                {mode: s} = a;
            if (r.isLeaving)
                return gn(i);
            const l = mn(i);
            if (!l)
                return gn(i);
            let c = fn(l, a, r, n, e => c = e);
            l.type !== ao && bn(l, c);
            let u = n.subTree && mn(n.subTree);
            if (u && u.type !== ao && !Ao(u, l) && un(n).type !== ao) {
                let e = fn(u, a, r, n);
                if (bn(u, e), "out-in" === s && l.type !== ao)
                    return r.isLeaving = !0, e.afterLeave = () => {
                        r.isLeaving = !1,
                        8 & n.job.flags || n.update(),
                        delete e.afterLeave,
                        u = void 0
                    }, gn(i);
                "in-out" === s && l.type !== ao ? e.delayLeave = (e, t, n) => {
                    hn(r, u)[String(u.key)] = u,
                    e[an] = () => {
                        t(),
                        e[an] = void 0,
                        delete c.delayedLeave,
                        u = void 0
                    },
                    c.delayedLeave = () => {
                        n(),
                        delete c.delayedLeave,
                        u = void 0
                    }
                } : u = void 0
            } else
                u && (u = void 0);
            return i
        }
    }
};
function hn(e, t) {
    const {leavingVNodes: n} = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null), n.set(t.type, r)), r
}
function fn(e, t, n, r, o) {
    const {appear: i, mode: a, persisted: s=!1, onBeforeEnter: l, onEnter: c, onAfterEnter: u, onEnterCancelled: p, onBeforeLeave: h, onLeave: f, onAfterLeave: g, onLeaveCancelled: m, onBeforeAppear: b, onAppear: A, onAfterAppear: y, onAppearCancelled: v} = t,
        _ = String(e.key),
        x = hn(n, e),
        w = (e, t) => {
            e && Et(e, r, 9, t)
        },
        C = (e, t) => {
            const n = t[1];
            w(e, t),
            d(e) ? e.every(e => e.length <= 1) && n() : e.length <= 1 && n()
        },
        E = {
            mode: a,
            persisted: s,
            beforeEnter(t) {
                let r = l;
                if (!n.isMounted) {
                    if (!i)
                        return;
                    r = b || l
                }
                t[an] && t[an](!0);
                const o = x[_];
                o && Ao(e, o) && o.el[an] && o.el[an](),
                w(r, [t])
            },
            enter(e) {
                let t = c,
                    r = u,
                    o = p;
                if (!n.isMounted) {
                    if (!i)
                        return;
                    t = A || c,
                    r = y || u,
                    o = v || p
                }
                let a = !1;
                const s = e[sn] = t => {
                    a || (a = !0, w(t ? o : r, [e]), E.delayedLeave && E.delayedLeave(), e[sn] = void 0)
                };
                t ? C(t, [e, s]) : s()
            },
            leave(t, r) {
                const o = String(e.key);
                if (t[sn] && t[sn](!0), n.isUnmounting)
                    return r();
                w(h, [t]);
                let i = !1;
                const a = t[an] = n => {
                    i || (i = !0, r(), w(n ? m : g, [t]), t[an] = void 0, x[o] === e && delete x[o])
                };
                x[o] = e,
                f ? C(f, [t, a]) : a()
            },
            clone(e) {
                const i = fn(e, t, n, r, o);
                return o && o(i), i
            }
        };
    return E
}
function gn(e) {
    if (En(e))
        return (e = wo(e)).children = null, e
}
function mn(e) {
    if (!En(e))
        return Kt(e.type) && e.children ? dn(e.children) : e;
    if (e.component)
        return e.component.subTree;
    const {shapeFlag: t, children: n} = e;
    if (n) {
        if (16 & t)
            return n[0];
        if (32 & t && f(n.default))
            return n.default()
    }
}
function bn(e, t) {
    6 & e.shapeFlag && e.component ? (e.transition = t, bn(e.component.subTree, t)) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function An(e, t=!1, n) {
    let r = [],
        o = 0;
    for (let i = 0; i < e.length; i++) {
        let a = e[i];
        const s = null == n ? a.key : String(n) + String(null != a.key ? a.key : i);
        a.type === oo ? (128 & a.patchFlag && o++, r = r.concat(An(a.children, t, s))) : (t || a.type !== ao) && r.push(null != s ? wo(a, {
            key: s
        }) : a)
    }
    if (o > 1)
        for (let i = 0; i < r.length; i++)
            r[i].patchFlag = -2;
    return r
}
function yn(e, t) {
    return f(e) ? (() => s({
        name: e.name
    }, t, {
        setup: e
    }))() : e
}
function vn(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}
const _n = new WeakMap;
function xn(e, n, r, i, a=!1) {
    if (d(e))
        return void e.forEach((e, t) => xn(e, n && (d(n) ? n[t] : n), r, i, a));
    if (Cn(i) && !a)
        return void (512 & i.shapeFlag && i.type.__asyncResolved && i.component.subTree.component && xn(e, n, r, i.component.subTree));
    const s = 4 & i.shapeFlag ? Vo(i.component) : i.el,
        c = a ? null : s,
        {i: p, r: h} = e,
        m = n && n.r,
        b = p.refs === t ? p.refs = {} : p.refs,
        A = p.setupState,
        y = ut(A),
        v = A === t ? o : e => u(y, e);
    if (null != m && m !== h)
        if (wn(n), g(m))
            b[m] = null,
            v(m) && (A[m] = null);
        else if (ht(m)) {
            m.value = null;
            const e = n;
            e.k && (b[e.k] = null)
        }
    if (f(h))
        Ct(h, p, 12, [c, b]);
    else {
        const t = g(h),
            n = ht(h);
        if (t || n) {
            const o = () => {
                if (e.f) {
                    const n = t ? v(h) ? A[h] : b[h] : h.value;
                    if (a)
                        d(n) && l(n, s);
                    else if (d(n))
                        n.includes(s) || n.push(s);
                    else if (t)
                        b[h] = [s],
                        v(h) && (A[h] = b[h]);
                    else {
                        const t = [s];
                        h.value = t,
                        e.k && (b[e.k] = t)
                    }
                } else
                    t ? (b[h] = c, v(h) && (A[h] = c)) : n && (h.value = c, e.k && (b[e.k] = c))
            };
            if (c) {
                const t = () => {
                    o(),
                    _n.delete(e)
                };
                t.id = -1,
                _n.set(e, t),
                Or(t, r)
            } else
                wn(e),
                o()
        }
    }
}
function wn(e) {
    const t = _n.get(e);
    t && (t.flags |= 8, _n.delete(e))
}
L().requestIdleCallback,
L().cancelIdleCallback;
const Cn = e => !!e.type.__asyncLoader,
    En = e => e.type.__isKeepAlive;
function Sn(e, t) {
    Tn(e, "a", t)
}
function In(e, t) {
    Tn(e, "da", t)
}
function Tn(e, t, n=Do) {
    const r = e.__wdc || (e.__wdc = () => {
        let t = n;
        for (; t;) {
            if (t.isDeactivated)
                return;
            t = t.parent
        }
        return e()
    });
    if (Rn(t, r, n), n) {
        let e = n.parent;
        for (; e && e.parent;)
            En(e.parent.vnode) && Mn(r, t, n, e),
            e = e.parent
    }
}
function Mn(e, t, n, r) {
    const o = Rn(t, e, r, !0);
    Nn(() => {
        l(r[t], o)
    }, n)
}
function Rn(e, t, n=Do, r=!1) {
    if (n) {
        const o = n[e] || (n[e] = []),
            i = t.__weh || (t.__weh = (...r) => {
                ge();
                const o = No(n),
                    i = Et(t, n, e, r);
                return o(), me(), i
            });
        return r ? o.unshift(i) : o.push(i), i
    }
}
const Bn = e => (t, n=Do) => {
        zo && "sp" !== e || Rn(e, (...e) => t(...e), n)
    },
    kn = Bn("bm"),
    Dn = Bn("m"),
    Pn = Bn("bu"),
    On = Bn("u"),
    Ln = Bn("bum"),
    Nn = Bn("um"),
    Fn = Bn("sp"),
    Un = Bn("rtg"),
    zn = Bn("rtc");
function Qn(e, t=Do) {
    Rn("ec", e, t)
}
const Gn = "components";
function jn(e, t) {
    return Wn(Gn, e, !0, t) || e
}
const Vn = Symbol.for("v-ndc");
function Hn(e) {
    return g(e) ? Wn(Gn, e, !1) || e : e || Vn
}
function $n(e) {
    return Wn("directives", e)
}
function Wn(e, t, n=!0, r=!1) {
    const o = Qt || Do;
    if (o) {
        const n = o.type;
        if (e === Gn) {
            const e = function(e, t=!0) {
                return f(e) ? e.displayName || e.name : e.name || t && e.__name
            }(n, !1);
            if (e && (e === t || e === S(t) || e === M(S(t))))
                return n
        }
        const i = Kn(o[e] || n[e], t) || Kn(o.appContext[e], t);
        return !i && r ? n : i
    }
}
function Kn(e, t) {
    return e && (e[t] || e[S(t)] || e[M(S(t))])
}
function qn(e, t, n, r) {
    let o;
    const i = n,
        a = d(e);
    if (a || g(e)) {
        let n = !1,
            r = !1;
        a && at(e) && (n = !lt(e), r = st(e), e = Me(e)),
        o = new Array(e.length);
        for (let a = 0, s = e.length; a < s; a++)
            o[a] = t(n ? r ? pt(dt(e[a])) : dt(e[a]) : e[a], a, void 0, i)
    } else if ("number" == typeof e) {
        o = new Array(e);
        for (let n = 0; n < e; n++)
            o[n] = t(n + 1, n, void 0, i)
    } else if (b(e))
        if (e[Symbol.iterator])
            o = Array.from(e, (e, n) => t(e, n, void 0, i));
        else {
            const n = Object.keys(e);
            o = new Array(n.length);
            for (let r = 0, a = n.length; r < a; r++) {
                const a = n[r];
                o[r] = t(e[a], a, r, i)
            }
        }
    else
        o = [];
    return o
}
function Xn(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (d(r))
            for (let t = 0; t < r.length; t++)
                e[r[t].name] = r[t].fn;
        else
            r && (e[r.name] = r.key ? (...e) => {
                const t = r.fn(...e);
                return t && (t.key = r.key), t
            } : r.fn)
    }
    return e
}
function Yn(e, t, n={}, r, o) {
    if (Qt.ce || Qt.parent && Cn(Qt.parent) && Qt.parent.ce) {
        const e = Object.keys(n).length > 0;
        return "default" !== t && (n.name = t), uo(), mo(oo, null, [xo("slot", n, r && r())], e ? -2 : 64)
    }
    let i = e[t];
    i && i._c && (i._d = !1),
    uo();
    const a = i && Jn(i(n)),
        s = n.key || a && a.key,
        l = mo(oo, {
            key: (s && !m(s) ? s : `_${t}`) + (!a && r ? "_fb" : "")
        }, a || (r ? r() : []), a && 1 === e._ ? 64 : -2);
    return l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), i && i._c && (i._d = !0), l
}
function Jn(e) {
    return e.some(e => !bo(e) || e.type !== ao && !(e.type === oo && !Jn(e.children))) ? e : null
}
function Zn(e, t) {
    const n = {};
    for (const r in e)
        n[/[A-Z]/.test(r) ? `on:${r}` : R(r)] = e[r];
    return n
}
const er = e => e ? Uo(e) ? Vo(e) : er(e.parent) : null,
    tr = s(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => er(e.parent),
        $root: e => er(e.root),
        $host: e => e.ce,
        $emit: e => e.emit,
        $options: e => lr(e),
        $forceUpdate: e => e.f || (e.f = () => {
            Ot(e.update)
        }),
        $nextTick: e => e.n || (e.n = Pt.bind(e.proxy)),
        $watch: e => $r.bind(e)
    }),
    nr = (e, n) => e !== t && !e.__isScriptSetup && u(e, n),
    rr = {
        get({_: e}, n) {
            if ("__v_skip" === n)
                return !0;
            const {ctx: r, setupState: o, data: i, props: a, accessCache: s, type: l, appContext: c} = e;
            let d;
            if ("$" !== n[0]) {
                const l = s[n];
                if (void 0 !== l)
                    switch (l) {
                    case 1:
                        return o[n];
                    case 2:
                        return i[n];
                    case 4:
                        return r[n];
                    case 3:
                        return a[n]
                    }
                else {
                    if (nr(o, n))
                        return s[n] = 1, o[n];
                    if (i !== t && u(i, n))
                        return s[n] = 2, i[n];
                    if ((d = e.propsOptions[0]) && u(d, n))
                        return s[n] = 3, a[n];
                    if (r !== t && u(r, n))
                        return s[n] = 4, r[n];
                    ir && (s[n] = 0)
                }
            }
            const p = tr[n];
            let h,
                f;
            return p ? ("$attrs" === n && Se(e.attrs, 0, ""), p(e)) : (h = l.__cssModules) && (h = h[n]) ? h : r !== t && u(r, n) ? (s[n] = 4, r[n]) : (f = c.config.globalProperties, u(f, n) ? f[n] : void 0)
        },
        set({_: e}, n, r) {
            const {data: o, setupState: i, ctx: a} = e;
            return nr(i, n) ? (i[n] = r, !0) : o !== t && u(o, n) ? (o[n] = r, !0) : !(u(e.props, n) || "$" === n[0] && n.slice(1) in e || (a[n] = r, 0))
        },
        has({_: {data: e, setupState: n, accessCache: r, ctx: o, appContext: i, propsOptions: a, type: s}}, l) {
            let c,
                d;
            return !!(r[l] || e !== t && "$" !== l[0] && u(e, l) || nr(n, l) || (c = a[0]) && u(c, l) || u(o, l) || u(tr, l) || u(i.config.globalProperties, l) || (d = s.__cssModules) && d[l])
        },
        defineProperty(e, t, n) {
            return null != n.get ? e._.accessCache[t] = 0 : u(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
        }
    };
function or(e) {
    return d(e) ? e.reduce((e, t) => (e[t] = null, e), {}) : e
}
let ir = !0;
function ar(e, t, n) {
    Et(d(e) ? e.map(e => e.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function sr(e, t, n, r) {
    let o = r.includes(".") ? Wr(n, r) : () => n[r];
    if (g(e)) {
        const n = t[e];
        f(n) && Vr(o, n)
    } else if (f(e))
        Vr(o, e.bind(n));
    else if (b(e))
        if (d(e))
            e.forEach(e => sr(e, t, n, r));
        else {
            const r = f(e.handler) ? e.handler.bind(n) : t[e.handler];
            f(r) && Vr(o, r, e)
        }
}
function lr(e) {
    const t = e.type,
        {mixins: n, extends: r} = t,
        {mixins: o, optionsCache: i, config: {optionMergeStrategies: a}} = e.appContext,
        s = i.get(t);
    let l;
    return s ? l = s : o.length || n || r ? (l = {}, o.length && o.forEach(e => cr(l, e, a, !0)), cr(l, t, a)) : l = t, b(t) && i.set(t, l), l
}
function cr(e, t, n, r=!1) {
    const {mixins: o, extends: i} = t;
    i && cr(e, i, n, !0),
    o && o.forEach(t => cr(e, t, n, !0));
    for (const a in t)
        if (r && "expose" === a)
            ;
        else {
            const r = ur[a] || n && n[a];
            e[a] = r ? r(e[a], t[a]) : t[a]
        }
    return e
}
const ur = {
    data: dr,
    props: gr,
    emits: gr,
    methods: fr,
    computed: fr,
    beforeCreate: hr,
    created: hr,
    beforeMount: hr,
    mounted: hr,
    beforeUpdate: hr,
    updated: hr,
    beforeDestroy: hr,
    beforeUnmount: hr,
    destroyed: hr,
    unmounted: hr,
    activated: hr,
    deactivated: hr,
    errorCaptured: hr,
    serverPrefetch: hr,
    components: fr,
    directives: fr,
    watch: function(e, t) {
        if (!e)
            return t;
        if (!t)
            return e;
        const n = s(Object.create(null), e);
        for (const r in t)
            n[r] = hr(e[r], t[r]);
        return n
    },
    provide: dr,
    inject: function(e, t) {
        return fr(pr(e), pr(t))
    }
};
function dr(e, t) {
    return t ? e ? function() {
        return s(f(e) ? e.call(this, this) : e, f(t) ? t.call(this, this) : t)
    } : t : e
}
function pr(e) {
    if (d(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function hr(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function fr(e, t) {
    return e ? s(Object.create(null), e, t) : t
}
function gr(e, t) {
    return e ? d(e) && d(t) ? [...new Set([...e, ...t])] : s(Object.create(null), or(e), or(null != t ? t : {})) : t
}
function mr() {
    return {
        app: null,
        config: {
            isNativeTag: o,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let br = 0;
function Ar(e, t) {
    return function(t, n=null) {
        f(t) || (t = s({}, t)),
        null == n || b(n) || (n = null);
        const r = mr(),
            o = new WeakSet,
            i = [];
        let a = !1;
        const l = r.app = {
            _uid: br++,
            _component: t,
            _props: n,
            _container: null,
            _context: r,
            _instance: null,
            version: Wo,
            get config() {
                return r.config
            },
            set config(e) {},
            use: (e, ...t) => (o.has(e) || (e && f(e.install) ? (o.add(e), e.install(l, ...t)) : f(e) && (o.add(e), e(l, ...t))), l),
            mixin: e => (r.mixins.includes(e) || r.mixins.push(e), l),
            component: (e, t) => t ? (r.components[e] = t, l) : r.components[e],
            directive: (e, t) => t ? (r.directives[e] = t, l) : r.directives[e],
            mount(o, i, s) {
                if (!a) {
                    const i = l._ceVNode || xo(t, n);
                    return i.appContext = r, !0 === s ? s = "svg" : !1 === s && (s = void 0), e(i, o, s), a = !0, l._container = o, o.__vue_app__ = l, Vo(i.component)
                }
            },
            onUnmount(e) {
                i.push(e)
            },
            unmount() {
                a && (Et(i, l._instance, 16), e(null, l._container), delete l._container.__vue_app__)
            },
            provide: (e, t) => (r.provides[e] = t, l),
            runWithContext(e) {
                const t = yr;
                yr = l;
                try {
                    return e()
                } finally {
                    yr = t
                }
            }
        };
        return l
    }
}
let yr = null;
function vr(e, t, n=!1) {
    const r = Po();
    if (r || yr) {
        let o = yr ? yr._context.provides : r ? null == r.parent || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (o && e in o)
            return o[e];
        if (arguments.length > 1)
            return n && f(t) ? t.call(r && r.proxy) : t
    }
}
const _r = {},
    xr = () => Object.create(_r),
    wr = e => Object.getPrototypeOf(e) === _r;
function Cr(e, n, r, o) {
    const [i, a] = e.propsOptions;
    let s,
        l = !1;
    if (n)
        for (let t in n) {
            if (w(t))
                continue;
            const c = n[t];
            let d;
            i && u(i, d = S(t)) ? a && a.includes(d) ? (s || (s = {}))[d] = c : r[d] = c : Jr(e.emitsOptions, t) || t in o && c === o[t] || (o[t] = c, l = !0)
        }
    if (a) {
        const n = ut(r),
            o = s || t;
        for (let t = 0; t < a.length; t++) {
            const s = a[t];
            r[s] = Er(i, n, s, o[s], e, !u(o, s))
        }
    }
    return l
}
function Er(e, t, n, r, o, i) {
    const a = e[n];
    if (null != a) {
        const e = u(a, "default");
        if (e && void 0 === r) {
            const e = a.default;
            if (a.type !== Function && !a.skipFactory && f(e)) {
                const {propsDefaults: i} = o;
                if (n in i)
                    r = i[n];
                else {
                    const a = No(o);
                    r = i[n] = e.call(null, t),
                    a()
                }
            } else
                r = e;
            o.ce && o.ce._setProp(n, r)
        }
        a[0] && (i && !e ? r = !1 : !a[1] || "" !== r && r !== T(n) || (r = !0))
    }
    return r
}
const Sr = new WeakMap;
function Ir(e, r, o=!1) {
    const i = o ? Sr : r.propsCache,
        a = i.get(e);
    if (a)
        return a;
    const l = e.props,
        c = {},
        p = [];
    let h = !1;
    if (!f(e)) {
        const t = e => {
            h = !0;
            const [t, n] = Ir(e, r, !0);
            s(c, t),
            n && p.push(...n)
        };
        !o && r.mixins.length && r.mixins.forEach(t),
        e.extends && t(e.extends),
        e.mixins && e.mixins.forEach(t)
    }
    if (!l && !h)
        return b(e) && i.set(e, n), n;
    if (d(l))
        for (let n = 0; n < l.length; n++) {
            const e = S(l[n]);
            Tr(e) && (c[e] = t)
        }
    else if (l)
        for (const t in l) {
            const e = S(t);
            if (Tr(e)) {
                const n = l[t],
                    r = c[e] = d(n) || f(n) ? {
                        type: n
                    } : s({}, n),
                    o = r.type;
                let i = !1,
                    a = !0;
                if (d(o))
                    for (let e = 0; e < o.length; ++e) {
                        const t = o[e],
                            n = f(t) && t.name;
                        if ("Boolean" === n) {
                            i = !0;
                            break
                        }
                        "String" === n && (a = !1)
                    }
                else
                    i = f(o) && "Boolean" === o.name;
                r[0] = i,
                r[1] = a,
                (i || u(r, "default")) && p.push(e)
            }
        }
    const g = [c, p];
    return b(e) && i.set(e, g), g
}
function Tr(e) {
    return "$" !== e[0] && !w(e)
}
const Mr = e => "_" === e || "_ctx" === e || "$stable" === e,
    Rr = e => d(e) ? e.map(So) : [So(e)],
    Br = (e, t, n) => {
        if (t._n)
            return t;
        const r = Vt((...e) => Rr(t(...e)), n);
        return r._c = !1, r
    },
    kr = (e, t, n) => {
        const r = e._ctx;
        for (const o in e) {
            if (Mr(o))
                continue;
            const n = e[o];
            if (f(n))
                t[o] = Br(0, n, r);
            else if (null != n) {
                const e = Rr(n);
                t[o] = () => e
            }
        }
    },
    Dr = (e, t) => {
        const n = Rr(t);
        e.slots.default = () => n
    },
    Pr = (e, t, n) => {
        for (const r in t)
            !n && Mr(r) || (e[r] = t[r])
    },
    Or = function(e, t) {
        var n;
        t && t.pendingBranch ? d(e) ? t.effects.push(...e) : t.effects.push(e) : (d(n = e) ? Mt.push(...n) : Rt && -1 === n.id ? Rt.splice(Bt + 1, 0, n) : 1 & n.flags || (Mt.push(n), n.flags |= 1), Lt())
    };
function Lr(e) {
    return function(e) {
        L().__VUE__ = !0;
        const {insert: o, remove: i, patchProp: a, createElement: s, createText: l, createComment: c, setText: d, setElementText: p, parentNode: h, nextSibling: f, setScopeId: g=r, insertStaticContent: m} = e,
            b = (e, t, n, r=null, o=null, i=null, a=void 0, s=null, l=!!t.dynamicChildren) => {
                if (e === t)
                    return;
                e && !Ao(e, t) && (r = X(e), H(e, o, i, !0), e = null),
                -2 === t.patchFlag && (l = !1, t.dynamicChildren = null);
                const {type: c, ref: u, shapeFlag: d} = t;
                switch (c) {
                case io:
                    y(e, t, n, r);
                    break;
                case ao:
                    v(e, t, n, r);
                    break;
                case so:
                    null == e && _(t, n, r, a);
                    break;
                case oo:
                    P(e, t, n, r, o, i, a, s, l);
                    break;
                default:
                    1 & d ? x(e, t, n, r, o, i, a, s, l) : 6 & d ? O(e, t, n, r, o, i, a, s, l) : (64 & d || 128 & d) && c.process(e, t, n, r, o, i, a, s, l, te)
                }
                null != u && o ? xn(u, e && e.ref, i, t || e, !t) : null == u && e && null != e.ref && xn(e.ref, null, i, e, !0)
            },
            y = (e, t, n, r) => {
                if (null == e)
                    o(t.el = l(t.children), n, r);
                else {
                    const n = t.el = e.el;
                    t.children !== e.children && d(n, t.children)
                }
            },
            v = (e, t, n, r) => {
                null == e ? o(t.el = c(t.children || ""), n, r) : t.el = e.el
            },
            _ = (e, t, n, r) => {
                [e.el, e.anchor] = m(e.children, t, n, r, e.el, e.anchor)
            },
            x = (e, t, n, r, o, i, a, s, l) => {
                "svg" === t.type ? a = "svg" : "math" === t.type && (a = "mathml"),
                null == e ? C(t, n, r, o, i, a, s, l) : M(e, t, o, i, a, s, l)
            },
            C = (e, t, n, r, i, l, c, u) => {
                let d,
                    h;
                const {props: f, shapeFlag: g, transition: m, dirs: b} = e;
                if (d = e.el = s(e.type, l, f && f.is, f), 8 & g ? p(d, e.children) : 16 & g && I(e.children, d, null, r, i, Nr(e, l), c, u), b && $t(e, null, r, "created"), E(d, e, e.scopeId, c, r), f) {
                    for (const e in f)
                        "value" === e || w(e) || a(d, e, null, f[e], l, r);
                    "value" in f && a(d, "value", null, f.value, l),
                    (h = f.onVnodeBeforeMount) && Ro(h, r, e)
                }
                b && $t(e, null, r, "beforeMount");
                const A = function(e, t) {
                    return (!e || e && !e.pendingBranch) && t && !t.persisted
                }(i, m);
                A && m.beforeEnter(d),
                o(d, t, n),
                ((h = f && f.onVnodeMounted) || A || b) && Or(() => {
                    h && Ro(h, r, e),
                    A && m.enter(d),
                    b && $t(e, null, r, "mounted")
                }, i)
            },
            E = (e, t, n, r, o) => {
                if (n && g(e, n), r)
                    for (let i = 0; i < r.length; i++)
                        g(e, r[i]);
                if (o) {
                    let n = o.subTree;
                    if (t === n || ro(n.type) && (n.ssContent === t || n.ssFallback === t)) {
                        const t = o.vnode;
                        E(e, t, t.scopeId, t.slotScopeIds, o.parent)
                    }
                }
            },
            I = (e, t, n, r, o, i, a, s, l=0) => {
                for (let c = l; c < e.length; c++) {
                    const l = e[c] = s ? Io(e[c]) : So(e[c]);
                    b(null, l, t, n, r, o, i, a, s)
                }
            },
            M = (e, n, r, o, i, s, l) => {
                const c = n.el = e.el;
                let {patchFlag: u, dynamicChildren: d, dirs: h} = n;
                u |= 16 & e.patchFlag;
                const f = e.props || t,
                    g = n.props || t;
                let m;
                if (r && Fr(r, !1), (m = g.onVnodeBeforeUpdate) && Ro(m, r, n, e), h && $t(n, e, r, "beforeUpdate"), r && Fr(r, !0), (f.innerHTML && null == g.innerHTML || f.textContent && null == g.textContent) && p(c, ""), d ? R(e.dynamicChildren, d, c, r, o, Nr(n, i), s) : l || Q(e, n, c, null, r, o, Nr(n, i), s, !1), u > 0) {
                    if (16 & u)
                        B(c, f, g, r, i);
                    else if (2 & u && f.class !== g.class && a(c, "class", null, g.class, i), 4 & u && a(c, "style", f.style, g.style, i), 8 & u) {
                        const e = n.dynamicProps;
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t],
                                o = f[n],
                                s = g[n];
                            s === o && "value" !== n || a(c, n, o, s, i, r)
                        }
                    }
                    1 & u && e.children !== n.children && p(c, n.children)
                } else
                    l || null != d || B(c, f, g, r, i);
                ((m = g.onVnodeUpdated) || h) && Or(() => {
                    m && Ro(m, r, n, e),
                    h && $t(n, e, r, "updated")
                }, o)
            },
            R = (e, t, n, r, o, i, a) => {
                for (let s = 0; s < t.length; s++) {
                    const l = e[s],
                        c = t[s],
                        u = l.el && (l.type === oo || !Ao(l, c) || 198 & l.shapeFlag) ? h(l.el) : n;
                    b(l, c, u, null, r, o, i, a, !0)
                }
            },
            B = (e, n, r, o, i) => {
                if (n !== r) {
                    if (n !== t)
                        for (const t in n)
                            w(t) || t in r || a(e, t, n[t], null, i, o);
                    for (const t in r) {
                        if (w(t))
                            continue;
                        const s = r[t],
                            l = n[t];
                        s !== l && "value" !== t && a(e, t, l, s, i, o)
                    }
                    "value" in r && a(e, "value", n.value, r.value, i)
                }
            },
            P = (e, t, n, r, i, a, s, c, u) => {
                const d = t.el = e ? e.el : l(""),
                    p = t.anchor = e ? e.anchor : l("");
                let {patchFlag: h, dynamicChildren: f, slotScopeIds: g} = t;
                g && (c = c ? c.concat(g) : g),
                null == e ? (o(d, n, r), o(p, n, r), I(t.children || [], n, p, i, a, s, c, u)) : h > 0 && 64 & h && f && e.dynamicChildren ? (R(e.dynamicChildren, f, n, i, a, s, c), (null != t.key || i && t === i.subTree) && Ur(e, t, !0)) : Q(e, t, n, p, i, a, s, c, u)
            },
            O = (e, t, n, r, o, i, a, s, l) => {
                t.slotScopeIds = s,
                null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, a, l) : N(t, n, r, o, i, a, l) : F(e, t, l)
            },
            N = (e, n, r, o, i, a, s) => {
                const l = e.component = function(e, n, r) {
                    const o = e.type,
                        i = (n ? n.appContext : e.appContext) || Bo,
                        a = {
                            uid: ko++,
                            vnode: e,
                            type: o,
                            parent: n,
                            appContext: i,
                            root: null,
                            next: null,
                            subTree: null,
                            effect: null,
                            update: null,
                            job: null,
                            scope: new J(!0),
                            render: null,
                            proxy: null,
                            exposed: null,
                            exposeProxy: null,
                            withProxy: null,
                            provides: n ? n.provides : Object.create(i.provides),
                            ids: n ? n.ids : ["", 0, 0],
                            accessCache: null,
                            renderCache: [],
                            components: null,
                            directives: null,
                            propsOptions: Ir(o, i),
                            emitsOptions: Yr(o, i),
                            emit: null,
                            emitted: null,
                            propsDefaults: t,
                            inheritAttrs: o.inheritAttrs,
                            ctx: t,
                            data: t,
                            props: t,
                            attrs: t,
                            slots: t,
                            refs: t,
                            setupState: t,
                            setupContext: null,
                            suspense: r,
                            suspenseId: r ? r.pendingId : 0,
                            asyncDep: null,
                            asyncResolved: !1,
                            isMounted: !1,
                            isUnmounted: !1,
                            isDeactivated: !1,
                            bc: null,
                            c: null,
                            bm: null,
                            m: null,
                            bu: null,
                            u: null,
                            um: null,
                            bum: null,
                            da: null,
                            a: null,
                            rtg: null,
                            rtc: null,
                            ec: null,
                            sp: null
                        };
                    return a.ctx = {
                        _: a
                    }, a.root = n ? n.root : a, a.emit = qr.bind(null, a), e.ce && e.ce(a), a
                }(e, o, i);
                if (En(e) && (l.ctx.renderer = te), function(e, t=!1, n=!1) {
                    t && Lo(t);
                    const {props: r, children: o} = e.vnode,
                        i = Uo(e);
                    (function(e, t, n, r=!1) {
                        const o = {},
                            i = xr();
                        e.propsDefaults = Object.create(null),
                        Cr(e, t, o, i);
                        for (const a in e.propsOptions[0])
                            a in o || (o[a] = void 0);
                        n ? e.props = r ? o : it(o, !1, He, Ye, et) : e.type.props ? e.props = o : e.props = i,
                        e.attrs = i
                    })(e, r, i, t),
                    ((e, t, n) => {
                        const r = e.slots = xr();
                        if (32 & e.vnode.shapeFlag) {
                            const e = t._;
                            e ? (Pr(r, t, n), n && D(r, "_", e, !0)) : kr(t, r)
                        } else
                            t && Dr(e, t)
                    })(e, o, n || t);
                    i && function(e, t) {
                        const n = e.type;
                        e.accessCache = Object.create(null),
                        e.proxy = new Proxy(e.ctx, rr);
                        const {setup: r} = n;
                        if (r) {
                            ge();
                            const n = e.setupContext = r.length > 1 ? function(e) {
                                    return {
                                        attrs: new Proxy(e.attrs, jo),
                                        slots: e.slots,
                                        emit: e.emit,
                                        expose: t => {
                                            e.exposed = t || {}
                                        }
                                    }
                                }(e) : null,
                                o = No(e),
                                i = Ct(r, e, 0, [e.props, n]),
                                a = A(i);
                            if (me(), o(), !a && !e.sp || Cn(e) || vn(e), a) {
                                if (i.then(Fo, Fo), t)
                                    return i.then(t => {
                                        Qo(e, t)
                                    }).catch(t => {
                                        St(t, e, 0)
                                    });
                                e.asyncDep = i
                            } else
                                Qo(e, i)
                        } else
                            Go(e)
                    }(e, t);
                    t && Lo(!1)
                }(l, !1, s), l.asyncDep) {
                    if (i && i.registerDep(l, U, s), !e.el) {
                        const t = l.subTree = xo(ao);
                        v(null, t, n, r),
                        e.placeholder = t.el
                    }
                } else
                    U(l, e, n, r, i, a, s)
            },
            F = (e, t, n) => {
                const r = t.component = e.component;
                if (function(e, t, n) {
                    const {props: r, children: o, component: i} = e,
                        {props: a, children: s, patchFlag: l} = t,
                        c = i.emitsOptions;
                    if (t.dirs || t.transition)
                        return !0;
                    if (!(n && l >= 0))
                        return !(!o && !s || s && s.$stable) || r !== a && (r ? !a || no(r, a, c) : !!a);
                    if (1024 & l)
                        return !0;
                    if (16 & l)
                        return r ? no(r, a, c) : !!a;
                    if (8 & l) {
                        const e = t.dynamicProps;
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            if (a[n] !== r[n] && !Jr(c, n))
                                return !0
                        }
                    }
                    return !1
                }(e, t, n)) {
                    if (r.asyncDep && !r.asyncResolved)
                        return void z(r, t, n);
                    r.next = t,
                    r.update()
                } else
                    t.el = e.el,
                    r.vnode = t
            },
            U = (e, t, n, r, o, i, a) => {
                const s = () => {
                    if (e.isMounted) {
                        let {next: t, bu: n, u: r, parent: l, vnode: c} = e;
                        {
                            const n = zr(e);
                            if (n)
                                return t && (t.el = c.el, z(e, t, a)), void n.asyncDep.then(() => {
                                    e.isUnmounted || s()
                                })
                        }
                        let u,
                            d = t;
                        Fr(e, !1),
                        t ? (t.el = c.el, z(e, t, a)) : t = c,
                        n && k(n),
                        (u = t.props && t.props.onVnodeBeforeUpdate) && Ro(u, l, t, c),
                        Fr(e, !0);
                        const p = Zr(e),
                            f = e.subTree;
                        e.subTree = p,
                        b(f, p, h(f.el), X(f), e, o, i),
                        t.el = p.el,
                        null === d && function({vnode: e, parent: t}, n) {
                            for (; t;) {
                                const r = t.subTree;
                                if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r !== e)
                                    break;
                                (e = t.vnode).el = n,
                                t = t.parent
                            }
                        }(e, p.el),
                        r && Or(r, o),
                        (u = t.props && t.props.onVnodeUpdated) && Or(() => Ro(u, l, t, c), o)
                    } else {
                        let a;
                        const {el: s, props: l} = t,
                            {bm: c, m: u, parent: d, root: p, type: h} = e,
                            f = Cn(t);
                        Fr(e, !1),
                        c && k(c),
                        !f && (a = l && l.onVnodeBeforeMount) && Ro(a, d, t),
                        Fr(e, !0);
                        {
                            p.ce && !1 !== p.ce._def.shadowRoot && p.ce._injectChildStyle(h);
                            const a = e.subTree = Zr(e);
                            b(null, a, n, r, e, o, i),
                            t.el = a.el
                        }
                        if (u && Or(u, o), !f && (a = l && l.onVnodeMounted)) {
                            const e = t;
                            Or(() => Ro(a, d, e), o)
                        }
                        (256 & t.shapeFlag || d && Cn(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && Or(e.a, o),
                        e.isMounted = !0,
                        t = n = r = null
                    }
                };
                e.scope.on();
                const l = e.effect = new ee(s);
                e.scope.off();
                const c = e.update = l.run.bind(l),
                    u = e.job = l.runIfDirty.bind(l);
                u.i = e,
                u.id = e.uid,
                l.scheduler = () => Ot(u),
                Fr(e, !0),
                c()
            },
            z = (e, n, r) => {
                n.component = e;
                const o = e.vnode.props;
                e.vnode = n,
                e.next = null,
                function(e, t, n, r) {
                    const {props: o, attrs: i, vnode: {patchFlag: a}} = e,
                        s = ut(o),
                        [l] = e.propsOptions;
                    let c = !1;
                    if (!(r || a > 0) || 16 & a) {
                        let r;
                        Cr(e, t, o, i) && (c = !0);
                        for (const i in s)
                            t && (u(t, i) || (r = T(i)) !== i && u(t, r)) || (l ? !n || void 0 === n[i] && void 0 === n[r] || (o[i] = Er(l, s, i, void 0, e, !0)) : delete o[i]);
                        if (i !== s)
                            for (const e in i)
                                t && u(t, e) || (delete i[e], c = !0)
                    } else if (8 & a) {
                        const n = e.vnode.dynamicProps;
                        for (let r = 0; r < n.length; r++) {
                            let a = n[r];
                            if (Jr(e.emitsOptions, a))
                                continue;
                            const d = t[a];
                            if (l)
                                if (u(i, a))
                                    d !== i[a] && (i[a] = d, c = !0);
                                else {
                                    const t = S(a);
                                    o[t] = Er(l, s, t, d, e, !1)
                                }
                            else
                                d !== i[a] && (i[a] = d, c = !0)
                        }
                    }
                    c && Ie(e.attrs, "set", "")
                }(e, n.props, o, r),
                ((e, n, r) => {
                    const {vnode: o, slots: i} = e;
                    let a = !0,
                        s = t;
                    if (32 & o.shapeFlag) {
                        const e = n._;
                        e ? r && 1 === e ? a = !1 : Pr(i, n, r) : (a = !n.$stable, kr(n, i)),
                        s = n
                    } else
                        n && (Dr(e, n), s = {
                            default: 1
                        });
                    if (a)
                        for (const t in i)
                            Mr(t) || null != s[t] || delete i[t]
                })(e, n.children, r),
                ge(),
                Nt(e),
                me()
            },
            Q = (e, t, n, r, o, i, a, s, l=!1) => {
                const c = e && e.children,
                    u = e ? e.shapeFlag : 0,
                    d = t.children,
                    {patchFlag: h, shapeFlag: f} = t;
                if (h > 0) {
                    if (128 & h)
                        return void j(c, d, n, r, o, i, a, s, l);
                    if (256 & h)
                        return void G(c, d, n, r, o, i, a, s, l)
                }
                8 & f ? (16 & u && q(c, o, i), d !== c && p(n, d)) : 16 & u ? 16 & f ? j(c, d, n, r, o, i, a, s, l) : q(c, o, i, !0) : (8 & u && p(n, ""), 16 & f && I(d, n, r, o, i, a, s, l))
            },
            G = (e, t, r, o, i, a, s, l, c) => {
                t = t || n;
                const u = (e = e || n).length,
                    d = t.length,
                    p = Math.min(u, d);
                let h;
                for (h = 0; h < p; h++) {
                    const n = t[h] = c ? Io(t[h]) : So(t[h]);
                    b(e[h], n, r, null, i, a, s, l, c)
                }
                u > d ? q(e, i, a, !0, !1, p) : I(t, r, o, i, a, s, l, c, p)
            },
            j = (e, t, r, o, i, a, s, l, c) => {
                let u = 0;
                const d = t.length;
                let p = e.length - 1,
                    h = d - 1;
                for (; u <= p && u <= h;) {
                    const n = e[u],
                        o = t[u] = c ? Io(t[u]) : So(t[u]);
                    if (!Ao(n, o))
                        break;
                    b(n, o, r, null, i, a, s, l, c),
                    u++
                }
                for (; u <= p && u <= h;) {
                    const n = e[p],
                        o = t[h] = c ? Io(t[h]) : So(t[h]);
                    if (!Ao(n, o))
                        break;
                    b(n, o, r, null, i, a, s, l, c),
                    p--,
                    h--
                }
                if (u > p) {
                    if (u <= h) {
                        const e = h + 1,
                            n = e < d ? t[e].el : o;
                        for (; u <= h;)
                            b(null, t[u] = c ? Io(t[u]) : So(t[u]), r, n, i, a, s, l, c),
                            u++
                    }
                } else if (u > h)
                    for (; u <= p;)
                        H(e[u], i, a, !0),
                        u++;
                else {
                    const f = u,
                        g = u,
                        m = new Map;
                    for (u = g; u <= h; u++) {
                        const e = t[u] = c ? Io(t[u]) : So(t[u]);
                        null != e.key && m.set(e.key, u)
                    }
                    let A,
                        y = 0;
                    const v = h - g + 1;
                    let _ = !1,
                        x = 0;
                    const w = new Array(v);
                    for (u = 0; u < v; u++)
                        w[u] = 0;
                    for (u = f; u <= p; u++) {
                        const n = e[u];
                        if (y >= v) {
                            H(n, i, a, !0);
                            continue
                        }
                        let o;
                        if (null != n.key)
                            o = m.get(n.key);
                        else
                            for (A = g; A <= h; A++)
                                if (0 === w[A - g] && Ao(n, t[A])) {
                                    o = A;
                                    break
                                }
                        void 0 === o ? H(n, i, a, !0) : (w[o - g] = u + 1, o >= x ? x = o : _ = !0, b(n, t[o], r, null, i, a, s, l, c), y++)
                    }
                    const C = _ ? function(e) {
                        const t = e.slice(),
                            n = [0];
                        let r,
                            o,
                            i,
                            a,
                            s;
                        const l = e.length;
                        for (r = 0; r < l; r++) {
                            const l = e[r];
                            if (0 !== l) {
                                if (o = n[n.length - 1], e[o] < l) {
                                    t[r] = o,
                                    n.push(r);
                                    continue
                                }
                                for (i = 0, a = n.length - 1; i < a;)
                                    s = i + a >> 1,
                                    e[n[s]] < l ? i = s + 1 : a = s;
                                l < e[n[i]] && (i > 0 && (t[r] = n[i - 1]), n[i] = r)
                            }
                        }
                        for (i = n.length, a = n[i - 1]; i-- > 0;)
                            n[i] = a,
                            a = t[a];
                        return n
                    }(w) : n;
                    for (A = C.length - 1, u = v - 1; u >= 0; u--) {
                        const e = g + u,
                            n = t[e],
                            p = t[e + 1],
                            h = e + 1 < d ? p.el || p.placeholder : o;
                        0 === w[u] ? b(null, n, r, h, i, a, s, l, c) : _ && (A < 0 || u !== C[A] ? V(n, r, h, 2) : A--)
                    }
                }
            },
            V = (e, t, n, r, a=null) => {
                const {el: s, type: l, transition: c, children: u, shapeFlag: d} = e;
                if (6 & d)
                    V(e.component.subTree, t, n, r);
                else if (128 & d)
                    e.suspense.move(t, n, r);
                else if (64 & d)
                    l.move(e, t, n, te);
                else if (l !== oo)
                    if (l !== so)
                        if (2 !== r && 1 & d && c)
                            if (0 === r)
                                c.beforeEnter(s),
                                o(s, t, n),
                                Or(() => c.enter(s), a);
                            else {
                                const {leave: r, delayLeave: a, afterLeave: l} = c,
                                    u = () => {
                                        e.ctx.isUnmounted ? i(s) : o(s, t, n)
                                    },
                                    d = () => {
                                        s._isLeaving && s[an](!0),
                                        r(s, () => {
                                            u(),
                                            l && l()
                                        })
                                    };
                                a ? a(s, u, d) : d()
                            }
                        else
                            o(s, t, n);
                    else
                        (({el: e, anchor: t}, n, r) => {
                            let i;
                            for (; e && e !== t;)
                                i = f(e),
                                o(e, n, r),
                                e = i;
                            o(t, n, r)
                        })(e, t, n);
                else {
                    o(s, t, n);
                    for (let e = 0; e < u.length; e++)
                        V(u[e], t, n, r);
                    o(e.anchor, t, n)
                }
            },
            H = (e, t, n, r=!1, o=!1) => {
                const {type: i, props: a, ref: s, children: l, dynamicChildren: c, shapeFlag: u, patchFlag: d, dirs: p, cacheIndex: h} = e;
                if (-2 === d && (o = !1), null != s && (ge(), xn(s, null, n, e, !0), me()), null != h && (t.renderCache[h] = void 0), 256 & u)
                    return void t.ctx.deactivate(e);
                const f = 1 & u && p,
                    g = !Cn(e);
                let m;
                if (g && (m = a && a.onVnodeBeforeUnmount) && Ro(m, t, e), 6 & u)
                    K(e.component, n, r);
                else {
                    if (128 & u)
                        return void e.suspense.unmount(n, r);
                    f && $t(e, null, t, "beforeUnmount"),
                    64 & u ? e.type.remove(e, t, n, te, r) : c && !c.hasOnce && (i !== oo || d > 0 && 64 & d) ? q(c, t, n, !1, !0) : (i === oo && 384 & d || !o && 16 & u) && q(l, t, n),
                    r && $(e)
                }
                (g && (m = a && a.onVnodeUnmounted) || f) && Or(() => {
                    m && Ro(m, t, e),
                    f && $t(e, null, t, "unmounted")
                }, n)
            },
            $ = e => {
                const {type: t, el: n, anchor: r, transition: o} = e;
                if (t === oo)
                    return void W(n, r);
                if (t === so)
                    return void (({el: e, anchor: t}) => {
                        let n;
                        for (; e && e !== t;)
                            n = f(e),
                            i(e),
                            e = n;
                        i(t)
                    })(e);
                const a = () => {
                    i(n),
                    o && !o.persisted && o.afterLeave && o.afterLeave()
                };
                if (1 & e.shapeFlag && o && !o.persisted) {
                    const {leave: t, delayLeave: r} = o,
                        i = () => t(n, a);
                    r ? r(e.el, a, i) : i()
                } else
                    a()
            },
            W = (e, t) => {
                let n;
                for (; e !== t;)
                    n = f(e),
                    i(e),
                    e = n;
                i(t)
            },
            K = (e, t, n) => {
                const {bum: r, scope: o, job: i, subTree: a, um: s, m: l, a: c} = e;
                Qr(l),
                Qr(c),
                r && k(r),
                o.stop(),
                i && (i.flags |= 8, H(a, e, t, n)),
                s && Or(s, t),
                Or(() => {
                    e.isUnmounted = !0
                }, t)
            },
            q = (e, t, n, r=!1, o=!1, i=0) => {
                for (let a = i; a < e.length; a++)
                    H(e[a], t, n, r, o)
            },
            X = e => {
                if (6 & e.shapeFlag)
                    return X(e.component.subTree);
                if (128 & e.shapeFlag)
                    return e.suspense.next();
                const t = f(e.anchor || e.el),
                    n = t && t[Wt];
                return n ? f(n) : t
            };
        let Y = !1;
        const Z = (e, t, n) => {
                null == e ? t._vnode && H(t._vnode, null, null, !0) : b(t._vnode || null, e, t, null, null, null, n),
                t._vnode = e,
                Y || (Y = !0, Nt(), Ft(), Y = !1)
            },
            te = {
                p: b,
                um: H,
                m: V,
                r: $,
                mt: N,
                mc: I,
                pc: Q,
                pbc: R,
                n: X,
                o: e
            };
        return {
            render: Z,
            hydrate: undefined,
            createApp: Ar(Z)
        }
    }(e)
}
function Nr({type: e, props: t}, n) {
    return "svg" === n && "foreignObject" === e || "mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function Fr({effect: e, job: t}, n) {
    n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5)
}
function Ur(e, t, n=!1) {
    const r = e.children,
        o = t.children;
    if (d(r) && d(o))
        for (let i = 0; i < r.length; i++) {
            const e = r[i];
            let t = o[i];
            1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[i] = Io(o[i]), t.el = e.el), n || -2 === t.patchFlag || Ur(e, t)),
            t.type === io && -1 !== t.patchFlag && (t.el = e.el),
            t.type !== ao || t.el || (t.el = e.el)
        }
}
function zr(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : zr(t)
}
function Qr(e) {
    if (e)
        for (let t = 0; t < e.length; t++)
            e[t].flags |= 8
}
const Gr = Symbol.for("v-scx"),
    jr = () => vr(Gr);
function Vr(e, t, n) {
    return Hr(e, t, n)
}
function Hr(e, n, o=t) {
    const {immediate: i, deep: a, flush: c, once: u} = o,
        p = s({}, o),
        h = n && i || !n && "post" !== c;
    let g;
    if (zo)
        if ("sync" === c) {
            const e = jr();
            g = e.__watcherHandles || (e.__watcherHandles = [])
        } else if (!h) {
            const e = () => {};
            return e.stop = r, e.resume = r, e.pause = r, e
        }
    const m = Do;
    p.call = (e, t, n) => Et(e, m, t, n);
    let b = !1;
    "post" === c ? p.scheduler = e => {
        Or(e, m && m.suspense)
    } : "sync" !== c && (b = !0, p.scheduler = (e, t) => {
        t ? e() : Ot(e)
    }),
    p.augmentJob = e => {
        n && (e.flags |= 4),
        b && (e.flags |= 2, m && (e.id = m.uid, e.i = m))
    };
    const A = function(e, n, o=t) {
        const {immediate: i, deep: a, once: s, scheduler: c, augmentJob: u, call: p} = o,
            h = e => a ? e : lt(e) || !1 === a || 0 === a ? wt(e, 1) : wt(e);
        let g,
            m,
            b,
            A,
            y = !1,
            v = !1;
        if (ht(e) ? (m = () => e.value, y = lt(e)) : at(e) ? (m = () => h(e), y = !0) : d(e) ? (v = !0, y = e.some(e => at(e) || lt(e)), m = () => e.map(e => ht(e) ? e.value : at(e) ? h(e) : f(e) ? p ? p(e, 2) : e() : void 0)) : m = f(e) ? n ? p ? () => p(e, 2) : e : () => {
            if (b) {
                ge();
                try {
                    b()
                } finally {
                    me()
                }
            }
            const t = xt;
            xt = g;
            try {
                return p ? p(e, 3, [A]) : e(A)
            } finally {
                xt = t
            }
        } : r, n && a) {
            const e = m,
                t = !0 === a ? 1 / 0 : a;
            m = () => wt(e(), t)
        }
        const _ = X,
            x = () => {
                g.stop(),
                _ && _.active && l(_.effects, g)
            };
        if (s && n) {
            const e = n;
            n = (...t) => {
                e(...t),
                x()
            }
        }
        let w = v ? new Array(e.length).fill(vt) : vt;
        const C = e => {
            if (1 & g.flags && (g.dirty || e))
                if (n) {
                    const e = g.run();
                    if (a || y || (v ? e.some((e, t) => B(e, w[t])) : B(e, w))) {
                        b && b();
                        const t = xt;
                        xt = g;
                        try {
                            const t = [e, w === vt ? void 0 : v && w[0] === vt ? [] : w, A];
                            w = e,
                            p ? p(n, 3, t) : n(...t)
                        } finally {
                            xt = t
                        }
                    }
                } else
                    g.run()
        };
        return u && u(C), g = new ee(m), g.scheduler = c ? () => c(C, !1) : C, A = e => function(e, t=!1, n=xt) {
            if (n) {
                let t = _t.get(n);
                t || _t.set(n, t = []),
                t.push(e)
            }
        }(e, !1, g), b = g.onStop = () => {
            const e = _t.get(g);
            if (e) {
                if (p)
                    p(e, 4);
                else
                    for (const t of e)
                        t();
                _t.delete(g)
            }
        }, n ? i ? C(!0) : w = g.run() : c ? c(C.bind(null, !0), !0) : g.run(), x.pause = g.pause.bind(g), x.resume = g.resume.bind(g), x.stop = x, x
    }(e, n, p);
    return zo && (g ? g.push(A) : h && A()), A
}
function $r(e, t, n) {
    const r = this.proxy,
        o = g(e) ? e.includes(".") ? Wr(r, e) : () => r[e] : e.bind(r, r);
    let i;
    f(t) ? i = t : (i = t.handler, n = t);
    const a = No(this),
        s = Hr(o, i.bind(r), n);
    return a(), s
}
function Wr(e, t) {
    const n = t.split(".");
    return () => {
        let t = e;
        for (let e = 0; e < n.length && t; e++)
            t = t[n[e]];
        return t
    }
}
const Kr = (e, t) => "modelValue" === t || "model-value" === t ? e.modelModifiers : e[`${t}Modifiers`] || e[`${S(t)}Modifiers`] || e[`${T(t)}Modifiers`];
function qr(e, n, ...r) {
    if (e.isUnmounted)
        return;
    const o = e.vnode.props || t;
    let i = r;
    const a = n.startsWith("update:"),
        s = a && Kr(o, n.slice(7));
    let l;
    s && (s.trim && (i = r.map(e => g(e) ? e.trim() : e)), s.number && (i = r.map(P)));
    let c = o[l = R(n)] || o[l = R(S(n))];
    !c && a && (c = o[l = R(T(n))]),
    c && Et(c, e, 6, i);
    const u = o[l + "Once"];
    if (u) {
        if (e.emitted) {
            if (e.emitted[l])
                return
        } else
            e.emitted = {};
        e.emitted[l] = !0,
        Et(u, e, 6, i)
    }
}
const Xr = new WeakMap;
function Yr(e, t, n=!1) {
    const r = n ? Xr : t.emitsCache,
        o = r.get(e);
    if (void 0 !== o)
        return o;
    const i = e.emits;
    let a = {},
        l = !1;
    if (!f(e)) {
        const r = e => {
            const n = Yr(e, t, !0);
            n && (l = !0, s(a, n))
        };
        !n && t.mixins.length && t.mixins.forEach(r),
        e.extends && r(e.extends),
        e.mixins && e.mixins.forEach(r)
    }
    return i || l ? (d(i) ? i.forEach(e => a[e] = null) : s(a, i), b(e) && r.set(e, a), a) : (b(e) && r.set(e, null), null)
}
function Jr(e, t) {
    return !(!e || !i(t)) && (t = t.slice(2).replace(/Once$/, ""), u(e, t[0].toLowerCase() + t.slice(1)) || u(e, T(t)) || u(e, t))
}
function Zr(e) {
    const {type: t, vnode: n, proxy: r, withProxy: o, propsOptions: [i], slots: s, attrs: l, emit: c, render: u, renderCache: d, props: p, data: h, setupState: f, ctx: g, inheritAttrs: m} = e,
        b = jt(e);
    let A,
        y;
    try {
        if (4 & n.shapeFlag) {
            const e = o || r,
                t = e;
            A = So(u.call(t, e, d, p, f, h, g)),
            y = l
        } else {
            const e = t;
            A = So(e.length > 1 ? e(p, {
                attrs: l,
                slots: s,
                emit: c
            }) : e(p, null)),
            y = t.props ? l : eo(l)
        }
    } catch (_) {
        lo.length = 0,
        St(_, e, 1),
        A = xo(ao)
    }
    let v = A;
    if (y && !1 !== m) {
        const e = Object.keys(y),
            {shapeFlag: t} = v;
        e.length && 7 & t && (i && e.some(a) && (y = to(y, i)), v = wo(v, y, !1, !0))
    }
    return n.dirs && (v = wo(v, null, !1, !0), v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs), n.transition && bn(v, n.transition), A = v, jt(b), A
}
const eo = e => {
        let t;
        for (const n in e)
            ("class" === n || "style" === n || i(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    },
    to = (e, t) => {
        const n = {};
        for (const r in e)
            a(r) && r.slice(9) in t || (n[r] = e[r]);
        return n
    };
function no(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let o = 0; o < r.length; o++) {
        const i = r[o];
        if (t[i] !== e[i] && !Jr(n, i))
            return !0
    }
    return !1
}
const ro = e => e.__isSuspense,
    oo = Symbol.for("v-fgt"),
    io = Symbol.for("v-txt"),
    ao = Symbol.for("v-cmt"),
    so = Symbol.for("v-stc"),
    lo = [];
let co = null;
function uo(e=!1) {
    lo.push(co = e ? null : [])
}
let po = 1;
function ho(e, t=!1) {
    po += e,
    e < 0 && co && t && (co.hasOnce = !0)
}
function fo(e) {
    return e.dynamicChildren = po > 0 ? co || n : null, lo.pop(), co = lo[lo.length - 1] || null, po > 0 && co && co.push(e), e
}
function go(e, t, n, r, o, i) {
    return fo(_o(e, t, n, r, o, i, !0))
}
function mo(e, t, n, r, o) {
    return fo(xo(e, t, n, r, o, !0))
}
function bo(e) {
    return !!e && !0 === e.__v_isVNode
}
function Ao(e, t) {
    return e.type === t.type && e.key === t.key
}
const yo = ({key: e}) => null != e ? e : null,
    vo = ({ref: e, ref_key: t, ref_for: n}) => ("number" == typeof e && (e = "" + e), null != e ? g(e) || ht(e) || f(e) ? {
        i: Qt,
        r: e,
        k: t,
        f: !!n
    } : e : null);
function _o(e, t=null, n=null, r=0, o=null, i=(e === oo ? 0 : 1), a=!1, s=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && yo(t),
        ref: t && vo(t),
        scopeId: Gt,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: r,
        dynamicProps: o,
        dynamicChildren: null,
        appContext: null,
        ctx: Qt
    };
    return s ? (To(l, n), 128 & i && e.normalize(l)) : n && (l.shapeFlag |= g(n) ? 8 : 16), po > 0 && !a && co && (l.patchFlag > 0 || 6 & i) && 32 !== l.patchFlag && co.push(l), l
}
const xo = function(e, t=null, n=null, r=0, o=null, i=!1) {
    if (e && e !== Vn || (e = ao), bo(e)) {
        const r = wo(e, t, !0);
        return n && To(r, n), po > 0 && !i && co && (6 & r.shapeFlag ? co[co.indexOf(e)] = r : co.push(r)), r.patchFlag = -2, r
    }
    var a;
    if (f(a = e) && "__vccOpts" in a && (e = e.__vccOpts), t) {
        t = function(e) {
            return e ? ct(e) || wr(e) ? s({}, e) : e : null
        }(t);
        let {class: e, style: n} = t;
        e && !g(e) && (t.class = G(e)),
        b(n) && (ct(n) && !d(n) && (n = s({}, n)), t.style = N(n))
    }
    return _o(e, t, n, r, o, g(e) ? 1 : ro(e) ? 128 : Kt(e) ? 64 : b(e) ? 4 : f(e) ? 2 : 0, i, !0)
};
function wo(e, t, n=!1, r=!1) {
    const {props: o, ref: i, patchFlag: a, children: s, transition: l} = e,
        c = t ? Mo(o || {}, t) : o,
        u = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: e.type,
            props: c,
            key: c && yo(c),
            ref: t && t.ref ? n && i ? d(i) ? i.concat(vo(t)) : [i, vo(t)] : vo(t) : i,
            scopeId: e.scopeId,
            slotScopeIds: e.slotScopeIds,
            children: s,
            target: e.target,
            targetStart: e.targetStart,
            targetAnchor: e.targetAnchor,
            staticCount: e.staticCount,
            shapeFlag: e.shapeFlag,
            patchFlag: t && e.type !== oo ? -1 === a ? 16 : 16 | a : a,
            dynamicProps: e.dynamicProps,
            dynamicChildren: e.dynamicChildren,
            appContext: e.appContext,
            dirs: e.dirs,
            transition: l,
            component: e.component,
            suspense: e.suspense,
            ssContent: e.ssContent && wo(e.ssContent),
            ssFallback: e.ssFallback && wo(e.ssFallback),
            placeholder: e.placeholder,
            el: e.el,
            anchor: e.anchor,
            ctx: e.ctx,
            ce: e.ce
        };
    return l && r && bn(u, l.clone(u)), u
}
function Co(e=" ", t=0) {
    return xo(io, null, e, t)
}
function Eo(e="", t=!1) {
    return t ? (uo(), mo(ao, null, e)) : xo(ao, null, e)
}
function So(e) {
    return null == e || "boolean" == typeof e ? xo(ao) : d(e) ? xo(oo, null, e.slice()) : bo(e) ? Io(e) : xo(io, null, String(e))
}
function Io(e) {
    return null === e.el && -1 !== e.patchFlag || e.memo ? e : wo(e)
}
function To(e, t) {
    let n = 0;
    const {shapeFlag: r} = e;
    if (null == t)
        t = null;
    else if (d(t))
        n = 16;
    else if ("object" == typeof t) {
        if (65 & r) {
            const n = t.default;
            return void (n && (n._c && (n._d = !1), To(e, n()), n._c && (n._d = !0)))
        }
        {
            n = 32;
            const r = t._;
            r || wr(t) ? 3 === r && Qt && (1 === Qt.slots._ ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = Qt
        }
    } else
        f(t) ? (t = {
            default: t,
            _ctx: Qt
        }, n = 32) : (t = String(t), 64 & r ? (n = 16, t = [Co(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function Mo(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const e in r)
            if ("class" === e)
                t.class !== r.class && (t.class = G([t.class, r.class]));
            else if ("style" === e)
                t.style = N([t.style, r.style]);
            else if (i(e)) {
                const n = t[e],
                    o = r[e];
                !o || n === o || d(n) && n.includes(o) || (t[e] = n ? [].concat(n, o) : o)
            } else
                "" !== e && (t[e] = r[e])
    }
    return t
}
function Ro(e, t, n, r=null) {
    Et(e, t, 7, [n, r])
}
const Bo = mr();
let ko = 0,
    Do = null;
const Po = () => Do || Qt;
let Oo,
    Lo;
{
    const e = L(),
        t = (t, n) => {
            let r;
            return (r = e[t]) || (r = e[t] = []), r.push(n), e => {
                r.length > 1 ? r.forEach(t => t(e)) : r[0](e)
            }
        };
    Oo = t("__VUE_INSTANCE_SETTERS__", e => Do = e),
    Lo = t("__VUE_SSR_SETTERS__", e => zo = e)
}
const No = e => {
        const t = Do;
        return Oo(e), e.scope.on(), () => {
            e.scope.off(),
            Oo(t)
        }
    },
    Fo = () => {
        Do && Do.scope.off(),
        Oo(null)
    };
function Uo(e) {
    return 4 & e.vnode.shapeFlag
}
let zo = !1;
function Qo(e, t, n) {
    f(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : b(t) && (e.setupState = At(t)),
    Go(e)
}
function Go(e, t, n) {
    const o = e.type;
    e.render || (e.render = o.render || r);
    {
        const t = No(e);
        ge();
        try {
            !function(e) {
                const t = lr(e),
                    n = e.proxy,
                    o = e.ctx;
                ir = !1,
                t.beforeCreate && ar(t.beforeCreate, e, "bc");
                const {data: i, computed: a, methods: s, watch: l, provide: c, inject: u, created: p, beforeMount: h, mounted: g, beforeUpdate: m, updated: A, activated: y, deactivated: v, beforeDestroy: _, beforeUnmount: x, destroyed: w, unmounted: C, render: E, renderTracked: S, renderTriggered: I, errorCaptured: T, serverPrefetch: M, expose: R, inheritAttrs: B, components: k, directives: D, filters: P} = t;
                if (u && function(e, t) {
                    d(e) && (e = pr(e));
                    for (const n in e) {
                        const r = e[n];
                        let o;
                        o = b(r) ? "default" in r ? vr(r.from || n, r.default, !0) : vr(r.from || n) : vr(r),
                        ht(o) ? Object.defineProperty(t, n, {
                            enumerable: !0,
                            configurable: !0,
                            get: () => o.value,
                            set: e => o.value = e
                        }) : t[n] = o
                    }
                }(u, o), s)
                    for (const r in s) {
                        const e = s[r];
                        f(e) && (o[r] = e.bind(n))
                    }
                if (i) {
                    const t = i.call(n, n);
                    b(t) && (e.data = rt(t))
                }
                if (ir = !0, a)
                    for (const d in a) {
                        const e = a[d],
                            t = f(e) ? e.bind(n, n) : f(e.get) ? e.get.bind(n, n) : r,
                            i = !f(e) && f(e.set) ? e.set.bind(n) : r,
                            s = Ho({
                                get: t,
                                set: i
                            });
                        Object.defineProperty(o, d, {
                            enumerable: !0,
                            configurable: !0,
                            get: () => s.value,
                            set: e => s.value = e
                        })
                    }
                if (l)
                    for (const r in l)
                        sr(l[r], o, n, r);
                if (c) {
                    const e = f(c) ? c.call(n) : c;
                    Reflect.ownKeys(e).forEach(t => {
                        !function(e, t) {
                            if (Do) {
                                let n = Do.provides;
                                const r = Do.parent && Do.parent.provides;
                                r === n && (n = Do.provides = Object.create(r)),
                                n[e] = t
                            }
                        }(t, e[t])
                    })
                }
                function O(e, t) {
                    d(t) ? t.forEach(t => e(t.bind(n))) : t && e(t.bind(n))
                }
                if (p && ar(p, e, "c"), O(kn, h), O(Dn, g), O(Pn, m), O(On, A), O(Sn, y), O(In, v), O(Qn, T), O(zn, S), O(Un, I), O(Ln, x), O(Nn, C), O(Fn, M), d(R))
                    if (R.length) {
                        const t = e.exposed || (e.exposed = {});
                        R.forEach(e => {
                            Object.defineProperty(t, e, {
                                get: () => n[e],
                                set: t => n[e] = t,
                                enumerable: !0
                            })
                        })
                    } else
                        e.exposed || (e.exposed = {});
                E && e.render === r && (e.render = E),
                null != B && (e.inheritAttrs = B),
                k && (e.components = k),
                D && (e.directives = D),
                M && vn(e)
            }(e)
        } finally {
            me(),
            t()
        }
    }
}
const jo = {
    get: (e, t) => (Se(e, 0, ""), e[t])
};
function Vo(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(At((t = e.exposed, !u(t, "__v_skip") && Object.isExtensible(t) && D(t, "__v_skip", !0), t)), {
        get: (t, n) => n in t ? t[n] : n in tr ? tr[n](e) : void 0,
        has: (e, t) => t in e || t in tr
    })) : e.proxy;
    var t
}
const Ho = (e, t) => {
    const n = function(e, t, n=!1) {
        let r,
            o;
        return f(e) ? r = e : (r = e.get, o = e.set), new yt(r, o, n)
    }(e, 0, zo);
    return n
};
function $o(e, t, n) {
    try {
        ho(-1);
        const r = arguments.length;
        return 2 === r ? b(t) && !d(t) ? bo(t) ? xo(e, null, [t]) : xo(e, t) : xo(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && bo(n) && (n = [n]), xo(e, t, n))
    } finally {
        ho(1)
    }
}
const Wo = "3.5.22";
let Ko;
const qo = "undefined" != typeof window && window.trustedTypes;
if (qo)
    try {
        Ko = qo.createPolicy("vue", {
            createHTML: e => e
        })
    } catch (gL) {}
const Xo = Ko ? e => Ko.createHTML(e) : e => e,
    Yo = "undefined" != typeof document ? document : null,
    Jo = Yo && Yo.createElement("template"),
    Zo = {
        insert: (e, t, n) => {
            t.insertBefore(e, n || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, n, r) => {
            const o = "svg" === t ? Yo.createElementNS("http://www.w3.org/2000/svg", e) : "mathml" === t ? Yo.createElementNS("http://www.w3.org/1998/Math/MathML", e) : n ? Yo.createElement(e, {
                is: n
            }) : Yo.createElement(e);
            return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple), o
        },
        createText: e => Yo.createTextNode(e),
        createComment: e => Yo.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => Yo.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        insertStaticContent(e, t, n, r, o, i) {
            const a = n ? n.previousSibling : t.lastChild;
            if (o && (o === i || o.nextSibling))
                for (; t.insertBefore(o.cloneNode(!0), n), o !== i && (o = o.nextSibling);)
                    ;
            else {
                Jo.innerHTML = Xo("svg" === r ? `<svg>${e}</svg>` : "mathml" === r ? `<math>${e}</math>` : e);
                const o = Jo.content;
                if ("svg" === r || "mathml" === r) {
                    const e = o.firstChild;
                    for (; e.firstChild;)
                        o.appendChild(e.firstChild);
                    o.removeChild(e)
                }
                t.insertBefore(o, n)
            }
            return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        }
    },
    ei = "transition",
    ti = "animation",
    ni = Symbol("_vtc"),
    ri = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    oi = s({}, cn, ri),
    ii = (e => (e.displayName = "Transition", e.props = oi, e))((e, {slots: t}) => $o(pn, function(e) {
        const t = {};
        for (const s in e)
            s in ri || (t[s] = e[s]);
        if (!1 === e.css)
            return t;
        const {name: n="v", type: r, duration: o, enterFromClass: i=`${n}-enter-from`, enterActiveClass: a=`${n}-enter-active`, enterToClass: l=`${n}-enter-to`, appearFromClass: c=i, appearActiveClass: u=a, appearToClass: d=l, leaveFromClass: p=`${n}-leave-from`, leaveActiveClass: h=`${n}-leave-active`, leaveToClass: f=`${n}-leave-to`} = e,
            g = function(e) {
                if (null == e)
                    return null;
                if (b(e))
                    return [li(e.enter), li(e.leave)];
                {
                    const t = li(e);
                    return [t, t]
                }
            }(o),
            m = g && g[0],
            A = g && g[1],
            {onBeforeEnter: y, onEnter: v, onEnterCancelled: _, onLeave: x, onLeaveCancelled: w, onBeforeAppear: C=y, onAppear: E=v, onAppearCancelled: S=_} = t,
            I = (e, t, n, r) => {
                e._enterCancelled = r,
                ui(e, t ? d : l),
                ui(e, t ? u : a),
                n && n()
            },
            T = (e, t) => {
                e._isLeaving = !1,
                ui(e, p),
                ui(e, f),
                ui(e, h),
                t && t()
            },
            M = e => (t, n) => {
                const o = e ? E : v,
                    a = () => I(t, e, n);
                ai(o, [t, a]),
                di(() => {
                    ui(t, e ? c : i),
                    ci(t, e ? d : l),
                    si(o) || hi(t, r, m, a)
                })
            };
        return s(t, {
            onBeforeEnter(e) {
                ai(y, [e]),
                ci(e, i),
                ci(e, a)
            },
            onBeforeAppear(e) {
                ai(C, [e]),
                ci(e, c),
                ci(e, u)
            },
            onEnter: M(!1),
            onAppear: M(!0),
            onLeave(e, t) {
                e._isLeaving = !0;
                const n = () => T(e, t);
                ci(e, p),
                e._enterCancelled ? (ci(e, h), mi(e)) : (mi(e), ci(e, h)),
                di(() => {
                    e._isLeaving && (ui(e, p), ci(e, f), si(x) || hi(e, r, A, n))
                }),
                ai(x, [e, n])
            },
            onEnterCancelled(e) {
                I(e, !1, void 0, !0),
                ai(_, [e])
            },
            onAppearCancelled(e) {
                I(e, !0, void 0, !0),
                ai(S, [e])
            },
            onLeaveCancelled(e) {
                T(e),
                ai(w, [e])
            }
        })
    }(e), t)),
    ai = (e, t=[]) => {
        d(e) ? e.forEach(e => e(...t)) : e && e(...t)
    },
    si = e => !!e && (d(e) ? e.some(e => e.length > 1) : e.length > 1);
function li(e) {
    const t = (e => {
        const t = g(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t
    })(e);
    return t
}
function ci(e, t) {
    t.split(/\s+/).forEach(t => t && e.classList.add(t)),
    (e[ni] || (e[ni] = new Set)).add(t)
}
function ui(e, t) {
    t.split(/\s+/).forEach(t => t && e.classList.remove(t));
    const n = e[ni];
    n && (n.delete(t), n.size || (e[ni] = void 0))
}
function di(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let pi = 0;
function hi(e, t, n, r) {
    const o = e._endId = ++pi,
        i = () => {
            o === e._endId && r()
        };
    if (null != n)
        return setTimeout(i, n);
    const {type: a, timeout: s, propCount: l} = function(e, t) {
        const n = window.getComputedStyle(e),
            r = e => (n[e] || "").split(", "),
            o = r(`${ei}Delay`),
            i = r(`${ei}Duration`),
            a = fi(o, i),
            s = r(`${ti}Delay`),
            l = r(`${ti}Duration`),
            c = fi(s, l);
        let u = null,
            d = 0,
            p = 0;
        t === ei ? a > 0 && (u = ei, d = a, p = i.length) : t === ti ? c > 0 && (u = ti, d = c, p = l.length) : (d = Math.max(a, c), u = d > 0 ? a > c ? ei : ti : null, p = u ? u === ei ? i.length : l.length : 0);
        return {
            type: u,
            timeout: d,
            propCount: p,
            hasTransform: u === ei && /\b(?:transform|all)(?:,|$)/.test(r(`${ei}Property`).toString())
        }
    }(e, t);
    if (!a)
        return r();
    const c = a + "end";
    let u = 0;
    const d = () => {
            e.removeEventListener(c, p),
            i()
        },
        p = t => {
            t.target === e && ++u >= l && d()
        };
    setTimeout(() => {
        u < l && d()
    }, s + 1),
    e.addEventListener(c, p)
}
function fi(e, t) {
    for (; e.length < t.length;)
        e = e.concat(e);
    return Math.max(...t.map((t, n) => gi(t) + gi(e[n])))
}
function gi(e) {
    return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", "."))
}
function mi(e) {
    return (e ? e.ownerDocument : document).body.offsetHeight
}
const bi = Symbol("_vod"),
    Ai = Symbol("_vsh"),
    yi = {
        name: "show",
        beforeMount(e, {value: t}, {transition: n}) {
            e[bi] = "none" === e.style.display ? "" : e.style.display,
            n && t ? n.beforeEnter(e) : vi(e, t)
        },
        mounted(e, {value: t}, {transition: n}) {
            n && t && n.enter(e)
        },
        updated(e, {value: t, oldValue: n}, {transition: r}) {
            !t != !n && (r ? t ? (r.beforeEnter(e), vi(e, !0), r.enter(e)) : r.leave(e, () => {
                vi(e, !1)
            }) : vi(e, t))
        },
        beforeUnmount(e, {value: t}) {
            vi(e, t)
        }
    };
function vi(e, t) {
    e.style.display = t ? e[bi] : "none",
    e[Ai] = !t
}
const _i = Symbol(""),
    xi = /(?:^|;)\s*display\s*:/,
    wi = /\s*!important$/;
function Ci(e, t, n) {
    if (d(n))
        n.forEach(n => Ci(e, t, n));
    else if (null == n && (n = ""), t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = function(e, t) {
            const n = Si[t];
            if (n)
                return n;
            let r = S(t);
            if ("filter" !== r && r in e)
                return Si[t] = r;
            r = M(r);
            for (let o = 0; o < Ei.length; o++) {
                const n = Ei[o] + r;
                if (n in e)
                    return Si[t] = n
            }
            return t
        }(e, t);
        wi.test(n) ? e.setProperty(T(r), n.replace(wi, ""), "important") : e[r] = n
    }
}
const Ei = ["Webkit", "Moz", "ms"],
    Si = {},
    Ii = "http://www.w3.org/1999/xlink";
function Ti(e, t, n, r, o, i=V(t)) {
    r && t.startsWith("xlink:") ? null == n ? e.removeAttributeNS(Ii, t.slice(6, t.length)) : e.setAttributeNS(Ii, t, n) : null == n || i && !H(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : m(n) ? String(n) : n)
}
function Mi(e, t, n, r, o) {
    if ("innerHTML" === t || "textContent" === t)
        return void (null != n && (e[t] = "innerHTML" === t ? Xo(n) : n));
    const i = e.tagName;
    if ("value" === t && "PROGRESS" !== i && !i.includes("-")) {
        const r = "OPTION" === i ? e.getAttribute("value") || "" : e.value,
            o = null == n ? "checkbox" === e.type ? "on" : "" : String(n);
        return r === o && "_value" in e || (e.value = o), null == n && e.removeAttribute(t), void (e._value = n)
    }
    let a = !1;
    if ("" === n || null == n) {
        const r = typeof e[t];
        "boolean" === r ? n = H(n) : null == n && "string" === r ? (n = "", a = !0) : "number" === r && (n = 0, a = !0)
    }
    try {
        e[t] = n
    } catch (gL) {}
    a && e.removeAttribute(o || t)
}
const Ri = Symbol("_vei");
const Bi = /(?:Once|Passive|Capture)$/;
let ki = 0;
const Di = Promise.resolve(),
    Pi = () => ki || (Di.then(() => ki = 0), ki = Date.now()),
    Oi = e => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
    Li = ["ctrl", "shift", "alt", "meta"],
    Ni = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && 0 !== e.button,
        middle: e => "button" in e && 1 !== e.button,
        right: e => "button" in e && 2 !== e.button,
        exact: (e, t) => Li.some(n => e[`${n}Key`] && !t.includes(n))
    },
    Fi = (e, t) => {
        const n = e._withMods || (e._withMods = {}),
            r = t.join(".");
        return n[r] || (n[r] = (n, ...r) => {
                for (let e = 0; e < t.length; e++) {
                    const r = Ni[t[e]];
                    if (r && r(n, t))
                        return
                }
                return e(n, ...r)
            })
    },
    Ui = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    zi = (e, t) => {
        const n = e._withKeys || (e._withKeys = {}),
            r = t.join(".");
        return n[r] || (n[r] = n => {
                if (!("key" in n))
                    return;
                const r = T(n.key);
                return t.some(e => e === r || Ui[e] === r) ? e(n) : void 0
            })
    },
    Qi = s({
        patchProp: (e, t, n, r, o, s) => {
            const l = "svg" === o;
            "class" === t ? function(e, t, n) {
                const r = e[ni];
                r && (t = (t ? [t, ...r] : [...r]).join(" ")),
                null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
            }(e, r, l) : "style" === t ? function(e, t, n) {
                const r = e.style,
                    o = g(n);
                let i = !1;
                if (n && !o) {
                    if (t)
                        if (g(t))
                            for (const e of t.split(";")) {
                                const t = e.slice(0, e.indexOf(":")).trim();
                                null == n[t] && Ci(r, t, "")
                            }
                        else
                            for (const e in t)
                                null == n[e] && Ci(r, e, "");
                    for (const e in n)
                        "display" === e && (i = !0),
                        Ci(r, e, n[e])
                } else if (o) {
                    if (t !== n) {
                        const e = r[_i];
                        e && (n += ";" + e),
                        r.cssText = n,
                        i = xi.test(n)
                    }
                } else
                    t && e.removeAttribute("style");
                bi in e && (e[bi] = i ? r.display : "", e[Ai] && (r.display = "none"))
            }(e, n, r) : i(t) ? a(t) || function(e, t, n, r, o=null) {
                const i = e[Ri] || (e[Ri] = {}),
                    a = i[t];
                if (r && a)
                    a.value = r;
                else {
                    const [n, s] = function(e) {
                        let t;
                        if (Bi.test(e)) {
                            let n;
                            for (t = {}; n = e.match(Bi);)
                                e = e.slice(0, e.length - n[0].length),
                                t[n[0].toLowerCase()] = !0
                        }
                        return [":" === e[2] ? e.slice(3) : T(e.slice(2)), t]
                    }(t);
                    if (r) {
                        const a = i[t] = function(e, t) {
                            const n = e => {
                                if (e._vts) {
                                    if (e._vts <= n.attached)
                                        return
                                } else
                                    e._vts = Date.now();
                                Et(function(e, t) {
                                    if (d(t)) {
                                        const n = e.stopImmediatePropagation;
                                        return e.stopImmediatePropagation = () => {
                                            n.call(e),
                                            e._stopped = !0
                                        }, t.map(e => t => !t._stopped && e && e(t))
                                    }
                                    return t
                                }(e, n.value), t, 5, [e])
                            };
                            return n.value = e, n.attached = Pi(), n
                        }(r, o);
                        !function(e, t, n, r) {
                            e.addEventListener(t, n, r)
                        }(e, n, a, s)
                    } else
                        a && (function(e, t, n, r) {
                            e.removeEventListener(t, n, r)
                        }(e, n, a, s), i[t] = void 0)
                }
            }(e, t, 0, r, s) : ("." === t[0] ? (t = t.slice(1), 1) : "^" === t[0] ? (t = t.slice(1), 0) : function(e, t, n, r) {
                if (r)
                    return "innerHTML" === t || "textContent" === t || !!(t in e && Oi(t) && f(n));
                if ("spellcheck" === t || "draggable" === t || "translate" === t || "autocorrect" === t)
                    return !1;
                if ("form" === t)
                    return !1;
                if ("list" === t && "INPUT" === e.tagName)
                    return !1;
                if ("type" === t && "TEXTAREA" === e.tagName)
                    return !1;
                if ("width" === t || "height" === t) {
                    const t = e.tagName;
                    if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t)
                        return !1
                }
                return (!Oi(t) || !g(n)) && t in e
            }(e, t, r, l)) ? (Mi(e, t, r), e.tagName.includes("-") || "value" !== t && "checked" !== t && "selected" !== t || Ti(e, t, r, l, 0, "value" !== t)) : !e._isVueCE || !/[A-Z]/.test(t) && g(r) ? ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r), Ti(e, t, r, l)) : Mi(e, S(t), r, 0, t)
        }
    }, Zo);
let Gi;
const ji = "180",
    Vi = 0,
    Hi = 1,
    $i = 2,
    Wi = 100,
    Ki = 101,
    qi = 102,
    Xi = 200,
    Yi = 201,
    Ji = 202,
    Zi = 203,
    ea = 204,
    ta = 205,
    na = 206,
    ra = 207,
    oa = 208,
    ia = 209,
    aa = 210,
    sa = 211,
    la = 212,
    ca = 213,
    ua = 214,
    da = 0,
    pa = 1,
    ha = 2,
    fa = 3,
    ga = 4,
    ma = 5,
    ba = 6,
    Aa = 7,
    ya = "attached",
    va = 301,
    _a = 302,
    xa = 303,
    wa = 306,
    Ca = 1e3,
    Ea = 1001,
    Sa = 1002,
    Ia = 1003,
    Ta = 1004,
    Ma = 1005,
    Ra = 1006,
    Ba = 1007,
    ka = 1008,
    Da = 1009,
    Pa = 1012,
    Oa = 1013,
    La = 1014,
    Na = 1015,
    Fa = 1016,
    Ua = 1017,
    za = 1018,
    Qa = 1020,
    Ga = 35902,
    ja = 35899,
    Va = 1021,
    Ha = 1022,
    $a = 1023,
    Wa = 1026,
    Ka = 1027,
    qa = 1028,
    Xa = 1029,
    Ya = 1030,
    Ja = 1031,
    Za = 1033,
    es = 33776,
    ts = 33777,
    ns = 33778,
    rs = 33779,
    os = 35840,
    is = 35841,
    as = 35842,
    ss = 35843,
    ls = 36196,
    cs = 37492,
    us = 37496,
    ds = 37808,
    ps = 37809,
    hs = 37810,
    fs = 37811,
    gs = 37812,
    ms = 37813,
    bs = 37814,
    As = 37815,
    ys = 37816,
    vs = 37817,
    _s = 37818,
    xs = 37819,
    ws = 37820,
    Cs = 37821,
    Es = 36492,
    Ss = 36494,
    Is = 36495,
    Ts = 36283,
    Ms = 36284,
    Rs = 36285,
    Bs = 36286,
    ks = 2300,
    Ds = 2301,
    Ps = 2302,
    Os = "",
    Ls = "srgb",
    Ns = "srgb-linear",
    Fs = "linear",
    Us = "srgb",
    zs = 7680,
    Qs = 512,
    Gs = 513,
    js = 514,
    Vs = 515,
    Hs = 516,
    $s = 517,
    Ws = 518,
    Ks = 519,
    qs = 35044,
    Xs = "300 es",
    Ys = 2e3,
    Js = 2001;
let Zs = class {
    addEventListener(e, t)
    {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []),
        -1 === n[e].indexOf(t) && n[e].push(t)
    }
    hasEventListener(e, t)
    {
        const n = this._listeners;
        return void 0 !== n && void 0 !== n[e] && -1 !== n[e].indexOf(t)
    }
    removeEventListener(e, t)
    {
        const n = this._listeners;
        if (void 0 === n)
            return;
        const r = n[e];
        if (void 0 !== r) {
            const e = r.indexOf(t);
            -1 !== e && r.splice(e, 1)
        }
    }
    dispatchEvent(e)
    {
        const t = this._listeners;
        if (void 0 === t)
            return;
        const n = t[e.type];
        if (void 0 !== n) {
            e.target = this;
            const t = n.slice(0);
            for (let n = 0, r = t.length; n < r; n++)
                t[n].call(this, e);
            e.target = null
        }
    }
}
;
const el = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let tl = 1234567;
const nl = Math.PI / 180,
    rl = 180 / Math.PI;
function ol() {
    const e = 4294967295 * Math.random() | 0,
        t = 4294967295 * Math.random() | 0,
        n = 4294967295 * Math.random() | 0,
        r = 4294967295 * Math.random() | 0;
    return (el[255 & e] + el[e >> 8 & 255] + el[e >> 16 & 255] + el[e >> 24 & 255] + "-" + el[255 & t] + el[t >> 8 & 255] + "-" + el[t >> 16 & 15 | 64] + el[t >> 24 & 255] + "-" + el[63 & n | 128] + el[n >> 8 & 255] + "-" + el[n >> 16 & 255] + el[n >> 24 & 255] + el[255 & r] + el[r >> 8 & 255] + el[r >> 16 & 255] + el[r >> 24 & 255]).toLowerCase()
}
function il(e, t, n) {
    return Math.max(t, Math.min(n, e))
}
function al(e, t) {
    return (e % t + t) % t
}
function sl(e, t, n) {
    return (1 - n) * e + n * t
}
function ll(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint32Array:
        return e / 4294967295;
    case Uint16Array:
        return e / 65535;
    case Uint8Array:
        return e / 255;
    case Int32Array:
        return Math.max(e / 2147483647, -1);
    case Int16Array:
        return Math.max(e / 32767, -1);
    case Int8Array:
        return Math.max(e / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function cl(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint32Array:
        return Math.round(4294967295 * e);
    case Uint16Array:
        return Math.round(65535 * e);
    case Uint8Array:
        return Math.round(255 * e);
    case Int32Array:
        return Math.round(2147483647 * e);
    case Int16Array:
        return Math.round(32767 * e);
    case Int8Array:
        return Math.round(127 * e);
    default:
        throw new Error("Invalid component type.")
    }
}
const ul = {
    DEG2RAD: nl,
    RAD2DEG: rl,
    generateUUID: ol,
    clamp: il,
    euclideanModulo: al,
    mapLinear: function(e, t, n, r, o) {
        return r + (e - t) * (o - r) / (n - t)
    },
    inverseLerp: function(e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0
    },
    lerp: sl,
    damp: function(e, t, n, r) {
        return sl(e, t, 1 - Math.exp(-n * r))
    },
    pingpong: function(e, t=1) {
        return t - Math.abs(al(e, 2 * t) - t)
    },
    smoothstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
    },
    smootherstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
    },
    randInt: function(e, t) {
        return e + Math.floor(Math.random() * (t - e + 1))
    },
    randFloat: function(e, t) {
        return e + Math.random() * (t - e)
    },
    randFloatSpread: function(e) {
        return e * (.5 - Math.random())
    },
    seededRandom: function(e) {
        void 0 !== e && (tl = e);
        let t = tl += 1831565813;
        return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
    },
    degToRad: function(e) {
        return e * nl
    },
    radToDeg: function(e) {
        return e * rl
    },
    isPowerOfTwo: function(e) {
        return !(e & e - 1) && 0 !== e
    },
    ceilPowerOfTwo: function(e) {
        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
    },
    floorPowerOfTwo: function(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
    },
    setQuaternionFromProperEuler: function(e, t, n, r, o) {
        const i = Math.cos,
            a = Math.sin,
            s = i(n / 2),
            l = a(n / 2),
            c = i((t + r) / 2),
            u = a((t + r) / 2),
            d = i((t - r) / 2),
            p = a((t - r) / 2),
            h = i((r - t) / 2),
            f = a((r - t) / 2);
        switch (o) {
        case "XYX":
            e.set(s * u, l * d, l * p, s * c);
            break;
        case "YZY":
            e.set(l * p, s * u, l * d, s * c);
            break;
        case "ZXZ":
            e.set(l * d, l * p, s * u, s * c);
            break;
        case "XZX":
            e.set(s * u, l * f, l * h, s * c);
            break;
        case "YXY":
            e.set(l * h, s * u, l * f, s * c);
            break;
        case "ZYZ":
            e.set(l * f, l * h, s * u, s * c)
        }
    },
    normalize: cl,
    denormalize: ll
};
class dl {
    constructor(e=0, t=0)
    {
        dl.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width()
    {
        return this.x
    }
    set width(e)
    {
        this.x = e
    }
    get height()
    {
        return this.y
    }
    set height(e)
    {
        this.y = e
    }
    set(e, t)
    {
        return this.x = e, this.y = t, this
    }
    setScalar(e)
    {
        return this.x = e, this.y = e, this
    }
    setX(e)
    {
        return this.x = e, this
    }
    setY(e)
    {
        return this.y = e, this
    }
    setComponent(e, t)
    {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e)
    {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y)
    }
    copy(e)
    {
        return this.x = e.x, this.y = e.y, this
    }
    add(e)
    {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e)
    {
        return this.x += e, this.y += e, this
    }
    addVectors(e, t)
    {
        return this.x = e.x + t.x, this.y = e.y + t.y, this
    }
    addScaledVector(e, t)
    {
        return this.x += e.x * t, this.y += e.y * t, this
    }
    sub(e)
    {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e)
    {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, t)
    {
        return this.x = e.x - t.x, this.y = e.y - t.y, this
    }
    multiply(e)
    {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e)
    {
        return this.x *= e, this.y *= e, this
    }
    divide(e)
    {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e)
    {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e)
    {
        const t = this.x,
            n = this.y,
            r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
    }
    min(e)
    {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e)
    {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, t)
    {
        return this.x = il(this.x, e.x, t.x), this.y = il(this.y, e.y, t.y), this
    }
    clampScalar(e, t)
    {
        return this.x = il(this.x, e, t), this.y = il(this.y, e, t), this
    }
    clampLength(e, t)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(il(n, e, t))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e)
    {
        return this.x * e.x + this.y * e.y
    }
    cross(e)
    {
        return this.x * e.y - this.y * e.x
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    angle()
    {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e)
    {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(il(n, -1, 1))
    }
    distanceTo(e)
    {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e)
    {
        const t = this.x - e.x,
            n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e)
    {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e)
    {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t)
    {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
    }
    lerpVectors(e, t, n)
    {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
    }
    equals(e)
    {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0)
    {
        return this.x = e[t], this.y = e[t + 1], this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this.x, e[t + 1] = this.y, e
    }
    fromBufferAttribute(e, t)
    {
        return this.x = e.getX(t), this.y = e.getY(t), this
    }
    rotateAround(e, t)
    {
        const n = Math.cos(t),
            r = Math.sin(t),
            o = this.x - e.x,
            i = this.y - e.y;
        return this.x = o * n - i * r + e.x, this.y = o * r + i * n + e.y, this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y
    }
}
class pl {
    constructor(e=0, t=0, n=0, r=1)
    {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = r
    }
    static slerpFlat(e, t, n, r, o, i, a)
    {
        let s = n[r + 0],
            l = n[r + 1],
            c = n[r + 2],
            u = n[r + 3];
        const d = o[i + 0],
            p = o[i + 1],
            h = o[i + 2],
            f = o[i + 3];
        if (0 === a)
            return e[t + 0] = s, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u);
        if (1 === a)
            return e[t + 0] = d, e[t + 1] = p, e[t + 2] = h, void (e[t + 3] = f);
        if (u !== f || s !== d || l !== p || c !== h) {
            let e = 1 - a;
            const t = s * d + l * p + c * h + u * f,
                n = t >= 0 ? 1 : -1,
                r = 1 - t * t;
            if (r > Number.EPSILON) {
                const o = Math.sqrt(r),
                    i = Math.atan2(o, t * n);
                e = Math.sin(e * i) / o,
                a = Math.sin(a * i) / o
            }
            const o = a * n;
            if (s = s * e + d * o, l = l * e + p * o, c = c * e + h * o, u = u * e + f * o, e === 1 - a) {
                const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                s *= e,
                l *= e,
                c *= e,
                u *= e
            }
        }
        e[t] = s,
        e[t + 1] = l,
        e[t + 2] = c,
        e[t + 3] = u
    }
    static multiplyQuaternionsFlat(e, t, n, r, o, i)
    {
        const a = n[r],
            s = n[r + 1],
            l = n[r + 2],
            c = n[r + 3],
            u = o[i],
            d = o[i + 1],
            p = o[i + 2],
            h = o[i + 3];
        return e[t] = a * h + c * u + s * p - l * d, e[t + 1] = s * h + c * d + l * u - a * p, e[t + 2] = l * h + c * p + a * d - s * u, e[t + 3] = c * h - a * u - s * d - l * p, e
    }
    get x()
    {
        return this._x
    }
    set x(e)
    {
        this._x = e,
        this._onChangeCallback()
    }
    get y()
    {
        return this._y
    }
    set y(e)
    {
        this._y = e,
        this._onChangeCallback()
    }
    get z()
    {
        return this._z
    }
    set z(e)
    {
        this._z = e,
        this._onChangeCallback()
    }
    get w()
    {
        return this._w
    }
    set w(e)
    {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, r)
    {
        return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
    }
    clone()
    {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e)
    {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, t=!0)
    {
        const n = e._x,
            r = e._y,
            o = e._z,
            i = e._order,
            a = Math.cos,
            s = Math.sin,
            l = a(n / 2),
            c = a(r / 2),
            u = a(o / 2),
            d = s(n / 2),
            p = s(r / 2),
            h = s(o / 2);
        switch (i) {
        case "XYZ":
            this._x = d * c * u + l * p * h,
            this._y = l * p * u - d * c * h,
            this._z = l * c * h + d * p * u,
            this._w = l * c * u - d * p * h;
            break;
        case "YXZ":
            this._x = d * c * u + l * p * h,
            this._y = l * p * u - d * c * h,
            this._z = l * c * h - d * p * u,
            this._w = l * c * u + d * p * h;
            break;
        case "ZXY":
            this._x = d * c * u - l * p * h,
            this._y = l * p * u + d * c * h,
            this._z = l * c * h + d * p * u,
            this._w = l * c * u - d * p * h;
            break;
        case "ZYX":
            this._x = d * c * u - l * p * h,
            this._y = l * p * u + d * c * h,
            this._z = l * c * h - d * p * u,
            this._w = l * c * u + d * p * h;
            break;
        case "YZX":
            this._x = d * c * u + l * p * h,
            this._y = l * p * u + d * c * h,
            this._z = l * c * h - d * p * u,
            this._w = l * c * u - d * p * h;
            break;
        case "XZY":
            this._x = d * c * u - l * p * h,
            this._y = l * p * u - d * c * h,
            this._z = l * c * h + d * p * u,
            this._w = l * c * u + d * p * h
        }
        return !0 === t && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, t)
    {
        const n = t / 2,
            r = Math.sin(n);
        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e)
    {
        const t = e.elements,
            n = t[0],
            r = t[4],
            o = t[8],
            i = t[1],
            a = t[5],
            s = t[9],
            l = t[2],
            c = t[6],
            u = t[10],
            d = n + a + u;
        if (d > 0) {
            const e = .5 / Math.sqrt(d + 1);
            this._w = .25 / e,
            this._x = (c - s) * e,
            this._y = (o - l) * e,
            this._z = (i - r) * e
        } else if (n > a && n > u) {
            const e = 2 * Math.sqrt(1 + n - a - u);
            this._w = (c - s) / e,
            this._x = .25 * e,
            this._y = (r + i) / e,
            this._z = (o + l) / e
        } else if (a > u) {
            const e = 2 * Math.sqrt(1 + a - n - u);
            this._w = (o - l) / e,
            this._x = (r + i) / e,
            this._y = .25 * e,
            this._z = (s + c) / e
        } else {
            const e = 2 * Math.sqrt(1 + u - n - a);
            this._w = (i - r) / e,
            this._x = (o + l) / e,
            this._y = (s + c) / e,
            this._z = .25 * e
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, t)
    {
        let n = e.dot(t) + 1;
        return n < 1e-8 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
    }
    angleTo(e)
    {
        return 2 * Math.acos(Math.abs(il(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t)
    {
        const n = this.angleTo(e);
        if (0 === n)
            return this;
        const r = Math.min(1, t / n);
        return this.slerp(e, r), this
    }
    identity()
    {
        return this.set(0, 0, 0, 1)
    }
    invert()
    {
        return this.conjugate()
    }
    conjugate()
    {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e)
    {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq()
    {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length()
    {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize()
    {
        let e = this.length();
        return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e)
    {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e)
    {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t)
    {
        const n = e._x,
            r = e._y,
            o = e._z,
            i = e._w,
            a = t._x,
            s = t._y,
            l = t._z,
            c = t._w;
        return this._x = n * c + i * a + r * l - o * s, this._y = r * c + i * s + o * a - n * l, this._z = o * c + i * l + n * s - r * a, this._w = i * c - n * a - r * s - o * l, this._onChangeCallback(), this
    }
    slerp(e, t)
    {
        if (0 === t)
            return this;
        if (1 === t)
            return this.copy(e);
        const n = this._x,
            r = this._y,
            o = this._z,
            i = this._w;
        let a = i * e._w + n * e._x + r * e._y + o * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
            return this._w = i, this._x = n, this._y = r, this._z = o, this;
        const s = 1 - a * a;
        if (s <= Number.EPSILON) {
            const e = 1 - t;
            return this._w = e * i + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * o + t * this._z, this.normalize(), this
        }
        const l = Math.sqrt(s),
            c = Math.atan2(l, a),
            u = Math.sin((1 - t) * c) / l,
            d = Math.sin(t * c) / l;
        return this._w = i * u + this._w * d, this._x = n * u + this._x * d, this._y = r * u + this._y * d, this._z = o * u + this._z * d, this._onChangeCallback(), this
    }
    slerpQuaternions(e, t, n)
    {
        return this.copy(e).slerp(t, n)
    }
    random()
    {
        const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            n = Math.random(),
            r = Math.sqrt(1 - n),
            o = Math.sqrt(n);
        return this.set(r * Math.sin(e), r * Math.cos(e), o * Math.sin(t), o * Math.cos(t))
    }
    equals(e)
    {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0)
    {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
    }
    fromBufferAttribute(e, t)
    {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
    }
    toJSON()
    {
        return this.toArray()
    }
    _onChange(e)
    {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]()
    {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class hl {
    constructor(e=0, t=0, n=0)
    {
        hl.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n)
    {
        return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
    }
    setScalar(e)
    {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e)
    {
        return this.x = e, this
    }
    setY(e)
    {
        return this.y = e, this
    }
    setZ(e)
    {
        return this.z = e, this
    }
    setComponent(e, t)
    {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e)
    {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e)
    {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e)
    {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e)
    {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, t)
    {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
    }
    addScaledVector(e, t)
    {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
    }
    sub(e)
    {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e)
    {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, t)
    {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
    }
    multiply(e)
    {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e)
    {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, t)
    {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
    }
    applyEuler(e)
    {
        return this.applyQuaternion(gl.setFromEuler(e))
    }
    applyAxisAngle(e, t)
    {
        return this.applyQuaternion(gl.setFromAxisAngle(e, t))
    }
    applyMatrix3(e)
    {
        const t = this.x,
            n = this.y,
            r = this.z,
            o = e.elements;
        return this.x = o[0] * t + o[3] * n + o[6] * r, this.y = o[1] * t + o[4] * n + o[7] * r, this.z = o[2] * t + o[5] * n + o[8] * r, this
    }
    applyNormalMatrix(e)
    {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e)
    {
        const t = this.x,
            n = this.y,
            r = this.z,
            o = e.elements,
            i = 1 / (o[3] * t + o[7] * n + o[11] * r + o[15]);
        return this.x = (o[0] * t + o[4] * n + o[8] * r + o[12]) * i, this.y = (o[1] * t + o[5] * n + o[9] * r + o[13]) * i, this.z = (o[2] * t + o[6] * n + o[10] * r + o[14]) * i, this
    }
    applyQuaternion(e)
    {
        const t = this.x,
            n = this.y,
            r = this.z,
            o = e.x,
            i = e.y,
            a = e.z,
            s = e.w,
            l = 2 * (i * r - a * n),
            c = 2 * (a * t - o * r),
            u = 2 * (o * n - i * t);
        return this.x = t + s * l + i * u - a * c, this.y = n + s * c + a * l - o * u, this.z = r + s * u + o * c - i * l, this
    }
    project(e)
    {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e)
    {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e)
    {
        const t = this.x,
            n = this.y,
            r = this.z,
            o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * r, this.y = o[1] * t + o[5] * n + o[9] * r, this.z = o[2] * t + o[6] * n + o[10] * r, this.normalize()
    }
    divide(e)
    {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e)
    {
        return this.multiplyScalar(1 / e)
    }
    min(e)
    {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e)
    {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, t)
    {
        return this.x = il(this.x, e.x, t.x), this.y = il(this.y, e.y, t.y), this.z = il(this.z, e.z, t.z), this
    }
    clampScalar(e, t)
    {
        return this.x = il(this.x, e, t), this.y = il(this.y, e, t), this.z = il(this.z, e, t), this
    }
    clampLength(e, t)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(il(n, e, t))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e)
    {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e)
    {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t)
    {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
    }
    lerpVectors(e, t, n)
    {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
    }
    cross(e)
    {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t)
    {
        const n = e.x,
            r = e.y,
            o = e.z,
            i = t.x,
            a = t.y,
            s = t.z;
        return this.x = r * s - o * a, this.y = o * i - n * s, this.z = n * a - r * i, this
    }
    projectOnVector(e)
    {
        const t = e.lengthSq();
        if (0 === t)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e)
    {
        return fl.copy(this).projectOnVector(e), this.sub(fl)
    }
    reflect(e)
    {
        return this.sub(fl.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e)
    {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(il(n, -1, 1))
    }
    distanceTo(e)
    {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e)
    {
        const t = this.x - e.x,
            n = this.y - e.y,
            r = this.z - e.z;
        return t * t + n * n + r * r
    }
    manhattanDistanceTo(e)
    {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e)
    {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n)
    {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
    }
    setFromCylindrical(e)
    {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n)
    {
        return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
    }
    setFromMatrixPosition(e)
    {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }
    setFromMatrixScale(e)
    {
        const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = n, this.z = r, this
    }
    setFromMatrixColumn(e, t)
    {
        return this.fromArray(e.elements, 4 * t)
    }
    setFromMatrix3Column(e, t)
    {
        return this.fromArray(e.elements, 3 * t)
    }
    setFromEuler(e)
    {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    setFromColor(e)
    {
        return this.x = e.r, this.y = e.g, this.z = e.b, this
    }
    equals(e)
    {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0)
    {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
    }
    fromBufferAttribute(e, t)
    {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection()
    {
        const e = Math.random() * Math.PI * 2,
            t = 2 * Math.random() - 1,
            n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const fl = new hl,
    gl = new pl;
class ml {
    constructor(e, t, n, r, o, i, a, s, l)
    {
        ml.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        void 0 !== e && this.set(e, t, n, r, o, i, a, s, l)
    }
    set(e, t, n, r, o, i, a, s, l)
    {
        const c = this.elements;
        return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = o, c[5] = s, c[6] = n, c[7] = i, c[8] = l, this
    }
    identity()
    {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e)
    {
        const t = this.elements,
            n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
    }
    extractBasis(e, t, n)
    {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e)
    {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    }
    multiply(e)
    {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e)
    {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t)
    {
        const n = e.elements,
            r = t.elements,
            o = this.elements,
            i = n[0],
            a = n[3],
            s = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            d = n[2],
            p = n[5],
            h = n[8],
            f = r[0],
            g = r[3],
            m = r[6],
            b = r[1],
            A = r[4],
            y = r[7],
            v = r[2],
            _ = r[5],
            x = r[8];
        return o[0] = i * f + a * b + s * v, o[3] = i * g + a * A + s * _, o[6] = i * m + a * y + s * x, o[1] = l * f + c * b + u * v, o[4] = l * g + c * A + u * _, o[7] = l * m + c * y + u * x, o[2] = d * f + p * b + h * v, o[5] = d * g + p * A + h * _, o[8] = d * m + p * y + h * x, this
    }
    multiplyScalar(e)
    {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
    }
    determinant()
    {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            o = e[3],
            i = e[4],
            a = e[5],
            s = e[6],
            l = e[7],
            c = e[8];
        return t * i * c - t * a * l - n * o * c + n * a * s + r * o * l - r * i * s
    }
    invert()
    {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            o = e[3],
            i = e[4],
            a = e[5],
            s = e[6],
            l = e[7],
            c = e[8],
            u = c * i - a * l,
            d = a * s - c * o,
            p = l * o - i * s,
            h = t * u + n * d + r * p;
        if (0 === h)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / h;
        return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (a * n - r * i) * f, e[3] = d * f, e[4] = (c * t - r * s) * f, e[5] = (r * o - a * t) * f, e[6] = p * f, e[7] = (n * s - l * t) * f, e[8] = (i * t - n * o) * f, this
    }
    transpose()
    {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }
    getNormalMatrix(e)
    {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e)
    {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
    }
    setUvTransform(e, t, n, r, o, i, a)
    {
        const s = Math.cos(o),
            l = Math.sin(o);
        return this.set(n * s, n * l, -n * (s * i + l * a) + i + e, -r * l, r * s, -r * (-l * i + s * a) + a + t, 0, 0, 1), this
    }
    scale(e, t)
    {
        return this.premultiply(bl.makeScale(e, t)), this
    }
    rotate(e)
    {
        return this.premultiply(bl.makeRotation(-e)), this
    }
    translate(e, t)
    {
        return this.premultiply(bl.makeTranslation(e, t)), this
    }
    makeTranslation(e, t)
    {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
    }
    makeRotation(e)
    {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
    }
    makeScale(e, t)
    {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
    }
    equals(e)
    {
        const t = this.elements,
            n = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== n[r])
                return !1;
        return !0
    }
    fromArray(e, t=0)
    {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0)
    {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
    }
    clone()
    {
        return (new this.constructor).fromArray(this.elements)
    }
}
const bl = new ml;
function Al(e) {
    for (let t = e.length - 1; t >= 0; --t)
        if (e[t] >= 65535)
            return !0;
    return !1
}
function yl(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
}
function vl() {
    const e = yl("canvas");
    return e.style.display = "block", e
}
const _l = {};
function xl(e) {
    e in _l || (_l[e] = !0)
}
const wl = (new ml).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
    Cl = (new ml).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function El() {
    const e = {
            enabled: !0,
            workingColorSpace: Ns,
            spaces: {},
            convert: function(e, t, n) {
                return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === Us && (e.r = Il(e.r), e.g = Il(e.g), e.b = Il(e.b)), this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ), e.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === Us && (e.r = Tl(e.r), e.g = Tl(e.g), e.b = Tl(e.b)), e) : e
            },
            workingToColorSpace: function(e, t) {
                return this.convert(e, this.workingColorSpace, t)
            },
            colorSpaceToWorking: function(e, t) {
                return this.convert(e, t, this.workingColorSpace)
            },
            getPrimaries: function(e) {
                return this.spaces[e].primaries
            },
            getTransfer: function(e) {
                return e === Os ? Fs : this.spaces[e].transfer
            },
            getToneMappingMode: function(e) {
                return this.spaces[e].outputColorSpaceConfig.toneMappingMode || "standard"
            },
            getLuminanceCoefficients: function(e, t=this.workingColorSpace) {
                return e.fromArray(this.spaces[t].luminanceCoefficients)
            },
            define: function(e) {
                Object.assign(this.spaces, e)
            },
            _getMatrix: function(e, t, n) {
                return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
            },
            _getDrawingBufferColorSpace: function(e) {
                return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
            },
            _getUnpackColorSpace: function(e=this.workingColorSpace) {
                return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
            },
            fromWorkingColorSpace: function(t, n) {
                return xl("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), e.workingToColorSpace(t, n)
            },
            toWorkingColorSpace: function(t, n) {
                return xl("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), e.colorSpaceToWorking(t, n)
            }
        },
        t = [.64, .33, .3, .6, .15, .06],
        n = [.2126, .7152, .0722],
        r = [.3127, .329];
    return e.define({
        [Ns]: {
            primaries: t,
            whitePoint: r,
            transfer: Fs,
            toXYZ: wl,
            fromXYZ: Cl,
            luminanceCoefficients: n,
            workingColorSpaceConfig: {
                unpackColorSpace: Ls
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Ls
            }
        },
        [Ls]: {
            primaries: t,
            whitePoint: r,
            transfer: Us,
            toXYZ: wl,
            fromXYZ: Cl,
            luminanceCoefficients: n,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Ls
            }
        }
    }), e
}
const Sl = El();
function Il(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
}
function Tl(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
}
let Ml,
    Rl = class {
        static getDataURL(e, t="image/png")
        {
            if (/^data:/i.test(e.src))
                return e.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            let n;
            if (e instanceof HTMLCanvasElement)
                n = e;
            else {
                void 0 === Ml && (Ml = yl("canvas")),
                Ml.width = e.width,
                Ml.height = e.height;
                const t = Ml.getContext("2d");
                e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height),
                n = Ml
            }
            return n.toDataURL(t)
        }
        static sRGBToLinear(e)
        {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                const t = yl("canvas");
                t.width = e.width,
                t.height = e.height;
                const n = t.getContext("2d");
                n.drawImage(e, 0, 0, e.width, e.height);
                const r = n.getImageData(0, 0, e.width, e.height),
                    o = r.data;
                for (let e = 0; e < o.length; e++)
                    o[e] = 255 * Il(o[e] / 255);
                return n.putImageData(r, 0, 0), t
            }
            if (e.data) {
                const t = e.data.slice(0);
                for (let e = 0; e < t.length; e++)
                    t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Il(t[e] / 255)) : t[e] = Il(t[e]);
                return {
                    data: t,
                    width: e.width,
                    height: e.height
                }
            }
            return e
        }
    }
    ,
    Bl = 0;
class kl {
    constructor(e=null)
    {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: Bl++
        }),
        this.uuid = ol(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e)
    {
        const t = this.data;
        return "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : null !== t ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e
    }
    set needsUpdate(e)
    {
        !0 === e && this.version++
    }
    toJSON(e)
    {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.images[this.uuid])
            return e.images[this.uuid];
        const n = {
                uuid: this.uuid,
                url: ""
            },
            r = this.data;
        if (null !== r) {
            let e;
            if (Array.isArray(r)) {
                e = [];
                for (let t = 0, n = r.length; t < n; t++)
                    r[t].isDataTexture ? e.push(Dl(r[t].image)) : e.push(Dl(r[t]))
            } else
                e = Dl(r);
            n.url = e
        }
        return t || (e.images[this.uuid] = n), n
    }
}
function Dl(e) {
    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Rl.getDataURL(e) : e.data ? {
        data: Array.from(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name
    } : {}
}
let Pl = 0;
const Ol = new hl;
let Ll = class e extends Zs {
    constructor(t=e.DEFAULT_IMAGE, n=e.DEFAULT_MAPPING, r=1001, o=1001, i=1006, a=1008, s=1023, l=1009, c=e.DEFAULT_ANISOTROPY, u="")
    {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Pl++
        }),
        this.uuid = ol(),
        this.name = "",
        this.source = new kl(t),
        this.mipmaps = [],
        this.mapping = n,
        this.channel = 0,
        this.wrapS = r,
        this.wrapT = o,
        this.magFilter = i,
        this.minFilter = a,
        this.anisotropy = c,
        this.format = s,
        this.internalFormat = null,
        this.type = l,
        this.offset = new dl(0, 0),
        this.repeat = new dl(1, 1),
        this.center = new dl(0, 0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new ml,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(t && t.depth && t.depth > 1),
        this.pmremVersion = 0
    }
    get width()
    {
        return this.source.getSize(Ol).x
    }
    get height()
    {
        return this.source.getSize(Ol).y
    }
    get depth()
    {
        return this.source.getSize(Ol).z
    }
    get image()
    {
        return this.source.data
    }
    set image(e=null)
    {
        this.source.data = e
    }
    updateMatrix()
    {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, t)
    {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges()
    {
        this.updateRanges.length = 0
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    copy(e)
    {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    setValues(e)
    {
        for (const t in e) {
            const n = e[t];
            if (void 0 === n)
                continue;
            const r = this[t];
            void 0 !== r && (r && n && r.isVector2 && n.isVector2 || r && n && r.isVector3 && n.isVector3 || r && n && r.isMatrix3 && n.isMatrix3 ? r.copy(n) : this[t] = n)
        }
    }
    toJSON(e)
    {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e)
    {
        if (300 !== this.mapping)
            return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Ca:
                e.x = e.x - Math.floor(e.x);
                break;
            case Ea:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Sa:
                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Ca:
                e.y = e.y - Math.floor(e.y);
                break;
            case Ea:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Sa:
                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e)
    {
        !0 === e && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e)
    {
        !0 === e && this.pmremVersion++
    }
}
;
Ll.DEFAULT_IMAGE = null,
Ll.DEFAULT_MAPPING = 300,
Ll.DEFAULT_ANISOTROPY = 1;
class Nl {
    constructor(e=0, t=0, n=0, r=1)
    {
        Nl.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = r
    }
    get width()
    {
        return this.z
    }
    set width(e)
    {
        this.z = e
    }
    get height()
    {
        return this.w
    }
    set height(e)
    {
        this.w = e
    }
    set(e, t, n, r)
    {
        return this.x = e, this.y = t, this.z = n, this.w = r, this
    }
    setScalar(e)
    {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e)
    {
        return this.x = e, this
    }
    setY(e)
    {
        return this.y = e, this
    }
    setZ(e)
    {
        return this.z = e, this
    }
    setW(e)
    {
        return this.w = e, this
    }
    setComponent(e, t)
    {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e)
    {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone()
    {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e)
    {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
    }
    add(e)
    {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e)
    {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, t)
    {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
    }
    addScaledVector(e, t)
    {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
    }
    sub(e)
    {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e)
    {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, t)
    {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
    }
    multiply(e)
    {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e)
    {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e)
    {
        const t = this.x,
            n = this.y,
            r = this.z,
            o = this.w,
            i = e.elements;
        return this.x = i[0] * t + i[4] * n + i[8] * r + i[12] * o, this.y = i[1] * t + i[5] * n + i[9] * r + i[13] * o, this.z = i[2] * t + i[6] * n + i[10] * r + i[14] * o, this.w = i[3] * t + i[7] * n + i[11] * r + i[15] * o, this
    }
    divide(e)
    {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
    }
    divideScalar(e)
    {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e)
    {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
    }
    setAxisAngleFromRotationMatrix(e)
    {
        let t,
            n,
            r,
            o;
        const i = .01,
            a = .1,
            s = e.elements,
            l = s[0],
            c = s[4],
            u = s[8],
            d = s[1],
            p = s[5],
            h = s[9],
            f = s[2],
            g = s[6],
            m = s[10];
        if (Math.abs(c - d) < i && Math.abs(u - f) < i && Math.abs(h - g) < i) {
            if (Math.abs(c + d) < a && Math.abs(u + f) < a && Math.abs(h + g) < a && Math.abs(l + p + m - 3) < a)
                return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (l + 1) / 2,
                s = (p + 1) / 2,
                b = (m + 1) / 2,
                A = (c + d) / 4,
                y = (u + f) / 4,
                v = (h + g) / 4;
            return e > s && e > b ? e < i ? (n = 0, r = .707106781, o = .707106781) : (n = Math.sqrt(e), r = A / n, o = y / n) : s > b ? s < i ? (n = .707106781, r = 0, o = .707106781) : (r = Math.sqrt(s), n = A / r, o = v / r) : b < i ? (n = .707106781, r = .707106781, o = 0) : (o = Math.sqrt(b), n = y / o, r = v / o), this.set(n, r, o, t), this
        }
        let b = Math.sqrt((g - h) * (g - h) + (u - f) * (u - f) + (d - c) * (d - c));
        return Math.abs(b) < .001 && (b = 1), this.x = (g - h) / b, this.y = (u - f) / b, this.z = (d - c) / b, this.w = Math.acos((l + p + m - 1) / 2), this
    }
    setFromMatrixPosition(e)
    {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
    }
    min(e)
    {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e)
    {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, t)
    {
        return this.x = il(this.x, e.x, t.x), this.y = il(this.y, e.y, t.y), this.z = il(this.z, e.z, t.z), this.w = il(this.w, e.w, t.w), this
    }
    clampScalar(e, t)
    {
        return this.x = il(this.x, e, t), this.y = il(this.y, e, t), this.z = il(this.z, e, t), this.w = il(this.w, e, t), this
    }
    clampLength(e, t)
    {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(il(n, e, t))
    }
    floor()
    {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil()
    {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round()
    {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero()
    {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate()
    {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e)
    {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq()
    {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength()
    {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize()
    {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e)
    {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t)
    {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
    }
    lerpVectors(e, t, n)
    {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
    }
    equals(e)
    {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0)
    {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
    }
    fromBufferAttribute(e, t)
    {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
    }
    random()
    {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }
    *[Symbol.iterator]()
    {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Fl extends Zs {
    constructor(e=1, t=1, n={})
    {
        super(),
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Ra,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, n),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = n.depth,
        this.scissor = new Nl(0, 0, e, t),
        this.scissorTest = !1,
        this.viewport = new Nl(0, 0, e, t);
        const r = {
                width: e,
                height: t,
                depth: n.depth
            },
            o = new Ll(r);
        this.textures = [];
        const i = n.count;
        for (let a = 0; a < i; a++)
            this.textures[a] = o.clone(),
            this.textures[a].isRenderTargetTexture = !0,
            this.textures[a].renderTarget = this;
        this._setTextureOptions(n),
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples,
        this.multiview = n.multiview
    }
    _setTextureOptions(e={})
    {
        const t = {
            minFilter: Ra,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        void 0 !== e.mapping && (t.mapping = e.mapping),
        void 0 !== e.wrapS && (t.wrapS = e.wrapS),
        void 0 !== e.wrapT && (t.wrapT = e.wrapT),
        void 0 !== e.wrapR && (t.wrapR = e.wrapR),
        void 0 !== e.magFilter && (t.magFilter = e.magFilter),
        void 0 !== e.minFilter && (t.minFilter = e.minFilter),
        void 0 !== e.format && (t.format = e.format),
        void 0 !== e.type && (t.type = e.type),
        void 0 !== e.anisotropy && (t.anisotropy = e.anisotropy),
        void 0 !== e.colorSpace && (t.colorSpace = e.colorSpace),
        void 0 !== e.flipY && (t.flipY = e.flipY),
        void 0 !== e.generateMipmaps && (t.generateMipmaps = e.generateMipmaps),
        void 0 !== e.internalFormat && (t.internalFormat = e.internalFormat);
        for (let n = 0; n < this.textures.length; n++)
            this.textures[n].setValues(t)
    }
    get texture()
    {
        return this.textures[0]
    }
    set texture(e)
    {
        this.textures[0] = e
    }
    set depthTexture(e)
    {
        null !== this._depthTexture && (this._depthTexture.renderTarget = null),
        null !== e && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture()
    {
        return this._depthTexture
    }
    setSize(e, t, n=1)
    {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let r = 0, o = this.textures.length; r < o; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = t,
                this.textures[r].image.depth = n,
                this.textures[r].isArrayTexture = this.textures[r].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    copy(e)
    {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let t = 0, n = e.textures.length; t < n; t++) {
            this.textures[t] = e.textures[t].clone(),
            this.textures[t].isRenderTargetTexture = !0,
            this.textures[t].renderTarget = this;
            const n = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new kl(n)
        }
        return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Ul extends Fl {
    constructor(e=1, t=1, n={})
    {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class zl extends Ll {
    constructor(e=null, t=1, n=1, r=1)
    {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        },
        this.magFilter = Ia,
        this.minFilter = Ia,
        this.wrapR = Ea,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e)
    {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates()
    {
        this.layerUpdates.clear()
    }
}
class Ql extends Ll {
    constructor(e=null, t=1, n=1, r=1)
    {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: r
        },
        this.magFilter = Ia,
        this.minFilter = Ia,
        this.wrapR = Ea,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Gl {
    constructor(e=new hl(1 / 0, 1 / 0, 1 / 0), t=new hl(-1 / 0, -1 / 0, -1 / 0))
    {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t)
    {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromArray(e)
    {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(Vl.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e)
    {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(Vl.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e)
    {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t)
    {
        const n = Vl.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
    }
    setFromObject(e, t=!1)
    {
        return this.makeEmpty(), this.expandByObject(e, t)
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    copy(e)
    {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty()
    {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty()
    {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e)
    {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e)
    {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e)
    {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e)
    {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e)
    {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, t=!1)
    {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (void 0 !== n) {
            const r = n.getAttribute("position");
            if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh)
                for (let t = 0, n = r.count; t < n; t++)
                    !0 === e.isMesh ? e.getVertexPosition(t, Vl) : Vl.fromBufferAttribute(r, t),
                    Vl.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Vl);
            else
                void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), Hl.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Hl.copy(n.boundingBox)),
                Hl.applyMatrix4(e.matrixWorld),
                this.union(Hl)
        }
        const r = e.children;
        for (let o = 0, i = r.length; o < i; o++)
            this.expandByObject(r[o], t);
        return this
    }
    containsPoint(e)
    {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e)
    {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t)
    {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e)
    {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e)
    {
        return this.clampPoint(e.center, Vl), Vl.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e)
    {
        let t,
            n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e)
    {
        if (this.isEmpty())
            return !1;
        this.getCenter(Jl),
        Zl.subVectors(this.max, Jl),
        $l.subVectors(e.a, Jl),
        Wl.subVectors(e.b, Jl),
        Kl.subVectors(e.c, Jl),
        ql.subVectors(Wl, $l),
        Xl.subVectors(Kl, Wl),
        Yl.subVectors($l, Kl);
        let t = [0, -ql.z, ql.y, 0, -Xl.z, Xl.y, 0, -Yl.z, Yl.y, ql.z, 0, -ql.x, Xl.z, 0, -Xl.x, Yl.z, 0, -Yl.x, -ql.y, ql.x, 0, -Xl.y, Xl.x, 0, -Yl.y, Yl.x, 0];
        return !!nc(t, $l, Wl, Kl, Zl) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!nc(t, $l, Wl, Kl, Zl) && (ec.crossVectors(ql, Xl), t = [ec.x, ec.y, ec.z], nc(t, $l, Wl, Kl, Zl)))
    }
    clampPoint(e, t)
    {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e)
    {
        return this.clampPoint(e, Vl).distanceTo(e)
    }
    getBoundingSphere(e)
    {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(Vl).length()), e
    }
    intersect(e)
    {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e)
    {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e)
    {
        return this.isEmpty() || (jl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), jl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), jl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), jl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), jl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), jl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), jl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), jl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(jl)), this
    }
    translate(e)
    {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e)
    {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON()
    {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e)
    {
        return this.min.fromArray(e.min), this.max.fromArray(e.max), this
    }
}
const jl = [new hl, new hl, new hl, new hl, new hl, new hl, new hl, new hl],
    Vl = new hl,
    Hl = new Gl,
    $l = new hl,
    Wl = new hl,
    Kl = new hl,
    ql = new hl,
    Xl = new hl,
    Yl = new hl,
    Jl = new hl,
    Zl = new hl,
    ec = new hl,
    tc = new hl;
function nc(e, t, n, r, o) {
    for (let i = 0, a = e.length - 3; i <= a; i += 3) {
        tc.fromArray(e, i);
        const a = o.x * Math.abs(tc.x) + o.y * Math.abs(tc.y) + o.z * Math.abs(tc.z),
            s = t.dot(tc),
            l = n.dot(tc),
            c = r.dot(tc);
        if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a)
            return !1
    }
    return !0
}
const rc = new Gl,
    oc = new hl,
    ic = new hl;
class ac {
    constructor(e=new hl, t=-1)
    {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t)
    {
        return this.center.copy(e), this.radius = t, this
    }
    setFromPoints(e, t)
    {
        const n = this.center;
        void 0 !== t ? n.copy(t) : rc.setFromPoints(e).getCenter(n);
        let r = 0;
        for (let o = 0, i = e.length; o < i; o++)
            r = Math.max(r, n.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(r), this
    }
    copy(e)
    {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty()
    {
        return this.radius < 0
    }
    makeEmpty()
    {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e)
    {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e)
    {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e)
    {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e)
    {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e)
    {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t)
    {
        const n = this.center.distanceToSquared(e);
        return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
    }
    getBoundingBox(e)
    {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e)
    {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e)
    {
        return this.center.add(e), this
    }
    expandByPoint(e)
    {
        if (this.isEmpty())
            return this.center.copy(e), this.radius = 0, this;
        oc.subVectors(e, this.center);
        const t = oc.lengthSq();
        if (t > this.radius * this.radius) {
            const e = Math.sqrt(t),
                n = .5 * (e - this.radius);
            this.center.addScaledVector(oc, n / e),
            this.radius += n
        }
        return this
    }
    union(e)
    {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (ic.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(oc.copy(e.center).add(ic)), this.expandByPoint(oc.copy(e.center).sub(ic))), this)
    }
    equals(e)
    {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    toJSON()
    {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e)
    {
        return this.radius = e.radius, this.center.fromArray(e.center), this
    }
}
const sc = new hl,
    lc = new hl,
    cc = new hl,
    uc = new hl,
    dc = new hl,
    pc = new hl,
    hc = new hl;
class fc {
    constructor(e=new hl, t=new hl(0, 0, -1))
    {
        this.origin = e,
        this.direction = t
    }
    set(e, t)
    {
        return this.origin.copy(e), this.direction.copy(t), this
    }
    copy(e)
    {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, t)
    {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e)
    {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e)
    {
        return this.origin.copy(this.at(e, sc)), this
    }
    closestPointToPoint(e, t)
    {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e)
    {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e)
    {
        const t = sc.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (sc.copy(this.origin).addScaledVector(this.direction, t), sc.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, r)
    {
        lc.copy(e).add(t).multiplyScalar(.5),
        cc.copy(t).sub(e).normalize(),
        uc.copy(this.origin).sub(lc);
        const o = .5 * e.distanceTo(t),
            i = -this.direction.dot(cc),
            a = uc.dot(this.direction),
            s = -uc.dot(cc),
            l = uc.lengthSq(),
            c = Math.abs(1 - i * i);
        let u,
            d,
            p,
            h;
        if (c > 0)
            if (u = i * s - a, d = i * a - s, h = o * c, u >= 0)
                if (d >= -h)
                    if (d <= h) {
                        const e = 1 / c;
                        u *= e,
                        d *= e,
                        p = u * (u + i * d + 2 * a) + d * (i * u + d + 2 * s) + l
                    } else
                        d = o,
                        u = Math.max(0, -(i * d + a)),
                        p = -u * u + d * (d + 2 * s) + l;
                else
                    d = -o,
                    u = Math.max(0, -(i * d + a)),
                    p = -u * u + d * (d + 2 * s) + l;
            else
                d <= -h ? (u = Math.max(0, -(-i * o + a)), d = u > 0 ? -o : Math.min(Math.max(-o, -s), o), p = -u * u + d * (d + 2 * s) + l) : d <= h ? (u = 0, d = Math.min(Math.max(-o, -s), o), p = d * (d + 2 * s) + l) : (u = Math.max(0, -(i * o + a)), d = u > 0 ? o : Math.min(Math.max(-o, -s), o), p = -u * u + d * (d + 2 * s) + l);
        else
            d = i > 0 ? -o : o,
            u = Math.max(0, -(i * d + a)),
            p = -u * u + d * (d + 2 * s) + l;
        return n && n.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(lc).addScaledVector(cc, d), p
    }
    intersectSphere(e, t)
    {
        sc.subVectors(e.center, this.origin);
        const n = sc.dot(this.direction),
            r = sc.dot(sc) - n * n,
            o = e.radius * e.radius;
        if (r > o)
            return null;
        const i = Math.sqrt(o - r),
            a = n - i,
            s = n + i;
        return s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
    }
    intersectsSphere(e)
    {
        return !(e.radius < 0) && this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e)
    {
        const t = e.normal.dot(this.direction);
        if (0 === t)
            return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t)
    {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t)
    }
    intersectsPlane(e)
    {
        const t = e.distanceToPoint(this.origin);
        return 0 === t || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t)
    {
        let n,
            r,
            o,
            i,
            a,
            s;
        const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            d = this.origin;
        return l >= 0 ? (n = (e.min.x - d.x) * l, r = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, r = (e.min.x - d.x) * l), c >= 0 ? (o = (e.min.y - d.y) * c, i = (e.max.y - d.y) * c) : (o = (e.max.y - d.y) * c, i = (e.min.y - d.y) * c), n > i || o > r ? null : ((o > n || isNaN(n)) && (n = o), (i < r || isNaN(r)) && (r = i), u >= 0 ? (a = (e.min.z - d.z) * u, s = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u, s = (e.min.z - d.z) * u), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
    }
    intersectsBox(e)
    {
        return null !== this.intersectBox(e, sc)
    }
    intersectTriangle(e, t, n, r, o)
    {
        dc.subVectors(t, e),
        pc.subVectors(n, e),
        hc.crossVectors(dc, pc);
        let i,
            a = this.direction.dot(hc);
        if (a > 0) {
            if (r)
                return null;
            i = 1
        } else {
            if (!(a < 0))
                return null;
            i = -1,
            a = -a
        }
        uc.subVectors(this.origin, e);
        const s = i * this.direction.dot(pc.crossVectors(uc, pc));
        if (s < 0)
            return null;
        const l = i * this.direction.dot(dc.cross(uc));
        if (l < 0)
            return null;
        if (s + l > a)
            return null;
        const c = -i * uc.dot(hc);
        return c < 0 ? null : this.at(c / a, o)
    }
    applyMatrix4(e)
    {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e)
    {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
}
class gc {
    constructor(e, t, n, r, o, i, a, s, l, c, u, d, p, h, f, g)
    {
        gc.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        void 0 !== e && this.set(e, t, n, r, o, i, a, s, l, c, u, d, p, h, f, g)
    }
    set(e, t, n, r, o, i, a, s, l, c, u, d, p, h, f, g)
    {
        const m = this.elements;
        return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = o, m[5] = i, m[9] = a, m[13] = s, m[2] = l, m[6] = c, m[10] = u, m[14] = d, m[3] = p, m[7] = h, m[11] = f, m[15] = g, this
    }
    identity()
    {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone()
    {
        return (new gc).fromArray(this.elements)
    }
    copy(e)
    {
        const t = this.elements,
            n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
    }
    copyPosition(e)
    {
        const t = this.elements,
            n = e.elements;
        return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
    }
    setFromMatrix3(e)
    {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, t, n)
    {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, t, n)
    {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e)
    {
        const t = this.elements,
            n = e.elements,
            r = 1 / mc.setFromMatrixColumn(e, 0).length(),
            o = 1 / mc.setFromMatrixColumn(e, 1).length(),
            i = 1 / mc.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * o, t[5] = n[5] * o, t[6] = n[6] * o, t[7] = 0, t[8] = n[8] * i, t[9] = n[9] * i, t[10] = n[10] * i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromEuler(e)
    {
        const t = this.elements,
            n = e.x,
            r = e.y,
            o = e.z,
            i = Math.cos(n),
            a = Math.sin(n),
            s = Math.cos(r),
            l = Math.sin(r),
            c = Math.cos(o),
            u = Math.sin(o);
        if ("XYZ" === e.order) {
            const e = i * c,
                n = i * u,
                r = a * c,
                o = a * u;
            t[0] = s * c,
            t[4] = -s * u,
            t[8] = l,
            t[1] = n + r * l,
            t[5] = e - o * l,
            t[9] = -a * s,
            t[2] = o - e * l,
            t[6] = r + n * l,
            t[10] = i * s
        } else if ("YXZ" === e.order) {
            const e = s * c,
                n = s * u,
                r = l * c,
                o = l * u;
            t[0] = e + o * a,
            t[4] = r * a - n,
            t[8] = i * l,
            t[1] = i * u,
            t[5] = i * c,
            t[9] = -a,
            t[2] = n * a - r,
            t[6] = o + e * a,
            t[10] = i * s
        } else if ("ZXY" === e.order) {
            const e = s * c,
                n = s * u,
                r = l * c,
                o = l * u;
            t[0] = e - o * a,
            t[4] = -i * u,
            t[8] = r + n * a,
            t[1] = n + r * a,
            t[5] = i * c,
            t[9] = o - e * a,
            t[2] = -i * l,
            t[6] = a,
            t[10] = i * s
        } else if ("ZYX" === e.order) {
            const e = i * c,
                n = i * u,
                r = a * c,
                o = a * u;
            t[0] = s * c,
            t[4] = r * l - n,
            t[8] = e * l + o,
            t[1] = s * u,
            t[5] = o * l + e,
            t[9] = n * l - r,
            t[2] = -l,
            t[6] = a * s,
            t[10] = i * s
        } else if ("YZX" === e.order) {
            const e = i * s,
                n = i * l,
                r = a * s,
                o = a * l;
            t[0] = s * c,
            t[4] = o - e * u,
            t[8] = r * u + n,
            t[1] = u,
            t[5] = i * c,
            t[9] = -a * c,
            t[2] = -l * c,
            t[6] = n * u + r,
            t[10] = e - o * u
        } else if ("XZY" === e.order) {
            const e = i * s,
                n = i * l,
                r = a * s,
                o = a * l;
            t[0] = s * c,
            t[4] = -u,
            t[8] = l * c,
            t[1] = e * u + o,
            t[5] = i * c,
            t[9] = n * u - r,
            t[2] = r * u - n,
            t[6] = a * c,
            t[10] = o * u + e
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromQuaternion(e)
    {
        return this.compose(Ac, e, yc)
    }
    lookAt(e, t, n)
    {
        const r = this.elements;
        return xc.subVectors(e, t), 0 === xc.lengthSq() && (xc.z = 1), xc.normalize(), vc.crossVectors(n, xc), 0 === vc.lengthSq() && (1 === Math.abs(n.z) ? xc.x += 1e-4 : xc.z += 1e-4, xc.normalize(), vc.crossVectors(n, xc)), vc.normalize(), _c.crossVectors(xc, vc), r[0] = vc.x, r[4] = _c.x, r[8] = xc.x, r[1] = vc.y, r[5] = _c.y, r[9] = xc.y, r[2] = vc.z, r[6] = _c.z, r[10] = xc.z, this
    }
    multiply(e)
    {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e)
    {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t)
    {
        const n = e.elements,
            r = t.elements,
            o = this.elements,
            i = n[0],
            a = n[4],
            s = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            d = n[9],
            p = n[13],
            h = n[2],
            f = n[6],
            g = n[10],
            m = n[14],
            b = n[3],
            A = n[7],
            y = n[11],
            v = n[15],
            _ = r[0],
            x = r[4],
            w = r[8],
            C = r[12],
            E = r[1],
            S = r[5],
            I = r[9],
            T = r[13],
            M = r[2],
            R = r[6],
            B = r[10],
            k = r[14],
            D = r[3],
            P = r[7],
            O = r[11],
            L = r[15];
        return o[0] = i * _ + a * E + s * M + l * D, o[4] = i * x + a * S + s * R + l * P, o[8] = i * w + a * I + s * B + l * O, o[12] = i * C + a * T + s * k + l * L, o[1] = c * _ + u * E + d * M + p * D, o[5] = c * x + u * S + d * R + p * P, o[9] = c * w + u * I + d * B + p * O, o[13] = c * C + u * T + d * k + p * L, o[2] = h * _ + f * E + g * M + m * D, o[6] = h * x + f * S + g * R + m * P, o[10] = h * w + f * I + g * B + m * O, o[14] = h * C + f * T + g * k + m * L, o[3] = b * _ + A * E + y * M + v * D, o[7] = b * x + A * S + y * R + v * P, o[11] = b * w + A * I + y * B + v * O, o[15] = b * C + A * T + y * k + v * L, this
    }
    multiplyScalar(e)
    {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
    }
    determinant()
    {
        const e = this.elements,
            t = e[0],
            n = e[4],
            r = e[8],
            o = e[12],
            i = e[1],
            a = e[5],
            s = e[9],
            l = e[13],
            c = e[2],
            u = e[6],
            d = e[10],
            p = e[14];
        return e[3] * (+o * s * u - r * l * u - o * a * d + n * l * d + r * a * p - n * s * p) + e[7] * (+t * s * p - t * l * d + o * i * d - r * i * p + r * l * c - o * s * c) + e[11] * (+t * l * u - t * a * p - o * i * u + n * i * p + o * a * c - n * l * c) + e[15] * (-r * a * c - t * s * u + t * a * d + r * i * u - n * i * d + n * s * c)
    }
    transpose()
    {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }
    setPosition(e, t, n)
    {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
    }
    invert()
    {
        const e = this.elements,
            t = e[0],
            n = e[1],
            r = e[2],
            o = e[3],
            i = e[4],
            a = e[5],
            s = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            d = e[10],
            p = e[11],
            h = e[12],
            f = e[13],
            g = e[14],
            m = e[15],
            b = u * g * l - f * d * l + f * s * p - a * g * p - u * s * m + a * d * m,
            A = h * d * l - c * g * l - h * s * p + i * g * p + c * s * m - i * d * m,
            y = c * f * l - h * u * l + h * a * p - i * f * p - c * a * m + i * u * m,
            v = h * u * s - c * f * s - h * a * d + i * f * d + c * a * g - i * u * g,
            _ = t * b + n * A + r * y + o * v;
        if (0 === _)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const x = 1 / _;
        return e[0] = b * x, e[1] = (f * d * o - u * g * o - f * r * p + n * g * p + u * r * m - n * d * m) * x, e[2] = (a * g * o - f * s * o + f * r * l - n * g * l - a * r * m + n * s * m) * x, e[3] = (u * s * o - a * d * o - u * r * l + n * d * l + a * r * p - n * s * p) * x, e[4] = A * x, e[5] = (c * g * o - h * d * o + h * r * p - t * g * p - c * r * m + t * d * m) * x, e[6] = (h * s * o - i * g * o - h * r * l + t * g * l + i * r * m - t * s * m) * x, e[7] = (i * d * o - c * s * o + c * r * l - t * d * l - i * r * p + t * s * p) * x, e[8] = y * x, e[9] = (h * u * o - c * f * o - h * n * p + t * f * p + c * n * m - t * u * m) * x, e[10] = (i * f * o - h * a * o + h * n * l - t * f * l - i * n * m + t * a * m) * x, e[11] = (c * a * o - i * u * o - c * n * l + t * u * l + i * n * p - t * a * p) * x, e[12] = v * x, e[13] = (c * f * r - h * u * r + h * n * d - t * f * d - c * n * g + t * u * g) * x, e[14] = (h * a * r - i * f * r - h * n * s + t * f * s + i * n * g - t * a * g) * x, e[15] = (i * u * r - c * a * r + c * n * s - t * u * s - i * n * d + t * a * d) * x, this
    }
    scale(e)
    {
        const t = this.elements,
            n = e.x,
            r = e.y,
            o = e.z;
        return t[0] *= n, t[4] *= r, t[8] *= o, t[1] *= n, t[5] *= r, t[9] *= o, t[2] *= n, t[6] *= r, t[10] *= o, t[3] *= n, t[7] *= r, t[11] *= o, this
    }
    getMaxScaleOnAxis()
    {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, r))
    }
    makeTranslation(e, t, n)
    {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
    }
    makeRotationX(e)
    {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e)
    {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e)
    {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, t)
    {
        const n = Math.cos(t),
            r = Math.sin(t),
            o = 1 - n,
            i = e.x,
            a = e.y,
            s = e.z,
            l = o * i,
            c = o * a;
        return this.set(l * i + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + n, c * s - r * i, 0, l * s - r * a, c * s + r * i, o * s * s + n, 0, 0, 0, 0, 1), this
    }
    makeScale(e, t, n)
    {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }
    makeShear(e, t, n, r, o, i)
    {
        return this.set(1, n, o, 0, e, 1, i, 0, t, r, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, t, n)
    {
        const r = this.elements,
            o = t._x,
            i = t._y,
            a = t._z,
            s = t._w,
            l = o + o,
            c = i + i,
            u = a + a,
            d = o * l,
            p = o * c,
            h = o * u,
            f = i * c,
            g = i * u,
            m = a * u,
            b = s * l,
            A = s * c,
            y = s * u,
            v = n.x,
            _ = n.y,
            x = n.z;
        return r[0] = (1 - (f + m)) * v, r[1] = (p + y) * v, r[2] = (h - A) * v, r[3] = 0, r[4] = (p - y) * _, r[5] = (1 - (d + m)) * _, r[6] = (g + b) * _, r[7] = 0, r[8] = (h + A) * x, r[9] = (g - b) * x, r[10] = (1 - (d + f)) * x, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
    }
    decompose(e, t, n)
    {
        const r = this.elements;
        let o = mc.set(r[0], r[1], r[2]).length();
        const i = mc.set(r[4], r[5], r[6]).length(),
            a = mc.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (o = -o),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        bc.copy(this);
        const s = 1 / o,
            l = 1 / i,
            c = 1 / a;
        return bc.elements[0] *= s, bc.elements[1] *= s, bc.elements[2] *= s, bc.elements[4] *= l, bc.elements[5] *= l, bc.elements[6] *= l, bc.elements[8] *= c, bc.elements[9] *= c, bc.elements[10] *= c, t.setFromRotationMatrix(bc), n.x = o, n.y = i, n.z = a, this
    }
    makePerspective(e, t, n, r, o, i, a=2e3, s=!1)
    {
        const l = this.elements,
            c = 2 * o / (t - e),
            u = 2 * o / (n - r),
            d = (t + e) / (t - e),
            p = (n + r) / (n - r);
        let h,
            f;
        if (s)
            h = o / (i - o),
            f = i * o / (i - o);
        else if (a === Ys)
            h = -(i + o) / (i - o),
            f = -2 * i * o / (i - o);
        else {
            if (a !== Js)
                throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
            h = -i / (i - o),
            f = -i * o / (i - o)
        }
        return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = h, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(e, t, n, r, o, i, a=2e3, s=!1)
    {
        const l = this.elements,
            c = 2 / (t - e),
            u = 2 / (n - r),
            d = -(t + e) / (t - e),
            p = -(n + r) / (n - r);
        let h,
            f;
        if (s)
            h = 1 / (i - o),
            f = i / (i - o);
        else if (a === Ys)
            h = -2 / (i - o),
            f = -(i + o) / (i - o);
        else {
            if (a !== Js)
                throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
            h = -1 / (i - o),
            f = -o / (i - o)
        }
        return l[0] = c, l[4] = 0, l[8] = 0, l[12] = d, l[1] = 0, l[5] = u, l[9] = 0, l[13] = p, l[2] = 0, l[6] = 0, l[10] = h, l[14] = f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(e)
    {
        const t = this.elements,
            n = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== n[r])
                return !1;
        return !0
    }
    fromArray(e, t=0)
    {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0)
    {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
    }
}
const mc = new hl,
    bc = new gc,
    Ac = new hl(0, 0, 0),
    yc = new hl(1, 1, 1),
    vc = new hl,
    _c = new hl,
    xc = new hl,
    wc = new gc,
    Cc = new pl;
class Ec {
    constructor(e=0, t=0, n=0, r=Ec.DEFAULT_ORDER)
    {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = r
    }
    get x()
    {
        return this._x
    }
    set x(e)
    {
        this._x = e,
        this._onChangeCallback()
    }
    get y()
    {
        return this._y
    }
    set y(e)
    {
        this._y = e,
        this._onChangeCallback()
    }
    get z()
    {
        return this._z
    }
    set z(e)
    {
        this._z = e,
        this._onChangeCallback()
    }
    get order()
    {
        return this._order
    }
    set order(e)
    {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, r=this._order)
    {
        return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
    }
    clone()
    {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e)
    {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, t=this._order, n=!0)
    {
        const r = e.elements,
            o = r[0],
            i = r[4],
            a = r[8],
            s = r[1],
            l = r[5],
            c = r[9],
            u = r[2],
            d = r[6],
            p = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(il(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-i, o)) : (this._x = Math.atan2(d, l), this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-il(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, o), this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(il(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-i, l)) : (this._y = 0, this._z = Math.atan2(s, o));
            break;
        case "ZYX":
            this._y = Math.asin(-il(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(s, o)) : (this._x = 0, this._z = Math.atan2(-i, l));
            break;
        case "YZX":
            this._z = Math.asin(il(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(a, p));
            break;
        case "XZY":
            this._z = Math.asin(-il(i, -1, 1)),
            Math.abs(i) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-c, p), this._y = 0)
        }
        return this._order = t, !0 === n && this._onChangeCallback(), this
    }
    setFromQuaternion(e, t, n)
    {
        return wc.makeRotationFromQuaternion(e), this.setFromRotationMatrix(wc, t, n)
    }
    setFromVector3(e, t=this._order)
    {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e)
    {
        return Cc.setFromEuler(this), this.setFromQuaternion(Cc, e)
    }
    equals(e)
    {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e)
    {
        return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
    }
    _onChange(e)
    {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]()
    {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Ec.DEFAULT_ORDER = "XYZ";
class Sc {
    constructor()
    {
        this.mask = 1
    }
    set(e)
    {
        this.mask = 1 << e >>> 0
    }
    enable(e)
    {
        this.mask |= 1 << e
    }
    enableAll()
    {
        this.mask = -1
    }
    toggle(e)
    {
        this.mask ^= 1 << e
    }
    disable(e)
    {
        this.mask &= ~(1 << e)
    }
    disableAll()
    {
        this.mask = 0
    }
    test(e)
    {
        return 0 !== (this.mask & e.mask)
    }
    isEnabled(e)
    {
        return !!(this.mask & 1 << e)
    }
}
let Ic = 0;
const Tc = new hl,
    Mc = new pl,
    Rc = new gc,
    Bc = new hl,
    kc = new hl,
    Dc = new hl,
    Pc = new pl,
    Oc = new hl(1, 0, 0),
    Lc = new hl(0, 1, 0),
    Nc = new hl(0, 0, 1),
    Fc = {
        type: "added"
    },
    Uc = {
        type: "removed"
    },
    zc = {
        type: "childadded",
        child: null
    },
    Qc = {
        type: "childremoved",
        child: null
    };
class Gc extends Zs {
    constructor()
    {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: Ic++
        }),
        this.uuid = ol(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Gc.DEFAULT_UP.clone();
        const e = new hl,
            t = new Ec,
            n = new pl,
            r = new hl(1, 1, 1);
        t._onChange(function() {
            n.setFromEuler(t, !1)
        }),
        n._onChange(function() {
            t.setFromQuaternion(n, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new gc
            },
            normalMatrix: {
                value: new ml
            }
        }),
        this.matrix = new gc,
        this.matrixWorld = new gc,
        this.matrixAutoUpdate = Gc.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Gc.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Sc,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e)
    {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e)
    {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, t)
    {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e)
    {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e)
    {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e)
    {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t)
    {
        return Mc.setFromAxisAngle(e, t), this.quaternion.multiply(Mc), this
    }
    rotateOnWorldAxis(e, t)
    {
        return Mc.setFromAxisAngle(e, t), this.quaternion.premultiply(Mc), this
    }
    rotateX(e)
    {
        return this.rotateOnAxis(Oc, e)
    }
    rotateY(e)
    {
        return this.rotateOnAxis(Lc, e)
    }
    rotateZ(e)
    {
        return this.rotateOnAxis(Nc, e)
    }
    translateOnAxis(e, t)
    {
        return Tc.copy(e).applyQuaternion(this.quaternion), this.position.add(Tc.multiplyScalar(t)), this
    }
    translateX(e)
    {
        return this.translateOnAxis(Oc, e)
    }
    translateY(e)
    {
        return this.translateOnAxis(Lc, e)
    }
    translateZ(e)
    {
        return this.translateOnAxis(Nc, e)
    }
    localToWorld(e)
    {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e)
    {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Rc.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n)
    {
        e.isVector3 ? Bc.copy(e) : Bc.set(e, t, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        kc.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Rc.lookAt(kc, Bc, this.up) : Rc.lookAt(Bc, kc, this.up),
        this.quaternion.setFromRotationMatrix(Rc),
        r && (Rc.extractRotation(r.matrixWorld), Mc.setFromRotationMatrix(Rc), this.quaternion.premultiply(Mc.invert()))
    }
    add(e)
    {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
                this.add(arguments[e]);
            return this
        }
        return e === this || e && e.isObject3D && (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Fc), zc.child = e, this.dispatchEvent(zc), zc.child = null), this
    }
    remove(e)
    {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
                this.remove(arguments[e]);
            return this
        }
        const t = this.children.indexOf(e);
        return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Uc), Qc.child = e, this.dispatchEvent(Qc), Qc.child = null), this
    }
    removeFromParent()
    {
        const e = this.parent;
        return null !== e && e.remove(this), this
    }
    clear()
    {
        return this.remove(...this.children)
    }
    attach(e)
    {
        return this.updateWorldMatrix(!0, !1), Rc.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Rc.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rc), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Fc), zc.child = e, this.dispatchEvent(zc), zc.child = null, this
    }
    getObjectById(e)
    {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e)
    {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t)
    {
        if (this[e] === t)
            return this;
        for (let n = 0, r = this.children.length; n < r; n++) {
            const r = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== r)
                return r
        }
    }
    getObjectsByProperty(e, t, n=[])
    {
        this[e] === t && n.push(this);
        const r = this.children;
        for (let o = 0, i = r.length; o < i; o++)
            r[o].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e)
    {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e)
    {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kc, e, Dc), e
    }
    getWorldScale(e)
    {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(kc, Pc, e), e
    }
    getWorldDirection(e)
    {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e)
    {
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].traverse(e)
    }
    traverseVisible(e)
    {
        if (!1 === this.visible)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e)
    {
        const t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e))
    }
    updateMatrix()
    {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e)
    {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;
        for (let n = 0, r = t.length; n < r; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t)
    {
        const n = this.parent;
        if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === t) {
            const e = this.children;
            for (let t = 0, n = e.length; t < n; t++)
                e[t].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e)
    {
        const t = void 0 === e || "string" == typeof e,
            n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        function o(t, n) {
            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
        }
        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.geometryInfo = this._geometryInfo.map(e => ({
            ...e,
            boundingBox: e.boundingBox ? e.boundingBox.toJSON() : void 0,
            boundingSphere: e.boundingSphere ? e.boundingSphere.toJSON() : void 0
        })), r.instanceInfo = this._instanceInfo.map(e => ({
            ...e
        })), r.availableInstanceIds = this._availableInstanceIds.slice(), r.availableGeometryIds = this._availableGeometryIds.slice(), r.nextIndexStart = this._nextIndexStart, r.nextVertexStart = this._nextVertexStart, r.geometryCount = this._geometryCount, r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.matricesTexture = this._matricesTexture.toJSON(e), r.indirectTexture = this._indirectTexture.toJSON(e), null !== this._colorsTexture && (r.colorsTexture = this._colorsTexture.toJSON(e)), null !== this.boundingSphere && (r.boundingSphere = this.boundingSphere.toJSON()), null !== this.boundingBox && (r.boundingBox = this.boundingBox.toJSON())), this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = o(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
                const n = t.shapes;
                if (Array.isArray(n))
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        o(e.shapes, r)
                    }
                else
                    o(e.shapes, n)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (o(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
            if (Array.isArray(this.material)) {
                const t = [];
                for (let n = 0, r = this.material.length; n < r; n++)
                    t.push(o(e.materials, this.material[n]));
                r.material = t
            } else
                r.material = o(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let t = 0; t < this.children.length; t++)
                r.children.push(this.children[t].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
                const n = this.animations[t];
                r.animations.push(o(e.animations, n))
            }
        }
        if (t) {
            const t = i(e.geometries),
                r = i(e.materials),
                o = i(e.textures),
                a = i(e.images),
                s = i(e.shapes),
                l = i(e.skeletons),
                c = i(e.animations),
                u = i(e.nodes);
            t.length > 0 && (n.geometries = t),
            r.length > 0 && (n.materials = r),
            o.length > 0 && (n.textures = o),
            a.length > 0 && (n.images = a),
            s.length > 0 && (n.shapes = s),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c),
            u.length > 0 && (n.nodes = u)
        }
        return n.object = r, n;
        function i(e) {
            const t = [];
            for (const n in e) {
                const r = e[n];
                delete r.metadata,
                t.push(r)
            }
            return t
        }
    }
    clone(e)
    {
        return (new this.constructor).copy(this, e)
    }
    copy(e, t=!0)
    {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
            for (let n = 0; n < e.children.length; n++) {
                const t = e.children[n];
                this.add(t.clone())
            }
        return this
    }
}
Gc.DEFAULT_UP = new hl(0, 1, 0),
Gc.DEFAULT_MATRIX_AUTO_UPDATE = !0,
Gc.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const jc = new hl,
    Vc = new hl,
    Hc = new hl,
    $c = new hl,
    Wc = new hl,
    Kc = new hl,
    qc = new hl,
    Xc = new hl,
    Yc = new hl,
    Jc = new hl,
    Zc = new Nl,
    eu = new Nl,
    tu = new Nl;
class nu {
    constructor(e=new hl, t=new hl, n=new hl)
    {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, r)
    {
        r.subVectors(n, t),
        jc.subVectors(e, t),
        r.cross(jc);
        const o = r.lengthSq();
        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, r, o)
    {
        jc.subVectors(r, t),
        Vc.subVectors(n, t),
        Hc.subVectors(e, t);
        const i = jc.dot(jc),
            a = jc.dot(Vc),
            s = jc.dot(Hc),
            l = Vc.dot(Vc),
            c = Vc.dot(Hc),
            u = i * l - a * a;
        if (0 === u)
            return o.set(0, 0, 0), null;
        const d = 1 / u,
            p = (l * s - a * c) * d,
            h = (i * c - a * s) * d;
        return o.set(1 - p - h, h, p)
    }
    static containsPoint(e, t, n, r)
    {
        return null !== this.getBarycoord(e, t, n, r, $c) && $c.x >= 0 && $c.y >= 0 && $c.x + $c.y <= 1
    }
    static getInterpolation(e, t, n, r, o, i, a, s)
    {
        return null === this.getBarycoord(e, t, n, r, $c) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(o, $c.x), s.addScaledVector(i, $c.y), s.addScaledVector(a, $c.z), s)
    }
    static getInterpolatedAttribute(e, t, n, r, o, i)
    {
        return Zc.setScalar(0), eu.setScalar(0), tu.setScalar(0), Zc.fromBufferAttribute(e, t), eu.fromBufferAttribute(e, n), tu.fromBufferAttribute(e, r), i.setScalar(0), i.addScaledVector(Zc, o.x), i.addScaledVector(eu, o.y), i.addScaledVector(tu, o.z), i
    }
    static isFrontFacing(e, t, n, r)
    {
        return jc.subVectors(n, t), Vc.subVectors(e, t), jc.cross(Vc).dot(r) < 0
    }
    set(e, t, n)
    {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
    }
    setFromPointsAndIndices(e, t, n, r)
    {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
    }
    setFromAttributeAndIndices(e, t, n, r)
    {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    copy(e)
    {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea()
    {
        return jc.subVectors(this.c, this.b), Vc.subVectors(this.a, this.b), .5 * jc.cross(Vc).length()
    }
    getMidpoint(e)
    {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e)
    {
        return nu.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e)
    {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t)
    {
        return nu.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, r, o)
    {
        return nu.getInterpolation(e, this.a, this.b, this.c, t, n, r, o)
    }
    containsPoint(e)
    {
        return nu.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e)
    {
        return nu.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e)
    {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t)
    {
        const n = this.a,
            r = this.b,
            o = this.c;
        let i,
            a;
        Wc.subVectors(r, n),
        Kc.subVectors(o, n),
        Xc.subVectors(e, n);
        const s = Wc.dot(Xc),
            l = Kc.dot(Xc);
        if (s <= 0 && l <= 0)
            return t.copy(n);
        Yc.subVectors(e, r);
        const c = Wc.dot(Yc),
            u = Kc.dot(Yc);
        if (c >= 0 && u <= c)
            return t.copy(r);
        const d = s * u - c * l;
        if (d <= 0 && s >= 0 && c <= 0)
            return i = s / (s - c), t.copy(n).addScaledVector(Wc, i);
        Jc.subVectors(e, o);
        const p = Wc.dot(Jc),
            h = Kc.dot(Jc);
        if (h >= 0 && p <= h)
            return t.copy(o);
        const f = p * l - s * h;
        if (f <= 0 && l >= 0 && h <= 0)
            return a = l / (l - h), t.copy(n).addScaledVector(Kc, a);
        const g = c * h - p * u;
        if (g <= 0 && u - c >= 0 && p - h >= 0)
            return qc.subVectors(o, r), a = (u - c) / (u - c + (p - h)), t.copy(r).addScaledVector(qc, a);
        const m = 1 / (g + f + d);
        return i = f * m, a = d * m, t.copy(n).addScaledVector(Wc, i).addScaledVector(Kc, a)
    }
    equals(e)
    {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const ru = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    ou = {
        h: 0,
        s: 0,
        l: 0
    },
    iu = {
        h: 0,
        s: 0,
        l: 0
    };
function au(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
}
class su {
    constructor(e, t, n)
    {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
    }
    set(e, t, n)
    {
        if (void 0 === t && void 0 === n) {
            const t = e;
            t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e)
    {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, t=Ls)
    {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, Sl.colorSpaceToWorking(this, t), this
    }
    setRGB(e, t, n, r=Sl.workingColorSpace)
    {
        return this.r = e, this.g = t, this.b = n, Sl.colorSpaceToWorking(this, r), this
    }
    setHSL(e, t, n, r=Sl.workingColorSpace)
    {
        if (e = al(e, 1), t = il(t, 0, 1), n = il(n, 0, 1), 0 === t)
            this.r = this.g = this.b = n;
        else {
            const r = n <= .5 ? n * (1 + t) : n + t - n * t,
                o = 2 * n - r;
            this.r = au(o, r, e + 1 / 3),
            this.g = au(o, r, e),
            this.b = au(o, r, e - 1 / 3)
        }
        return Sl.colorSpaceToWorking(this, r), this
    }
    setStyle(e, t=Ls)
    {
        function n(e) {
            void 0 !== e && parseFloat(e)
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let e;
            const o = r[1],
                i = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                    return n(e[4]), this.setRGB(Math.min(255, parseInt(e[1], 10)) / 255, Math.min(255, parseInt(e[2], 10)) / 255, Math.min(255, parseInt(e[3], 10)) / 255, t);
                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                    return n(e[4]), this.setRGB(Math.min(100, parseInt(e[1], 10)) / 100, Math.min(100, parseInt(e[2], 10)) / 100, Math.min(100, parseInt(e[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                    return n(e[4]), this.setHSL(parseFloat(e[1]) / 360, parseFloat(e[2]) / 100, parseFloat(e[3]) / 100, t)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const e = r[1],
                n = e.length;
            if (3 === n)
                return this.setRGB(parseInt(e.charAt(0), 16) / 15, parseInt(e.charAt(1), 16) / 15, parseInt(e.charAt(2), 16) / 15, t);
            if (6 === n)
                return this.setHex(parseInt(e, 16), t)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Ls)
    {
        const n = ru[e.toLowerCase()];
        return void 0 !== n && this.setHex(n, t), this
    }
    clone()
    {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e)
    {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e)
    {
        return this.r = Il(e.r), this.g = Il(e.g), this.b = Il(e.b), this
    }
    copyLinearToSRGB(e)
    {
        return this.r = Tl(e.r), this.g = Tl(e.g), this.b = Tl(e.b), this
    }
    convertSRGBToLinear()
    {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB()
    {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e=Ls)
    {
        return Sl.workingToColorSpace(lu.copy(this), e), 65536 * Math.round(il(255 * lu.r, 0, 255)) + 256 * Math.round(il(255 * lu.g, 0, 255)) + Math.round(il(255 * lu.b, 0, 255))
    }
    getHexString(e=Ls)
    {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=Sl.workingColorSpace)
    {
        Sl.workingToColorSpace(lu.copy(this), t);
        const n = lu.r,
            r = lu.g,
            o = lu.b,
            i = Math.max(n, r, o),
            a = Math.min(n, r, o);
        let s,
            l;
        const c = (a + i) / 2;
        if (a === i)
            s = 0,
            l = 0;
        else {
            const e = i - a;
            switch (l = c <= .5 ? e / (i + a) : e / (2 - i - a), i) {
            case n:
                s = (r - o) / e + (r < o ? 6 : 0);
                break;
            case r:
                s = (o - n) / e + 2;
                break;
            case o:
                s = (n - r) / e + 4
            }
            s /= 6
        }
        return e.h = s, e.s = l, e.l = c, e
    }
    getRGB(e, t=Sl.workingColorSpace)
    {
        return Sl.workingToColorSpace(lu.copy(this), t), e.r = lu.r, e.g = lu.g, e.b = lu.b, e
    }
    getStyle(e=Ls)
    {
        Sl.workingToColorSpace(lu.copy(this), e);
        const t = lu.r,
            n = lu.g,
            r = lu.b;
        return e !== Ls ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * r)})`
    }
    offsetHSL(e, t, n)
    {
        return this.getHSL(ou), this.setHSL(ou.h + e, ou.s + t, ou.l + n)
    }
    add(e)
    {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, t)
    {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
    }
    addScalar(e)
    {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e)
    {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e)
    {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e)
    {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, t)
    {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
    }
    lerpColors(e, t, n)
    {
        return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
    }
    lerpHSL(e, t)
    {
        this.getHSL(ou),
        e.getHSL(iu);
        const n = sl(ou.h, iu.h, t),
            r = sl(ou.s, iu.s, t),
            o = sl(ou.l, iu.l, t);
        return this.setHSL(n, r, o), this
    }
    setFromVector3(e)
    {
        return this.r = e.x, this.g = e.y, this.b = e.z, this
    }
    applyMatrix3(e)
    {
        const t = this.r,
            n = this.g,
            r = this.b,
            o = e.elements;
        return this.r = o[0] * t + o[3] * n + o[6] * r, this.g = o[1] * t + o[4] * n + o[7] * r, this.b = o[2] * t + o[5] * n + o[8] * r, this
    }
    equals(e)
    {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0)
    {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
    }
    toArray(e=[], t=0)
    {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
    }
    fromBufferAttribute(e, t)
    {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
    }
    toJSON()
    {
        return this.getHex()
    }
    *[Symbol.iterator]()
    {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const lu = new su;
su.NAMES = ru;
let cu = 0,
    uu = class  extends Zs{
        constructor()
        {
            super(),
            this.isMaterial = !0,
            Object.defineProperty(this, "id", {
                value: cu++
            }),
            this.uuid = ol(),
            this.name = "",
            this.type = "Material",
            this.blending = 1,
            this.side = 0,
            this.vertexColors = !1,
            this.opacity = 1,
            this.transparent = !1,
            this.alphaHash = !1,
            this.blendSrc = 204,
            this.blendDst = 205,
            this.blendEquation = Wi,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.blendColor = new su(0, 0, 0),
            this.blendAlpha = 0,
            this.depthFunc = 3,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.stencilWriteMask = 255,
            this.stencilFunc = 519,
            this.stencilRef = 0,
            this.stencilFuncMask = 255,
            this.stencilFail = zs,
            this.stencilZFail = zs,
            this.stencilZPass = zs,
            this.stencilWrite = !1,
            this.clippingPlanes = null,
            this.clipIntersection = !1,
            this.clipShadows = !1,
            this.shadowSide = null,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.dithering = !1,
            this.alphaToCoverage = !1,
            this.premultipliedAlpha = !1,
            this.forceSinglePass = !1,
            this.allowOverride = !0,
            this.visible = !0,
            this.toneMapped = !0,
            this.userData = {},
            this.version = 0,
            this._alphaTest = 0
        }
        get alphaTest()
        {
            return this._alphaTest
        }
        set alphaTest(e)
        {
            this._alphaTest > 0 != e > 0 && this.version++,
            this._alphaTest = e
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey()
        {
            return this.onBeforeCompile.toString()
        }
        setValues(e)
        {
            if (void 0 !== e)
                for (const t in e) {
                    const n = e[t];
                    if (void 0 === n)
                        continue;
                    const r = this[t];
                    void 0 !== r && (r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n)
                }
        }
        toJSON(e)
        {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.7,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function r(e) {
                const t = [];
                for (const n in e) {
                    const r = e[n];
                    delete r.metadata,
                    t.push(r)
                }
                return t
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== Wi && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zs && (n.stencilFail = this.stencilFail), this.stencilZFail !== zs && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== zs && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                const t = r(e.textures),
                    o = r(e.images);
                t.length > 0 && (n.textures = t),
                o.length > 0 && (n.images = o)
            }
            return n
        }
        clone()
        {
            return (new this.constructor).copy(this)
        }
        copy(e)
        {
            this.name = e.name,
            this.blending = e.blending,
            this.side = e.side,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.blendColor.copy(e.blendColor),
            this.blendAlpha = e.blendAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.stencilWriteMask = e.stencilWriteMask,
            this.stencilFunc = e.stencilFunc,
            this.stencilRef = e.stencilRef,
            this.stencilFuncMask = e.stencilFuncMask,
            this.stencilFail = e.stencilFail,
            this.stencilZFail = e.stencilZFail,
            this.stencilZPass = e.stencilZPass,
            this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (null !== t) {
                const e = t.length;
                n = new Array(e);
                for (let r = 0; r !== e; ++r)
                    n[r] = t[r].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
        }
        dispose()
        {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(e)
        {
            !0 === e && this.version++
        }
    }
    ;
class du extends uu {
    constructor(e)
    {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new su(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ec,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const pu = hu();
function hu() {
    const e = new ArrayBuffer(4),
        t = new Float32Array(e),
        n = new Uint32Array(e),
        r = new Uint32Array(512),
        o = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const e = l - 127;
        e < -27 ? (r[l] = 0, r[256 | l] = 32768, o[l] = 24, o[256 | l] = 24) : e < -14 ? (r[l] = 1024 >> -e - 14, r[256 | l] = 1024 >> -e - 14 | 32768, o[l] = -e - 1, o[256 | l] = -e - 1) : e <= 15 ? (r[l] = e + 15 << 10, r[256 | l] = e + 15 << 10 | 32768, o[l] = 13, o[256 | l] = 13) : e < 128 ? (r[l] = 31744, r[256 | l] = 64512, o[l] = 24, o[256 | l] = 24) : (r[l] = 31744, r[256 | l] = 64512, o[l] = 13, o[256 | l] = 13)
    }
    const i = new Uint32Array(2048),
        a = new Uint32Array(64),
        s = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let e = l << 13,
            t = 0;
        for (; !(8388608 & e);)
            e <<= 1,
            t -= 8388608;
        e &= -8388609,
        t += 947912704,
        i[l] = e | t
    }
    for (let l = 1024; l < 2048; ++l)
        i[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        a[l] = l << 23;
    a[31] = 1199570944,
    a[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        a[l] = 2147483648 + (l - 32 << 23);
    a[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        32 !== l && (s[l] = 1024);
    return {
        floatView: t,
        uint32View: n,
        baseTable: r,
        shiftTable: o,
        mantissaTable: i,
        exponentTable: a,
        offsetTable: s
    }
}
class fu {
    static toHalfFloat(e)
    {
        return function(e) {
            Math.abs(e),
            e = il(e, -65504, 65504),
            pu.floatView[0] = e;
            const t = pu.uint32View[0],
                n = t >> 23 & 511;
            return pu.baseTable[n] + ((8388607 & t) >> pu.shiftTable[n])
        }(e)
    }
    static fromHalfFloat(e)
    {
        return function(e) {
            const t = e >> 10;
            return pu.uint32View[0] = pu.mantissaTable[pu.offsetTable[t] + (1023 & e)] + pu.exponentTable[t], pu.floatView[0]
        }(e)
    }
}
const gu = new hl,
    mu = new dl;
let bu = 0;
class Au {
    constructor(e, t, n=!1)
    {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: bu++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = n,
        this.usage = qs,
        this.updateRanges = [],
        this.gpuType = Na,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e)
    {
        !0 === e && this.version++
    }
    setUsage(e)
    {
        return this.usage = e, this
    }
    addUpdateRange(e, t)
    {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges()
    {
        this.updateRanges.length = 0
    }
    copy(e)
    {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
    }
    copyAt(e, t, n)
    {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let r = 0, o = this.itemSize; r < o; r++)
            this.array[e + r] = t.array[n + r];
        return this
    }
    copyArray(e)
    {
        return this.array.set(e), this
    }
    applyMatrix3(e)
    {
        if (2 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
                mu.fromBufferAttribute(this, t),
                mu.applyMatrix3(e),
                this.setXY(t, mu.x, mu.y);
        else if (3 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
                gu.fromBufferAttribute(this, t),
                gu.applyMatrix3(e),
                this.setXYZ(t, gu.x, gu.y, gu.z);
        return this
    }
    applyMatrix4(e)
    {
        for (let t = 0, n = this.count; t < n; t++)
            gu.fromBufferAttribute(this, t),
            gu.applyMatrix4(e),
            this.setXYZ(t, gu.x, gu.y, gu.z);
        return this
    }
    applyNormalMatrix(e)
    {
        for (let t = 0, n = this.count; t < n; t++)
            gu.fromBufferAttribute(this, t),
            gu.applyNormalMatrix(e),
            this.setXYZ(t, gu.x, gu.y, gu.z);
        return this
    }
    transformDirection(e)
    {
        for (let t = 0, n = this.count; t < n; t++)
            gu.fromBufferAttribute(this, t),
            gu.transformDirection(e),
            this.setXYZ(t, gu.x, gu.y, gu.z);
        return this
    }
    set(e, t=0)
    {
        return this.array.set(e, t), this
    }
    getComponent(e, t)
    {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = ll(n, this.array)), n
    }
    setComponent(e, t, n)
    {
        return this.normalized && (n = cl(n, this.array)), this.array[e * this.itemSize + t] = n, this
    }
    getX(e)
    {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = ll(t, this.array)), t
    }
    setX(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.array[e * this.itemSize] = t, this
    }
    getY(e)
    {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = ll(t, this.array)), t
    }
    setY(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.array[e * this.itemSize + 1] = t, this
    }
    getZ(e)
    {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = ll(t, this.array)), t
    }
    setZ(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.array[e * this.itemSize + 2] = t, this
    }
    getW(e)
    {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = ll(t, this.array)), t
    }
    setW(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.array[e * this.itemSize + 3] = t, this
    }
    setXY(e, t, n)
    {
        return e *= this.itemSize, this.normalized && (t = cl(t, this.array), n = cl(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
    }
    setXYZ(e, t, n, r)
    {
        return e *= this.itemSize, this.normalized && (t = cl(t, this.array), n = cl(n, this.array), r = cl(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
    }
    setXYZW(e, t, n, r, o)
    {
        return e *= this.itemSize, this.normalized && (t = cl(t, this.array), n = cl(n, this.array), r = cl(r, this.array), o = cl(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = o, this
    }
    onUpload(e)
    {
        return this.onUploadCallback = e, this
    }
    clone()
    {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON()
    {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return "" !== this.name && (e.name = this.name), this.usage !== qs && (e.usage = this.usage), e
    }
}
class yu extends Au {
    constructor(e, t, n)
    {
        super(new Uint16Array(e), t, n)
    }
}
class vu extends Au {
    constructor(e, t, n)
    {
        super(new Uint32Array(e), t, n)
    }
}
class _u extends Au {
    constructor(e, t, n)
    {
        super(new Float32Array(e), t, n)
    }
}
let xu = 0;
const wu = new gc,
    Cu = new Gc,
    Eu = new hl,
    Su = new Gl,
    Iu = new Gl,
    Tu = new hl;
class Mu extends Zs {
    constructor()
    {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: xu++
        }),
        this.uuid = ol(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex()
    {
        return this.index
    }
    setIndex(e)
    {
        return Array.isArray(e) ? this.index = new (Al(e) ? vu : yu)(e, 1) : this.index = e, this
    }
    setIndirect(e)
    {
        return this.indirect = e, this
    }
    getIndirect()
    {
        return this.indirect
    }
    getAttribute(e)
    {
        return this.attributes[e]
    }
    setAttribute(e, t)
    {
        return this.attributes[e] = t, this
    }
    deleteAttribute(e)
    {
        return delete this.attributes[e], this
    }
    hasAttribute(e)
    {
        return void 0 !== this.attributes[e]
    }
    addGroup(e, t, n=0)
    {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups()
    {
        this.groups = []
    }
    setDrawRange(e, t)
    {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e)
    {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (void 0 !== n) {
            const t = (new ml).getNormalMatrix(e);
            n.applyNormalMatrix(t),
            n.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }
    applyQuaternion(e)
    {
        return wu.makeRotationFromQuaternion(e), this.applyMatrix4(wu), this
    }
    rotateX(e)
    {
        return wu.makeRotationX(e), this.applyMatrix4(wu), this
    }
    rotateY(e)
    {
        return wu.makeRotationY(e), this.applyMatrix4(wu), this
    }
    rotateZ(e)
    {
        return wu.makeRotationZ(e), this.applyMatrix4(wu), this
    }
    translate(e, t, n)
    {
        return wu.makeTranslation(e, t, n), this.applyMatrix4(wu), this
    }
    scale(e, t, n)
    {
        return wu.makeScale(e, t, n), this.applyMatrix4(wu), this
    }
    lookAt(e)
    {
        return Cu.lookAt(e), Cu.updateMatrix(), this.applyMatrix4(Cu.matrix), this
    }
    center()
    {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Eu).negate(), this.translate(Eu.x, Eu.y, Eu.z), this
    }
    setFromPoints(e)
    {
        const t = this.getAttribute("position");
        if (void 0 === t) {
            const t = [];
            for (let n = 0, r = e.length; n < r; n++) {
                const r = e[n];
                t.push(r.x, r.y, r.z || 0)
            }
            this.setAttribute("position", new _u(t, 3))
        } else {
            const n = Math.min(e.length, t.count);
            for (let r = 0; r < n; r++) {
                const n = e[r];
                t.setXYZ(r, n.x, n.y, n.z || 0)
            }
            e.length,
            t.count,
            t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox()
    {
        null === this.boundingBox && (this.boundingBox = new Gl);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
            this.boundingBox.set(new hl(-1 / 0, -1 / 0, -1 / 0), new hl(1 / 0, 1 / 0, 1 / 0));
        else {
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        Su.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (Tu.addVectors(this.boundingBox.min, Su.min), this.boundingBox.expandByPoint(Tu), Tu.addVectors(this.boundingBox.max, Su.max), this.boundingBox.expandByPoint(Tu)) : (this.boundingBox.expandByPoint(Su.min), this.boundingBox.expandByPoint(Su.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
        }
    }
    computeBoundingSphere()
    {
        null === this.boundingSphere && (this.boundingSphere = new ac);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
            this.boundingSphere.set(new hl, 1 / 0);
        else if (e) {
            const n = this.boundingSphere.center;
            if (Su.setFromBufferAttribute(e), t)
                for (let e = 0, o = t.length; e < o; e++) {
                    const n = t[e];
                    Iu.setFromBufferAttribute(n),
                    this.morphTargetsRelative ? (Tu.addVectors(Su.min, Iu.min), Su.expandByPoint(Tu), Tu.addVectors(Su.max, Iu.max), Su.expandByPoint(Tu)) : (Su.expandByPoint(Iu.min), Su.expandByPoint(Iu.max))
                }
            Su.getCenter(n);
            let r = 0;
            for (let t = 0, o = e.count; t < o; t++)
                Tu.fromBufferAttribute(e, t),
                r = Math.max(r, n.distanceToSquared(Tu));
            if (t)
                for (let o = 0, i = t.length; o < i; o++) {
                    const i = t[o],
                        a = this.morphTargetsRelative;
                    for (let t = 0, o = i.count; t < o; t++)
                        Tu.fromBufferAttribute(i, t),
                        a && (Eu.fromBufferAttribute(e, t), Tu.add(Eu)),
                        r = Math.max(r, n.distanceToSquared(Tu))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius)
        }
    }
    computeTangents()
    {
        const e = this.index,
            t = this.attributes;
        if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
            return;
        const n = t.position,
            r = t.normal,
            o = t.uv;
        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Au(new Float32Array(4 * n.count), 4));
        const i = this.getAttribute("tangent"),
            a = [],
            s = [];
        for (let w = 0; w < n.count; w++)
            a[w] = new hl,
            s[w] = new hl;
        const l = new hl,
            c = new hl,
            u = new hl,
            d = new dl,
            p = new dl,
            h = new dl,
            f = new hl,
            g = new hl;
        function m(e, t, r) {
            l.fromBufferAttribute(n, e),
            c.fromBufferAttribute(n, t),
            u.fromBufferAttribute(n, r),
            d.fromBufferAttribute(o, e),
            p.fromBufferAttribute(o, t),
            h.fromBufferAttribute(o, r),
            c.sub(l),
            u.sub(l),
            p.sub(d),
            h.sub(d);
            const i = 1 / (p.x * h.y - h.x * p.y);
            isFinite(i) && (f.copy(c).multiplyScalar(h.y).addScaledVector(u, -p.y).multiplyScalar(i), g.copy(u).multiplyScalar(p.x).addScaledVector(c, -h.x).multiplyScalar(i), a[e].add(f), a[t].add(f), a[r].add(f), s[e].add(g), s[t].add(g), s[r].add(g))
        }
        let b = this.groups;
        0 === b.length && (b = [{
            start: 0,
            count: e.count
        }]);
        for (let w = 0, C = b.length; w < C; ++w) {
            const t = b[w],
                n = t.start;
            for (let r = n, o = n + t.count; r < o; r += 3)
                m(e.getX(r + 0), e.getX(r + 1), e.getX(r + 2))
        }
        const A = new hl,
            y = new hl,
            v = new hl,
            _ = new hl;
        function x(e) {
            v.fromBufferAttribute(r, e),
            _.copy(v);
            const t = a[e];
            A.copy(t),
            A.sub(v.multiplyScalar(v.dot(t))).normalize(),
            y.crossVectors(_, t);
            const n = y.dot(s[e]) < 0 ? -1 : 1;
            i.setXYZW(e, A.x, A.y, A.z, n)
        }
        for (let w = 0, C = b.length; w < C; ++w) {
            const t = b[w],
                n = t.start;
            for (let r = n, o = n + t.count; r < o; r += 3)
                x(e.getX(r + 0)),
                x(e.getX(r + 1)),
                x(e.getX(r + 2))
        }
    }
    computeVertexNormals()
    {
        const e = this.index,
            t = this.getAttribute("position");
        if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
                n = new Au(new Float32Array(3 * t.count), 3),
                this.setAttribute("normal", n);
            else
                for (let e = 0, t = n.count; e < t; e++)
                    n.setXYZ(e, 0, 0, 0);
            const r = new hl,
                o = new hl,
                i = new hl,
                a = new hl,
                s = new hl,
                l = new hl,
                c = new hl,
                u = new hl;
            if (e)
                for (let d = 0, p = e.count; d < p; d += 3) {
                    const p = e.getX(d + 0),
                        h = e.getX(d + 1),
                        f = e.getX(d + 2);
                    r.fromBufferAttribute(t, p),
                    o.fromBufferAttribute(t, h),
                    i.fromBufferAttribute(t, f),
                    c.subVectors(i, o),
                    u.subVectors(r, o),
                    c.cross(u),
                    a.fromBufferAttribute(n, p),
                    s.fromBufferAttribute(n, h),
                    l.fromBufferAttribute(n, f),
                    a.add(c),
                    s.add(c),
                    l.add(c),
                    n.setXYZ(p, a.x, a.y, a.z),
                    n.setXYZ(h, s.x, s.y, s.z),
                    n.setXYZ(f, l.x, l.y, l.z)
                }
            else
                for (let e = 0, d = t.count; e < d; e += 3)
                    r.fromBufferAttribute(t, e + 0),
                    o.fromBufferAttribute(t, e + 1),
                    i.fromBufferAttribute(t, e + 2),
                    c.subVectors(i, o),
                    u.subVectors(r, o),
                    c.cross(u),
                    n.setXYZ(e + 0, c.x, c.y, c.z),
                    n.setXYZ(e + 1, c.x, c.y, c.z),
                    n.setXYZ(e + 2, c.x, c.y, c.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals()
    {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            Tu.fromBufferAttribute(e, t),
            Tu.normalize(),
            e.setXYZ(t, Tu.x, Tu.y, Tu.z)
    }
    toNonIndexed()
    {
        function e(e, t) {
            const n = e.array,
                r = e.itemSize,
                o = e.normalized,
                i = new n.constructor(t.length * r);
            let a = 0,
                s = 0;
            for (let l = 0, c = t.length; l < c; l++) {
                a = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                for (let e = 0; e < r; e++)
                    i[s++] = n[a++]
            }
            return new Au(i, r, o)
        }
        if (null === this.index)
            return this;
        const t = new Mu,
            n = this.index.array,
            r = this.attributes;
        for (const a in r) {
            const o = e(r[a], n);
            t.setAttribute(a, o)
        }
        const o = this.morphAttributes;
        for (const a in o) {
            const r = [],
                i = o[a];
            for (let t = 0, o = i.length; t < o; t++) {
                const o = e(i[t], n);
                r.push(o)
            }
            t.morphAttributes[a] = r
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const i = this.groups;
        for (let a = 0, s = i.length; a < s; a++) {
            const e = i[a];
            t.addGroup(e.start, e.count, e.materialIndex)
        }
        return t
    }
    toJSON()
    {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
            const t = this.parameters;
            for (const n in t)
                void 0 !== t[n] && (e[n] = t[n]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        null !== t && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const s in n) {
            const t = n[s];
            e.data.attributes[s] = t.toJSON(e.data)
        }
        const r = {};
        let o = !1;
        for (const s in this.morphAttributes) {
            const t = this.morphAttributes[s],
                n = [];
            for (let r = 0, o = t.length; r < o; r++) {
                const o = t[r];
                n.push(o.toJSON(e.data))
            }
            n.length > 0 && (r[s] = n, o = !0)
        }
        o && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const i = this.groups;
        i.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(i)));
        const a = this.boundingSphere;
        return null !== a && (e.data.boundingSphere = a.toJSON()), e
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    copy(e)
    {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone());
        const r = e.attributes;
        for (const l in r) {
            const e = r[l];
            this.setAttribute(l, e.clone(t))
        }
        const o = e.morphAttributes;
        for (const l in o) {
            const e = [],
                n = o[l];
            for (let r = 0, o = n.length; r < o; r++)
                e.push(n[r].clone(t));
            this.morphAttributes[l] = e
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const i = e.groups;
        for (let l = 0, c = i.length; l < c; l++) {
            const e = i[l];
            this.addGroup(e.start, e.count, e.materialIndex)
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const s = e.boundingSphere;
        return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
    }
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Ru = new gc,
    Bu = new fc,
    ku = new ac,
    Du = new hl,
    Pu = new hl,
    Ou = new hl,
    Lu = new hl,
    Nu = new hl,
    Fu = new hl,
    Uu = new hl,
    zu = new hl;
let Qu = class  extends Gc{
    constructor(e=new Mu, t=new du)
    {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, t)
    {
        return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
    getVertexPosition(e, t)
    {
        const n = this.geometry,
            r = n.attributes.position,
            o = n.morphAttributes.position,
            i = n.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (o && a) {
            Fu.set(0, 0, 0);
            for (let n = 0, r = o.length; n < r; n++) {
                const r = a[n],
                    s = o[n];
                0 !== r && (Nu.fromBufferAttribute(s, e), i ? Fu.addScaledVector(Nu, r) : Fu.addScaledVector(Nu.sub(t), r))
            }
            t.add(Fu)
        }
        return t
    }
    raycast(e, t)
    {
        const n = this.geometry,
            r = this.material,
            o = this.matrixWorld;
        if (void 0 !== r) {
            if (null === n.boundingSphere && n.computeBoundingSphere(), ku.copy(n.boundingSphere), ku.applyMatrix4(o), Bu.copy(e.ray).recast(e.near), !1 === ku.containsPoint(Bu.origin)) {
                if (null === Bu.intersectSphere(ku, Du))
                    return;
                if (Bu.origin.distanceToSquared(Du) > (e.far - e.near) ** 2)
                    return
            }
            Ru.copy(o).invert(),
            Bu.copy(e.ray).applyMatrix4(Ru),
            null !== n.boundingBox && !1 === Bu.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Bu)
        }
    }
    _computeIntersections(e, t, n)
    {
        let r;
        const o = this.geometry,
            i = this.material,
            a = o.index,
            s = o.attributes.position,
            l = o.attributes.uv,
            c = o.attributes.uv1,
            u = o.attributes.normal,
            d = o.groups,
            p = o.drawRange;
        if (null !== a)
            if (Array.isArray(i))
                for (let h = 0, f = d.length; h < f; h++) {
                    const o = d[h],
                        s = i[o.materialIndex];
                    for (let i = Math.max(o.start, p.start), d = Math.min(a.count, Math.min(o.start + o.count, p.start + p.count)); i < d; i += 3)
                        r = Gu(this, s, e, n, l, c, u, a.getX(i), a.getX(i + 1), a.getX(i + 2)),
                        r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = o.materialIndex, t.push(r))
                }
            else
                for (let h = Math.max(0, p.start), f = Math.min(a.count, p.start + p.count); h < f; h += 3)
                    r = Gu(this, i, e, n, l, c, u, a.getX(h), a.getX(h + 1), a.getX(h + 2)),
                    r && (r.faceIndex = Math.floor(h / 3), t.push(r));
        else if (void 0 !== s)
            if (Array.isArray(i))
                for (let h = 0, f = d.length; h < f; h++) {
                    const o = d[h],
                        a = i[o.materialIndex];
                    for (let i = Math.max(o.start, p.start), d = Math.min(s.count, Math.min(o.start + o.count, p.start + p.count)); i < d; i += 3)
                        r = Gu(this, a, e, n, l, c, u, i, i + 1, i + 2),
                        r && (r.faceIndex = Math.floor(i / 3), r.face.materialIndex = o.materialIndex, t.push(r))
                }
            else
                for (let h = Math.max(0, p.start), f = Math.min(s.count, p.start + p.count); h < f; h += 3)
                    r = Gu(this, i, e, n, l, c, u, h, h + 1, h + 2),
                    r && (r.faceIndex = Math.floor(h / 3), t.push(r))
    }
}
;
function Gu(e, t, n, r, o, i, a, s, l, c) {
    e.getVertexPosition(s, Pu),
    e.getVertexPosition(l, Ou),
    e.getVertexPosition(c, Lu);
    const u = function(e, t, n, r, o, i, a, s) {
        let l;
        if (l = 1 === t.side ? r.intersectTriangle(a, i, o, !0, s) : r.intersectTriangle(o, i, a, 0 === t.side, s), null === l)
            return null;
        zu.copy(s),
        zu.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(zu);
        return c < n.near || c > n.far ? null : {
            distance: c,
            point: zu.clone(),
            object: e
        }
    }(e, t, n, r, Pu, Ou, Lu, Uu);
    if (u) {
        const e = new hl;
        nu.getBarycoord(Uu, Pu, Ou, Lu, e),
        o && (u.uv = nu.getInterpolatedAttribute(o, s, l, c, e, new dl)),
        i && (u.uv1 = nu.getInterpolatedAttribute(i, s, l, c, e, new dl)),
        a && (u.normal = nu.getInterpolatedAttribute(a, s, l, c, e, new hl), u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
        const t = {
            a: s,
            b: l,
            c: c,
            normal: new hl,
            materialIndex: 0
        };
        nu.getNormal(Pu, Ou, Lu, t.normal),
        u.face = t,
        u.barycoord = e
    }
    return u
}
class ju extends Mu {
    constructor(e=1, t=1, n=1, r=1, o=1, i=1)
    {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: r,
            heightSegments: o,
            depthSegments: i
        };
        const a = this;
        r = Math.floor(r),
        o = Math.floor(o),
        i = Math.floor(i);
        const s = [],
            l = [],
            c = [],
            u = [];
        let d = 0,
            p = 0;
        function h(e, t, n, r, o, i, h, f, g, m, b) {
            const A = i / g,
                y = h / m,
                v = i / 2,
                _ = h / 2,
                x = f / 2,
                w = g + 1,
                C = m + 1;
            let E = 0,
                S = 0;
            const I = new hl;
            for (let a = 0; a < C; a++) {
                const i = a * y - _;
                for (let s = 0; s < w; s++) {
                    const d = s * A - v;
                    I[e] = d * r,
                    I[t] = i * o,
                    I[n] = x,
                    l.push(I.x, I.y, I.z),
                    I[e] = 0,
                    I[t] = 0,
                    I[n] = f > 0 ? 1 : -1,
                    c.push(I.x, I.y, I.z),
                    u.push(s / g),
                    u.push(1 - a / m),
                    E += 1
                }
            }
            for (let a = 0; a < m; a++)
                for (let e = 0; e < g; e++) {
                    const t = d + e + w * a,
                        n = d + e + w * (a + 1),
                        r = d + (e + 1) + w * (a + 1),
                        o = d + (e + 1) + w * a;
                    s.push(t, n, o),
                    s.push(n, r, o),
                    S += 6
                }
            a.addGroup(p, S, b),
            p += S,
            d += E
        }
        h("z", "y", "x", -1, -1, n, t, e, i, o, 0),
        h("z", "y", "x", 1, -1, n, t, -e, i, o, 1),
        h("x", "z", "y", 1, 1, e, n, t, r, i, 2),
        h("x", "z", "y", 1, -1, e, n, -t, r, i, 3),
        h("x", "y", "z", 1, -1, e, t, n, r, o, 4),
        h("x", "y", "z", -1, -1, e, t, -n, r, o, 5),
        this.setIndex(s),
        this.setAttribute("position", new _u(l, 3)),
        this.setAttribute("normal", new _u(c, 3)),
        this.setAttribute("uv", new _u(u, 2))
    }
    copy(e)
    {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e)
    {
        return new ju(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}
function Vu(e) {
    const t = {};
    for (const n in e) {
        t[n] = {};
        for (const r in e[n]) {
            const o = e[n][r];
            o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture || o.isQuaternion) ? o.isRenderTargetTexture ? t[n][r] = null : t[n][r] = o.clone() : Array.isArray(o) ? t[n][r] = o.slice() : t[n][r] = o
        }
    }
    return t
}
function Hu(e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = Vu(e[n]);
        for (const e in r)
            t[e] = r[e]
    }
    return t
}
function $u(e) {
    const t = e.getRenderTarget();
    return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : Sl.workingColorSpace
}
const Wu = {
    clone: Vu,
    merge: Hu
};
class Ku extends uu {
    constructor(e)
    {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        void 0 !== e && this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Vu(e.uniforms), this.uniformsGroups = function(e) {
            const t = [];
            for (let n = 0; n < e.length; n++)
                t.push(e[n].clone());
            return t
        }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const n = this.uniforms[r].value;
            n && n.isTexture ? t.uniforms[r] = {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? t.uniforms[r] = {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: n.toArray()
            } : t.uniforms[r] = {
                value: n
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const r in this.extensions)
            !0 === this.extensions[r] && (n[r] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t
    }
}
let qu = class  extends Gc{
    constructor()
    {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new gc,
        this.projectionMatrix = new gc,
        this.projectionMatrixInverse = new gc,
        this.coordinateSystem = Ys,
        this._reversedDepth = !1
    }
    get reversedDepth()
    {
        return this._reversedDepth
    }
    copy(e, t)
    {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
    }
    getWorldDirection(e)
    {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e)
    {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t)
    {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
}
;
const Xu = new hl,
    Yu = new dl,
    Ju = new dl;
class Zu extends qu {
    constructor(e=50, t=1, n=.1, r=2e3)
    {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e)
    {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = 2 * rl * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength()
    {
        const e = Math.tan(.5 * nl * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV()
    {
        return 2 * rl * Math.atan(Math.tan(.5 * nl * this.fov) / this.zoom)
    }
    getFilmWidth()
    {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight()
    {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n)
    {
        Xu.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Xu.x, Xu.y).multiplyScalar(-e / Xu.z),
        Xu.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(Xu.x, Xu.y).multiplyScalar(-e / Xu.z)
    }
    getViewSize(e, t)
    {
        return this.getViewBounds(e, Yu, Ju), t.subVectors(Ju, Yu)
    }
    setViewOffset(e, t, n, r, o, i)
    {
        this.aspect = e / t,
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = r,
        this.view.width = o,
        this.view.height = i,
        this.updateProjectionMatrix()
    }
    clearViewOffset()
    {
        null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix()
    {
        const e = this.near;
        let t = e * Math.tan(.5 * nl * this.fov) / this.zoom,
            n = 2 * t,
            r = this.aspect * n,
            o = -.5 * r;
        const i = this.view;
        if (null !== this.view && this.view.enabled) {
            const e = i.fullWidth,
                a = i.fullHeight;
            o += i.offsetX * r / e,
            t -= i.offsetY * n / a,
            r *= i.width / e,
            n *= i.height / a
        }
        const a = this.filmOffset;
        0 !== a && (o += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(o, o + r, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
    }
}
const ed = -90;
class td extends Gc {
    constructor(e, t, n)
    {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new Zu(ed, 1, e, t);
        r.layers = this.layers,
        this.add(r);
        const o = new Zu(ed, 1, e, t);
        o.layers = this.layers,
        this.add(o);
        const i = new Zu(ed, 1, e, t);
        i.layers = this.layers,
        this.add(i);
        const a = new Zu(ed, 1, e, t);
        a.layers = this.layers,
        this.add(a);
        const s = new Zu(ed, 1, e, t);
        s.layers = this.layers,
        this.add(s);
        const l = new Zu(ed, 1, e, t);
        l.layers = this.layers,
        this.add(l)
    }
    updateCoordinateSystem()
    {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [n, r, o, i, a, s] = t;
        for (const l of t)
            this.remove(l);
        if (e === Ys)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, 1, 0),
            i.up.set(0, 0, 1),
            i.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            s.up.set(0, 1, 0),
            s.lookAt(0, 0, -1);
        else {
            if (e !== Js)
                throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, 1, 0),
            i.up.set(0, 0, -1),
            i.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            s.up.set(0, -1, 0),
            s.lookAt(0, 0, -1)
        }
        for (const l of t)
            this.add(l),
            l.updateMatrixWorld()
    }
    update(e, t)
    {
        null === this.parent && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
        const [o, i, a, s, l, c] = this.children,
            u = e.getRenderTarget(),
            d = e.getActiveCubeFace(),
            p = e.getActiveMipmapLevel(),
            h = e.xr.enabled;
        e.xr.enabled = !1;
        const f = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, r),
        e.render(t, o),
        e.setRenderTarget(n, 1, r),
        e.render(t, i),
        e.setRenderTarget(n, 2, r),
        e.render(t, a),
        e.setRenderTarget(n, 3, r),
        e.render(t, s),
        e.setRenderTarget(n, 4, r),
        e.render(t, l),
        n.texture.generateMipmaps = f,
        e.setRenderTarget(n, 5, r),
        e.render(t, c),
        e.setRenderTarget(u, d, p),
        e.xr.enabled = h,
        n.texture.needsPMREMUpdate = !0
    }
}
class nd extends Ll {
    constructor(e=[], t=301, n, r, o, i, a, s, l, c)
    {
        super(e, t, n, r, o, i, a, s, l, c),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images()
    {
        return this.image
    }
    set images(e)
    {
        this.image = e
    }
}
class rd extends Ul {
    constructor(e=1, t={})
    {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
                width: e,
                height: e,
                depth: 1
            },
            r = [n, n, n, n, n, n];
        this.texture = new nd(r),
        this._setTextureOptions(t),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, t)
    {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
                tEquirect: {
                    value: null
                }
            },
            r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            o = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            i = new ju(5, 5, 5),
            a = new Ku({
                name: "CubemapFromEquirect",
                uniforms: Vu(n),
                vertexShader: r,
                fragmentShader: o,
                side: 1,
                blending: 0
            });
        a.uniforms.tEquirect.value = t;
        const s = new Qu(i, a),
            l = t.minFilter;
        return t.minFilter === ka && (t.minFilter = Ra), new td(1, 10, this).update(e, s), t.minFilter = l, s.geometry.dispose(), s.material.dispose(), this
    }
    clear(e, t=!0, n=!0, r=!0)
    {
        const o = e.getRenderTarget();
        for (let i = 0; i < 6; i++)
            e.setRenderTarget(this, i),
            e.clear(t, n, r);
        e.setRenderTarget(o)
    }
}
class od extends Gc {
    constructor()
    {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const id = {
    type: "move"
};
class ad {
    constructor()
    {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace()
    {
        return null === this._hand && (this._hand = new od, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace()
    {
        return null === this._targetRay && (this._targetRay = new od, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new hl, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new hl), this._targetRay
    }
    getGripSpace()
    {
        return null === this._grip && (this._grip = new od, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new hl, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new hl), this._grip
    }
    dispatchEvent(e)
    {
        return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
    }
    connect(e)
    {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e)
    {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
    }
    update(e, t, n)
    {
        let r = null,
            o = null,
            i = null;
        const a = this._targetRay,
            s = this._grip,
            l = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState) {
            if (l && e.hand) {
                i = !0;
                for (const i of e.hand.values()) {
                    const e = t.getJointPose(i, n),
                        r = this._getHandJoint(l, i);
                    null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius),
                    r.visible = null !== e
                }
                const r = l.joints["index-finger-tip"],
                    o = l.joints["thumb-tip"],
                    a = r.position.distanceTo(o.position),
                    s = .02,
                    c = .005;
                l.inputState.pinching && a > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !l.inputState.pinching && a <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                null !== s && e.gripSpace && (o = t.getPose(e.gripSpace, n), null !== o && (s.matrix.fromArray(o.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(o.linearVelocity)) : s.hasLinearVelocity = !1, o.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(o.angularVelocity)) : s.hasAngularVelocity = !1));
            null !== a && (r = t.getPose(e.targetRaySpace, n), null === r && null !== o && (r = o), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(id)))
        }
        return null !== a && (a.visible = null !== r), null !== s && (s.visible = null !== o), null !== l && (l.visible = null !== i), this
    }
    _getHandJoint(e, t)
    {
        if (void 0 === e.joints[t.jointName]) {
            const n = new od;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
let sd = class  extends Gc{
    constructor()
    {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Ec,
        this.environmentIntensity = 1,
        this.environmentRotation = new Ec,
        this.overrideMaterial = null,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, t)
    {
        return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
    }
}
;
class ld {
    constructor(e, t)
    {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.usage = qs,
        this.updateRanges = [],
        this.version = 0,
        this.uuid = ol()
    }
    onUploadCallback() {}
    set needsUpdate(e)
    {
        !0 === e && this.version++
    }
    setUsage(e)
    {
        return this.usage = e, this
    }
    addUpdateRange(e, t)
    {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges()
    {
        this.updateRanges.length = 0
    }
    copy(e)
    {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, t, n)
    {
        e *= this.stride,
        n *= t.stride;
        for (let r = 0, o = this.stride; r < o; r++)
            this.array[e + r] = t.array[n + r];
        return this
    }
    set(e, t=0)
    {
        return this.array.set(e, t), this
    }
    clone(e)
    {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ol()),
        void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n
    }
    onUpload(e)
    {
        return this.onUploadCallback = e, this
    }
    toJSON(e)
    {
        return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ol()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const cd = new hl;
class ud {
    constructor(e, t, n, r=!1)
    {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = r
    }
    get count()
    {
        return this.data.count
    }
    get array()
    {
        return this.data.array
    }
    set needsUpdate(e)
    {
        this.data.needsUpdate = e
    }
    applyMatrix4(e)
    {
        for (let t = 0, n = this.data.count; t < n; t++)
            cd.fromBufferAttribute(this, t),
            cd.applyMatrix4(e),
            this.setXYZ(t, cd.x, cd.y, cd.z);
        return this
    }
    applyNormalMatrix(e)
    {
        for (let t = 0, n = this.count; t < n; t++)
            cd.fromBufferAttribute(this, t),
            cd.applyNormalMatrix(e),
            this.setXYZ(t, cd.x, cd.y, cd.z);
        return this
    }
    transformDirection(e)
    {
        for (let t = 0, n = this.count; t < n; t++)
            cd.fromBufferAttribute(this, t),
            cd.transformDirection(e),
            this.setXYZ(t, cd.x, cd.y, cd.z);
        return this
    }
    getComponent(e, t)
    {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = ll(n, this.array)), n
    }
    setComponent(e, t, n)
    {
        return this.normalized && (n = cl(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
    }
    setX(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
    }
    setY(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
    }
    setZ(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
    }
    setW(e, t)
    {
        return this.normalized && (t = cl(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
    }
    getX(e)
    {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = ll(t, this.array)), t
    }
    getY(e)
    {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = ll(t, this.array)), t
    }
    getZ(e)
    {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = ll(t, this.array)), t
    }
    getW(e)
    {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = ll(t, this.array)), t
    }
    setXY(e, t, n)
    {
        return e = e * this.data.stride + this.offset, this.normalized && (t = cl(t, this.array), n = cl(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
    }
    setXYZ(e, t, n, r)
    {
        return e = e * this.data.stride + this.offset, this.normalized && (t = cl(t, this.array), n = cl(n, this.array), r = cl(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
    }
    setXYZW(e, t, n, r, o)
    {
        return e = e * this.data.stride + this.offset, this.normalized && (t = cl(t, this.array), n = cl(n, this.array), r = cl(r, this.array), o = cl(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = o, this
    }
    clone(e)
    {
        if (void 0 === e) {
            const e = [];
            for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                    e.push(this.data.array[n + t])
            }
            return new Au(new this.array.constructor(e), this.itemSize, this.normalized)
        }
        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ud(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e)
    {
        if (void 0 === e) {
            const e = [];
            for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                    e.push(this.data.array[n + t])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized
            }
        }
        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
const dd = new hl,
    pd = new Nl,
    hd = new Nl,
    fd = new hl,
    gd = new gc,
    md = new hl,
    bd = new ac,
    Ad = new gc,
    yd = new fc;
class vd extends Qu {
    constructor(e, t)
    {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = ya,
        this.bindMatrix = new gc,
        this.bindMatrixInverse = new gc,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox()
    {
        const e = this.geometry;
        null === this.boundingBox && (this.boundingBox = new Gl),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, md),
            this.boundingBox.expandByPoint(md)
    }
    computeBoundingSphere()
    {
        const e = this.geometry;
        null === this.boundingSphere && (this.boundingSphere = new ac),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, md),
            this.boundingSphere.expandByPoint(md)
    }
    copy(e, t)
    {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    raycast(e, t)
    {
        const n = this.material,
            r = this.matrixWorld;
        void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), bd.copy(this.boundingSphere), bd.applyMatrix4(r), !1 !== e.ray.intersectsSphere(bd) && (Ad.copy(r).invert(), yd.copy(e.ray).applyMatrix4(Ad), null !== this.boundingBox && !1 === yd.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, yd)))
    }
    getVertexPosition(e, t)
    {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
    }
    bind(e, t)
    {
        this.skeleton = e,
        void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose()
    {
        this.skeleton.pose()
    }
    normalizeSkinWeights()
    {
        const e = new Nl,
            t = this.geometry.attributes.skinWeight;
        for (let n = 0, r = t.count; n < r; n++) {
            e.fromBufferAttribute(t, n);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e)
    {
        super.updateMatrixWorld(e),
        this.bindMode === ya ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
    }
    applyBoneTransform(e, t)
    {
        const n = this.skeleton,
            r = this.geometry;
        pd.fromBufferAttribute(r.attributes.skinIndex, e),
        hd.fromBufferAttribute(r.attributes.skinWeight, e),
        dd.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let o = 0; o < 4; o++) {
            const e = hd.getComponent(o);
            if (0 !== e) {
                const r = pd.getComponent(o);
                gd.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                t.addScaledVector(fd.copy(dd).applyMatrix4(gd), e)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class _d extends Gc {
    constructor()
    {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class xd extends Ll {
    constructor(e=null, t=1, n=1, r, o, i, a, s, l=1003, c=1003, u, d)
    {
        super(null, i, a, s, l, c, r, o, u, d),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const wd = new gc,
    Cd = new gc;
class Ed {
    constructor(e=[], t=[])
    {
        this.uuid = ol(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init()
    {
        const e = this.bones,
            t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length)
            this.calculateInverses();
        else if (e.length !== t.length) {
            this.boneInverses = [];
            for (let e = 0, t = this.bones.length; e < t; e++)
                this.boneInverses.push(new gc)
        }
    }
    calculateInverses()
    {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new gc;
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(t)
        }
    }
    pose()
    {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        }
    }
    update()
    {
        const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            r = this.boneTexture;
        for (let o = 0, i = e.length; o < i; o++) {
            const r = e[o] ? e[o].matrixWorld : Cd;
            wd.multiplyMatrices(r, t[o]),
            wd.toArray(n, 16 * o)
        }
        null !== r && (r.needsUpdate = !0)
    }
    clone()
    {
        return new Ed(this.bones, this.boneInverses)
    }
    computeBoneTexture()
    {
        let e = Math.sqrt(4 * this.bones.length);
        e = 4 * Math.ceil(e / 4),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new xd(t, e, e, $a, Na);
        return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
    }
    getBoneByName(e)
    {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const n = this.bones[t];
            if (n.name === e)
                return n
        }
    }
    dispose()
    {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, t)
    {
        this.uuid = e.uuid;
        for (let n = 0, r = e.bones.length; n < r; n++) {
            let r = t[e.bones[n]];
            void 0 === r && (r = new _d),
            this.bones.push(r),
            this.boneInverses.push((new gc).fromArray(e.boneInverses[n]))
        }
        return this.init(), this
    }
    toJSON()
    {
        const e = {
            metadata: {
                version: 4.7,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
            n = this.boneInverses;
        for (let r = 0, o = t.length; r < o; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const i = n[r];
            e.boneInverses.push(i.toArray())
        }
        return e
    }
}
class Sd extends Au {
    constructor(e, t, n, r=1)
    {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e)
    {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON()
    {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const Id = new gc,
    Td = new gc,
    Md = [],
    Rd = new Gl,
    Bd = new gc,
    kd = new Qu,
    Dd = new ac;
let Pd = class  extends Qu{
    constructor(e, t, n)
    {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Sd(new Float32Array(16 * n), 16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let r = 0; r < n; r++)
            this.setMatrixAt(r, Bd)
    }
    computeBoundingBox()
    {
        const e = this.geometry,
            t = this.count;
        null === this.boundingBox && (this.boundingBox = new Gl),
        null === e.boundingBox && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Id),
            Rd.copy(e.boundingBox).applyMatrix4(Id),
            this.boundingBox.union(Rd)
    }
    computeBoundingSphere()
    {
        const e = this.geometry,
            t = this.count;
        null === this.boundingSphere && (this.boundingSphere = new ac),
        null === e.boundingSphere && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Id),
            Dd.copy(e.boundingSphere).applyMatrix4(Id),
            this.boundingSphere.union(Dd)
    }
    copy(e, t)
    {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    getColorAt(e, t)
    {
        t.fromArray(this.instanceColor.array, 3 * e)
    }
    getMatrixAt(e, t)
    {
        t.fromArray(this.instanceMatrix.array, 16 * e)
    }
    getMorphAt(e, t)
    {
        const n = t.morphTargetInfluences,
            r = this.morphTexture.source.data.data,
            o = e * (n.length + 1) + 1;
        for (let i = 0; i < n.length; i++)
            n[i] = r[o + i]
    }
    raycast(e, t)
    {
        const n = this.matrixWorld,
            r = this.count;
        if (kd.geometry = this.geometry, kd.material = this.material, void 0 !== kd.material && (null === this.boundingSphere && this.computeBoundingSphere(), Dd.copy(this.boundingSphere), Dd.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Dd)))
            for (let o = 0; o < r; o++) {
                this.getMatrixAt(o, Id),
                Td.multiplyMatrices(n, Id),
                kd.matrixWorld = Td,
                kd.raycast(e, Md);
                for (let e = 0, n = Md.length; e < n; e++) {
                    const n = Md[e];
                    n.instanceId = o,
                    n.object = this,
                    t.push(n)
                }
                Md.length = 0
            }
    }
    setColorAt(e, t)
    {
        null === this.instanceColor && (this.instanceColor = new Sd(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)),
        t.toArray(this.instanceColor.array, 3 * e)
    }
    setMatrixAt(e, t)
    {
        t.toArray(this.instanceMatrix.array, 16 * e)
    }
    setMorphAt(e, t)
    {
        const n = t.morphTargetInfluences,
            r = n.length + 1;
        null === this.morphTexture && (this.morphTexture = new xd(new Float32Array(r * this.count), r, this.count, qa, Na));
        const o = this.morphTexture.source.data.data;
        let i = 0;
        for (let l = 0; l < n.length; l++)
            i += n[l];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - i,
            s = r * e;
        o[s] = a,
        o.set(n, s + 1)
    }
    updateMorphTargets() {}
    dispose()
    {
        this.dispatchEvent({
            type: "dispose"
        }),
        null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null)
    }
}
;
const Od = new hl,
    Ld = new hl,
    Nd = new ml;
class Fd {
    constructor(e=new hl(1, 0, 0), t=0)
    {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t)
    {
        return this.normal.copy(e), this.constant = t, this
    }
    setComponents(e, t, n, r)
    {
        return this.normal.set(e, t, n), this.constant = r, this
    }
    setFromNormalAndCoplanarPoint(e, t)
    {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this
    }
    setFromCoplanarPoints(e, t, n)
    {
        const r = Od.subVectors(n, t).cross(Ld.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this
    }
    copy(e)
    {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize()
    {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate()
    {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e)
    {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e)
    {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t)
    {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t)
    {
        const n = e.delta(Od),
            r = this.normal.dot(n);
        if (0 === r)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const o = -(e.start.dot(this.normal) + this.constant) / r;
        return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o)
    }
    intersectsLine(e)
    {
        const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e)
    {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e)
    {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e)
    {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t)
    {
        const n = t || Nd.getNormalMatrix(e),
            r = this.coplanarPoint(Od).applyMatrix4(e),
            o = this.normal.applyMatrix3(n).normalize();
        return this.constant = -r.dot(o), this
    }
    translate(e)
    {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e)
    {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
}
const Ud = new ac,
    zd = new dl(.5, .5),
    Qd = new hl;
class Gd {
    constructor(e=new Fd, t=new Fd, n=new Fd, r=new Fd, o=new Fd, i=new Fd)
    {
        this.planes = [e, t, n, r, o, i]
    }
    set(e, t, n, r, o, i)
    {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(o), a[5].copy(i), this
    }
    copy(e)
    {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=2e3, n=!1)
    {
        const r = this.planes,
            o = e.elements,
            i = o[0],
            a = o[1],
            s = o[2],
            l = o[3],
            c = o[4],
            u = o[5],
            d = o[6],
            p = o[7],
            h = o[8],
            f = o[9],
            g = o[10],
            m = o[11],
            b = o[12],
            A = o[13],
            y = o[14],
            v = o[15];
        if (r[0].setComponents(l - i, p - c, m - h, v - b).normalize(), r[1].setComponents(l + i, p + c, m + h, v + b).normalize(), r[2].setComponents(l + a, p + u, m + f, v + A).normalize(), r[3].setComponents(l - a, p - u, m - f, v - A).normalize(), n)
            r[4].setComponents(s, d, g, y).normalize(),
            r[5].setComponents(l - s, p - d, m - g, v - y).normalize();
        else if (r[4].setComponents(l - s, p - d, m - g, v - y).normalize(), t === Ys)
            r[5].setComponents(l + s, p + d, m + g, v + y).normalize();
        else {
            if (t !== Js)
                throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
            r[5].setComponents(s, d, g, y).normalize()
        }
        return this
    }
    intersectsObject(e)
    {
        if (void 0 !== e.boundingSphere)
            null === e.boundingSphere && e.computeBoundingSphere(),
            Ud.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            null === t.boundingSphere && t.computeBoundingSphere(),
            Ud.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Ud)
    }
    intersectsSprite(e)
    {
        Ud.center.set(0, 0, 0);
        const t = zd.distanceTo(e.center);
        return Ud.radius = .7071067811865476 + t, Ud.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ud)
    }
    intersectsSphere(e)
    {
        const t = this.planes,
            n = e.center,
            r = -e.radius;
        for (let o = 0; o < 6; o++)
            if (t[o].distanceToPoint(n) < r)
                return !1;
        return !0
    }
    intersectsBox(e)
    {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const r = t[n];
            if (Qd.x = r.normal.x > 0 ? e.max.x : e.min.x, Qd.y = r.normal.y > 0 ? e.max.y : e.min.y, Qd.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Qd) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e)
    {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
}
class jd extends uu {
    constructor(e)
    {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new su(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const Vd = new hl,
    Hd = new hl,
    $d = new gc,
    Wd = new fc,
    Kd = new ac,
    qd = new hl,
    Xd = new hl;
class Yd extends Gc {
    constructor(e=new Mu, t=new jd)
    {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    computeLineDistances()
    {
        const e = this.geometry;
        if (null === e.index) {
            const t = e.attributes.position,
                n = [0];
            for (let e = 1, r = t.count; e < r; e++)
                Vd.fromBufferAttribute(t, e - 1),
                Hd.fromBufferAttribute(t, e),
                n[e] = n[e - 1],
                n[e] += Vd.distanceTo(Hd);
            e.setAttribute("lineDistance", new _u(n, 1))
        }
        return this
    }
    raycast(e, t)
    {
        const n = this.geometry,
            r = this.matrixWorld,
            o = e.params.Line.threshold,
            i = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), Kd.copy(n.boundingSphere), Kd.applyMatrix4(r), Kd.radius += o, !1 === e.ray.intersectsSphere(Kd))
            return;
        $d.copy(r).invert(),
        Wd.copy(e.ray).applyMatrix4($d);
        const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            s = a * a,
            l = this.isLineSegments ? 2 : 1,
            c = n.index,
            u = n.attributes.position;
        if (null !== c) {
            const n = Math.max(0, i.start),
                r = Math.min(c.count, i.start + i.count);
            for (let o = n, i = r - 1; o < i; o += l) {
                const n = c.getX(o),
                    r = c.getX(o + 1),
                    i = Jd(this, e, Wd, s, n, r, o);
                i && t.push(i)
            }
            if (this.isLineLoop) {
                const o = c.getX(r - 1),
                    i = c.getX(n),
                    a = Jd(this, e, Wd, s, o, i, r - 1);
                a && t.push(a)
            }
        } else {
            const n = Math.max(0, i.start),
                r = Math.min(u.count, i.start + i.count);
            for (let o = n, i = r - 1; o < i; o += l) {
                const n = Jd(this, e, Wd, s, o, o + 1, o);
                n && t.push(n)
            }
            if (this.isLineLoop) {
                const o = Jd(this, e, Wd, s, r - 1, n, r - 1);
                o && t.push(o)
            }
        }
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
}
function Jd(e, t, n, r, o, i, a) {
    const s = e.geometry.attributes.position;
    if (Vd.fromBufferAttribute(s, o), Hd.fromBufferAttribute(s, i), n.distanceSqToSegment(Vd, Hd, qd, Xd) > r)
        return;
    qd.applyMatrix4(e.matrixWorld);
    const l = t.ray.origin.distanceTo(qd);
    return l < t.near || l > t.far ? void 0 : {
        distance: l,
        point: Xd.clone().applyMatrix4(e.matrixWorld),
        index: a,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: e
    }
}
const Zd = new hl,
    ep = new hl;
class tp extends Yd {
    constructor(e, t)
    {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances()
    {
        const e = this.geometry;
        if (null === e.index) {
            const t = e.attributes.position,
                n = [];
            for (let e = 0, r = t.count; e < r; e += 2)
                Zd.fromBufferAttribute(t, e),
                ep.fromBufferAttribute(t, e + 1),
                n[e] = 0 === e ? 0 : n[e - 1],
                n[e + 1] = n[e] + Zd.distanceTo(ep);
            e.setAttribute("lineDistance", new _u(n, 1))
        }
        return this
    }
}
class np extends Yd {
    constructor(e, t)
    {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class rp extends uu {
    constructor(e)
    {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new su(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const op = new gc,
    ip = new fc,
    ap = new ac,
    sp = new hl;
class lp extends Gc {
    constructor(e=new Mu, t=new rp)
    {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    raycast(e, t)
    {
        const n = this.geometry,
            r = this.matrixWorld,
            o = e.params.Points.threshold,
            i = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), ap.copy(n.boundingSphere), ap.applyMatrix4(r), ap.radius += o, !1 === e.ray.intersectsSphere(ap))
            return;
        op.copy(r).invert(),
        ip.copy(e.ray).applyMatrix4(op);
        const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            s = a * a,
            l = n.index,
            c = n.attributes.position;
        if (null !== l)
            for (let u = Math.max(0, i.start), d = Math.min(l.count, i.start + i.count); u < d; u++) {
                const n = l.getX(u);
                sp.fromBufferAttribute(c, n),
                cp(sp, n, s, r, e, t, this)
            }
        else
            for (let u = Math.max(0, i.start), d = Math.min(c.count, i.start + i.count); u < d; u++)
                sp.fromBufferAttribute(c, u),
                cp(sp, u, s, r, e, t, this)
    }
    updateMorphTargets()
    {
        const e = this.geometry.morphAttributes,
            t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
}
function cp(e, t, n, r, o, i, a) {
    const s = ip.distanceSqToPoint(e);
    if (s < n) {
        const n = new hl;
        ip.closestPointToPoint(e, n),
        n.applyMatrix4(r);
        const l = o.ray.origin.distanceTo(n);
        if (l < o.near || l > o.far)
            return;
        i.push({
            distance: l,
            distanceToRay: Math.sqrt(s),
            point: n,
            index: t,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a
        })
    }
}
class up extends Ll {
    constructor(e, t, n, r, o, i, a, s, l, c, u, d)
    {
        super(null, i, a, s, l, c, r, o, u, d),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: n
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class dp extends up {
    constructor(e, t, n, r, o, i)
    {
        super(e, t, n, o, i),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = Ea,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e)
    {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates()
    {
        this.layerUpdates.clear()
    }
}
class pp extends up {
    constructor(e, t, n)
    {
        super(void 0, e[0].width, e[0].height, t, n, va),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class hp extends Ll {
    constructor(e, t, n, r, o, i, a, s, l)
    {
        super(e, t, n, r, o, i, a, s, l),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class fp extends Ll {
    constructor(e, t, n=1014, r, o, i, a=1003, s=1003, l, c=1026, u=1)
    {
        if (c !== Wa && c !== Ka)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        super({
            width: e,
            height: t,
            depth: u
        }, r, o, i, a, s, c, n, l),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e)
    {
        return super.copy(e), this.source = new kl(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
    }
}
class gp extends Ll {
    constructor(e=null)
    {
        super(),
        this.sourceTexture = e,
        this.isExternalTexture = !0
    }
    copy(e)
    {
        return super.copy(e), this.sourceTexture = e.sourceTexture, this
    }
}
class mp extends Mu {
    constructor(e=1, t=1, n=1, r=1)
    {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        };
        const o = e / 2,
            i = t / 2,
            a = Math.floor(n),
            s = Math.floor(r),
            l = a + 1,
            c = s + 1,
            u = e / a,
            d = t / s,
            p = [],
            h = [],
            f = [],
            g = [];
        for (let m = 0; m < c; m++) {
            const e = m * d - i;
            for (let t = 0; t < l; t++) {
                const n = t * u - o;
                h.push(n, -e, 0),
                f.push(0, 0, 1),
                g.push(t / a),
                g.push(1 - m / s)
            }
        }
        for (let m = 0; m < s; m++)
            for (let e = 0; e < a; e++) {
                const t = e + l * m,
                    n = e + l * (m + 1),
                    r = e + 1 + l * (m + 1),
                    o = e + 1 + l * m;
                p.push(t, n, o),
                p.push(n, r, o)
            }
        this.setIndex(p),
        this.setAttribute("position", new _u(h, 3)),
        this.setAttribute("normal", new _u(f, 3)),
        this.setAttribute("uv", new _u(g, 2))
    }
    copy(e)
    {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e)
    {
        return new mp(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
class bp extends uu {
    constructor(e)
    {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new su(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
    }
}
class Ap extends uu {
    constructor(e)
    {
        super(),
        this.isMeshStandardMaterial = !0,
        this.type = "MeshStandardMaterial",
        this.defines = {
            STANDARD: ""
        },
        this.color = new su(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new su(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new dl(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Ec,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class yp extends Ap {
    constructor(e)
    {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new dl(1, 1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return il(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(e) {
                this.ior = (1 + .4 * e) / (1 - .4 * e)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new su(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new su(1, 1, 1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new su(1, 1, 1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy()
    {
        return this._anisotropy
    }
    set anisotropy(e)
    {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat()
    {
        return this._clearcoat
    }
    set clearcoat(e)
    {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence()
    {
        return this._iridescence
    }
    set iridescence(e)
    {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion()
    {
        return this._dispersion
    }
    set dispersion(e)
    {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen()
    {
        return this._sheen
    }
    set sheen(e)
    {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission()
    {
        return this._transmission
    }
    set transmission(e)
    {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e)
    {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class vp extends uu {
    constructor(e)
    {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class _p extends uu {
    constructor(e)
    {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e)
    {
        return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
function xp(e, t) {
    return e && e.constructor !== t ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
}
function wp(e) {
    const t = e.length,
        n = new Array(t);
    for (let r = 0; r !== t; ++r)
        n[r] = r;
    return n.sort(function(t, n) {
        return e[t] - e[n]
    }), n
}
function Cp(e, t, n) {
    const r = e.length,
        o = new e.constructor(r);
    for (let i = 0, a = 0; a !== r; ++i) {
        const r = n[i] * t;
        for (let n = 0; n !== t; ++n)
            o[a++] = e[r + n]
    }
    return o
}
function Ep(e, t, n, r) {
    let o = 1,
        i = e[0];
    for (; void 0 !== i && void 0 === i[r];)
        i = e[o++];
    if (void 0 === i)
        return;
    let a = i[r];
    if (void 0 !== a)
        if (Array.isArray(a))
            do {
                a = i[r],
                void 0 !== a && (t.push(i.time), n.push(...a)),
                i = e[o++]
            } while (void 0 !== i);
        else if (void 0 !== a.toArray)
            do {
                a = i[r],
                void 0 !== a && (t.push(i.time), a.toArray(n, n.length)),
                i = e[o++]
            } while (void 0 !== i);
        else
            do {
                a = i[r],
                void 0 !== a && (t.push(i.time), n.push(a)),
                i = e[o++]
            } while (void 0 !== i)
}
class Sp {
    constructor(e, t, n, r)
    {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== r ? r : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e)
    {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
            r = t[n],
            o = t[n - 1];
        e:
        {
            t:
            {
                let i;
                n:
                {
                    r:
                    if (!(e < r)) {
                        for (let i = n + 2; ;) {
                            if (void 0 === r) {
                                if (e < o)
                                    break r;
                                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                            }
                            if (n === i)
                                break;
                            if (o = r, r = t[++n], e < r)
                                break t
                        }
                        i = t.length;
                        break n
                    }
                    if (!(e >= o)) {
                        const a = t[1];
                        e < a && (n = 2, o = a);
                        for (let i = n - 2; ;) {
                            if (void 0 === o)
                                return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === i)
                                break;
                            if (r = o, o = t[--n - 1], e >= o)
                                break t
                        }
                        i = n,
                        n = 0;
                        break n
                    }
                    break e
                }for (; n < i;) {
                    const r = n + i >>> 1;
                    e < t[r] ? i = r : n = r + 1
                }
                if (r = t[n], o = t[n - 1], void 0 === o)
                    return this._cachedIndex = 0, this.copySampleValue_(0);
                if (void 0 === r)
                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
            }this._cachedIndex = n,
            this.intervalChanged_(n, o, r)
        }return this.interpolate_(n, o, e, r)
    }
    getSettings_()
    {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e)
    {
        const t = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            o = e * r;
        for (let i = 0; i !== r; ++i)
            t[i] = n[o + i];
        return t
    }
    interpolate_()
    {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class Ip extends Sp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: 2400,
            endingEnd: 2400
        }
    }
    intervalChanged_(e, t, n)
    {
        const r = this.parameterPositions;
        let o = e - 2,
            i = e + 1,
            a = r[o],
            s = r[i];
        if (void 0 === a)
            switch (this.getSettings_().endingStart) {
            case 2401:
                o = e,
                a = 2 * t - n;
                break;
            case 2402:
                o = r.length - 2,
                a = t + r[o] - r[o + 1];
                break;
            default:
                o = e,
                a = n
            }
        if (void 0 === s)
            switch (this.getSettings_().endingEnd) {
            case 2401:
                i = e,
                s = 2 * n - t;
                break;
            case 2402:
                i = 1,
                s = n + r[1] - r[0];
                break;
            default:
                i = e - 1,
                s = t
            }
        const l = .5 * (n - t),
            c = this.valueSize;
        this._weightPrev = l / (t - a),
        this._weightNext = l / (s - n),
        this._offsetPrev = o * c,
        this._offsetNext = i * c
    }
    interpolate_(e, t, n, r)
    {
        const o = this.resultBuffer,
            i = this.sampleValues,
            a = this.valueSize,
            s = e * a,
            l = s - a,
            c = this._offsetPrev,
            u = this._offsetNext,
            d = this._weightPrev,
            p = this._weightNext,
            h = (n - t) / (r - t),
            f = h * h,
            g = f * h,
            m = -d * g + 2 * d * f - d * h,
            b = (1 + d) * g + (-1.5 - 2 * d) * f + (-.5 + d) * h + 1,
            A = (-1 - p) * g + (1.5 + p) * f + .5 * h,
            y = p * g - p * f;
        for (let v = 0; v !== a; ++v)
            o[v] = m * i[c + v] + b * i[l + v] + A * i[s + v] + y * i[u + v];
        return o
    }
}
class Tp extends Sp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
    interpolate_(e, t, n, r)
    {
        const o = this.resultBuffer,
            i = this.sampleValues,
            a = this.valueSize,
            s = e * a,
            l = s - a,
            c = (n - t) / (r - t),
            u = 1 - c;
        for (let d = 0; d !== a; ++d)
            o[d] = i[l + d] * u + i[s + d] * c;
        return o
    }
}
class Mp extends Sp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
    interpolate_(e)
    {
        return this.copySampleValue_(e - 1)
    }
}
class Rp {
    constructor(e, t, n, r)
    {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = xp(t, this.TimeBufferType),
        this.values = xp(n, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e)
    {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: xp(e.times, Array),
                values: xp(e.values, Array)
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (n.interpolation = t)
        }
        return n.type = e.ValueTypeName, n
    }
    InterpolantFactoryMethodDiscrete(e)
    {
        return new Mp(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e)
    {
        return new Tp(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e)
    {
        return new Ip(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e)
    {
        let t;
        switch (e) {
        case ks:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Ds:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Ps:
            t = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === t) {
            const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation)
                    throw new Error(t);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return this
        }
        return this.createInterpolant = t, this
    }
    getInterpolation()
    {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return ks;
        case this.InterpolantFactoryMethodLinear:
            return Ds;
        case this.InterpolantFactoryMethodSmooth:
            return Ps
        }
    }
    getValueSize()
    {
        return this.values.length / this.times.length
    }
    shift(e)
    {
        if (0 !== e) {
            const t = this.times;
            for (let n = 0, r = t.length; n !== r; ++n)
                t[n] += e
        }
        return this
    }
    scale(e)
    {
        if (1 !== e) {
            const t = this.times;
            for (let n = 0, r = t.length; n !== r; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t)
    {
        const n = this.times,
            r = n.length;
        let o = 0,
            i = r - 1;
        for (; o !== r && n[o] < e;)
            ++o;
        for (; -1 !== i && n[i] > t;)
            --i;
        if (++i, 0 !== o || i !== r) {
            o >= i && (i = Math.max(i, 1), o = i - 1);
            const e = this.getValueSize();
            this.times = n.slice(o, i),
            this.values = this.values.slice(o * e, i * e)
        }
        return this
    }
    validate()
    {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (e = !1);
        const n = this.times,
            r = this.values,
            o = n.length;
        0 === o && (e = !1);
        let i = null;
        for (let s = 0; s !== o; s++) {
            const t = n[s];
            if ("number" == typeof t && isNaN(t)) {
                e = !1;
                break
            }
            if (null !== i && i > t) {
                e = !1;
                break
            }
            i = t
        }
        if (void 0 !== r && (a = r, ArrayBuffer.isView(a) && !(a instanceof DataView)))
            for (let s = 0, l = r.length; s !== l; ++s) {
                const t = r[s];
                if (isNaN(t)) {
                    e = !1;
                    break
                }
            }
        var a;
        return e
    }
    optimize()
    {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = this.getValueSize(),
            r = this.getInterpolation() === Ps,
            o = e.length - 1;
        let i = 1;
        for (let a = 1; a < o; ++a) {
            let o = !1;
            const s = e[a];
            if (s !== e[a + 1] && (1 !== a || s !== e[0]))
                if (r)
                    o = !0;
                else {
                    const e = a * n,
                        r = e - n,
                        i = e + n;
                    for (let a = 0; a !== n; ++a) {
                        const n = t[e + a];
                        if (n !== t[r + a] || n !== t[i + a]) {
                            o = !0;
                            break
                        }
                    }
                }
            if (o) {
                if (a !== i) {
                    e[i] = e[a];
                    const r = a * n,
                        o = i * n;
                    for (let e = 0; e !== n; ++e)
                        t[o + e] = t[r + e]
                }
                ++i
            }
        }
        if (o > 0) {
            e[i] = e[o];
            for (let e = o * n, r = i * n, a = 0; a !== n; ++a)
                t[r + a] = t[e + a];
            ++i
        }
        return i !== e.length ? (this.times = e.slice(0, i), this.values = t.slice(0, i * n)) : (this.times = e, this.values = t), this
    }
    clone()
    {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = new (0, this.constructor)(this.name, e, t);
        return n.createInterpolant = this.createInterpolant, n
    }
}
Rp.prototype.ValueTypeName = "",
Rp.prototype.TimeBufferType = Float32Array,
Rp.prototype.ValueBufferType = Float32Array,
Rp.prototype.DefaultInterpolation = Ds;
class Bp extends Rp {
    constructor(e, t, n)
    {
        super(e, t, n)
    }
}
Bp.prototype.ValueTypeName = "bool",
Bp.prototype.ValueBufferType = Array,
Bp.prototype.DefaultInterpolation = ks,
Bp.prototype.InterpolantFactoryMethodLinear = void 0,
Bp.prototype.InterpolantFactoryMethodSmooth = void 0;
class kp extends Rp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
}
kp.prototype.ValueTypeName = "color";
class Dp extends Rp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
}
Dp.prototype.ValueTypeName = "number";
class Pp extends Sp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
    interpolate_(e, t, n, r)
    {
        const o = this.resultBuffer,
            i = this.sampleValues,
            a = this.valueSize,
            s = (n - t) / (r - t);
        let l = e * a;
        for (let c = l + a; l !== c; l += 4)
            pl.slerpFlat(o, 0, i, l - a, i, l, s);
        return o
    }
}
class Op extends Rp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
    InterpolantFactoryMethodLinear(e)
    {
        return new Pp(this.times, this.values, this.getValueSize(), e)
    }
}
Op.prototype.ValueTypeName = "quaternion",
Op.prototype.InterpolantFactoryMethodSmooth = void 0;
class Lp extends Rp {
    constructor(e, t, n)
    {
        super(e, t, n)
    }
}
Lp.prototype.ValueTypeName = "string",
Lp.prototype.ValueBufferType = Array,
Lp.prototype.DefaultInterpolation = ks,
Lp.prototype.InterpolantFactoryMethodLinear = void 0,
Lp.prototype.InterpolantFactoryMethodSmooth = void 0;
class Np extends Rp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
}
Np.prototype.ValueTypeName = "vector";
class Fp {
    constructor(e="", t=-1, n=[], r=2500)
    {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = r,
        this.uuid = ol(),
        this.userData = {},
        this.duration < 0 && this.resetDuration()
    }
    static parse(e)
    {
        const t = [],
            n = e.tracks,
            r = 1 / (e.fps || 1);
        for (let i = 0, a = n.length; i !== a; ++i)
            t.push(Up(n[i]).scale(r));
        const o = new this(e.name, e.duration, t, e.blendMode);
        return o.uuid = e.uuid, o.userData = JSON.parse(e.userData || "{}"), o
    }
    static toJSON(e)
    {
        const t = [],
            n = e.tracks,
            r = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode,
                userData: JSON.stringify(e.userData)
            };
        for (let o = 0, i = n.length; o !== i; ++o)
            t.push(Rp.toJSON(n[o]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, n, r)
    {
        const o = t.length,
            i = [];
        for (let a = 0; a < o; a++) {
            let e = [],
                s = [];
            e.push((a + o - 1) % o, a, (a + 1) % o),
            s.push(0, 1, 0);
            const l = wp(e);
            e = Cp(e, 1, l),
            s = Cp(s, 1, l),
            r || 0 !== e[0] || (e.push(o), s.push(s[0])),
            i.push(new Dp(".morphTargetInfluences[" + t[a].name + "]", e, s).scale(1 / n))
        }
        return new this(e, -1, i)
    }
    static findByName(e, t)
    {
        let n = e;
        if (!Array.isArray(e)) {
            const t = e;
            n = t.geometry && t.geometry.animations || t.animations
        }
        for (let r = 0; r < n.length; r++)
            if (n[r].name === t)
                return n[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n)
    {
        const r = {},
            o = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, s = e.length; a < s; a++) {
            const t = e[a],
                n = t.name.match(o);
            if (n && n.length > 1) {
                const e = n[1];
                let o = r[e];
                o || (r[e] = o = []),
                o.push(t)
            }
        }
        const i = [];
        for (const a in r)
            i.push(this.CreateFromMorphTargetSequence(a, r[a], t, n));
        return i
    }
    static parseAnimation(e, t)
    {
        if (!e)
            return null;
        const n = function(e, t, n, r, o) {
                if (0 !== n.length) {
                    const i = [],
                        a = [];
                    Ep(n, i, a, r),
                    0 !== i.length && o.push(new e(t, i, a))
                }
            },
            r = [],
            o = e.name || "default",
            i = e.fps || 30,
            a = e.blendMode;
        let s = e.length || -1;
        const l = e.hierarchy || [];
        for (let c = 0; c < l.length; c++) {
            const e = l[c].keys;
            if (e && 0 !== e.length)
                if (e[0].morphTargets) {
                    const t = {};
                    let n;
                    for (n = 0; n < e.length; n++)
                        if (e[n].morphTargets)
                            for (let r = 0; r < e[n].morphTargets.length; r++)
                                t[e[n].morphTargets[r]] = -1;
                    for (const o in t) {
                        const t = [],
                            i = [];
                        for (let r = 0; r !== e[n].morphTargets.length; ++r) {
                            const r = e[n];
                            t.push(r.time),
                            i.push(r.morphTarget === o ? 1 : 0)
                        }
                        r.push(new Dp(".morphTargetInfluence[" + o + "]", t, i))
                    }
                    s = t.length * i
                } else {
                    const o = ".bones[" + t[c].name + "]";
                    n(Np, o + ".position", e, "pos", r),
                    n(Op, o + ".quaternion", e, "rot", r),
                    n(Np, o + ".scale", e, "scl", r)
                }
        }
        return 0 === r.length ? null : new this(o, s, r, a)
    }
    resetDuration()
    {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
            const n = this.tracks[t];
            e = Math.max(e, n.times[n.times.length - 1])
        }
        return this.duration = e, this
    }
    trim()
    {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate()
    {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize()
    {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone()
    {
        const e = [];
        for (let n = 0; n < this.tracks.length; n++)
            e.push(this.tracks[n].clone());
        const t = new this.constructor(this.name, this.duration, e, this.blendMode);
        return t.userData = JSON.parse(JSON.stringify(this.userData)), t
    }
    toJSON()
    {
        return this.constructor.toJSON(this)
    }
}
function Up(e) {
    if (void 0 === e.type)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = function(e) {
        switch (e.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Dp;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Np;
        case "color":
            return kp;
        case "quaternion":
            return Op;
        case "bool":
        case "boolean":
            return Bp;
        case "string":
            return Lp
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
    }(e.type);
    if (void 0 === e.times) {
        const t = [],
            n = [];
        Ep(e.keys, t, n, "value"),
        e.times = t,
        e.values = n
    }
    return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
}
const zp = {
    enabled: !1,
    files: {},
    add: function(e, t) {
        !1 !== this.enabled && (this.files[e] = t)
    },
    get: function(e) {
        if (!1 !== this.enabled)
            return this.files[e]
    },
    remove: function(e) {
        delete this.files[e]
    },
    clear: function() {
        this.files = {}
    }
};
class Qp {
    constructor(e, t, n)
    {
        const r = this;
        let o,
            i = !1,
            a = 0,
            s = 0;
        const l = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.abortController = new AbortController,
        this.itemStart = function(e) {
            s++,
            !1 === i && void 0 !== r.onStart && r.onStart(e, a, s),
            i = !0
        },
        this.itemEnd = function(e) {
            a++,
            void 0 !== r.onProgress && r.onProgress(e, a, s),
            a === s && (i = !1, void 0 !== r.onLoad && r.onLoad())
        },
        this.itemError = function(e) {
            void 0 !== r.onError && r.onError(e)
        },
        this.resolveURL = function(e) {
            return o ? o(e) : e
        },
        this.setURLModifier = function(e) {
            return o = e, this
        },
        this.addHandler = function(e, t) {
            return l.push(e, t), this
        },
        this.removeHandler = function(e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2), this
        },
        this.getHandler = function(e) {
            for (let t = 0, n = l.length; t < n; t += 2) {
                const n = l[t],
                    r = l[t + 1];
                if (n.global && (n.lastIndex = 0), n.test(e))
                    return r
            }
            return null
        },
        this.abort = function() {
            return this.abortController.abort(), this.abortController = new AbortController, this
        }
    }
}
const Gp = new Qp;
class jp {
    constructor(e)
    {
        this.manager = void 0 !== e ? e : Gp,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t)
    {
        const n = this;
        return new Promise(function(r, o) {
            n.load(e, r, t, o)
        })
    }
    parse() {}
    setCrossOrigin(e)
    {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e)
    {
        return this.withCredentials = e, this
    }
    setPath(e)
    {
        return this.path = e, this
    }
    setResourcePath(e)
    {
        return this.resourcePath = e, this
    }
    setRequestHeader(e)
    {
        return this.requestHeader = e, this
    }
    abort()
    {
        return this
    }
}
jp.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Vp = {};
class Hp extends Error {
    constructor(e, t)
    {
        super(e),
        this.response = t
    }
}
class $p extends jp {
    constructor(e)
    {
        super(e),
        this.mimeType = "",
        this.responseType = "",
        this._abortController = new AbortController
    }
    load(e, t, n, r)
    {
        void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const o = zp.get(`file:${e}`);
        if (void 0 !== o)
            return this.manager.itemStart(e), setTimeout(() => {
                t && t(o),
                this.manager.itemEnd(e)
            }, 0), o;
        if (void 0 !== Vp[e])
            return void Vp[e].push({
                onLoad: t,
                onProgress: n,
                onError: r
            });
        Vp[e] = [],
        Vp[e].push({
            onLoad: t,
            onProgress: n,
            onError: r
        });
        const i = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
                signal: "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
            }),
            a = this.mimeType,
            s = this.responseType;
        fetch(i).then(t => {
            if (200 === t.status || 0 === t.status) {
                if (t.status, "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                    return t;
                const n = Vp[e],
                    r = t.body.getReader(),
                    o = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
                    i = o ? parseInt(o) : 0,
                    a = 0 !== i;
                let s = 0;
                const l = new ReadableStream({
                    start(e) {
                        !function t() {
                            r.read().then(({done: r, value: o}) => {
                                if (r)
                                    e.close();
                                else {
                                    s += o.byteLength;
                                    const r = new ProgressEvent("progress", {
                                        lengthComputable: a,
                                        loaded: s,
                                        total: i
                                    });
                                    for (let e = 0, t = n.length; e < t; e++) {
                                        const t = n[e];
                                        t.onProgress && t.onProgress(r)
                                    }
                                    e.enqueue(o),
                                    t()
                                }
                            }, t => {
                                e.error(t)
                            })
                        }()
                    }
                });
                return new Response(l)
            }
            throw new Hp(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
        }).then(e => {
            switch (s) {
            case "arraybuffer":
                return e.arrayBuffer();
            case "blob":
                return e.blob();
            case "document":
                return e.text().then(e => (new DOMParser).parseFromString(e, a));
            case "json":
                return e.json();
            default:
                if ("" === a)
                    return e.text();
                {
                    const t = /charset="?([^;"\s]*)"?/i.exec(a),
                        n = t && t[1] ? t[1].toLowerCase() : void 0,
                        r = new TextDecoder(n);
                    return e.arrayBuffer().then(e => r.decode(e))
                }
            }
        }).then(t => {
            zp.add(`file:${e}`, t);
            const n = Vp[e];
            delete Vp[e];
            for (let e = 0, r = n.length; e < r; e++) {
                const r = n[e];
                r.onLoad && r.onLoad(t)
            }
        }).catch(t => {
            const n = Vp[e];
            if (void 0 === n)
                throw this.manager.itemError(e), t;
            delete Vp[e];
            for (let e = 0, r = n.length; e < r; e++) {
                const r = n[e];
                r.onError && r.onError(t)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }),
        this.manager.itemStart(e)
    }
    setResponseType(e)
    {
        return this.responseType = e, this
    }
    setMimeType(e)
    {
        return this.mimeType = e, this
    }
    abort()
    {
        return this._abortController.abort(), this._abortController = new AbortController, this
    }
}
const Wp = new WeakMap;
class Kp extends jp {
    constructor(e)
    {
        super(e)
    }
    load(e, t, n, r)
    {
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const o = this,
            i = zp.get(`image:${e}`);
        if (void 0 !== i) {
            if (!0 === i.complete)
                o.manager.itemStart(e),
                setTimeout(function() {
                    t && t(i),
                    o.manager.itemEnd(e)
                }, 0);
            else {
                let e = Wp.get(i);
                void 0 === e && (e = [], Wp.set(i, e)),
                e.push({
                    onLoad: t,
                    onError: r
                })
            }
            return i
        }
        const a = yl("img");
        function s() {
            c(),
            t && t(this);
            const n = Wp.get(this) || [];
            for (let e = 0; e < n.length; e++) {
                const t = n[e];
                t.onLoad && t.onLoad(this)
            }
            Wp.delete(this),
            o.manager.itemEnd(e)
        }
        function l(t) {
            c(),
            r && r(t),
            zp.remove(`image:${e}`);
            const n = Wp.get(this) || [];
            for (let e = 0; e < n.length; e++) {
                const r = n[e];
                r.onError && r.onError(t)
            }
            Wp.delete(this),
            o.manager.itemError(e),
            o.manager.itemEnd(e)
        }
        function c() {
            a.removeEventListener("load", s, !1),
            a.removeEventListener("error", l, !1)
        }
        return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), zp.add(`image:${e}`, a), o.manager.itemStart(e), a.src = e, a
    }
}
class qp extends jp {
    constructor(e)
    {
        super(e)
    }
    load(e, t, n, r)
    {
        const o = this,
            i = new xd,
            a = new $p(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(o.withCredentials), a.load(e, function(e) {
            let n;
            try {
                n = o.parse(e)
            } catch (a) {
                if (void 0 === r)
                    return;
                r(a)
            }
            void 0 !== n.image ? i.image = n.image : void 0 !== n.data && (i.image.width = n.width, i.image.height = n.height, i.image.data = n.data),
            i.wrapS = void 0 !== n.wrapS ? n.wrapS : Ea,
            i.wrapT = void 0 !== n.wrapT ? n.wrapT : Ea,
            i.magFilter = void 0 !== n.magFilter ? n.magFilter : Ra,
            i.minFilter = void 0 !== n.minFilter ? n.minFilter : Ra,
            i.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
            void 0 !== n.colorSpace && (i.colorSpace = n.colorSpace),
            void 0 !== n.flipY && (i.flipY = n.flipY),
            void 0 !== n.format && (i.format = n.format),
            void 0 !== n.type && (i.type = n.type),
            void 0 !== n.mipmaps && (i.mipmaps = n.mipmaps, i.minFilter = ka),
            1 === n.mipmapCount && (i.minFilter = Ra),
            void 0 !== n.generateMipmaps && (i.generateMipmaps = n.generateMipmaps),
            i.needsUpdate = !0,
            t && t(i, n)
        }, n, r), i
    }
}
class Xp extends jp {
    constructor(e)
    {
        super(e)
    }
    load(e, t, n, r)
    {
        const o = new Ll,
            i = new Kp(this.manager);
        return i.setCrossOrigin(this.crossOrigin), i.setPath(this.path), i.load(e, function(e) {
            o.image = e,
            o.needsUpdate = !0,
            void 0 !== t && t(o)
        }, n, r), o
    }
}
let Yp = class  extends Gc{
    constructor(e, t=1)
    {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new su(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t)
    {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), void 0 !== this.target && (t.object.target = this.target.uuid), t
    }
}
;
class Jp extends Yp {
    constructor(e, t, n)
    {
        super(e, n),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(Gc.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new su(t)
    }
    copy(e, t)
    {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this
    }
}
const Zp = new gc,
    eh = new hl,
    th = new hl;
class nh {
    constructor(e)
    {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new dl(512, 512),
        this.mapType = Da,
        this.map = null,
        this.mapPass = null,
        this.matrix = new gc,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Gd,
        this._frameExtents = new dl(1, 1),
        this._viewportCount = 1,
        this._viewports = [new Nl(0, 0, 1, 1)]
    }
    getViewportCount()
    {
        return this._viewportCount
    }
    getFrustum()
    {
        return this._frustum
    }
    updateMatrices(e)
    {
        const t = this.camera,
            n = this.matrix;
        eh.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(eh),
        th.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(th),
        t.updateMatrixWorld(),
        Zp.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Zp, t.coordinateSystem, t.reversedDepth),
        t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(Zp)
    }
    getViewport(e)
    {
        return this._viewports[e]
    }
    getFrameExtents()
    {
        return this._frameExtents
    }
    dispose()
    {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e)
    {
        return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
    toJSON()
    {
        const e = {};
        return 1 !== this.intensity && (e.intensity = this.intensity), 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class rh extends nh {
    constructor()
    {
        super(new Zu(50, 1, .5, 500)),
        this.isSpotLightShadow = !0,
        this.focus = 1,
        this.aspect = 1
    }
    updateMatrices(e)
    {
        const t = this.camera,
            n = 2 * rl * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height * this.aspect,
            o = e.distance || t.far;
        n === t.fov && r === t.aspect && o === t.far || (t.fov = n, t.aspect = r, t.far = o, t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e)
    {
        return super.copy(e), this.focus = e.focus, this
    }
}
class oh extends Yp {
    constructor(e, t, n=0, r=Math.PI / 3, o=0, i=2)
    {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Gc.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Gc,
        this.distance = n,
        this.angle = r,
        this.penumbra = o,
        this.decay = i,
        this.map = null,
        this.shadow = new rh
    }
    get power()
    {
        return this.intensity * Math.PI
    }
    set power(e)
    {
        this.intensity = e / Math.PI
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
const ih = new gc,
    ah = new hl,
    sh = new hl;
class lh extends nh {
    constructor()
    {
        super(new Zu(90, 1, .5, 500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new dl(4, 2),
        this._viewportCount = 6,
        this._viewports = [new Nl(2, 1, 1, 1), new Nl(0, 1, 1, 1), new Nl(3, 1, 1, 1), new Nl(1, 1, 1, 1), new Nl(3, 0, 1, 1), new Nl(1, 0, 1, 1)],
        this._cubeDirections = [new hl(1, 0, 0), new hl(-1, 0, 0), new hl(0, 0, 1), new hl(0, 0, -1), new hl(0, 1, 0), new hl(0, -1, 0)],
        this._cubeUps = [new hl(0, 1, 0), new hl(0, 1, 0), new hl(0, 1, 0), new hl(0, 1, 0), new hl(0, 0, 1), new hl(0, 0, -1)]
    }
    updateMatrices(e, t=0)
    {
        const n = this.camera,
            r = this.matrix,
            o = e.distance || n.far;
        o !== n.far && (n.far = o, n.updateProjectionMatrix()),
        ah.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(ah),
        sh.copy(n.position),
        sh.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(sh),
        n.updateMatrixWorld(),
        r.makeTranslation(-ah.x, -ah.y, -ah.z),
        ih.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(ih, n.coordinateSystem, n.reversedDepth)
    }
}
class ch extends Yp {
    constructor(e, t, n=0, r=2)
    {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = r,
        this.shadow = new lh
    }
    get power()
    {
        return 4 * this.intensity * Math.PI
    }
    set power(e)
    {
        this.intensity = e / (4 * Math.PI)
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class uh extends qu {
    constructor(e=-1, t=1, n=1, r=-1, o=.1, i=2e3)
    {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = r,
        this.near = o,
        this.far = i,
        this.updateProjectionMatrix()
    }
    copy(e, t)
    {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, t, n, r, o, i)
    {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = r,
        this.view.width = o,
        this.view.height = i,
        this.updateProjectionMatrix()
    }
    clearViewOffset()
    {
        null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix()
    {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        let o = n - e,
            i = n + e,
            a = r + t,
            s = r - t;
        if (null !== this.view && this.view.enabled) {
            const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            o += e * this.view.offsetX,
            i = o + e * this.view.width,
            a -= t * this.view.offsetY,
            s = a - t * this.view.height
        }
        this.projectionMatrix.makeOrthographic(o, i, a, s, this.near, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e)
    {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
    }
}
class dh extends nh {
    constructor()
    {
        super(new uh(-5, 5, 5, -5, .5, 500)),
        this.isDirectionalLightShadow = !0
    }
}
class ph extends Yp {
    constructor(e, t)
    {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Gc.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Gc,
        this.shadow = new dh
    }
    dispose()
    {
        this.shadow.dispose()
    }
    copy(e)
    {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class hh {
    static extractUrlBase(e)
    {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t)
    {
        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
const fh = new WeakMap;
class gh extends jp {
    constructor(e)
    {
        super(e),
        this.isImageBitmapLoader = !0,
        this.options = {
            premultiplyAlpha: "none"
        },
        this._abortController = new AbortController
    }
    setOptions(e)
    {
        return this.options = e, this
    }
    load(e, t, n, r)
    {
        void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const o = this,
            i = zp.get(`image-bitmap:${e}`);
        if (void 0 !== i)
            return o.manager.itemStart(e), i.then ? void i.then(n => {
                if (!0 !== fh.has(i))
                    return t && t(n), o.manager.itemEnd(e), n;
                r && r(fh.get(i)),
                o.manager.itemError(e),
                o.manager.itemEnd(e)
            }) : (setTimeout(function() {
                t && t(i),
                o.manager.itemEnd(e)
            }, 0), i);
        const a = {};
        a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
        a.headers = this.requestHeader,
        a.signal = "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
        const s = fetch(e, a).then(function(e) {
            return e.blob()
        }).then(function(e) {
            return createImageBitmap(e, Object.assign(o.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(n) {
            return zp.add(`image-bitmap:${e}`, n), t && t(n), o.manager.itemEnd(e), n
        }).catch(function(t) {
            r && r(t),
            fh.set(s, t),
            zp.remove(`image-bitmap:${e}`),
            o.manager.itemError(e),
            o.manager.itemEnd(e)
        });
        zp.add(`image-bitmap:${e}`, s),
        o.manager.itemStart(e)
    }
    abort()
    {
        return this._abortController.abort(), this._abortController = new AbortController, this
    }
}
class mh extends Zu {
    constructor(e=[])
    {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
class bh {
    constructor(e=!0)
    {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start()
    {
        this.startTime = performance.now(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop()
    {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime()
    {
        return this.getDelta(), this.elapsedTime
    }
    getDelta()
    {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(), 0;
        if (this.running) {
            const t = performance.now();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
const Ah = "\\[\\]\\.:\\/",
    yh = new RegExp("[" + Ah + "]", "g"),
    vh = "[^" + Ah + "]",
    _h = "[^" + Ah.replace("\\.", "") + "]",
    xh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", vh) + /(WCOD+)?/.source.replace("WCOD", _h) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vh) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vh) + "$"),
    wh = ["material", "materials", "bones", "map"];
class Ch {
    constructor(e, t, n)
    {
        this.path = t,
        this.parsedPath = n || Ch.parseTrackName(t),
        this.node = Ch.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n)
    {
        return e && e.isAnimationObjectGroup ? new Ch.Composite(e, t, n) : new Ch(e, t, n)
    }
    static sanitizeNodeName(e)
    {
        return e.replace(/\s/g, "_").replace(yh, "")
    }
    static parseTrackName(e)
    {
        const t = xh.exec(e);
        if (null === t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            },
            r = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== r && -1 !== r) {
            const e = n.nodeName.substring(r + 1);
            -1 !== wh.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t)
    {
        if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (void 0 !== n)
                return n
        }
        if (e.children) {
            const n = function(e) {
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r];
                        if (o.name === t || o.uuid === t)
                            return o;
                        const i = n(o.children);
                        if (i)
                            return i
                    }
                    return null
                },
                r = n(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t)
    {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t)
    {
        const n = this.resolvedProperty;
        for (let r = 0, o = n.length; r !== o; ++r)
            e[t++] = n[r]
    }
    _getValue_arrayElement(e, t)
    {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t)
    {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t)
    {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t)
    {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t)
    {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t)
    {
        const n = this.resolvedProperty;
        for (let r = 0, o = n.length; r !== o; ++r)
            n[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t)
    {
        const n = this.resolvedProperty;
        for (let r = 0, o = n.length; r !== o; ++r)
            n[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t)
    {
        const n = this.resolvedProperty;
        for (let r = 0, o = n.length; r !== o; ++r)
            n[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t)
    {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t)
    {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t)
    {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t)
    {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t)
    {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t)
    {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t)
    {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t)
    {
        this.bind(),
        this.setValue(e, t)
    }
    bind()
    {
        let e = this.node;
        const t = this.parsedPath,
            n = t.objectName,
            r = t.propertyName;
        let o = t.propertyIndex;
        if (e || (e = Ch.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e)
            return;
        if (n) {
            let r = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material)
                    return;
                if (!e.material.materials)
                    return;
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton)
                    return;
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++)
                    if (e[t].name === r) {
                        r = t;
                        break
                    }
                break;
            case "map":
                if ("map" in e) {
                    e = e.map;
                    break
                }
                if (!e.material)
                    return;
                if (!e.material.map)
                    return;
                e = e.material.map;
                break;
            default:
                if (void 0 === e[n])
                    return;
                e = e[n]
            }
            if (void 0 !== r) {
                if (void 0 === e[r])
                    return;
                e = e[r]
            }
        }
        const i = e[r];
        if (void 0 === i)
            return void t.nodeName;
        let a = this.Versioning.None;
        this.targetObject = e,
        !0 === e.isMaterial ? a = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let s = this.BindingType.Direct;
        if (void 0 !== o) {
            if ("morphTargetInfluences" === r) {
                if (!e.geometry)
                    return;
                if (!e.geometry.morphAttributes)
                    return;
                void 0 !== e.morphTargetDictionary[o] && (o = e.morphTargetDictionary[o])
            }
            s = this.BindingType.ArrayElement,
            this.resolvedProperty = i,
            this.propertyIndex = o
        } else
            void 0 !== i.fromArray && void 0 !== i.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = i) : Array.isArray(i) ? (s = this.BindingType.EntireArray, this.resolvedProperty = i) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[s],
        this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
    }
    unbind()
    {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Ch.Composite = class {
    constructor(e, t, n)
    {
        const r = n || Ch.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t)
    {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
            r = this._bindings[n];
        void 0 !== r && r.getValue(e, t)
    }
    setValue(e, t)
    {
        const n = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, o = n.length; r !== o; ++r)
            n[r].setValue(e, t)
    }
    bind()
    {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind()
    {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
,
Ch.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
},
Ch.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
},
Ch.prototype.GetterByBindingType = [Ch.prototype._getValue_direct, Ch.prototype._getValue_array, Ch.prototype._getValue_arrayElement, Ch.prototype._getValue_toArray],
Ch.prototype.SetterByBindingTypeAndVersioning = [[Ch.prototype._setValue_direct, Ch.prototype._setValue_direct_setNeedsUpdate, Ch.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ch.prototype._setValue_array, Ch.prototype._setValue_array_setNeedsUpdate, Ch.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ch.prototype._setValue_arrayElement, Ch.prototype._setValue_arrayElement_setNeedsUpdate, Ch.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ch.prototype._setValue_fromArray, Ch.prototype._setValue_fromArray_setNeedsUpdate, Ch.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Eh {
    constructor(e)
    {
        this.value = e
    }
    clone()
    {
        return new Eh(void 0 === this.value.clone ? this.value : this.value.clone())
    }
}
class Sh {
    constructor(e=1, t=0, n=0)
    {
        this.radius = e,
        this.phi = t,
        this.theta = n
    }
    set(e, t, n)
    {
        return this.radius = e, this.phi = t, this.theta = n, this
    }
    copy(e)
    {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe()
    {
        const e = 1e-6;
        return this.phi = il(this.phi, e, Math.PI - e), this
    }
    setFromVector3(e)
    {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n)
    {
        return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(il(t / this.radius, -1, 1))), this
    }
    clone()
    {
        return (new this.constructor).copy(this)
    }
}
class Ih extends Zs {
    constructor(e, t=null)
    {
        super(),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.state = -1,
        this.keys = {},
        this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        },
        this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect(e)
    {
        void 0 !== e && (null !== this.domElement && this.disconnect(), this.domElement = e)
    }
    disconnect() {}
    dispose() {}
    update() {}
}
function Th(e, t, n, r) {
    const o = function(e) {
        switch (e) {
        case Da:
        case 1010:
            return {
                byteLength: 1,
                components: 1
            };
        case Pa:
        case 1011:
        case Fa:
            return {
                byteLength: 2,
                components: 1
            };
        case Ua:
        case za:
            return {
                byteLength: 2,
                components: 4
            };
        case La:
        case Oa:
        case Na:
            return {
                byteLength: 4,
                components: 1
            };
        case Ga:
        case ja:
            return {
                byteLength: 4,
                components: 3
            }
        }
        throw new Error(`Unknown texture type ${e}.`)
    }(r);
    switch (n) {
    case Va:
        return e * t;
    case qa:
    case Xa:
        return e * t / o.components * o.byteLength;
    case Ya:
    case Ja:
        return e * t * 2 / o.components * o.byteLength;
    case Ha:
        return e * t * 3 / o.components * o.byteLength;
    case $a:
    case Za:
        return e * t * 4 / o.components * o.byteLength;
    case es:
    case ts:
        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case ns:
    case rs:
        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case is:
    case ss:
        return Math.max(e, 16) * Math.max(t, 8) / 4;
    case os:
    case as:
        return Math.max(e, 8) * Math.max(t, 8) / 2;
    case ls:
    case cs:
        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case us:
    case ds:
        return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case ps:
        return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case hs:
        return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case fs:
        return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case gs:
        return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case ms:
        return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case bs:
        return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case As:
        return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case ys:
        return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case vs:
        return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case _s:
        return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case xs:
        return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case ws:
        return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case Cs:
        return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case Es:
    case Ss:
    case Is:
        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
    case Ts:
    case Ms:
        return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
    case Rs:
    case Bs:
        return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${n} format.`)
}
function Mh() {
    let e = null,
        t = !1,
        n = null,
        r = null;
    function o(t, i) {
        n(t, i),
        r = e.requestAnimationFrame(o)
    }
    return {
        start: function() {
            !0 !== t && null !== n && (r = e.requestAnimationFrame(o), t = !0)
        },
        stop: function() {
            e.cancelAnimationFrame(r),
            t = !1
        },
        setAnimationLoop: function(e) {
            n = e
        },
        setContext: function(t) {
            e = t
        }
    }
}
function Rh(e) {
    const t = new WeakMap;
    return {
        get: function(e) {
            return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
        },
        remove: function(n) {
            n.isInterleavedBufferAttribute && (n = n.data);
            const r = t.get(n);
            r && (e.deleteBuffer(r.buffer), t.delete(n))
        },
        update: function(n, r) {
            if (n.isInterleavedBufferAttribute && (n = n.data), n.isGLBufferAttribute) {
                const e = t.get(n);
                return void ((!e || e.version < n.version) && t.set(n, {
                    buffer: n.buffer,
                    type: n.type,
                    bytesPerElement: n.elementSize,
                    version: n.version
                }))
            }
            const o = t.get(n);
            if (void 0 === o)
                t.set(n, function(t, n) {
                    const r = t.array,
                        o = t.usage,
                        i = r.byteLength,
                        a = e.createBuffer();
                    let s;
                    if (e.bindBuffer(n, a), e.bufferData(n, r, o), t.onUploadCallback(), r instanceof Float32Array)
                        s = e.FLOAT;
                    else if ("undefined" != typeof Float16Array && r instanceof Float16Array)
                        s = e.HALF_FLOAT;
                    else if (r instanceof Uint16Array)
                        s = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                    else if (r instanceof Int16Array)
                        s = e.SHORT;
                    else if (r instanceof Uint32Array)
                        s = e.UNSIGNED_INT;
                    else if (r instanceof Int32Array)
                        s = e.INT;
                    else if (r instanceof Int8Array)
                        s = e.BYTE;
                    else if (r instanceof Uint8Array)
                        s = e.UNSIGNED_BYTE;
                    else {
                        if (!(r instanceof Uint8ClampedArray))
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                        s = e.UNSIGNED_BYTE
                    }
                    return {
                        buffer: a,
                        type: s,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version,
                        size: i
                    }
                }(n, r));
            else if (o.version < n.version) {
                if (o.size !== n.array.byteLength)
                    throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                !function(t, n, r) {
                    const o = n.array,
                        i = n.updateRanges;
                    if (e.bindBuffer(r, t), 0 === i.length)
                        e.bufferSubData(r, 0, o);
                    else {
                        i.sort((e, t) => e.start - t.start);
                        let t = 0;
                        for (let e = 1; e < i.length; e++) {
                            const n = i[t],
                                r = i[e];
                            r.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, r.start + r.count - n.start) : (++t, i[t] = r)
                        }
                        i.length = t + 1;
                        for (let n = 0, a = i.length; n < a; n++) {
                            const t = i[n];
                            e.bufferSubData(r, t.start * o.BYTES_PER_ELEMENT, o, t.start, t.count)
                        }
                        n.clearUpdateRanges()
                    }
                    n.onUploadCallback()
                }(o.buffer, n, r),
                o.version = n.version
            }
        }
    }
}
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: ji
    }
})),
"undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = ji));
const Bh = {
        alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
        alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
        batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
        iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
        lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
        morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
        normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
        iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
        opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
        shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
        uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
    },
    kh = {
        common: {
            diffuse: {
                value: new su(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new ml
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ml
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new ml
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new ml
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new ml
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new ml
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new ml
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new ml
            },
            normalScale: {
                value: new dl(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new ml
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new ml
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new ml
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new ml
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new su(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new su(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ml
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new ml
            }
        },
        sprite: {
            diffuse: {
                value: new su(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new dl(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new ml
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new ml
            },
            alphaTest: {
                value: 0
            }
        }
    },
    Dh = {
        basic: {
            uniforms: Hu([kh.common, kh.specularmap, kh.envmap, kh.aomap, kh.lightmap, kh.fog]),
            vertexShader: Bh.meshbasic_vert,
            fragmentShader: Bh.meshbasic_frag
        },
        lambert: {
            uniforms: Hu([kh.common, kh.specularmap, kh.envmap, kh.aomap, kh.lightmap, kh.emissivemap, kh.bumpmap, kh.normalmap, kh.displacementmap, kh.fog, kh.lights, {
                emissive: {
                    value: new su(0)
                }
            }]),
            vertexShader: Bh.meshlambert_vert,
            fragmentShader: Bh.meshlambert_frag
        },
        phong: {
            uniforms: Hu([kh.common, kh.specularmap, kh.envmap, kh.aomap, kh.lightmap, kh.emissivemap, kh.bumpmap, kh.normalmap, kh.displacementmap, kh.fog, kh.lights, {
                emissive: {
                    value: new su(0)
                },
                specular: {
                    value: new su(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Bh.meshphong_vert,
            fragmentShader: Bh.meshphong_frag
        },
        standard: {
            uniforms: Hu([kh.common, kh.envmap, kh.aomap, kh.lightmap, kh.emissivemap, kh.bumpmap, kh.normalmap, kh.displacementmap, kh.roughnessmap, kh.metalnessmap, kh.fog, kh.lights, {
                emissive: {
                    value: new su(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Bh.meshphysical_vert,
            fragmentShader: Bh.meshphysical_frag
        },
        toon: {
            uniforms: Hu([kh.common, kh.aomap, kh.lightmap, kh.emissivemap, kh.bumpmap, kh.normalmap, kh.displacementmap, kh.gradientmap, kh.fog, kh.lights, {
                emissive: {
                    value: new su(0)
                }
            }]),
            vertexShader: Bh.meshtoon_vert,
            fragmentShader: Bh.meshtoon_frag
        },
        matcap: {
            uniforms: Hu([kh.common, kh.bumpmap, kh.normalmap, kh.displacementmap, kh.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Bh.meshmatcap_vert,
            fragmentShader: Bh.meshmatcap_frag
        },
        points: {
            uniforms: Hu([kh.points, kh.fog]),
            vertexShader: Bh.points_vert,
            fragmentShader: Bh.points_frag
        },
        dashed: {
            uniforms: Hu([kh.common, kh.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Bh.linedashed_vert,
            fragmentShader: Bh.linedashed_frag
        },
        depth: {
            uniforms: Hu([kh.common, kh.displacementmap]),
            vertexShader: Bh.depth_vert,
            fragmentShader: Bh.depth_frag
        },
        normal: {
            uniforms: Hu([kh.common, kh.bumpmap, kh.normalmap, kh.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Bh.meshnormal_vert,
            fragmentShader: Bh.meshnormal_frag
        },
        sprite: {
            uniforms: Hu([kh.sprite, kh.fog]),
            vertexShader: Bh.sprite_vert,
            fragmentShader: Bh.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new ml
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Bh.background_vert,
            fragmentShader: Bh.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new ml
                }
            },
            vertexShader: Bh.backgroundCube_vert,
            fragmentShader: Bh.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Bh.cube_vert,
            fragmentShader: Bh.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Bh.equirect_vert,
            fragmentShader: Bh.equirect_frag
        },
        distanceRGBA: {
            uniforms: Hu([kh.common, kh.displacementmap, {
                referencePosition: {
                    value: new hl
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Bh.distanceRGBA_vert,
            fragmentShader: Bh.distanceRGBA_frag
        },
        shadow: {
            uniforms: Hu([kh.lights, kh.fog, {
                color: {
                    value: new su(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Bh.shadow_vert,
            fragmentShader: Bh.shadow_frag
        }
    };
Dh.physical = {
    uniforms: Hu([Dh.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new ml
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new ml
        },
        clearcoatNormalScale: {
            value: new dl(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new ml
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new ml
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new ml
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new su(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new ml
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new ml
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new ml
        },
        transmissionSamplerSize: {
            value: new dl
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new ml
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new su(0)
        },
        specularColor: {
            value: new su(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new ml
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new ml
        },
        anisotropyVector: {
            value: new dl
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new ml
        }
    }]),
    vertexShader: Bh.meshphysical_vert,
    fragmentShader: Bh.meshphysical_frag
};
const Ph = {
        r: 0,
        b: 0,
        g: 0
    },
    Oh = new Ec,
    Lh = new gc;
function Nh(e, t, n, r, o, i, a) {
    const s = new su(0);
    let l,
        c,
        u = !0 === i ? 0 : 1,
        d = null,
        p = 0,
        h = null;
    function f(e) {
        let r = !0 === e.isScene ? e.background : null;
        return r && r.isTexture && (r = (e.backgroundBlurriness > 0 ? n : t).get(r)), r
    }
    function g(t, n) {
        t.getRGB(Ph, $u(e)),
        r.buffers.color.setClear(Ph.r, Ph.g, Ph.b, n, a)
    }
    return {
        getClearColor: function() {
            return s
        },
        setClearColor: function(e, t=1) {
            s.set(e),
            u = t,
            g(s, u)
        },
        getClearAlpha: function() {
            return u
        },
        setClearAlpha: function(e) {
            u = e,
            g(s, u)
        },
        render: function(t) {
            let n = !1;
            const o = f(t);
            null === o ? g(s, u) : o && o.isColor && (g(o, 1), n = !0);
            const i = e.xr.getEnvironmentBlendMode();
            "additive" === i ? r.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === i && r.buffers.color.setClear(0, 0, 0, 0, a),
            (e.autoClear || n) && (r.buffers.depth.setTest(!0), r.buffers.depth.setMask(!0), r.buffers.color.setMask(!0), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
        },
        addToRenderList: function(t, n) {
            const r = f(n);
            r && (r.isCubeTexture || r.mapping === wa) ? (void 0 === c && (c = new Qu(new ju(1, 1, 1), new Ku({
                name: "BackgroundCubeMaterial",
                uniforms: Vu(Dh.backgroundCube.uniforms),
                vertexShader: Dh.backgroundCube.vertexShader,
                fragmentShader: Dh.backgroundCube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(e, t, n) {
                this.matrixWorld.copyPosition(n.matrixWorld)
            }, Object.defineProperty(c.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }), o.update(c)), Oh.copy(n.backgroundRotation), Oh.x *= -1, Oh.y *= -1, Oh.z *= -1, r.isCubeTexture && !1 === r.isRenderTargetTexture && (Oh.y *= -1, Oh.z *= -1), c.material.uniforms.envMap.value = r, c.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(Lh.makeRotationFromEuler(Oh)), c.material.toneMapped = Sl.getTransfer(r.colorSpace) !== Us, d === r && p === r.version && h === e.toneMapping || (c.material.needsUpdate = !0, d = r, p = r.version, h = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null)) : r && r.isTexture && (void 0 === l && (l = new Qu(new mp(2, 2), new Ku({
                name: "BackgroundMaterial",
                uniforms: Vu(Dh.background.uniforms),
                vertexShader: Dh.background.vertexShader,
                fragmentShader: Dh.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
                allowOverride: !1
            })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }), o.update(l)), l.material.uniforms.t2D.value = r, l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, l.material.toneMapped = Sl.getTransfer(r.colorSpace) !== Us, !0 === r.matrixAutoUpdate && r.updateMatrix(), l.material.uniforms.uvTransform.value.copy(r.matrix), d === r && p === r.version && h === e.toneMapping || (l.material.needsUpdate = !0, d = r, p = r.version, h = e.toneMapping), l.layers.enableAll(), t.unshift(l, l.geometry, l.material, 0, 0, null))
        },
        dispose: function() {
            void 0 !== c && (c.geometry.dispose(), c.material.dispose(), c = void 0),
            void 0 !== l && (l.geometry.dispose(), l.material.dispose(), l = void 0)
        }
    }
}
function Fh(e, t) {
    const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
        r = {},
        o = c(null);
    let i = o,
        a = !1;
    function s(t) {
        return e.bindVertexArray(t)
    }
    function l(t) {
        return e.deleteVertexArray(t)
    }
    function c(e) {
        const t = [],
            r = [],
            o = [];
        for (let i = 0; i < n; i++)
            t[i] = 0,
            r[i] = 0,
            o[i] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: r,
            attributeDivisors: o,
            object: e,
            attributes: {},
            index: null
        }
    }
    function u() {
        const e = i.newAttributes;
        for (let t = 0, n = e.length; t < n; t++)
            e[t] = 0
    }
    function d(e) {
        p(e, 0)
    }
    function p(t, n) {
        const r = i.newAttributes,
            o = i.enabledAttributes,
            a = i.attributeDivisors;
        r[t] = 1,
        0 === o[t] && (e.enableVertexAttribArray(t), o[t] = 1),
        a[t] !== n && (e.vertexAttribDivisor(t, n), a[t] = n)
    }
    function h() {
        const t = i.newAttributes,
            n = i.enabledAttributes;
        for (let r = 0, o = n.length; r < o; r++)
            n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
    }
    function f(t, n, r, o, i, a, s) {
        !0 === s ? e.vertexAttribIPointer(t, n, r, i, a) : e.vertexAttribPointer(t, n, r, o, i, a)
    }
    function g() {
        m(),
        a = !0,
        i !== o && (i = o, s(i.object))
    }
    function m() {
        o.geometry = null,
        o.program = null,
        o.wireframe = !1
    }
    return {
        setup: function(n, o, l, g, m) {
            let b = !1;
            const A = function(t, n, o) {
                const i = !0 === o.wireframe;
                let a = r[t.id];
                void 0 === a && (a = {}, r[t.id] = a);
                let s = a[n.id];
                void 0 === s && (s = {}, a[n.id] = s);
                let l = s[i];
                return void 0 === l && (l = c(e.createVertexArray()), s[i] = l), l
            }(g, l, o);
            i !== A && (i = A, s(i.object)),
            b = function(e, t, n, r) {
                const o = i.attributes,
                    a = t.attributes;
                let s = 0;
                const l = n.getAttributes();
                for (const i in l)
                    if (l[i].location >= 0) {
                        const t = o[i];
                        let n = a[i];
                        if (void 0 === n && ("instanceMatrix" === i && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === i && e.instanceColor && (n = e.instanceColor)), void 0 === t)
                            return !0;
                        if (t.attribute !== n)
                            return !0;
                        if (n && t.data !== n.data)
                            return !0;
                        s++
                    }
                return i.attributesNum !== s || i.index !== r
            }(n, g, l, m),
            b && function(e, t, n, r) {
                const o = {},
                    a = t.attributes;
                let s = 0;
                const l = n.getAttributes();
                for (const i in l)
                    if (l[i].location >= 0) {
                        let t = a[i];
                        void 0 === t && ("instanceMatrix" === i && e.instanceMatrix && (t = e.instanceMatrix), "instanceColor" === i && e.instanceColor && (t = e.instanceColor));
                        const n = {};
                        n.attribute = t,
                        t && t.data && (n.data = t.data),
                        o[i] = n,
                        s++
                    }
                i.attributes = o,
                i.attributesNum = s,
                i.index = r
            }(n, g, l, m),
            null !== m && t.update(m, e.ELEMENT_ARRAY_BUFFER),
            (b || a) && (a = !1, function(n, r, o, i) {
                u();
                const a = i.attributes,
                    s = o.getAttributes(),
                    l = r.defaultAttributeValues;
                for (const c in s) {
                    const r = s[c];
                    if (r.location >= 0) {
                        let o = a[c];
                        if (void 0 === o && ("instanceMatrix" === c && n.instanceMatrix && (o = n.instanceMatrix), "instanceColor" === c && n.instanceColor && (o = n.instanceColor)), void 0 !== o) {
                            const a = o.normalized,
                                s = o.itemSize,
                                l = t.get(o);
                            if (void 0 === l)
                                continue;
                            const c = l.buffer,
                                u = l.type,
                                h = l.bytesPerElement,
                                g = u === e.INT || u === e.UNSIGNED_INT || o.gpuType === Oa;
                            if (o.isInterleavedBufferAttribute) {
                                const t = o.data,
                                    l = t.stride,
                                    m = o.offset;
                                if (t.isInstancedInterleavedBuffer) {
                                    for (let e = 0; e < r.locationSize; e++)
                                        p(r.location + e, t.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === i._maxInstanceCount && (i._maxInstanceCount = t.meshPerAttribute * t.count)
                                } else
                                    for (let e = 0; e < r.locationSize; e++)
                                        d(r.location + e);
                                e.bindBuffer(e.ARRAY_BUFFER, c);
                                for (let e = 0; e < r.locationSize; e++)
                                    f(r.location + e, s / r.locationSize, u, a, l * h, (m + s / r.locationSize * e) * h, g)
                            } else {
                                if (o.isInstancedBufferAttribute) {
                                    for (let e = 0; e < r.locationSize; e++)
                                        p(r.location + e, o.meshPerAttribute);
                                    !0 !== n.isInstancedMesh && void 0 === i._maxInstanceCount && (i._maxInstanceCount = o.meshPerAttribute * o.count)
                                } else
                                    for (let e = 0; e < r.locationSize; e++)
                                        d(r.location + e);
                                e.bindBuffer(e.ARRAY_BUFFER, c);
                                for (let e = 0; e < r.locationSize; e++)
                                    f(r.location + e, s / r.locationSize, u, a, s * h, s / r.locationSize * e * h, g)
                            }
                        } else if (void 0 !== l) {
                            const t = l[c];
                            if (void 0 !== t)
                                switch (t.length) {
                                case 2:
                                    e.vertexAttrib2fv(r.location, t);
                                    break;
                                case 3:
                                    e.vertexAttrib3fv(r.location, t);
                                    break;
                                case 4:
                                    e.vertexAttrib4fv(r.location, t);
                                    break;
                                default:
                                    e.vertexAttrib1fv(r.location, t)
                                }
                        }
                    }
                }
                h()
            }(n, o, l, g), null !== m && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(m).buffer))
        },
        reset: g,
        resetDefaultState: m,
        dispose: function() {
            g();
            for (const e in r) {
                const t = r[e];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n)
                        l(n[e].object),
                        delete n[e];
                    delete t[e]
                }
                delete r[e]
            }
        },
        releaseStatesOfGeometry: function(e) {
            if (void 0 === r[e.id])
                return;
            const t = r[e.id];
            for (const n in t) {
                const e = t[n];
                for (const t in e)
                    l(e[t].object),
                    delete e[t];
                delete t[n]
            }
            delete r[e.id]
        },
        releaseStatesOfProgram: function(e) {
            for (const t in r) {
                const n = r[t];
                if (void 0 === n[e.id])
                    continue;
                const o = n[e.id];
                for (const e in o)
                    l(o[e].object),
                    delete o[e];
                delete n[e.id]
            }
        },
        initAttributes: u,
        enableAttribute: d,
        disableUnusedAttributes: h
    }
}
function Uh(e, t, n) {
    let r;
    function o(t, o, i) {
        0 !== i && (e.drawArraysInstanced(r, t, o, i), n.update(o, r, i))
    }
    this.setMode = function(e) {
        r = e
    },
    this.render = function(t, o) {
        e.drawArrays(r, t, o),
        n.update(o, r, 1)
    },
    this.renderInstances = o,
    this.renderMultiDraw = function(e, o, i) {
        if (0 === i)
            return;
        t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, e, 0, o, 0, i);
        let a = 0;
        for (let t = 0; t < i; t++)
            a += o[t];
        n.update(a, r, 1)
    },
    this.renderMultiDrawInstances = function(e, i, a, s) {
        if (0 === a)
            return;
        const l = t.get("WEBGL_multi_draw");
        if (null === l)
            for (let t = 0; t < e.length; t++)
                o(e[t], i[t], s[t]);
        else {
            l.multiDrawArraysInstancedWEBGL(r, e, 0, i, 0, s, 0, a);
            let t = 0;
            for (let e = 0; e < a; e++)
                t += i[e] * s[e];
            n.update(t, r, 1)
        }
    }
}
function zh(e, t, n, r) {
    let o;
    function i(t) {
        if ("highp" === t) {
            if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                return "highp";
            t = "mediump"
        }
        return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let a = void 0 !== n.precision ? n.precision : "highp";
    const s = i(a);
    s !== a && (a = s);
    const l = !0 === n.logarithmicDepthBuffer,
        c = !0 === n.reversedDepthBuffer && t.has("EXT_clip_control"),
        u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
        d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: function() {
            if (void 0 !== o)
                return o;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                const n = t.get("EXT_texture_filter_anisotropic");
                o = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else
                o = 0;
            return o
        },
        getMaxPrecision: i,
        textureFormatReadable: function(t) {
            return t === $a || r.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
        },
        textureTypeReadable: function(n) {
            const o = n === Fa && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
            return !(n !== Da && r.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== Na && !o)
        },
        precision: a,
        logarithmicDepthBuffer: l,
        reversedDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: d,
        maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
        maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
        maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
        maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
        maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
        maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
        vertexTextures: d > 0,
        maxSamples: e.getParameter(e.MAX_SAMPLES)
    }
}
function Qh(e) {
    const t = this;
    let n = null,
        r = 0,
        o = !1,
        i = !1;
    const a = new Fd,
        s = new ml,
        l = {
            value: null,
            needsUpdate: !1
        };
    function c(e, n, r, o) {
        const i = null !== e ? e.length : 0;
        let c = null;
        if (0 !== i) {
            if (c = l.value, !0 !== o || null === c) {
                const t = r + 4 * i,
                    o = n.matrixWorldInverse;
                s.getNormalMatrix(o),
                (null === c || c.length < t) && (c = new Float32Array(t));
                for (let n = 0, l = r; n !== i; ++n, l += 4)
                    a.copy(e[n]).applyMatrix4(o, s),
                    a.normal.toArray(c, l),
                    c[l + 3] = a.constant
            }
            l.value = c,
            l.needsUpdate = !0
        }
        return t.numPlanes = i, t.numIntersection = 0, c
    }
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(e, t) {
        const n = 0 !== e.length || t || 0 !== r || o;
        return o = t, r = e.length, n
    },
    this.beginShadows = function() {
        i = !0,
        c(null)
    },
    this.endShadows = function() {
        i = !1
    },
    this.setGlobalState = function(e, t) {
        n = c(e, t, 0)
    },
    this.setState = function(a, s, u) {
        const d = a.clippingPlanes,
            p = a.clipIntersection,
            h = a.clipShadows,
            f = e.get(a);
        if (!o || null === d || 0 === d.length || i && !h)
            i ? c(null) : (l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0);
        else {
            const e = i ? 0 : r,
                t = 4 * e;
            let o = f.clippingState || null;
            l.value = o,
            o = c(d, s, t, u);
            for (let r = 0; r !== t; ++r)
                o[r] = n[r];
            f.clippingState = o,
            this.numIntersection = p ? this.numPlanes : 0,
            this.numPlanes += e
        }
    }
}
function Gh(e) {
    let t = new WeakMap;
    function n(e, t) {
        return t === xa ? e.mapping = va : 304 === t && (e.mapping = _a), e
    }
    function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const o = t.get(n);
        void 0 !== o && (t.delete(n), o.dispose())
    }
    return {
        get: function(o) {
            if (o && o.isTexture) {
                const i = o.mapping;
                if (i === xa || 304 === i) {
                    if (t.has(o))
                        return n(t.get(o).texture, o.mapping);
                    {
                        const i = o.image;
                        if (i && i.height > 0) {
                            const a = new rd(i.height);
                            return a.fromEquirectangularTexture(e, o), t.set(o, a), o.addEventListener("dispose", r), n(a.texture, o.mapping)
                        }
                        return null
                    }
                }
            }
            return o
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}
const jh = [.125, .215, .35, .446, .526, .582],
    Vh = new uh,
    Hh = new su;
let $h = null,
    Wh = 0,
    Kh = 0,
    qh = !1;
const Xh = (1 + Math.sqrt(5)) / 2,
    Yh = 1 / Xh,
    Jh = [new hl(-Xh, Yh, 0), new hl(Xh, Yh, 0), new hl(-Yh, 0, Xh), new hl(Yh, 0, Xh), new hl(0, Xh, -Yh), new hl(0, Xh, Yh), new hl(-1, 1, -1), new hl(1, 1, -1), new hl(-1, 1, 1), new hl(1, 1, 1)],
    Zh = new hl;
class ef {
    constructor(e)
    {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, r=100, o={})
    {
        const {size: i=256, position: a=Zh} = o;
        $h = this._renderer.getRenderTarget(),
        Wh = this._renderer.getActiveCubeFace(),
        Kh = this._renderer.getActiveMipmapLevel(),
        qh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(i);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, n, r, s, a), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(e, t=null)
    {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null)
    {
        return this._fromTexture(e, t)
    }
    compileCubemapShader()
    {
        null === this._cubemapMaterial && (this._cubemapMaterial = of(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader()
    {
        null === this._equirectMaterial && (this._equirectMaterial = rf(), this._compileMaterial(this._equirectMaterial))
    }
    dispose()
    {
        this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose()
    }
    _setSize(e)
    {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose()
    {
        null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e)
    {
        this._renderer.setRenderTarget($h, Wh, Kh),
        this._renderer.xr.enabled = qh,
        e.scissorTest = !1,
        nf(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t)
    {
        e.mapping === va || e.mapping === _a ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        $h = this._renderer.getRenderTarget(),
        Wh = this._renderer.getActiveCubeFace(),
        Kh = this._renderer.getActiveMipmapLevel(),
        qh = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    }
    _allocateTargets()
    {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
                magFilter: Ra,
                minFilter: Ra,
                generateMipmaps: !1,
                type: Fa,
                format: $a,
                colorSpace: Ns,
                depthBuffer: !1
            },
            r = tf(e, t, n);
        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            null !== this._pingPongRenderTarget && this._dispose(),
            this._pingPongRenderTarget = tf(e, t, n);
            const {_lodMax: r} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                const t = [],
                    n = [],
                    r = [];
                let o = e;
                const i = e - 4 + 1 + jh.length;
                for (let a = 0; a < i; a++) {
                    const i = Math.pow(2, o);
                    n.push(i);
                    let s = 1 / i;
                    a > e - 4 ? s = jh[a - e + 4 - 1] : 0 === a && (s = 0),
                    r.push(s);
                    const l = 1 / (i - 2),
                        c = -l,
                        u = 1 + l,
                        d = [c, c, u, c, u, u, c, c, u, u, c, u],
                        p = 6,
                        h = 6,
                        f = 3,
                        g = 2,
                        m = 1,
                        b = new Float32Array(f * h * p),
                        A = new Float32Array(g * h * p),
                        y = new Float32Array(m * h * p);
                    for (let e = 0; e < p; e++) {
                        const t = e % 3 * 2 / 3 - 1,
                            n = e > 2 ? 0 : -1,
                            r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                        b.set(r, f * h * e),
                        A.set(d, g * h * e);
                        const o = [e, e, e, e, e, e];
                        y.set(o, m * h * e)
                    }
                    const v = new Mu;
                    v.setAttribute("position", new Au(b, f)),
                    v.setAttribute("uv", new Au(A, g)),
                    v.setAttribute("faceIndex", new Au(y, m)),
                    t.push(v),
                    o > 4 && o--
                }
                return {
                    lodPlanes: t,
                    sizeLods: n,
                    sigmas: r
                }
            }(r)),
            this._blurMaterial = function(e, t, n) {
                const r = new Float32Array(20),
                    o = new hl(0, 1, 0);
                return new Ku({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: 20,
                        CUBEUV_TEXEL_WIDTH: 1 / t,
                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                        CUBEUV_MAX_MIP: `${e}.0`
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: r
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: o
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }(r, e, t)
        }
        return r
    }
    _compileMaterial(e)
    {
        const t = new Qu(this._lodPlanes[0], e);
        this._renderer.compile(t, Vh)
    }
    _sceneToCubeUV(e, t, n, r, o)
    {
        const i = new Zu(90, 1, t, n),
            a = [1, -1, 1, 1, 1, 1],
            s = [1, 1, 1, -1, -1, -1],
            l = this._renderer,
            c = l.autoClear,
            u = l.toneMapping;
        l.getClearColor(Hh),
        l.toneMapping = 0,
        l.autoClear = !1,
        l.state.buffers.depth.getReversed() && (l.setRenderTarget(r), l.clearDepth(), l.setRenderTarget(null));
        const d = new du({
                name: "PMREM.Background",
                side: 1,
                depthWrite: !1,
                depthTest: !1
            }),
            p = new Qu(new ju, d);
        let h = !1;
        const f = e.background;
        f ? f.isColor && (d.color.copy(f), e.background = null, h = !0) : (d.color.copy(Hh), h = !0);
        for (let g = 0; g < 6; g++) {
            const t = g % 3;
            0 === t ? (i.up.set(0, a[g], 0), i.position.set(o.x, o.y, o.z), i.lookAt(o.x + s[g], o.y, o.z)) : 1 === t ? (i.up.set(0, 0, a[g]), i.position.set(o.x, o.y, o.z), i.lookAt(o.x, o.y + s[g], o.z)) : (i.up.set(0, a[g], 0), i.position.set(o.x, o.y, o.z), i.lookAt(o.x, o.y, o.z + s[g]));
            const n = this._cubeSize;
            nf(r, t * n, g > 2 ? n : 0, n, n),
            l.setRenderTarget(r),
            h && l.render(p, i),
            l.render(e, i)
        }
        p.geometry.dispose(),
        p.material.dispose(),
        l.toneMapping = u,
        l.autoClear = c,
        e.background = f
    }
    _textureToCubeUV(e, t)
    {
        const n = this._renderer,
            r = e.mapping === va || e.mapping === _a;
        r ? (null === this._cubemapMaterial && (this._cubemapMaterial = of()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = rf());
        const o = r ? this._cubemapMaterial : this._equirectMaterial,
            i = new Qu(this._lodPlanes[0], o);
        o.uniforms.envMap.value = e;
        const a = this._cubeSize;
        nf(t, 0, 0, 3 * a, 2 * a),
        n.setRenderTarget(t),
        n.render(i, Vh)
    }
    _applyPMREM(e)
    {
        const t = this._renderer,
            n = t.autoClear;
        t.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let o = 1; o < r; o++) {
            const t = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]),
                n = Jh[(r - o - 1) % Jh.length];
            this._blur(e, o - 1, o, t, n)
        }
        t.autoClear = n
    }
    _blur(e, t, n, r, o)
    {
        const i = this._pingPongRenderTarget;
        this._halfBlur(e, i, t, n, r, "latitudinal", o),
        this._halfBlur(i, e, n, n, r, "longitudinal", o)
    }
    _halfBlur(e, t, n, r, o, i, a)
    {
        const s = this._renderer,
            l = this._blurMaterial,
            c = new Qu(this._lodPlanes[r], l),
            u = l.uniforms,
            d = this._sizeLods[n] - 1,
            p = isFinite(o) ? Math.PI / (2 * d) : 2 * Math.PI / 39,
            h = o / p,
            f = isFinite(o) ? 1 + Math.floor(3 * h) : 20,
            g = [];
        let m = 0;
        for (let y = 0; y < 20; ++y) {
            const e = y / h,
                t = Math.exp(-e * e / 2);
            g.push(t),
            0 === y ? m += t : y < f && (m += 2 * t)
        }
        for (let y = 0; y < g.length; y++)
            g[y] = g[y] / m;
        u.envMap.value = e.texture,
        u.samples.value = f,
        u.weights.value = g,
        u.latitudinal.value = "latitudinal" === i,
        a && (u.poleAxis.value = a);
        const {_lodMax: b} = this;
        u.dTheta.value = p,
        u.mipInt.value = b - n;
        const A = this._sizeLods[r];
        nf(t, 3 * A * (r > b - 4 ? r - b + 4 : 0), 4 * (this._cubeSize - A), 3 * A, 2 * A),
        s.setRenderTarget(t),
        s.render(c, Vh)
    }
}
function tf(e, t, n) {
    const r = new Ul(e, t, n);
    return r.texture.mapping = wa, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
}
function nf(e, t, n, r, o) {
    e.viewport.set(t, n, r, o),
    e.scissor.set(t, n, r, o)
}
function rf() {
    return new Ku({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}
function of() {
    return new Ku({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}
function af(e) {
    let t = new WeakMap,
        n = null;
    function r(e) {
        const n = e.target;
        n.removeEventListener("dispose", r);
        const o = t.get(n);
        void 0 !== o && (t.delete(n), o.dispose())
    }
    return {
        get: function(o) {
            if (o && o.isTexture) {
                const i = o.mapping,
                    a = i === xa || 304 === i,
                    s = i === va || i === _a;
                if (a || s) {
                    let i = t.get(o);
                    const l = void 0 !== i ? i.texture.pmremVersion : 0;
                    if (o.isRenderTargetTexture && o.pmremVersion !== l)
                        return null === n && (n = new ef(e)), i = a ? n.fromEquirectangular(o, i) : n.fromCubemap(o, i), i.texture.pmremVersion = o.pmremVersion, t.set(o, i), i.texture;
                    if (void 0 !== i)
                        return i.texture;
                    {
                        const l = o.image;
                        return a && l && l.height > 0 || s && l && function(e) {
                            let t = 0;
                            for (let n = 0; n < 6; n++)
                                void 0 !== e[n] && t++;
                            return 6 === t
                        }(l) ? (null === n && (n = new ef(e)), i = a ? n.fromEquirectangular(o) : n.fromCubemap(o), i.texture.pmremVersion = o.pmremVersion, t.set(o, i), o.addEventListener("dispose", r), i.texture) : null
                    }
                }
            }
            return o
        },
        dispose: function() {
            t = new WeakMap,
            null !== n && (n.dispose(), n = null)
        }
    }
}
function sf(e) {
    const t = {};
    function n(n) {
        if (void 0 !== t[n])
            return t[n];
        let r;
        switch (n) {
        case "WEBGL_depth_texture":
            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = e.getExtension(n)
        }
        return t[n] = r, r
    }
    return {
        has: function(e) {
            return null !== n(e)
        },
        init: function() {
            n("EXT_color_buffer_float"),
            n("WEBGL_clip_cull_distance"),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture"),
            n("WEBGL_render_shared_exponent")
        },
        get: function(e) {
            const t = n(e);
            return null === t && xl("THREE.WebGLRenderer: " + e + " extension not supported."), t
        }
    }
}
function lf(e, t, n, r) {
    const o = {},
        i = new WeakMap;
    function a(e) {
        const s = e.target;
        null !== s.index && t.remove(s.index);
        for (const n in s.attributes)
            t.remove(s.attributes[n]);
        s.removeEventListener("dispose", a),
        delete o[s.id];
        const l = i.get(s);
        l && (t.remove(l), i.delete(s)),
        r.releaseStatesOfGeometry(s),
        !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
        n.memory.geometries--
    }
    function s(e) {
        const n = [],
            r = e.index,
            o = e.attributes.position;
        let a = 0;
        if (null !== r) {
            const e = r.array;
            a = r.version;
            for (let t = 0, r = e.length; t < r; t += 3) {
                const r = e[t + 0],
                    o = e[t + 1],
                    i = e[t + 2];
                n.push(r, o, o, i, i, r)
            }
        } else {
            if (void 0 === o)
                return;
            {
                const e = o.array;
                a = o.version;
                for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                    const e = t + 0,
                        r = t + 1,
                        o = t + 2;
                    n.push(e, r, r, o, o, e)
                }
            }
        }
        const s = new (Al(n) ? vu : yu)(n, 1);
        s.version = a;
        const l = i.get(e);
        l && t.remove(l),
        i.set(e, s)
    }
    return {
        get: function(e, t) {
            return !0 === o[t.id] || (t.addEventListener("dispose", a), o[t.id] = !0, n.memory.geometries++), t
        },
        update: function(n) {
            const r = n.attributes;
            for (const o in r)
                t.update(r[o], e.ARRAY_BUFFER)
        },
        getWireframeAttribute: function(e) {
            const t = i.get(e);
            if (t) {
                const n = e.index;
                null !== n && t.version < n.version && s(e)
            } else
                s(e);
            return i.get(e)
        }
    }
}
function cf(e, t, n) {
    let r,
        o,
        i;
    function a(t, a, s) {
        0 !== s && (e.drawElementsInstanced(r, a, o, t * i, s), n.update(a, r, s))
    }
    this.setMode = function(e) {
        r = e
    },
    this.setIndex = function(e) {
        o = e.type,
        i = e.bytesPerElement
    },
    this.render = function(t, a) {
        e.drawElements(r, a, o, t * i),
        n.update(a, r, 1)
    },
    this.renderInstances = a,
    this.renderMultiDraw = function(e, i, a) {
        if (0 === a)
            return;
        t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, i, 0, o, e, 0, a);
        let s = 0;
        for (let t = 0; t < a; t++)
            s += i[t];
        n.update(s, r, 1)
    },
    this.renderMultiDrawInstances = function(e, s, l, c) {
        if (0 === l)
            return;
        const u = t.get("WEBGL_multi_draw");
        if (null === u)
            for (let t = 0; t < e.length; t++)
                a(e[t] / i, s[t], c[t]);
        else {
            u.multiDrawElementsInstancedWEBGL(r, s, 0, o, e, 0, c, 0, l);
            let t = 0;
            for (let e = 0; e < l; e++)
                t += s[e] * c[e];
            n.update(t, r, 1)
        }
    }
}
function uf(e) {
    const t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function() {
            t.calls = 0,
            t.triangles = 0,
            t.points = 0,
            t.lines = 0
        },
        update: function(n, r, o) {
            switch (t.calls++, r) {
            case e.TRIANGLES:
                t.triangles += o * (n / 3);
                break;
            case e.LINES:
                t.lines += o * (n / 2);
                break;
            case e.LINE_STRIP:
                t.lines += o * (n - 1);
                break;
            case e.LINE_LOOP:
                t.lines += o * n;
                break;
            case e.POINTS:
                t.points += o * n
            }
        }
    }
}
function df(e, t, n) {
    const r = new WeakMap,
        o = new Nl;
    return {
        update: function(i, a, s) {
            const l = i.morphTargetInfluences,
                c = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
                u = void 0 !== c ? c.length : 0;
            let d = r.get(a);
            if (void 0 === d || d.count !== u) {
                let e = function() {
                    b.dispose(),
                    r.delete(a),
                    a.removeEventListener("dispose", e)
                };
                void 0 !== d && d.texture.dispose();
                const n = void 0 !== a.morphAttributes.position,
                    i = void 0 !== a.morphAttributes.normal,
                    s = void 0 !== a.morphAttributes.color,
                    l = a.morphAttributes.position || [],
                    c = a.morphAttributes.normal || [],
                    p = a.morphAttributes.color || [];
                let h = 0;
                !0 === n && (h = 1),
                !0 === i && (h = 2),
                !0 === s && (h = 3);
                let f = a.attributes.position.count * h,
                    g = 1;
                f > t.maxTextureSize && (g = Math.ceil(f / t.maxTextureSize), f = t.maxTextureSize);
                const m = new Float32Array(f * g * 4 * u),
                    b = new zl(m, f, g, u);
                b.type = Na,
                b.needsUpdate = !0;
                const A = 4 * h;
                for (let t = 0; t < u; t++) {
                    const e = l[t],
                        r = c[t],
                        a = p[t],
                        u = f * g * 4 * t;
                    for (let t = 0; t < e.count; t++) {
                        const l = t * A;
                        !0 === n && (o.fromBufferAttribute(e, t), m[u + l + 0] = o.x, m[u + l + 1] = o.y, m[u + l + 2] = o.z, m[u + l + 3] = 0),
                        !0 === i && (o.fromBufferAttribute(r, t), m[u + l + 4] = o.x, m[u + l + 5] = o.y, m[u + l + 6] = o.z, m[u + l + 7] = 0),
                        !0 === s && (o.fromBufferAttribute(a, t), m[u + l + 8] = o.x, m[u + l + 9] = o.y, m[u + l + 10] = o.z, m[u + l + 11] = 4 === a.itemSize ? o.w : 1)
                    }
                }
                d = {
                    count: u,
                    texture: b,
                    size: new dl(f, g)
                },
                r.set(a, d),
                a.addEventListener("dispose", e)
            }
            if (!0 === i.isInstancedMesh && null !== i.morphTexture)
                s.getUniforms().setValue(e, "morphTexture", i.morphTexture, n);
            else {
                let t = 0;
                for (let e = 0; e < l.length; e++)
                    t += l[e];
                const n = a.morphTargetsRelative ? 1 : 1 - t;
                s.getUniforms().setValue(e, "morphTargetBaseInfluence", n),
                s.getUniforms().setValue(e, "morphTargetInfluences", l)
            }
            s.getUniforms().setValue(e, "morphTargetsTexture", d.texture, n),
            s.getUniforms().setValue(e, "morphTargetsTextureSize", d.size)
        }
    }
}
function pf(e, t, n, r) {
    let o = new WeakMap;
    function i(e) {
        const t = e.target;
        t.removeEventListener("dispose", i),
        n.remove(t.instanceMatrix),
        null !== t.instanceColor && n.remove(t.instanceColor)
    }
    return {
        update: function(a) {
            const s = r.render.frame,
                l = a.geometry,
                c = t.get(a, l);
            if (o.get(c) !== s && (t.update(c), o.set(c, s)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", i) && a.addEventListener("dispose", i), o.get(a) !== s && (n.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER), o.set(a, s))), a.isSkinnedMesh) {
                const e = a.skeleton;
                o.get(e) !== s && (e.update(), o.set(e, s))
            }
            return c
        },
        dispose: function() {
            o = new WeakMap
        }
    }
}
const hf = new Ll,
    ff = new fp(1, 1),
    gf = new zl,
    mf = new Ql,
    bf = new nd,
    Af = [],
    yf = [],
    vf = new Float32Array(16),
    _f = new Float32Array(9),
    xf = new Float32Array(4);
function wf(e, t, n) {
    const r = e[0];
    if (r <= 0 || r > 0)
        return e;
    const o = t * n;
    let i = Af[o];
    if (void 0 === i && (i = new Float32Array(o), Af[o] = i), 0 !== t) {
        r.toArray(i, 0);
        for (let r = 1, o = 0; r !== t; ++r)
            o += n,
            e[r].toArray(i, o)
    }
    return i
}
function Cf(e, t) {
    if (e.length !== t.length)
        return !1;
    for (let n = 0, r = e.length; n < r; n++)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function Ef(e, t) {
    for (let n = 0, r = t.length; n < r; n++)
        e[n] = t[n]
}
function Sf(e, t) {
    let n = yf[t];
    void 0 === n && (n = new Int32Array(t), yf[t] = n);
    for (let r = 0; r !== t; ++r)
        n[r] = e.allocateTextureUnit();
    return n
}
function If(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
}
function Tf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
    else {
        if (Cf(n, t))
            return;
        e.uniform2fv(this.addr, t),
        Ef(n, t)
    }
}
function Mf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
    else if (void 0 !== t.r)
        n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
    else {
        if (Cf(n, t))
            return;
        e.uniform3fv(this.addr, t),
        Ef(n, t)
    }
}
function Rf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
    else {
        if (Cf(n, t))
            return;
        e.uniform4fv(this.addr, t),
        Ef(n, t)
    }
}
function Bf(e, t) {
    const n = this.cache,
        r = t.elements;
    if (void 0 === r) {
        if (Cf(n, t))
            return;
        e.uniformMatrix2fv(this.addr, !1, t),
        Ef(n, t)
    } else {
        if (Cf(n, r))
            return;
        xf.set(r),
        e.uniformMatrix2fv(this.addr, !1, xf),
        Ef(n, r)
    }
}
function kf(e, t) {
    const n = this.cache,
        r = t.elements;
    if (void 0 === r) {
        if (Cf(n, t))
            return;
        e.uniformMatrix3fv(this.addr, !1, t),
        Ef(n, t)
    } else {
        if (Cf(n, r))
            return;
        _f.set(r),
        e.uniformMatrix3fv(this.addr, !1, _f),
        Ef(n, r)
    }
}
function Df(e, t) {
    const n = this.cache,
        r = t.elements;
    if (void 0 === r) {
        if (Cf(n, t))
            return;
        e.uniformMatrix4fv(this.addr, !1, t),
        Ef(n, t)
    } else {
        if (Cf(n, r))
            return;
        vf.set(r),
        e.uniformMatrix4fv(this.addr, !1, vf),
        Ef(n, r)
    }
}
function Pf(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
}
function Of(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
    else {
        if (Cf(n, t))
            return;
        e.uniform2iv(this.addr, t),
        Ef(n, t)
    }
}
function Lf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
    else {
        if (Cf(n, t))
            return;
        e.uniform3iv(this.addr, t),
        Ef(n, t)
    }
}
function Nf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
    else {
        if (Cf(n, t))
            return;
        e.uniform4iv(this.addr, t),
        Ef(n, t)
    }
}
function Ff(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
}
function Uf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
    else {
        if (Cf(n, t))
            return;
        e.uniform2uiv(this.addr, t),
        Ef(n, t)
    }
}
function zf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
    else {
        if (Cf(n, t))
            return;
        e.uniform3uiv(this.addr, t),
        Ef(n, t)
    }
}
function Qf(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
    else {
        if (Cf(n, t))
            return;
        e.uniform4uiv(this.addr, t),
        Ef(n, t)
    }
}
function Gf(e, t, n) {
    const r = this.cache,
        o = n.allocateTextureUnit();
    let i;
    r[0] !== o && (e.uniform1i(this.addr, o), r[0] = o),
    this.type === e.SAMPLER_2D_SHADOW ? (ff.compareFunction = 515, i = ff) : i = hf,
    n.setTexture2D(t || i, o)
}
function jf(e, t, n) {
    const r = this.cache,
        o = n.allocateTextureUnit();
    r[0] !== o && (e.uniform1i(this.addr, o), r[0] = o),
    n.setTexture3D(t || mf, o)
}
function Vf(e, t, n) {
    const r = this.cache,
        o = n.allocateTextureUnit();
    r[0] !== o && (e.uniform1i(this.addr, o), r[0] = o),
    n.setTextureCube(t || bf, o)
}
function Hf(e, t, n) {
    const r = this.cache,
        o = n.allocateTextureUnit();
    r[0] !== o && (e.uniform1i(this.addr, o), r[0] = o),
    n.setTexture2DArray(t || gf, o)
}
function $f(e, t) {
    e.uniform1fv(this.addr, t)
}
function Wf(e, t) {
    const n = wf(t, this.size, 2);
    e.uniform2fv(this.addr, n)
}
function Kf(e, t) {
    const n = wf(t, this.size, 3);
    e.uniform3fv(this.addr, n)
}
function qf(e, t) {
    const n = wf(t, this.size, 4);
    e.uniform4fv(this.addr, n)
}
function Xf(e, t) {
    const n = wf(t, this.size, 4);
    e.uniformMatrix2fv(this.addr, !1, n)
}
function Yf(e, t) {
    const n = wf(t, this.size, 9);
    e.uniformMatrix3fv(this.addr, !1, n)
}
function Jf(e, t) {
    const n = wf(t, this.size, 16);
    e.uniformMatrix4fv(this.addr, !1, n)
}
function Zf(e, t) {
    e.uniform1iv(this.addr, t)
}
function eg(e, t) {
    e.uniform2iv(this.addr, t)
}
function tg(e, t) {
    e.uniform3iv(this.addr, t)
}
function ng(e, t) {
    e.uniform4iv(this.addr, t)
}
function rg(e, t) {
    e.uniform1uiv(this.addr, t)
}
function og(e, t) {
    e.uniform2uiv(this.addr, t)
}
function ig(e, t) {
    e.uniform3uiv(this.addr, t)
}
function ag(e, t) {
    e.uniform4uiv(this.addr, t)
}
function sg(e, t, n) {
    const r = this.cache,
        o = t.length,
        i = Sf(n, o);
    Cf(r, i) || (e.uniform1iv(this.addr, i), Ef(r, i));
    for (let a = 0; a !== o; ++a)
        n.setTexture2D(t[a] || hf, i[a])
}
function lg(e, t, n) {
    const r = this.cache,
        o = t.length,
        i = Sf(n, o);
    Cf(r, i) || (e.uniform1iv(this.addr, i), Ef(r, i));
    for (let a = 0; a !== o; ++a)
        n.setTexture3D(t[a] || mf, i[a])
}
function cg(e, t, n) {
    const r = this.cache,
        o = t.length,
        i = Sf(n, o);
    Cf(r, i) || (e.uniform1iv(this.addr, i), Ef(r, i));
    for (let a = 0; a !== o; ++a)
        n.setTextureCube(t[a] || bf, i[a])
}
function ug(e, t, n) {
    const r = this.cache,
        o = t.length,
        i = Sf(n, o);
    Cf(r, i) || (e.uniform1iv(this.addr, i), Ef(r, i));
    for (let a = 0; a !== o; ++a)
        n.setTexture2DArray(t[a] || gf, i[a])
}
class dg {
    constructor(e, t, n)
    {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return If;
            case 35664:
                return Tf;
            case 35665:
                return Mf;
            case 35666:
                return Rf;
            case 35674:
                return Bf;
            case 35675:
                return kf;
            case 35676:
                return Df;
            case 5124:
            case 35670:
                return Pf;
            case 35667:
            case 35671:
                return Of;
            case 35668:
            case 35672:
                return Lf;
            case 35669:
            case 35673:
                return Nf;
            case 5125:
                return Ff;
            case 36294:
                return Uf;
            case 36295:
                return zf;
            case 36296:
                return Qf;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Gf;
            case 35679:
            case 36299:
            case 36307:
                return jf;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Vf;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Hf
            }
        }(t.type)
    }
}
class pg {
    constructor(e, t, n)
    {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return $f;
            case 35664:
                return Wf;
            case 35665:
                return Kf;
            case 35666:
                return qf;
            case 35674:
                return Xf;
            case 35675:
                return Yf;
            case 35676:
                return Jf;
            case 5124:
            case 35670:
                return Zf;
            case 35667:
            case 35671:
                return eg;
            case 35668:
            case 35672:
                return tg;
            case 35669:
            case 35673:
                return ng;
            case 5125:
                return rg;
            case 36294:
                return og;
            case 36295:
                return ig;
            case 36296:
                return ag;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return sg;
            case 35679:
            case 36299:
            case 36307:
                return lg;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return cg;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return ug
            }
        }(t.type)
    }
}
class hg {
    constructor(e)
    {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n)
    {
        const r = this.seq;
        for (let o = 0, i = r.length; o !== i; ++o) {
            const i = r[o];
            i.setValue(e, t[i.id], n)
        }
    }
}
const fg = /(\w+)(\])?(\[|\.)?/g;
function gg(e, t) {
    e.seq.push(t),
    e.map[t.id] = t
}
function mg(e, t, n) {
    const r = e.name,
        o = r.length;
    for (fg.lastIndex = 0;;) {
        const i = fg.exec(r),
            a = fg.lastIndex;
        let s = i[1];
        const l = "]" === i[2],
            c = i[3];
        if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === o) {
            gg(n, void 0 === c ? new dg(s, e, t) : new pg(s, e, t));
            break
        }
        {
            let e = n.map[s];
            void 0 === e && (e = new hg(s), gg(n, e)),
            n = e
        }
    }
}
class bg {
    constructor(e, t)
    {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < n; ++r) {
            const n = e.getActiveUniform(t, r);
            mg(n, e.getUniformLocation(t, n.name), this)
        }
    }
    setValue(e, t, n, r)
    {
        const o = this.map[t];
        void 0 !== o && o.setValue(e, n, r)
    }
    setOptional(e, t, n)
    {
        const r = t[n];
        void 0 !== r && this.setValue(e, n, r)
    }
    static upload(e, t, n, r)
    {
        for (let o = 0, i = t.length; o !== i; ++o) {
            const i = t[o],
                a = n[i.id];
            !1 !== a.needsUpdate && i.setValue(e, a.value, r)
        }
    }
    static seqWithValue(e, t)
    {
        const n = [];
        for (let r = 0, o = e.length; r !== o; ++r) {
            const o = e[r];
            o.id in t && n.push(o)
        }
        return n
    }
}
function Ag(e, t, n) {
    const r = e.createShader(t);
    return e.shaderSource(r, n), e.compileShader(r), r
}
let yg = 0;
const vg = new ml;
function _g(e, t, n) {
    const r = e.getShaderParameter(t, e.COMPILE_STATUS),
        o = (e.getShaderInfoLog(t) || "").trim();
    if (r && "" === o)
        return "";
    const i = /ERROR: 0:(\d+)/.exec(o);
    if (i) {
        const r = parseInt(i[1]);
        return n.toUpperCase() + "\n\n" + o + "\n\n" + function(e, t) {
            const n = e.split("\n"),
                r = [],
                o = Math.max(t - 6, 0),
                i = Math.min(t + 6, n.length);
            for (let a = o; a < i; a++) {
                const e = a + 1;
                r.push(`${e === t ? ">" : " "} ${e}: ${n[a]}`)
            }
            return r.join("\n")
        }(e.getShaderSource(t), r)
    }
    return o
}
function xg(e, t) {
    const n = function(e) {
        Sl._getMatrix(vg, Sl.workingColorSpace, e);
        const t = `mat3( ${vg.elements.map(e => e.toFixed(4))} )`;
        switch (Sl.getTransfer(e)) {
        case Fs:
            return [t, "LinearTransferOETF"];
        case Us:
            return [t, "sRGBTransferOETF"];
        default:
            return [t, "LinearTransferOETF"]
        }
    }(t);
    return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
}
function wg(e, t) {
    let n;
    switch (t) {
    case 1:
    default:
        n = "Linear";
        break;
    case 2:
        n = "Reinhard";
        break;
    case 3:
        n = "Cineon";
        break;
    case 4:
        n = "ACESFilmic";
        break;
    case 6:
        n = "AgX";
        break;
    case 7:
        n = "Neutral";
        break;
    case 5:
        n = "Custom"
    }
    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}
const Cg = new hl;
function Eg(e) {
    return "" !== e
}
function Sg(e, t) {
    const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}
function Ig(e, t) {
    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}
const Tg = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Mg(e) {
    return e.replace(Tg, Bg)
}
const Rg = new Map;
function Bg(e, t) {
    let n = Bh[t];
    if (void 0 === n) {
        const e = Rg.get(t);
        if (void 0 === e)
            throw new Error("Can not resolve #include <" + t + ">");
        n = Bh[e]
    }
    return Mg(n)
}
const kg = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Dg(e) {
    return e.replace(kg, Pg)
}
function Pg(e, t, n, r) {
    let o = "";
    for (let i = parseInt(t); i < parseInt(n); i++)
        o += r.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    return o
}
function Og(e) {
    let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
    return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
}
function Lg(e, t, n, r) {
    const o = e.getContext(),
        i = n.defines;
    let a = n.vertexShader,
        s = n.fragmentShader;
    const l = function(e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
        }(n),
        c = function(e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
                switch (e.envMapMode) {
                case va:
                case _a:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case wa:
                    t = "ENVMAP_TYPE_CUBE_UV"
                }
            return t
        }(n),
        u = function(e) {
            let t = "ENVMAP_MODE_REFLECTION";
            return e.envMap && e.envMapMode === _a && (t = "ENVMAP_MODE_REFRACTION"), t
        }(n),
        d = function(e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
                switch (e.combine) {
                case 0:
                    t = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    t = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    t = "ENVMAP_BLENDING_ADD"
                }
            return t
        }(n),
        p = function(e) {
            const t = e.envMapCubeUVHeight;
            if (null === t)
                return null;
            const n = Math.log2(t) - 2,
                r = 1 / t;
            return {
                texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                texelHeight: r,
                maxMip: n
            }
        }(n),
        h = function(e) {
            return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Eg).join("\n")
        }(n),
        f = function(e) {
            const t = [];
            for (const n in e) {
                const r = e[n];
                !1 !== r && t.push("#define " + n + " " + r)
            }
            return t.join("\n")
        }(i),
        g = o.createProgram();
    let m,
        b,
        A = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Eg).join("\n"), m.length > 0 && (m += "\n"), b = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Eg).join("\n"), b.length > 0 && (b += "\n")) : (m = [Og(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Eg).join("\n"), b = [Og(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Bh.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? wg("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Bh.colorspace_pars_fragment, xg("linearToOutputTexel", n.outputColorSpace), (Sl.getLuminanceCoefficients(Cg), ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${Cg.x.toFixed(4)}, ${Cg.y.toFixed(4)}, ${Cg.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Eg).join("\n")),
    a = Mg(a),
    a = Sg(a, n),
    a = Ig(a, n),
    s = Mg(s),
    s = Sg(s, n),
    s = Ig(s, n),
    a = Dg(a),
    s = Dg(s),
    !0 !== n.isRawShaderMaterial && (A = "#version 300 es\n", m = [h, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, b = ["#define varying in", n.glslVersion === Xs ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Xs ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
    const y = A + m + a,
        v = A + b + s,
        _ = Ag(o, o.VERTEX_SHADER, y),
        x = Ag(o, o.FRAGMENT_SHADER, v);
    function w(t) {
        if (e.debug.checkShaderErrors) {
            const n = o.getProgramInfoLog(g) || "",
                r = o.getShaderInfoLog(_) || "",
                i = o.getShaderInfoLog(x) || "",
                a = n.trim(),
                s = r.trim(),
                l = i.trim();
            let c = !0,
                u = !0;
            !1 === o.getProgramParameter(g, o.LINK_STATUS) ? (c = !1, "function" == typeof e.debug.onShaderError ? e.debug.onShaderError(o, g, _, x) : (_g(o, _, "vertex"), _g(o, x, "fragment"))) : "" !== a || "" !== s && "" !== l || (u = !1),
            u && (t.diagnostics = {
                runnable: c,
                programLog: a,
                vertexShader: {
                    log: s,
                    prefix: m
                },
                fragmentShader: {
                    log: l,
                    prefix: b
                }
            })
        }
        o.deleteShader(_),
        o.deleteShader(x),
        C = new bg(o, g),
        E = function(e, t) {
            const n = {},
                r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
            for (let o = 0; o < r; o++) {
                const r = e.getActiveAttrib(t, o),
                    i = r.name;
                let a = 1;
                r.type === e.FLOAT_MAT2 && (a = 2),
                r.type === e.FLOAT_MAT3 && (a = 3),
                r.type === e.FLOAT_MAT4 && (a = 4),
                n[i] = {
                    type: r.type,
                    location: e.getAttribLocation(t, i),
                    locationSize: a
                }
            }
            return n
        }(o, g)
    }
    let C,
        E;
    o.attachShader(g, _),
    o.attachShader(g, x),
    void 0 !== n.index0AttributeName ? o.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(g, 0, "position"),
    o.linkProgram(g),
    this.getUniforms = function() {
        return void 0 === C && w(this), C
    },
    this.getAttributes = function() {
        return void 0 === E && w(this), E
    };
    let S = !1 === n.rendererExtensionParallelShaderCompile;
    return this.isReady = function() {
        return !1 === S && (S = o.getProgramParameter(g, 37297)), S
    }, this.destroy = function() {
        r.releaseStatesOfProgram(this),
        o.deleteProgram(g),
        this.program = void 0
    }, this.type = n.shaderType, this.name = n.shaderName, this.id = yg++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = _, this.fragmentShader = x, this
}
let Ng = 0;
class Fg {
    constructor()
    {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e)
    {
        const t = e.vertexShader,
            n = e.fragmentShader,
            r = this._getShaderStage(t),
            o = this._getShaderStage(n),
            i = this._getShaderCacheForMaterial(e);
        return !1 === i.has(r) && (i.add(r), r.usedTimes++), !1 === i.has(o) && (i.add(o), o.usedTimes++), this
    }
    remove(e)
    {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            0 === n.usedTimes && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e)
    {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e)
    {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose()
    {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e)
    {
        const t = this.materialCache;
        let n = t.get(e);
        return void 0 === n && (n = new Set, t.set(e, n)), n
    }
    _getShaderStage(e)
    {
        const t = this.shaderCache;
        let n = t.get(e);
        return void 0 === n && (n = new Ug(e), t.set(e, n)), n
    }
}
class Ug {
    constructor(e)
    {
        this.id = Ng++,
        this.code = e,
        this.usedTimes = 0
    }
}
function zg(e, t, n, r, o, i, a) {
    const s = new Sc,
        l = new Fg,
        c = new Set,
        u = [],
        d = o.logarithmicDepthBuffer,
        p = o.vertexTextures;
    let h = o.precision;
    const f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(e) {
        return c.add(e), 0 === e ? "uv" : `uv${e}`
    }
    return {
        getParameters: function(i, s, u, m, b) {
            const A = m.fog,
                y = b.geometry,
                v = i.isMeshStandardMaterial ? m.environment : null,
                _ = (i.isMeshStandardMaterial ? n : t).get(i.envMap || v),
                x = _ && _.mapping === wa ? _.image.height : null,
                w = f[i.type];
            null !== i.precision && (h = o.getMaxPrecision(i.precision), i.precision);
            const C = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                E = void 0 !== C ? C.length : 0;
            let S,
                I,
                T,
                M,
                R = 0;
            if (void 0 !== y.morphAttributes.position && (R = 1), void 0 !== y.morphAttributes.normal && (R = 2), void 0 !== y.morphAttributes.color && (R = 3), w) {
                const e = Dh[w];
                S = e.vertexShader,
                I = e.fragmentShader
            } else
                S = i.vertexShader,
                I = i.fragmentShader,
                l.update(i),
                T = l.getVertexShaderID(i),
                M = l.getFragmentShaderID(i);
            const B = e.getRenderTarget(),
                k = e.state.buffers.depth.getReversed(),
                D = !0 === b.isInstancedMesh,
                P = !0 === b.isBatchedMesh,
                O = !!i.map,
                L = !!i.matcap,
                N = !!_,
                F = !!i.aoMap,
                U = !!i.lightMap,
                z = !!i.bumpMap,
                Q = !!i.normalMap,
                G = !!i.displacementMap,
                j = !!i.emissiveMap,
                V = !!i.metalnessMap,
                H = !!i.roughnessMap,
                $ = i.anisotropy > 0,
                W = i.clearcoat > 0,
                K = i.dispersion > 0,
                q = i.iridescence > 0,
                X = i.sheen > 0,
                Y = i.transmission > 0,
                J = $ && !!i.anisotropyMap,
                Z = W && !!i.clearcoatMap,
                ee = W && !!i.clearcoatNormalMap,
                te = W && !!i.clearcoatRoughnessMap,
                ne = q && !!i.iridescenceMap,
                re = q && !!i.iridescenceThicknessMap,
                oe = X && !!i.sheenColorMap,
                ie = X && !!i.sheenRoughnessMap,
                ae = !!i.specularMap,
                se = !!i.specularColorMap,
                le = !!i.specularIntensityMap,
                ce = Y && !!i.transmissionMap,
                ue = Y && !!i.thicknessMap,
                de = !!i.gradientMap,
                pe = !!i.alphaMap,
                he = i.alphaTest > 0,
                fe = !!i.alphaHash,
                ge = !!i.extensions;
            let me = 0;
            i.toneMapped && (null !== B && !0 !== B.isXRRenderTarget || (me = e.toneMapping));
            const be = {
                shaderID: w,
                shaderType: i.type,
                shaderName: i.name,
                vertexShader: S,
                fragmentShader: I,
                defines: i.defines,
                customVertexShaderID: T,
                customFragmentShaderID: M,
                isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                glslVersion: i.glslVersion,
                precision: h,
                batching: P,
                batchingColor: P && null !== b._colorsTexture,
                instancing: D,
                instancingColor: D && null !== b.instanceColor,
                instancingMorph: D && null !== b.morphTexture,
                supportsVertexTextures: p,
                outputColorSpace: null === B ? e.outputColorSpace : !0 === B.isXRRenderTarget ? B.texture.colorSpace : Ns,
                alphaToCoverage: !!i.alphaToCoverage,
                map: O,
                matcap: L,
                envMap: N,
                envMapMode: N && _.mapping,
                envMapCubeUVHeight: x,
                aoMap: F,
                lightMap: U,
                bumpMap: z,
                normalMap: Q,
                displacementMap: p && G,
                emissiveMap: j,
                normalMapObjectSpace: Q && 1 === i.normalMapType,
                normalMapTangentSpace: Q && 0 === i.normalMapType,
                metalnessMap: V,
                roughnessMap: H,
                anisotropy: $,
                anisotropyMap: J,
                clearcoat: W,
                clearcoatMap: Z,
                clearcoatNormalMap: ee,
                clearcoatRoughnessMap: te,
                dispersion: K,
                iridescence: q,
                iridescenceMap: ne,
                iridescenceThicknessMap: re,
                sheen: X,
                sheenColorMap: oe,
                sheenRoughnessMap: ie,
                specularMap: ae,
                specularColorMap: se,
                specularIntensityMap: le,
                transmission: Y,
                transmissionMap: ce,
                thicknessMap: ue,
                gradientMap: de,
                opaque: !1 === i.transparent && 1 === i.blending && !1 === i.alphaToCoverage,
                alphaMap: pe,
                alphaTest: he,
                alphaHash: fe,
                combine: i.combine,
                mapUv: O && g(i.map.channel),
                aoMapUv: F && g(i.aoMap.channel),
                lightMapUv: U && g(i.lightMap.channel),
                bumpMapUv: z && g(i.bumpMap.channel),
                normalMapUv: Q && g(i.normalMap.channel),
                displacementMapUv: G && g(i.displacementMap.channel),
                emissiveMapUv: j && g(i.emissiveMap.channel),
                metalnessMapUv: V && g(i.metalnessMap.channel),
                roughnessMapUv: H && g(i.roughnessMap.channel),
                anisotropyMapUv: J && g(i.anisotropyMap.channel),
                clearcoatMapUv: Z && g(i.clearcoatMap.channel),
                clearcoatNormalMapUv: ee && g(i.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: te && g(i.clearcoatRoughnessMap.channel),
                iridescenceMapUv: ne && g(i.iridescenceMap.channel),
                iridescenceThicknessMapUv: re && g(i.iridescenceThicknessMap.channel),
                sheenColorMapUv: oe && g(i.sheenColorMap.channel),
                sheenRoughnessMapUv: ie && g(i.sheenRoughnessMap.channel),
                specularMapUv: ae && g(i.specularMap.channel),
                specularColorMapUv: se && g(i.specularColorMap.channel),
                specularIntensityMapUv: le && g(i.specularIntensityMap.channel),
                transmissionMapUv: ce && g(i.transmissionMap.channel),
                thicknessMapUv: ue && g(i.thicknessMap.channel),
                alphaMapUv: pe && g(i.alphaMap.channel),
                vertexTangents: !!y.attributes.tangent && (Q || $),
                vertexColors: i.vertexColors,
                vertexAlphas: !0 === i.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                pointsUvs: !0 === b.isPoints && !!y.attributes.uv && (O || pe),
                fog: !!A,
                useFog: !0 === i.fog,
                fogExp2: !!A && A.isFogExp2,
                flatShading: !0 === i.flatShading && !1 === i.wireframe,
                sizeAttenuation: !0 === i.sizeAttenuation,
                logarithmicDepthBuffer: d,
                reversedDepthBuffer: k,
                skinning: !0 === b.isSkinnedMesh,
                morphTargets: void 0 !== y.morphAttributes.position,
                morphNormals: void 0 !== y.morphAttributes.normal,
                morphColors: void 0 !== y.morphAttributes.color,
                morphTargetsCount: E,
                morphTextureStride: R,
                numDirLights: s.directional.length,
                numPointLights: s.point.length,
                numSpotLights: s.spot.length,
                numSpotLightMaps: s.spotLightMap.length,
                numRectAreaLights: s.rectArea.length,
                numHemiLights: s.hemi.length,
                numDirLightShadows: s.directionalShadowMap.length,
                numPointLightShadows: s.pointShadowMap.length,
                numSpotLightShadows: s.spotShadowMap.length,
                numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                numLightProbes: s.numLightProbes,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: i.dithering,
                shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: me,
                decodeVideoTexture: O && !0 === i.map.isVideoTexture && Sl.getTransfer(i.map.colorSpace) === Us,
                decodeVideoTextureEmissive: j && !0 === i.emissiveMap.isVideoTexture && Sl.getTransfer(i.emissiveMap.colorSpace) === Us,
                premultipliedAlpha: i.premultipliedAlpha,
                doubleSided: 2 === i.side,
                flipSided: 1 === i.side,
                useDepthPacking: i.depthPacking >= 0,
                depthPacking: i.depthPacking || 0,
                index0AttributeName: i.index0AttributeName,
                extensionClipCullDistance: ge && !0 === i.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: (ge && !0 === i.extensions.multiDraw || P) && r.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: i.customProgramCacheKey()
            };
            return be.vertexUv1s = c.has(1), be.vertexUv2s = c.has(2), be.vertexUv3s = c.has(3), c.clear(), be
        },
        getProgramCacheKey: function(t) {
            const n = [];
            if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                for (const e in t.defines)
                    n.push(e),
                    n.push(t.defines[e]);
            return !1 === t.isRawShaderMaterial && (function(e, t) {
                e.push(t.precision),
                e.push(t.outputColorSpace),
                e.push(t.envMapMode),
                e.push(t.envMapCubeUVHeight),
                e.push(t.mapUv),
                e.push(t.alphaMapUv),
                e.push(t.lightMapUv),
                e.push(t.aoMapUv),
                e.push(t.bumpMapUv),
                e.push(t.normalMapUv),
                e.push(t.displacementMapUv),
                e.push(t.emissiveMapUv),
                e.push(t.metalnessMapUv),
                e.push(t.roughnessMapUv),
                e.push(t.anisotropyMapUv),
                e.push(t.clearcoatMapUv),
                e.push(t.clearcoatNormalMapUv),
                e.push(t.clearcoatRoughnessMapUv),
                e.push(t.iridescenceMapUv),
                e.push(t.iridescenceThicknessMapUv),
                e.push(t.sheenColorMapUv),
                e.push(t.sheenRoughnessMapUv),
                e.push(t.specularMapUv),
                e.push(t.specularColorMapUv),
                e.push(t.specularIntensityMapUv),
                e.push(t.transmissionMapUv),
                e.push(t.thicknessMapUv),
                e.push(t.combine),
                e.push(t.fogExp2),
                e.push(t.sizeAttenuation),
                e.push(t.morphTargetsCount),
                e.push(t.morphAttributeCount),
                e.push(t.numDirLights),
                e.push(t.numPointLights),
                e.push(t.numSpotLights),
                e.push(t.numSpotLightMaps),
                e.push(t.numHemiLights),
                e.push(t.numRectAreaLights),
                e.push(t.numDirLightShadows),
                e.push(t.numPointLightShadows),
                e.push(t.numSpotLightShadows),
                e.push(t.numSpotLightShadowsWithMaps),
                e.push(t.numLightProbes),
                e.push(t.shadowMapType),
                e.push(t.toneMapping),
                e.push(t.numClippingPlanes),
                e.push(t.numClipIntersection),
                e.push(t.depthPacking)
            }(n, t), function(e, t) {
                s.disableAll(),
                t.supportsVertexTextures && s.enable(0),
                t.instancing && s.enable(1),
                t.instancingColor && s.enable(2),
                t.instancingMorph && s.enable(3),
                t.matcap && s.enable(4),
                t.envMap && s.enable(5),
                t.normalMapObjectSpace && s.enable(6),
                t.normalMapTangentSpace && s.enable(7),
                t.clearcoat && s.enable(8),
                t.iridescence && s.enable(9),
                t.alphaTest && s.enable(10),
                t.vertexColors && s.enable(11),
                t.vertexAlphas && s.enable(12),
                t.vertexUv1s && s.enable(13),
                t.vertexUv2s && s.enable(14),
                t.vertexUv3s && s.enable(15),
                t.vertexTangents && s.enable(16),
                t.anisotropy && s.enable(17),
                t.alphaHash && s.enable(18),
                t.batching && s.enable(19),
                t.dispersion && s.enable(20),
                t.batchingColor && s.enable(21),
                t.gradientMap && s.enable(22),
                e.push(s.mask),
                s.disableAll(),
                t.fog && s.enable(0),
                t.useFog && s.enable(1),
                t.flatShading && s.enable(2),
                t.logarithmicDepthBuffer && s.enable(3),
                t.reversedDepthBuffer && s.enable(4),
                t.skinning && s.enable(5),
                t.morphTargets && s.enable(6),
                t.morphNormals && s.enable(7),
                t.morphColors && s.enable(8),
                t.premultipliedAlpha && s.enable(9),
                t.shadowMapEnabled && s.enable(10),
                t.doubleSided && s.enable(11),
                t.flipSided && s.enable(12),
                t.useDepthPacking && s.enable(13),
                t.dithering && s.enable(14),
                t.transmission && s.enable(15),
                t.sheen && s.enable(16),
                t.opaque && s.enable(17),
                t.pointsUvs && s.enable(18),
                t.decodeVideoTexture && s.enable(19),
                t.decodeVideoTextureEmissive && s.enable(20),
                t.alphaToCoverage && s.enable(21),
                e.push(s.mask)
            }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
        },
        getUniforms: function(e) {
            const t = f[e.type];
            let n;
            if (t) {
                const e = Dh[t];
                n = Wu.clone(e.uniforms)
            } else
                n = e.uniforms;
            return n
        },
        acquireProgram: function(t, n) {
            let r;
            for (let e = 0, o = u.length; e < o; e++) {
                const t = u[e];
                if (t.cacheKey === n) {
                    r = t,
                    ++r.usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new Lg(e, n, t, i), u.push(r)), r
        },
        releaseProgram: function(e) {
            if (0 === --e.usedTimes) {
                const t = u.indexOf(e);
                u[t] = u[u.length - 1],
                u.pop(),
                e.destroy()
            }
        },
        releaseShaderCache: function(e) {
            l.remove(e)
        },
        programs: u,
        dispose: function() {
            l.dispose()
        }
    }
}
function Qg() {
    let e = new WeakMap;
    return {
        has: function(t) {
            return e.has(t)
        },
        get: function(t) {
            let n = e.get(t);
            return void 0 === n && (n = {}, e.set(t, n)), n
        },
        remove: function(t) {
            e.delete(t)
        },
        update: function(t, n, r) {
            e.get(t)[n] = r
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function Gg(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
}
function jg(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
}
function Vg() {
    const e = [];
    let t = 0;
    const n = [],
        r = [],
        o = [];
    function i(n, r, o, i, a, s) {
        let l = e[t];
        return void 0 === l ? (l = {
            id: n.id,
            object: n,
            geometry: r,
            material: o,
            groupOrder: i,
            renderOrder: n.renderOrder,
            z: a,
            group: s
        }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = o, l.groupOrder = i, l.renderOrder = n.renderOrder, l.z = a, l.group = s), t++, l
    }
    return {
        opaque: n,
        transmissive: r,
        transparent: o,
        init: function() {
            t = 0,
            n.length = 0,
            r.length = 0,
            o.length = 0
        },
        push: function(e, t, a, s, l, c) {
            const u = i(e, t, a, s, l, c);
            a.transmission > 0 ? r.push(u) : !0 === a.transparent ? o.push(u) : n.push(u)
        },
        unshift: function(e, t, a, s, l, c) {
            const u = i(e, t, a, s, l, c);
            a.transmission > 0 ? r.unshift(u) : !0 === a.transparent ? o.unshift(u) : n.unshift(u)
        },
        finish: function() {
            for (let n = t, r = e.length; n < r; n++) {
                const t = e[n];
                if (null === t.id)
                    break;
                t.id = null,
                t.object = null,
                t.geometry = null,
                t.material = null,
                t.group = null
            }
        },
        sort: function(e, t) {
            n.length > 1 && n.sort(e || Gg),
            r.length > 1 && r.sort(t || jg),
            o.length > 1 && o.sort(t || jg)
        }
    }
}
function Hg() {
    let e = new WeakMap;
    return {
        get: function(t, n) {
            const r = e.get(t);
            let o;
            return void 0 === r ? (o = new Vg, e.set(t, [o])) : n >= r.length ? (o = new Vg, r.push(o)) : o = r[n], o
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function $g() {
    const e = {};
    return {
        get: function(t) {
            if (void 0 !== e[t.id])
                return e[t.id];
            let n;
            switch (t.type) {
            case "DirectionalLight":
                n = {
                    direction: new hl,
                    color: new su
                };
                break;
            case "SpotLight":
                n = {
                    position: new hl,
                    direction: new hl,
                    color: new su,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                n = {
                    position: new hl,
                    color: new su,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                n = {
                    direction: new hl,
                    skyColor: new su,
                    groundColor: new su
                };
                break;
            case "RectAreaLight":
                n = {
                    color: new su,
                    position: new hl,
                    halfWidth: new hl,
                    halfHeight: new hl
                }
            }
            return e[t.id] = n, n
        }
    }
}
let Wg = 0;
function Kg(e, t) {
    return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
}
function qg(e) {
    const t = new $g,
        n = function() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                        n = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new dl
                        };
                        break;
                    case "PointLight":
                        n = {
                            shadowIntensity: 1,
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new dl,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        }
                    }
                    return e[t.id] = n, n
                }
            }
        }(),
        r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let s = 0; s < 9; s++)
        r.probe.push(new hl);
    const o = new hl,
        i = new gc,
        a = new gc;
    return {
        setup: function(o) {
            let i = 0,
                a = 0,
                s = 0;
            for (let e = 0; e < 9; e++)
                r.probe[e].set(0, 0, 0);
            let l = 0,
                c = 0,
                u = 0,
                d = 0,
                p = 0,
                h = 0,
                f = 0,
                g = 0,
                m = 0,
                b = 0,
                A = 0;
            o.sort(Kg);
            for (let e = 0, v = o.length; e < v; e++) {
                const y = o[e],
                    v = y.color,
                    _ = y.intensity,
                    x = y.distance,
                    w = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                if (y.isAmbientLight)
                    i += v.r * _,
                    a += v.g * _,
                    s += v.b * _;
                else if (y.isLightProbe) {
                    for (let e = 0; e < 9; e++)
                        r.probe[e].addScaledVector(y.sh.coefficients[e], _);
                    A++
                } else if (y.isDirectionalLight) {
                    const e = t.get(y);
                    if (e.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) {
                        const e = y.shadow,
                            t = n.get(y);
                        t.shadowIntensity = e.intensity,
                        t.shadowBias = e.bias,
                        t.shadowNormalBias = e.normalBias,
                        t.shadowRadius = e.radius,
                        t.shadowMapSize = e.mapSize,
                        r.directionalShadow[l] = t,
                        r.directionalShadowMap[l] = w,
                        r.directionalShadowMatrix[l] = y.shadow.matrix,
                        h++
                    }
                    r.directional[l] = e,
                    l++
                } else if (y.isSpotLight) {
                    const e = t.get(y);
                    e.position.setFromMatrixPosition(y.matrixWorld),
                    e.color.copy(v).multiplyScalar(_),
                    e.distance = x,
                    e.coneCos = Math.cos(y.angle),
                    e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)),
                    e.decay = y.decay,
                    r.spot[u] = e;
                    const o = y.shadow;
                    if (y.map && (r.spotLightMap[m] = y.map, m++, o.updateMatrices(y), y.castShadow && b++), r.spotLightMatrix[u] = o.matrix, y.castShadow) {
                        const e = n.get(y);
                        e.shadowIntensity = o.intensity,
                        e.shadowBias = o.bias,
                        e.shadowNormalBias = o.normalBias,
                        e.shadowRadius = o.radius,
                        e.shadowMapSize = o.mapSize,
                        r.spotShadow[u] = e,
                        r.spotShadowMap[u] = w,
                        g++
                    }
                    u++
                } else if (y.isRectAreaLight) {
                    const e = t.get(y);
                    e.color.copy(v).multiplyScalar(_),
                    e.halfWidth.set(.5 * y.width, 0, 0),
                    e.halfHeight.set(0, .5 * y.height, 0),
                    r.rectArea[d] = e,
                    d++
                } else if (y.isPointLight) {
                    const e = t.get(y);
                    if (e.color.copy(y.color).multiplyScalar(y.intensity), e.distance = y.distance, e.decay = y.decay, y.castShadow) {
                        const e = y.shadow,
                            t = n.get(y);
                        t.shadowIntensity = e.intensity,
                        t.shadowBias = e.bias,
                        t.shadowNormalBias = e.normalBias,
                        t.shadowRadius = e.radius,
                        t.shadowMapSize = e.mapSize,
                        t.shadowCameraNear = e.camera.near,
                        t.shadowCameraFar = e.camera.far,
                        r.pointShadow[c] = t,
                        r.pointShadowMap[c] = w,
                        r.pointShadowMatrix[c] = y.shadow.matrix,
                        f++
                    }
                    r.point[c] = e,
                    c++
                } else if (y.isHemisphereLight) {
                    const e = t.get(y);
                    e.skyColor.copy(y.color).multiplyScalar(_),
                    e.groundColor.copy(y.groundColor).multiplyScalar(_),
                    r.hemi[p] = e,
                    p++
                }
            }
            d > 0 && (!0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = kh.LTC_FLOAT_1, r.rectAreaLTC2 = kh.LTC_FLOAT_2) : (r.rectAreaLTC1 = kh.LTC_HALF_1, r.rectAreaLTC2 = kh.LTC_HALF_2)),
            r.ambient[0] = i,
            r.ambient[1] = a,
            r.ambient[2] = s;
            const y = r.hash;
            y.directionalLength === l && y.pointLength === c && y.spotLength === u && y.rectAreaLength === d && y.hemiLength === p && y.numDirectionalShadows === h && y.numPointShadows === f && y.numSpotShadows === g && y.numSpotMaps === m && y.numLightProbes === A || (r.directional.length = l, r.spot.length = u, r.rectArea.length = d, r.point.length = c, r.hemi.length = p, r.directionalShadow.length = h, r.directionalShadowMap.length = h, r.pointShadow.length = f, r.pointShadowMap.length = f, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = h, r.pointShadowMatrix.length = f, r.spotLightMatrix.length = g + m - b, r.spotLightMap.length = m, r.numSpotLightShadowsWithMaps = b, r.numLightProbes = A, y.directionalLength = l, y.pointLength = c, y.spotLength = u, y.rectAreaLength = d, y.hemiLength = p, y.numDirectionalShadows = h, y.numPointShadows = f, y.numSpotShadows = g, y.numSpotMaps = m, y.numLightProbes = A, r.version = Wg++)
        },
        setupView: function(e, t) {
            let n = 0,
                s = 0,
                l = 0,
                c = 0,
                u = 0;
            const d = t.matrixWorldInverse;
            for (let p = 0, h = e.length; p < h; p++) {
                const t = e[p];
                if (t.isDirectionalLight) {
                    const e = r.directional[n];
                    e.direction.setFromMatrixPosition(t.matrixWorld),
                    o.setFromMatrixPosition(t.target.matrixWorld),
                    e.direction.sub(o),
                    e.direction.transformDirection(d),
                    n++
                } else if (t.isSpotLight) {
                    const e = r.spot[l];
                    e.position.setFromMatrixPosition(t.matrixWorld),
                    e.position.applyMatrix4(d),
                    e.direction.setFromMatrixPosition(t.matrixWorld),
                    o.setFromMatrixPosition(t.target.matrixWorld),
                    e.direction.sub(o),
                    e.direction.transformDirection(d),
                    l++
                } else if (t.isRectAreaLight) {
                    const e = r.rectArea[c];
                    e.position.setFromMatrixPosition(t.matrixWorld),
                    e.position.applyMatrix4(d),
                    a.identity(),
                    i.copy(t.matrixWorld),
                    i.premultiply(d),
                    a.extractRotation(i),
                    e.halfWidth.set(.5 * t.width, 0, 0),
                    e.halfHeight.set(0, .5 * t.height, 0),
                    e.halfWidth.applyMatrix4(a),
                    e.halfHeight.applyMatrix4(a),
                    c++
                } else if (t.isPointLight) {
                    const e = r.point[s];
                    e.position.setFromMatrixPosition(t.matrixWorld),
                    e.position.applyMatrix4(d),
                    s++
                } else if (t.isHemisphereLight) {
                    const e = r.hemi[u];
                    e.direction.setFromMatrixPosition(t.matrixWorld),
                    e.direction.transformDirection(d),
                    u++
                }
            }
        },
        state: r
    }
}
function Xg(e) {
    const t = new qg(e),
        n = [],
        r = [],
        o = {
            lightsArray: n,
            shadowsArray: r,
            camera: null,
            lights: t,
            transmissionRenderTarget: {}
        };
    return {
        init: function(e) {
            o.camera = e,
            n.length = 0,
            r.length = 0
        },
        state: o,
        setupLights: function() {
            t.setup(n)
        },
        setupLightsView: function(e) {
            t.setupView(n, e)
        },
        pushLight: function(e) {
            n.push(e)
        },
        pushShadow: function(e) {
            r.push(e)
        }
    }
}
function Yg(e) {
    let t = new WeakMap;
    return {
        get: function(n, r=0) {
            const o = t.get(n);
            let i;
            return void 0 === o ? (i = new Xg(e), t.set(n, [i])) : r >= o.length ? (i = new Xg(e), o.push(i)) : i = o[r], i
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}
function Jg(e, t, n) {
    let r = new Gd;
    const o = new dl,
        i = new dl,
        a = new Nl,
        s = new vp({
            depthPacking: 3201
        }),
        l = new _p,
        c = {},
        u = n.maxTextureSize,
        d = {
            [Vi]: 1,
            [Hi]: 0,
            [$i]: 2
        },
        p = new Ku({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new dl
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        }),
        h = p.clone();
    h.defines.HORIZONTAL_PASS = 1;
    const f = new Mu;
    f.setAttribute("position", new Au(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const g = new Qu(f, p),
        m = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = 1;
    let b = this.type;
    function A(n, r) {
        const i = t.update(g);
        p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples, h.defines.VSM_SAMPLES = n.blurSamples, p.needsUpdate = !0, h.needsUpdate = !0),
        null === n.mapPass && (n.mapPass = new Ul(o.x, o.y)),
        p.uniforms.shadow_pass.value = n.map.texture,
        p.uniforms.resolution.value = n.mapSize,
        p.uniforms.radius.value = n.radius,
        e.setRenderTarget(n.mapPass),
        e.clear(),
        e.renderBufferDirect(r, null, i, p, g, null),
        h.uniforms.shadow_pass.value = n.mapPass.texture,
        h.uniforms.resolution.value = n.mapSize,
        h.uniforms.radius.value = n.radius,
        e.setRenderTarget(n.map),
        e.clear(),
        e.renderBufferDirect(r, null, i, h, g, null)
    }
    function y(t, n, r, o) {
        let i = null;
        const a = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
        if (void 0 !== a)
            i = a;
        else if (i = !0 === r.isPointLight ? l : s, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0 || !0 === n.alphaToCoverage) {
            const e = i.uuid,
                t = n.uuid;
            let r = c[e];
            void 0 === r && (r = {}, c[e] = r);
            let o = r[t];
            void 0 === o && (o = i.clone(), r[t] = o, n.addEventListener("dispose", _)),
            i = o
        }
        return i.visible = n.visible, i.wireframe = n.wireframe, i.side = 3 === o ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], i.alphaMap = n.alphaMap, i.alphaTest = !0 === n.alphaToCoverage ? .5 : n.alphaTest, i.map = n.map, i.clipShadows = n.clipShadows, i.clippingPlanes = n.clippingPlanes, i.clipIntersection = n.clipIntersection, i.displacementMap = n.displacementMap, i.displacementScale = n.displacementScale, i.displacementBias = n.displacementBias, i.wireframeLinewidth = n.wireframeLinewidth, i.linewidth = n.linewidth, !0 === r.isPointLight && !0 === i.isMeshDistanceMaterial && (e.properties.get(i).light = r), i
    }
    function v(n, o, i, a, s) {
        if (!1 === n.visible)
            return;
        if (n.layers.test(o.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || r.intersectsObject(n))) {
            n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, n.matrixWorld);
            const r = t.update(n),
                l = n.material;
            if (Array.isArray(l)) {
                const t = r.groups;
                for (let c = 0, u = t.length; c < u; c++) {
                    const u = t[c],
                        d = l[u.materialIndex];
                    if (d && d.visible) {
                        const t = y(n, d, a, s);
                        n.onBeforeShadow(e, n, o, i, r, t, u),
                        e.renderBufferDirect(i, null, r, t, n, u),
                        n.onAfterShadow(e, n, o, i, r, t, u)
                    }
                }
            } else if (l.visible) {
                const t = y(n, l, a, s);
                n.onBeforeShadow(e, n, o, i, r, t, null),
                e.renderBufferDirect(i, null, r, t, n, null),
                n.onAfterShadow(e, n, o, i, r, t, null)
            }
        }
        const l = n.children;
        for (let e = 0, t = l.length; e < t; e++)
            v(l[e], o, i, a, s)
    }
    function _(e) {
        e.target.removeEventListener("dispose", _);
        for (const t in c) {
            const n = c[t],
                r = e.target.uuid;
            r in n && (n[r].dispose(), delete n[r])
        }
    }
    this.render = function(t, n, s) {
        if (!1 === m.enabled)
            return;
        if (!1 === m.autoUpdate && !1 === m.needsUpdate)
            return;
        if (0 === t.length)
            return;
        const l = e.getRenderTarget(),
            c = e.getActiveCubeFace(),
            d = e.getActiveMipmapLevel(),
            p = e.state;
        p.setBlending(0),
        !0 === p.buffers.depth.getReversed() ? p.buffers.color.setClear(0, 0, 0, 0) : p.buffers.color.setClear(1, 1, 1, 1),
        p.buffers.depth.setTest(!0),
        p.setScissorTest(!1);
        const h = 3 !== b && 3 === this.type,
            f = 3 === b && 3 !== this.type;
        for (let g = 0, m = t.length; g < m; g++) {
            const l = t[g],
                c = l.shadow;
            if (void 0 === c)
                continue;
            if (!1 === c.autoUpdate && !1 === c.needsUpdate)
                continue;
            o.copy(c.mapSize);
            const d = c.getFrameExtents();
            if (o.multiply(d), i.copy(c.mapSize), (o.x > u || o.y > u) && (o.x > u && (i.x = Math.floor(u / d.x), o.x = i.x * d.x, c.mapSize.x = i.x), o.y > u && (i.y = Math.floor(u / d.y), o.y = i.y * d.y, c.mapSize.y = i.y)), null === c.map || !0 === h || !0 === f) {
                const e = 3 !== this.type ? {
                    minFilter: Ia,
                    magFilter: Ia
                } : {};
                null !== c.map && c.map.dispose(),
                c.map = new Ul(o.x, o.y, e),
                c.map.texture.name = l.name + ".shadowMap",
                c.camera.updateProjectionMatrix()
            }
            e.setRenderTarget(c.map),
            e.clear();
            const m = c.getViewportCount();
            for (let e = 0; e < m; e++) {
                const t = c.getViewport(e);
                a.set(i.x * t.x, i.y * t.y, i.x * t.z, i.y * t.w),
                p.viewport(a),
                c.updateMatrices(l, e),
                r = c.getFrustum(),
                v(n, s, c.camera, l, this.type)
            }
            !0 !== c.isPointLightShadow && 3 === this.type && A(c, s),
            c.needsUpdate = !1
        }
        b = this.type,
        m.needsUpdate = !1,
        e.setRenderTarget(l, c, d)
    }
}
const Zg = {
    [da]: 1,
    [ha]: 6,
    [ga]: 7,
    [fa]: 5,
    [pa]: 0,
    [ba]: 2,
    [Aa]: 4,
    [ma]: 3
};
function em(e, t) {
    const n = new function() {
            let t = !1;
            const n = new Nl;
            let r = null;
            const o = new Nl(0, 0, 0, 0);
            return {
                setMask: function(n) {
                    r === n || t || (e.colorMask(n, n, n, n), r = n)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, r, i, a, s) {
                    !0 === s && (t *= a, r *= a, i *= a),
                    n.set(t, r, i, a),
                    !1 === o.equals(n) && (e.clearColor(t, r, i, a), o.copy(n))
                },
                reset: function() {
                    t = !1,
                    r = null,
                    o.set(-1, 0, 0, 0)
                }
            }
        },
        r = new function() {
            let n = !1,
                r = !1,
                o = null,
                i = null,
                a = null;
            return {
                setReversed: function(e) {
                    if (r !== e) {
                        const n = t.get("EXT_clip_control");
                        e ? n.clipControlEXT(n.LOWER_LEFT_EXT, n.ZERO_TO_ONE_EXT) : n.clipControlEXT(n.LOWER_LEFT_EXT, n.NEGATIVE_ONE_TO_ONE_EXT),
                        r = e;
                        const o = a;
                        a = null,
                        this.setClear(o)
                    }
                },
                getReversed: function() {
                    return r
                },
                setTest: function(t) {
                    t ? z(e.DEPTH_TEST) : Q(e.DEPTH_TEST)
                },
                setMask: function(t) {
                    o === t || n || (e.depthMask(t), o = t)
                },
                setFunc: function(t) {
                    if (r && (t = Zg[t]), i !== t) {
                        switch (t) {
                        case 0:
                            e.depthFunc(e.NEVER);
                            break;
                        case 1:
                            e.depthFunc(e.ALWAYS);
                            break;
                        case 2:
                            e.depthFunc(e.LESS);
                            break;
                        case 3:
                        default:
                            e.depthFunc(e.LEQUAL);
                            break;
                        case 4:
                            e.depthFunc(e.EQUAL);
                            break;
                        case 5:
                            e.depthFunc(e.GEQUAL);
                            break;
                        case 6:
                            e.depthFunc(e.GREATER);
                            break;
                        case 7:
                            e.depthFunc(e.NOTEQUAL)
                        }
                        i = t
                    }
                },
                setLocked: function(e) {
                    n = e
                },
                setClear: function(t) {
                    a !== t && (r && (t = 1 - t), e.clearDepth(t), a = t)
                },
                reset: function() {
                    n = !1,
                    o = null,
                    i = null,
                    a = null,
                    r = !1
                }
            }
        },
        o = new function() {
            let t = !1,
                n = null,
                r = null,
                o = null,
                i = null,
                a = null,
                s = null,
                l = null,
                c = null;
            return {
                setTest: function(n) {
                    t || (n ? z(e.STENCIL_TEST) : Q(e.STENCIL_TEST))
                },
                setMask: function(r) {
                    n === r || t || (e.stencilMask(r), n = r)
                },
                setFunc: function(t, n, a) {
                    r === t && o === n && i === a || (e.stencilFunc(t, n, a), r = t, o = n, i = a)
                },
                setOp: function(t, n, r) {
                    a === t && s === n && l === r || (e.stencilOp(t, n, r), a = t, s = n, l = r)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    c !== t && (e.clearStencil(t), c = t)
                },
                reset: function() {
                    t = !1,
                    n = null,
                    r = null,
                    o = null,
                    i = null,
                    a = null,
                    s = null,
                    l = null,
                    c = null
                }
            }
        },
        i = new WeakMap,
        a = new WeakMap;
    let s = {},
        l = {},
        c = new WeakMap,
        u = [],
        d = null,
        p = !1,
        h = null,
        f = null,
        g = null,
        m = null,
        b = null,
        A = null,
        y = null,
        v = new su(0, 0, 0),
        _ = 0,
        x = !1,
        w = null,
        C = null,
        E = null,
        S = null,
        I = null;
    const T = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let M = !1,
        R = 0;
    const B = e.getParameter(e.VERSION);
    -1 !== B.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(B)[1]), M = R >= 1) : -1 !== B.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), M = R >= 2);
    let k = null,
        D = {};
    const P = e.getParameter(e.SCISSOR_BOX),
        O = e.getParameter(e.VIEWPORT),
        L = (new Nl).fromArray(P),
        N = (new Nl).fromArray(O);
    function F(t, n, r, o) {
        const i = new Uint8Array(4),
            a = e.createTexture();
        e.bindTexture(t, a),
        e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
        e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
        for (let s = 0; s < r; s++)
            t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, o, 0, e.RGBA, e.UNSIGNED_BYTE, i) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, i);
        return a
    }
    const U = {};
    function z(t) {
        !0 !== s[t] && (e.enable(t), s[t] = !0)
    }
    function Q(t) {
        !1 !== s[t] && (e.disable(t), s[t] = !1)
    }
    U[e.TEXTURE_2D] = F(e.TEXTURE_2D, e.TEXTURE_2D, 1),
    U[e.TEXTURE_CUBE_MAP] = F(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    U[e.TEXTURE_2D_ARRAY] = F(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
    U[e.TEXTURE_3D] = F(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
    n.setClear(0, 0, 0, 1),
    r.setClear(1),
    o.setClear(0),
    z(e.DEPTH_TEST),
    r.setFunc(3),
    H(!1),
    $(1),
    z(e.CULL_FACE),
    V(0);
    const G = {
        [Wi]: e.FUNC_ADD,
        [Ki]: e.FUNC_SUBTRACT,
        [qi]: e.FUNC_REVERSE_SUBTRACT
    };
    G[103] = e.MIN,
    G[104] = e.MAX;
    const j = {
        [Xi]: e.ZERO,
        [Yi]: e.ONE,
        [Ji]: e.SRC_COLOR,
        [ea]: e.SRC_ALPHA,
        [aa]: e.SRC_ALPHA_SATURATE,
        [oa]: e.DST_COLOR,
        [na]: e.DST_ALPHA,
        [Zi]: e.ONE_MINUS_SRC_COLOR,
        [ta]: e.ONE_MINUS_SRC_ALPHA,
        [ia]: e.ONE_MINUS_DST_COLOR,
        [ra]: e.ONE_MINUS_DST_ALPHA,
        [sa]: e.CONSTANT_COLOR,
        [la]: e.ONE_MINUS_CONSTANT_COLOR,
        [ca]: e.CONSTANT_ALPHA,
        [ua]: e.ONE_MINUS_CONSTANT_ALPHA
    };
    function V(t, n, r, o, i, a, s, l, c, u) {
        if (0 !== t) {
            if (!1 === p && (z(e.BLEND), p = !0), 5 === t)
                i = i || n,
                a = a || r,
                s = s || o,
                n === f && i === b || (e.blendEquationSeparate(G[n], G[i]), f = n, b = i),
                r === g && o === m && a === A && s === y || (e.blendFuncSeparate(j[r], j[o], j[a], j[s]), g = r, m = o, A = a, y = s),
                !1 !== l.equals(v) && c === _ || (e.blendColor(l.r, l.g, l.b, c), v.copy(l), _ = c),
                h = t,
                x = !1;
            else if (t !== h || u !== x) {
                if (f === Wi && b === Wi || (e.blendEquation(e.FUNC_ADD), f = Wi, b = Wi), u)
                    switch (t) {
                    case 1:
                        e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 2:
                        e.blendFunc(e.ONE, e.ONE);
                        break;
                    case 3:
                        e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                        break;
                    case 4:
                        e.blendFuncSeparate(e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE)
                    }
                else
                    switch (t) {
                    case 1:
                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                        break;
                    case 2:
                        e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE)
                    }
                g = null,
                m = null,
                A = null,
                y = null,
                v.set(0, 0, 0),
                _ = 0,
                h = t,
                x = u
            }
        } else
            !0 === p && (Q(e.BLEND), p = !1)
    }
    function H(t) {
        w !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), w = t)
    }
    function $(t) {
        0 !== t ? (z(e.CULL_FACE), t !== C && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : Q(e.CULL_FACE),
        C = t
    }
    function W(t, n, r) {
        t ? (z(e.POLYGON_OFFSET_FILL), S === n && I === r || (e.polygonOffset(n, r), S = n, I = r)) : Q(e.POLYGON_OFFSET_FILL)
    }
    return {
        buffers: {
            color: n,
            depth: r,
            stencil: o
        },
        enable: z,
        disable: Q,
        bindFramebuffer: function(t, n) {
            return l[t] !== n && (e.bindFramebuffer(t, n), l[t] = n, t === e.DRAW_FRAMEBUFFER && (l[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (l[e.DRAW_FRAMEBUFFER] = n), !0)
        },
        drawBuffers: function(t, n) {
            let r = u,
                o = !1;
            if (t) {
                r = c.get(n),
                void 0 === r && (r = [], c.set(n, r));
                const i = t.textures;
                if (r.length !== i.length || r[0] !== e.COLOR_ATTACHMENT0) {
                    for (let t = 0, n = i.length; t < n; t++)
                        r[t] = e.COLOR_ATTACHMENT0 + t;
                    r.length = i.length,
                    o = !0
                }
            } else
                r[0] !== e.BACK && (r[0] = e.BACK, o = !0);
            o && e.drawBuffers(r)
        },
        useProgram: function(t) {
            return d !== t && (e.useProgram(t), d = t, !0)
        },
        setBlending: V,
        setMaterial: function(t, i) {
            2 === t.side ? Q(e.CULL_FACE) : z(e.CULL_FACE);
            let a = 1 === t.side;
            i && (a = !a),
            H(a),
            1 === t.blending && !1 === t.transparent ? V(0) : V(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
            r.setFunc(t.depthFunc),
            r.setTest(t.depthTest),
            r.setMask(t.depthWrite),
            n.setMask(t.colorWrite);
            const s = t.stencilWrite;
            o.setTest(s),
            s && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
            W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
            !0 === t.alphaToCoverage ? z(e.SAMPLE_ALPHA_TO_COVERAGE) : Q(e.SAMPLE_ALPHA_TO_COVERAGE)
        },
        setFlipSided: H,
        setCullFace: $,
        setLineWidth: function(t) {
            t !== E && (M && e.lineWidth(t), E = t)
        },
        setPolygonOffset: W,
        setScissorTest: function(t) {
            t ? z(e.SCISSOR_TEST) : Q(e.SCISSOR_TEST)
        },
        activeTexture: function(t) {
            void 0 === t && (t = e.TEXTURE0 + T - 1),
            k !== t && (e.activeTexture(t), k = t)
        },
        bindTexture: function(t, n, r) {
            void 0 === r && (r = null === k ? e.TEXTURE0 + T - 1 : k);
            let o = D[r];
            void 0 === o && (o = {
                type: void 0,
                texture: void 0
            }, D[r] = o),
            o.type === t && o.texture === n || (k !== r && (e.activeTexture(r), k = r), e.bindTexture(t, n || U[t]), o.type = t, o.texture = n)
        },
        unbindTexture: function() {
            const t = D[k];
            void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
        },
        compressedTexImage2D: function() {
            try {
                e.compressedTexImage2D(...arguments)
            } catch (t) {}
        },
        compressedTexImage3D: function() {
            try {
                e.compressedTexImage3D(...arguments)
            } catch (t) {}
        },
        texImage2D: function() {
            try {
                e.texImage2D(...arguments)
            } catch (t) {}
        },
        texImage3D: function() {
            try {
                e.texImage3D(...arguments)
            } catch (t) {}
        },
        updateUBOMapping: function(t, n) {
            let r = a.get(n);
            void 0 === r && (r = new WeakMap, a.set(n, r));
            let o = r.get(t);
            void 0 === o && (o = e.getUniformBlockIndex(n, t.name), r.set(t, o))
        },
        uniformBlockBinding: function(t, n) {
            const r = a.get(n).get(t);
            i.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), i.set(n, r))
        },
        texStorage2D: function() {
            try {
                e.texStorage2D(...arguments)
            } catch (t) {}
        },
        texStorage3D: function() {
            try {
                e.texStorage3D(...arguments)
            } catch (t) {}
        },
        texSubImage2D: function() {
            try {
                e.texSubImage2D(...arguments)
            } catch (t) {}
        },
        texSubImage3D: function() {
            try {
                e.texSubImage3D(...arguments)
            } catch (t) {}
        },
        compressedTexSubImage2D: function() {
            try {
                e.compressedTexSubImage2D(...arguments)
            } catch (t) {}
        },
        compressedTexSubImage3D: function() {
            try {
                e.compressedTexSubImage3D(...arguments)
            } catch (t) {}
        },
        scissor: function(t) {
            !1 === L.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), L.copy(t))
        },
        viewport: function(t) {
            !1 === N.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), N.copy(t))
        },
        reset: function() {
            e.disable(e.BLEND),
            e.disable(e.CULL_FACE),
            e.disable(e.DEPTH_TEST),
            e.disable(e.POLYGON_OFFSET_FILL),
            e.disable(e.SCISSOR_TEST),
            e.disable(e.STENCIL_TEST),
            e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
            e.blendEquation(e.FUNC_ADD),
            e.blendFunc(e.ONE, e.ZERO),
            e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
            e.blendColor(0, 0, 0, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(e.LESS),
            r.setReversed(!1),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(e.ALWAYS, 0, 4294967295),
            e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
            e.clearStencil(0),
            e.cullFace(e.BACK),
            e.frontFace(e.CCW),
            e.polygonOffset(0, 0),
            e.activeTexture(e.TEXTURE0),
            e.bindFramebuffer(e.FRAMEBUFFER, null),
            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
            e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            s = {},
            k = null,
            D = {},
            l = {},
            c = new WeakMap,
            u = [],
            d = null,
            p = !1,
            h = null,
            f = null,
            g = null,
            m = null,
            b = null,
            A = null,
            y = null,
            v = new su(0, 0, 0),
            _ = 0,
            x = !1,
            w = null,
            C = null,
            E = null,
            S = null,
            I = null,
            L.set(0, 0, e.canvas.width, e.canvas.height),
            N.set(0, 0, e.canvas.width, e.canvas.height),
            n.reset(),
            r.reset(),
            o.reset()
        }
    }
}
function tm(e, t, n, r, o, i, a) {
    const s = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
        l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
        c = new dl,
        u = new WeakMap;
    let d;
    const p = new WeakMap;
    let h = !1;
    try {
        h = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
    } catch (V) {}
    function f(e, t) {
        return h ? new OffscreenCanvas(e, t) : yl("canvas")
    }
    function g(e, t, n) {
        let r = 1;
        const o = j(e);
        if ((o.width > n || o.height > n) && (r = n / Math.max(o.width, o.height)), r < 1) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                const n = Math.floor(r * o.width),
                    i = Math.floor(r * o.height);
                void 0 === d && (d = f(n, i));
                const a = t ? f(n, i) : d;
                return a.width = n, a.height = i, a.getContext("2d").drawImage(e, 0, 0, n, i), a
            }
            return e
        }
        return e
    }
    function m(e) {
        return e.generateMipmaps
    }
    function b(t) {
        e.generateMipmap(t)
    }
    function A(t) {
        return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
    }
    function y(n, r, o, i, a=!1) {
        if (null !== n && void 0 !== e[n])
            return e[n];
        let s = r;
        if (r === e.RED && (o === e.FLOAT && (s = e.R32F), o === e.HALF_FLOAT && (s = e.R16F), o === e.UNSIGNED_BYTE && (s = e.R8)), r === e.RED_INTEGER && (o === e.UNSIGNED_BYTE && (s = e.R8UI), o === e.UNSIGNED_SHORT && (s = e.R16UI), o === e.UNSIGNED_INT && (s = e.R32UI), o === e.BYTE && (s = e.R8I), o === e.SHORT && (s = e.R16I), o === e.INT && (s = e.R32I)), r === e.RG && (o === e.FLOAT && (s = e.RG32F), o === e.HALF_FLOAT && (s = e.RG16F), o === e.UNSIGNED_BYTE && (s = e.RG8)), r === e.RG_INTEGER && (o === e.UNSIGNED_BYTE && (s = e.RG8UI), o === e.UNSIGNED_SHORT && (s = e.RG16UI), o === e.UNSIGNED_INT && (s = e.RG32UI), o === e.BYTE && (s = e.RG8I), o === e.SHORT && (s = e.RG16I), o === e.INT && (s = e.RG32I)), r === e.RGB_INTEGER && (o === e.UNSIGNED_BYTE && (s = e.RGB8UI), o === e.UNSIGNED_SHORT && (s = e.RGB16UI), o === e.UNSIGNED_INT && (s = e.RGB32UI), o === e.BYTE && (s = e.RGB8I), o === e.SHORT && (s = e.RGB16I), o === e.INT && (s = e.RGB32I)), r === e.RGBA_INTEGER && (o === e.UNSIGNED_BYTE && (s = e.RGBA8UI), o === e.UNSIGNED_SHORT && (s = e.RGBA16UI), o === e.UNSIGNED_INT && (s = e.RGBA32UI), o === e.BYTE && (s = e.RGBA8I), o === e.SHORT && (s = e.RGBA16I), o === e.INT && (s = e.RGBA32I)), r === e.RGB && (o === e.UNSIGNED_INT_5_9_9_9_REV && (s = e.RGB9_E5), o === e.UNSIGNED_INT_10F_11F_11F_REV && (s = e.R11F_G11F_B10F)), r === e.RGBA) {
            const t = a ? Fs : Sl.getTransfer(i);
            o === e.FLOAT && (s = e.RGBA32F),
            o === e.HALF_FLOAT && (s = e.RGBA16F),
            o === e.UNSIGNED_BYTE && (s = t === Us ? e.SRGB8_ALPHA8 : e.RGBA8),
            o === e.UNSIGNED_SHORT_4_4_4_4 && (s = e.RGBA4),
            o === e.UNSIGNED_SHORT_5_5_5_1 && (s = e.RGB5_A1)
        }
        return s !== e.R16F && s !== e.R32F && s !== e.RG16F && s !== e.RG32F && s !== e.RGBA16F && s !== e.RGBA32F || t.get("EXT_color_buffer_float"), s
    }
    function v(t, n) {
        let r;
        return t ? null === n || n === La || n === Qa ? r = e.DEPTH24_STENCIL8 : n === Na ? r = e.DEPTH32F_STENCIL8 : n === Pa && (r = e.DEPTH24_STENCIL8) : null === n || n === La || n === Qa ? r = e.DEPTH_COMPONENT24 : n === Na ? r = e.DEPTH_COMPONENT32F : n === Pa && (r = e.DEPTH_COMPONENT16), r
    }
    function _(e, t) {
        return !0 === m(e) || e.isFramebufferTexture && e.minFilter !== Ia && e.minFilter !== Ra ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
    }
    function x(e) {
        const t = e.target;
        t.removeEventListener("dispose", x),
        function(e) {
            const t = r.get(e);
            if (void 0 === t.__webglInit)
                return;
            const n = e.source,
                o = p.get(n);
            if (o) {
                const r = o[t.__cacheKey];
                r.usedTimes--,
                0 === r.usedTimes && C(e),
                0 === Object.keys(o).length && p.delete(n)
            }
            r.remove(e)
        }(t),
        t.isVideoTexture && u.delete(t)
    }
    function w(t) {
        const n = t.target;
        n.removeEventListener("dispose", w),
        function(t) {
            const n = r.get(t);
            if (t.depthTexture && (t.depthTexture.dispose(), r.remove(t.depthTexture)), t.isWebGLCubeRenderTarget)
                for (let r = 0; r < 6; r++) {
                    if (Array.isArray(n.__webglFramebuffer[r]))
                        for (let t = 0; t < n.__webglFramebuffer[r].length; t++)
                            e.deleteFramebuffer(n.__webglFramebuffer[r][t]);
                    else
                        e.deleteFramebuffer(n.__webglFramebuffer[r]);
                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[r])
                }
            else {
                if (Array.isArray(n.__webglFramebuffer))
                    for (let t = 0; t < n.__webglFramebuffer.length; t++)
                        e.deleteFramebuffer(n.__webglFramebuffer[t]);
                else
                    e.deleteFramebuffer(n.__webglFramebuffer);
                if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                    for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                        n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
            }
            const o = t.textures;
            for (let i = 0, s = o.length; i < s; i++) {
                const t = r.get(o[i]);
                t.__webglTexture && (e.deleteTexture(t.__webglTexture), a.memory.textures--),
                r.remove(o[i])
            }
            r.remove(t)
        }(n)
    }
    function C(t) {
        const n = r.get(t);
        e.deleteTexture(n.__webglTexture);
        const o = t.source;
        delete p.get(o)[n.__cacheKey],
        a.memory.textures--
    }
    let E = 0;
    function S(t, o) {
        const i = r.get(t);
        if (t.isVideoTexture && function(e) {
            const t = a.render.frame;
            u.get(e) !== t && (u.set(e, t), e.update())
        }(t), !1 === t.isRenderTargetTexture && !0 !== t.isExternalTexture && t.version > 0 && i.__version !== t.version) {
            const e = t.image;
            if (null === e)
                ;
            else if (!1 !== e.complete)
                return void D(i, t, o)
        } else
            t.isExternalTexture && (i.__webglTexture = t.sourceTexture ? t.sourceTexture : null);
        n.bindTexture(e.TEXTURE_2D, i.__webglTexture, e.TEXTURE0 + o)
    }
    const I = {
            [Ca]: e.REPEAT,
            [Ea]: e.CLAMP_TO_EDGE,
            [Sa]: e.MIRRORED_REPEAT
        },
        T = {
            [Ia]: e.NEAREST,
            [Ta]: e.NEAREST_MIPMAP_NEAREST,
            [Ma]: e.NEAREST_MIPMAP_LINEAR,
            [Ra]: e.LINEAR,
            [Ba]: e.LINEAR_MIPMAP_NEAREST,
            [ka]: e.LINEAR_MIPMAP_LINEAR
        },
        M = {
            [Qs]: e.NEVER,
            [Ks]: e.ALWAYS,
            [Gs]: e.LESS,
            [Vs]: e.LEQUAL,
            [js]: e.EQUAL,
            [Ws]: e.GEQUAL,
            [Hs]: e.GREATER,
            [$s]: e.NOTEQUAL
        };
    function R(n, i) {
        if (i.type === Na && !1 === t.has("OES_texture_float_linear") && (i.magFilter === Ra || i.magFilter === Ba || i.magFilter === Ma || i.magFilter === ka || i.minFilter === Ra || i.minFilter === Ba || i.minFilter === Ma || i.minFilter), e.texParameteri(n, e.TEXTURE_WRAP_S, I[i.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, I[i.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, I[i.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, T[i.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, T[i.minFilter]), i.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, M[i.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
            if (i.magFilter === Ia)
                return;
            if (i.minFilter !== Ma && i.minFilter !== ka)
                return;
            if (i.type === Na && !1 === t.has("OES_texture_float_linear"))
                return;
            if (i.anisotropy > 1 || r.get(i).__currentAnisotropy) {
                const a = t.get("EXT_texture_filter_anisotropic");
                e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, o.getMaxAnisotropy())),
                r.get(i).__currentAnisotropy = i.anisotropy
            }
        }
    }
    function B(t, n) {
        let r = !1;
        void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", x));
        const o = n.source;
        let i = p.get(o);
        void 0 === i && (i = {}, p.set(o, i));
        const s = function(e) {
            const t = [];
            return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
        }(n);
        if (s !== t.__cacheKey) {
            void 0 === i[s] && (i[s] = {
                texture: e.createTexture(),
                usedTimes: 0
            }, a.memory.textures++, r = !0),
            i[s].usedTimes++;
            const o = i[t.__cacheKey];
            void 0 !== o && (i[t.__cacheKey].usedTimes--, 0 === o.usedTimes && C(n)),
            t.__cacheKey = s,
            t.__webglTexture = i[s].texture
        }
        return r
    }
    function k(e, t, n) {
        return Math.floor(Math.floor(e / n) / t)
    }
    function D(t, a, s) {
        let l = e.TEXTURE_2D;
        (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
        a.isData3DTexture && (l = e.TEXTURE_3D);
        const c = B(t, a),
            u = a.source;
        n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + s);
        const d = r.get(u);
        if (u.version !== d.__version || !0 === c) {
            n.activeTexture(e.TEXTURE0 + s);
            const t = Sl.getPrimaries(Sl.workingColorSpace),
                r = a.colorSpace === Os ? null : Sl.getPrimaries(a.colorSpace),
                p = a.colorSpace === Os || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
            e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
            let h = g(a.image, !1, o.maxTextureSize);
            h = G(a, h);
            const f = i.convert(a.format, a.colorSpace),
                A = i.convert(a.type);
            let x,
                w = y(a.internalFormat, f, A, a.colorSpace, a.isVideoTexture);
            R(l, a);
            const C = a.mipmaps,
                E = !0 !== a.isVideoTexture,
                S = void 0 === d.__version || !0 === c,
                I = u.dataReady,
                T = _(a, h);
            if (a.isDepthTexture)
                w = v(a.format === Ka, a.type),
                S && (E ? n.texStorage2D(e.TEXTURE_2D, 1, w, h.width, h.height) : n.texImage2D(e.TEXTURE_2D, 0, w, h.width, h.height, 0, f, A, null));
            else if (a.isDataTexture)
                if (C.length > 0) {
                    E && S && n.texStorage2D(e.TEXTURE_2D, T, w, C[0].width, C[0].height);
                    for (let t = 0, r = C.length; t < r; t++)
                        x = C[t],
                        E ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, A, x.data) : n.texImage2D(e.TEXTURE_2D, t, w, x.width, x.height, 0, f, A, x.data);
                    a.generateMipmaps = !1
                } else
                    E ? (S && n.texStorage2D(e.TEXTURE_2D, T, w, h.width, h.height), I && function(t, r, o, i) {
                        const a = t.updateRanges;
                        if (0 === a.length)
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, r.width, r.height, o, i, r.data);
                        else {
                            a.sort((e, t) => e.start - t.start);
                            let s = 0;
                            for (let e = 1; e < a.length; e++) {
                                const t = a[s],
                                    n = a[e],
                                    o = t.start + t.count,
                                    i = k(n.start, r.width, 4),
                                    l = k(t.start, r.width, 4);
                                n.start <= o + 1 && i === l && k(n.start + n.count - 1, r.width, 4) === i ? t.count = Math.max(t.count, n.start + n.count - t.start) : (++s, a[s] = n)
                            }
                            a.length = s + 1;
                            const l = e.getParameter(e.UNPACK_ROW_LENGTH),
                                c = e.getParameter(e.UNPACK_SKIP_PIXELS),
                                u = e.getParameter(e.UNPACK_SKIP_ROWS);
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, r.width);
                            for (let t = 0, d = a.length; t < d; t++) {
                                const s = a[t],
                                    l = Math.floor(s.start / 4),
                                    c = Math.ceil(s.count / 4),
                                    u = l % r.width,
                                    d = Math.floor(l / r.width),
                                    p = c,
                                    h = 1;
                                e.pixelStorei(e.UNPACK_SKIP_PIXELS, u),
                                e.pixelStorei(e.UNPACK_SKIP_ROWS, d),
                                n.texSubImage2D(e.TEXTURE_2D, 0, u, d, p, h, o, i, r.data)
                            }
                            t.clearUpdateRanges(),
                            e.pixelStorei(e.UNPACK_ROW_LENGTH, l),
                            e.pixelStorei(e.UNPACK_SKIP_PIXELS, c),
                            e.pixelStorei(e.UNPACK_SKIP_ROWS, u)
                        }
                    }(a, h, f, A)) : n.texImage2D(e.TEXTURE_2D, 0, w, h.width, h.height, 0, f, A, h.data);
            else if (a.isCompressedTexture)
                if (a.isCompressedArrayTexture) {
                    E && S && n.texStorage3D(e.TEXTURE_2D_ARRAY, T, w, C[0].width, C[0].height, h.depth);
                    for (let t = 0, r = C.length; t < r; t++)
                        if (x = C[t], a.format !== $a) {
                            if (null !== f)
                                if (E) {
                                    if (I)
                                        if (a.layerUpdates.size > 0) {
                                            const r = Th(x.width, x.height, a.format, a.type);
                                            for (const o of a.layerUpdates) {
                                                const i = x.data.subarray(o * r / x.data.BYTES_PER_ELEMENT, (o + 1) * r / x.data.BYTES_PER_ELEMENT);
                                                n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, o, x.width, x.height, 1, f, i)
                                            }
                                            a.clearLayerUpdates()
                                        } else
                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, h.depth, f, x.data)
                                } else
                                    n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, w, x.width, x.height, h.depth, 0, x.data, 0, 0)
                        } else
                            E ? I && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, x.width, x.height, h.depth, f, A, x.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, w, x.width, x.height, h.depth, 0, f, A, x.data)
                } else {
                    E && S && n.texStorage2D(e.TEXTURE_2D, T, w, C[0].width, C[0].height);
                    for (let t = 0, r = C.length; t < r; t++)
                        x = C[t],
                        a.format !== $a ? null !== f && (E ? I && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, x.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, w, x.width, x.height, 0, x.data)) : E ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, x.width, x.height, f, A, x.data) : n.texImage2D(e.TEXTURE_2D, t, w, x.width, x.height, 0, f, A, x.data)
                }
            else if (a.isDataArrayTexture)
                if (E) {
                    if (S && n.texStorage3D(e.TEXTURE_2D_ARRAY, T, w, h.width, h.height, h.depth), I)
                        if (a.layerUpdates.size > 0) {
                            const t = Th(h.width, h.height, a.format, a.type);
                            for (const r of a.layerUpdates) {
                                const o = h.data.subarray(r * t / h.data.BYTES_PER_ELEMENT, (r + 1) * t / h.data.BYTES_PER_ELEMENT);
                                n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, r, h.width, h.height, 1, f, A, o)
                            }
                            a.clearLayerUpdates()
                        } else
                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, h.width, h.height, h.depth, f, A, h.data)
                } else
                    n.texImage3D(e.TEXTURE_2D_ARRAY, 0, w, h.width, h.height, h.depth, 0, f, A, h.data);
            else if (a.isData3DTexture)
                E ? (S && n.texStorage3D(e.TEXTURE_3D, T, w, h.width, h.height, h.depth), I && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, h.width, h.height, h.depth, f, A, h.data)) : n.texImage3D(e.TEXTURE_3D, 0, w, h.width, h.height, h.depth, 0, f, A, h.data);
            else if (a.isFramebufferTexture) {
                if (S)
                    if (E)
                        n.texStorage2D(e.TEXTURE_2D, T, w, h.width, h.height);
                    else {
                        let t = h.width,
                            r = h.height;
                        for (let o = 0; o < T; o++)
                            n.texImage2D(e.TEXTURE_2D, o, w, t, r, 0, f, A, null),
                            t >>= 1,
                            r >>= 1
                    }
            } else if (C.length > 0) {
                if (E && S) {
                    const t = j(C[0]);
                    n.texStorage2D(e.TEXTURE_2D, T, w, t.width, t.height)
                }
                for (let t = 0, r = C.length; t < r; t++)
                    x = C[t],
                    E ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, A, x) : n.texImage2D(e.TEXTURE_2D, t, w, f, A, x);
                a.generateMipmaps = !1
            } else if (E) {
                if (S) {
                    const t = j(h);
                    n.texStorage2D(e.TEXTURE_2D, T, w, t.width, t.height)
                }
                I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, A, h)
            } else
                n.texImage2D(e.TEXTURE_2D, 0, w, f, A, h);
            m(a) && b(l),
            d.__version = u.version,
            a.onUpdate && a.onUpdate(a)
        }
        t.__version = a.version
    }
    function P(t, o, a, l, c, u) {
        const d = i.convert(a.format, a.colorSpace),
            p = i.convert(a.type),
            h = y(a.internalFormat, d, p, a.colorSpace),
            f = r.get(o),
            g = r.get(a);
        if (g.__renderTarget = o, !f.__hasExternalTextures) {
            const t = Math.max(1, o.width >> u),
                r = Math.max(1, o.height >> u);
            c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, h, t, r, o.depth, 0, d, p, null) : n.texImage2D(c, u, h, t, r, 0, d, p, null)
        }
        n.bindFramebuffer(e.FRAMEBUFFER, t),
        Q(o) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, g.__webglTexture, 0, z(o)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, g.__webglTexture, u),
        n.bindFramebuffer(e.FRAMEBUFFER, null)
    }
    function O(t, n, r) {
        if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer) {
            const o = n.depthTexture,
                i = o && o.isDepthTexture ? o.type : null,
                a = v(n.stencilBuffer, i),
                l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                c = z(n);
            Q(n) ? s.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, a, n.width, n.height) : r ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, a, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, a, n.width, n.height),
            e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
        } else {
            const t = n.textures;
            for (let o = 0; o < t.length; o++) {
                const a = t[o],
                    l = i.convert(a.format, a.colorSpace),
                    c = i.convert(a.type),
                    u = y(a.internalFormat, l, c, a.colorSpace),
                    d = z(n);
                r && !1 === Q(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, u, n.width, n.height) : Q(n) ? s.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height)
            }
        }
        e.bindRenderbuffer(e.RENDERBUFFER, null)
    }
    function L(t, o) {
        if (o && o.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(e.FRAMEBUFFER, t), !o.depthTexture || !o.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const i = r.get(o.depthTexture);
        i.__renderTarget = o,
        i.__webglTexture && o.depthTexture.image.width === o.width && o.depthTexture.image.height === o.height || (o.depthTexture.image.width = o.width, o.depthTexture.image.height = o.height, o.depthTexture.needsUpdate = !0),
        S(o.depthTexture, 0);
        const a = i.__webglTexture,
            l = z(o);
        if (o.depthTexture.format === Wa)
            Q(o) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
        else {
            if (o.depthTexture.format !== Ka)
                throw new Error("Unknown depthTexture format");
            Q(o) ? s.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
        }
    }
    function N(t) {
        const o = r.get(t),
            i = !0 === t.isWebGLCubeRenderTarget;
        if (o.__boundDepthTexture !== t.depthTexture) {
            const e = t.depthTexture;
            if (o.__depthDisposeCallback && o.__depthDisposeCallback(), e) {
                const t = () => {
                    delete o.__boundDepthTexture,
                    delete o.__depthDisposeCallback,
                    e.removeEventListener("dispose", t)
                };
                e.addEventListener("dispose", t),
                o.__depthDisposeCallback = t
            }
            o.__boundDepthTexture = e
        }
        if (t.depthTexture && !o.__autoAllocateDepthBuffer) {
            if (i)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const e = t.texture.mipmaps;
            e && e.length > 0 ? L(o.__webglFramebuffer[0], t) : L(o.__webglFramebuffer, t)
        } else if (i) {
            o.__webglDepthbuffer = [];
            for (let r = 0; r < 6; r++)
                if (n.bindFramebuffer(e.FRAMEBUFFER, o.__webglFramebuffer[r]), void 0 === o.__webglDepthbuffer[r])
                    o.__webglDepthbuffer[r] = e.createRenderbuffer(),
                    O(o.__webglDepthbuffer[r], t, !1);
                else {
                    const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                        i = o.__webglDepthbuffer[r];
                    e.bindRenderbuffer(e.RENDERBUFFER, i),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
                }
        } else {
            const r = t.texture.mipmaps;
            if (r && r.length > 0 ? n.bindFramebuffer(e.FRAMEBUFFER, o.__webglFramebuffer[0]) : n.bindFramebuffer(e.FRAMEBUFFER, o.__webglFramebuffer), void 0 === o.__webglDepthbuffer)
                o.__webglDepthbuffer = e.createRenderbuffer(),
                O(o.__webglDepthbuffer, t, !1);
            else {
                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                    r = o.__webglDepthbuffer;
                e.bindRenderbuffer(e.RENDERBUFFER, r),
                e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, r)
            }
        }
        n.bindFramebuffer(e.FRAMEBUFFER, null)
    }
    const F = [],
        U = [];
    function z(e) {
        return Math.min(o.maxSamples, e.samples)
    }
    function Q(e) {
        const n = r.get(e);
        return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
    }
    function G(e, t) {
        const n = e.colorSpace;
        return e.format, e.type, !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== Ns && n !== Os && Sl.getTransfer(n), t
    }
    function j(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c
    }
    this.allocateTextureUnit = function() {
        const e = E;
        return o.maxTextures, E += 1, e
    },
    this.resetTextureUnits = function() {
        E = 0
    },
    this.setTexture2D = S,
    this.setTexture2DArray = function(t, o) {
        const i = r.get(t);
        !1 === t.isRenderTargetTexture && t.version > 0 && i.__version !== t.version ? D(i, t, o) : n.bindTexture(e.TEXTURE_2D_ARRAY, i.__webglTexture, e.TEXTURE0 + o)
    },
    this.setTexture3D = function(t, o) {
        const i = r.get(t);
        !1 === t.isRenderTargetTexture && t.version > 0 && i.__version !== t.version ? D(i, t, o) : n.bindTexture(e.TEXTURE_3D, i.__webglTexture, e.TEXTURE0 + o)
    },
    this.setTextureCube = function(t, a) {
        const s = r.get(t);
        t.version > 0 && s.__version !== t.version ? function(t, a, s) {
            if (6 !== a.image.length)
                return;
            const l = B(t, a),
                c = a.source;
            n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + s);
            const u = r.get(c);
            if (c.version !== u.__version || !0 === l) {
                n.activeTexture(e.TEXTURE0 + s);
                const t = Sl.getPrimaries(Sl.workingColorSpace),
                    r = a.colorSpace === Os ? null : Sl.getPrimaries(a.colorSpace),
                    d = a.colorSpace === Os || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                const p = a.isCompressedTexture || a.image[0].isCompressedTexture,
                    h = a.image[0] && a.image[0].isDataTexture,
                    f = [];
                for (let e = 0; e < 6; e++)
                    f[e] = p || h ? h ? a.image[e].image : a.image[e] : g(a.image[e], !0, o.maxCubemapSize),
                    f[e] = G(a, f[e]);
                const A = f[0],
                    v = i.convert(a.format, a.colorSpace),
                    x = i.convert(a.type),
                    w = y(a.internalFormat, v, x, a.colorSpace),
                    C = !0 !== a.isVideoTexture,
                    E = void 0 === u.__version || !0 === l,
                    S = c.dataReady;
                let I,
                    T = _(a, A);
                if (R(e.TEXTURE_CUBE_MAP, a), p) {
                    C && E && n.texStorage2D(e.TEXTURE_CUBE_MAP, T, w, A.width, A.height);
                    for (let t = 0; t < 6; t++) {
                        I = f[t].mipmaps;
                        for (let r = 0; r < I.length; r++) {
                            const o = I[r];
                            a.format !== $a ? null !== v && (C ? S && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, o.width, o.height, v, o.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, w, o.width, o.height, 0, o.data)) : C ? S && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, o.width, o.height, v, x, o.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, w, o.width, o.height, 0, v, x, o.data)
                        }
                    }
                } else {
                    if (I = a.mipmaps, C && E) {
                        I.length > 0 && T++;
                        const t = j(f[0]);
                        n.texStorage2D(e.TEXTURE_CUBE_MAP, T, w, t.width, t.height)
                    }
                    for (let t = 0; t < 6; t++)
                        if (h) {
                            C ? S && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, f[t].width, f[t].height, v, x, f[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, w, f[t].width, f[t].height, 0, v, x, f[t].data);
                            for (let r = 0; r < I.length; r++) {
                                const o = I[r].image[t].image;
                                C ? S && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, o.width, o.height, v, x, o.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, w, o.width, o.height, 0, v, x, o.data)
                            }
                        } else {
                            C ? S && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, v, x, f[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, w, v, x, f[t]);
                            for (let r = 0; r < I.length; r++) {
                                const o = I[r];
                                C ? S && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, v, x, o.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, w, v, x, o.image[t])
                            }
                        }
                }
                m(a) && b(e.TEXTURE_CUBE_MAP),
                u.__version = c.version,
                a.onUpdate && a.onUpdate(a)
            }
            t.__version = a.version
        }(s, t, a) : n.bindTexture(e.TEXTURE_CUBE_MAP, s.__webglTexture, e.TEXTURE0 + a)
    },
    this.rebindTextures = function(t, n, o) {
        const i = r.get(t);
        void 0 !== n && P(i.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
        void 0 !== o && N(t)
    },
    this.setupRenderTarget = function(t) {
        const o = t.texture,
            s = r.get(t),
            l = r.get(o);
        t.addEventListener("dispose", w);
        const c = t.textures,
            u = !0 === t.isWebGLCubeRenderTarget,
            d = c.length > 1;
        if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = o.version, a.memory.textures++), u) {
            s.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++)
                if (o.mipmaps && o.mipmaps.length > 0) {
                    s.__webglFramebuffer[t] = [];
                    for (let n = 0; n < o.mipmaps.length; n++)
                        s.__webglFramebuffer[t][n] = e.createFramebuffer()
                } else
                    s.__webglFramebuffer[t] = e.createFramebuffer()
        } else {
            if (o.mipmaps && o.mipmaps.length > 0) {
                s.__webglFramebuffer = [];
                for (let t = 0; t < o.mipmaps.length; t++)
                    s.__webglFramebuffer[t] = e.createFramebuffer()
            } else
                s.__webglFramebuffer = e.createFramebuffer();
            if (d)
                for (let t = 0, n = c.length; t < n; t++) {
                    const n = r.get(c[t]);
                    void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), a.memory.textures++)
                }
            if (t.samples > 0 && !1 === Q(t)) {
                s.__webglMultisampledFramebuffer = e.createFramebuffer(),
                s.__webglColorRenderbuffer = [],
                n.bindFramebuffer(e.FRAMEBUFFER, s.__webglMultisampledFramebuffer);
                for (let n = 0; n < c.length; n++) {
                    const r = c[n];
                    s.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                    e.bindRenderbuffer(e.RENDERBUFFER, s.__webglColorRenderbuffer[n]);
                    const o = i.convert(r.format, r.colorSpace),
                        a = i.convert(r.type),
                        l = y(r.internalFormat, o, a, r.colorSpace, !0 === t.isXRRenderTarget),
                        u = z(t);
                    e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, s.__webglColorRenderbuffer[n])
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null),
                t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), O(s.__webglDepthRenderbuffer, t, !0)),
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
        }
        if (u) {
            n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
            R(e.TEXTURE_CUBE_MAP, o);
            for (let n = 0; n < 6; n++)
                if (o.mipmaps && o.mipmaps.length > 0)
                    for (let r = 0; r < o.mipmaps.length; r++)
                        P(s.__webglFramebuffer[n][r], t, o, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                else
                    P(s.__webglFramebuffer[n], t, o, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
            m(o) && b(e.TEXTURE_CUBE_MAP),
            n.unbindTexture()
        } else if (d) {
            for (let o = 0, i = c.length; o < i; o++) {
                const i = c[o],
                    a = r.get(i);
                let l = e.TEXTURE_2D;
                (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (l = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                n.bindTexture(l, a.__webglTexture),
                R(l, i),
                P(s.__webglFramebuffer, t, i, e.COLOR_ATTACHMENT0 + o, l, 0),
                m(i) && b(l)
            }
            n.unbindTexture()
        } else {
            let r = e.TEXTURE_2D;
            if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(r, l.__webglTexture), R(r, o), o.mipmaps && o.mipmaps.length > 0)
                for (let n = 0; n < o.mipmaps.length; n++)
                    P(s.__webglFramebuffer[n], t, o, e.COLOR_ATTACHMENT0, r, n);
            else
                P(s.__webglFramebuffer, t, o, e.COLOR_ATTACHMENT0, r, 0);
            m(o) && b(r),
            n.unbindTexture()
        }
        t.depthBuffer && N(t)
    },
    this.updateRenderTargetMipmap = function(e) {
        const t = e.textures;
        for (let o = 0, i = t.length; o < i; o++) {
            const i = t[o];
            if (m(i)) {
                const t = A(e),
                    o = r.get(i).__webglTexture;
                n.bindTexture(t, o),
                b(t),
                n.unbindTexture()
            }
        }
    },
    this.updateMultisampleRenderTarget = function(t) {
        if (t.samples > 0)
            if (!1 === Q(t)) {
                const o = t.textures,
                    i = t.width,
                    a = t.height;
                let s = e.COLOR_BUFFER_BIT;
                const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                    u = r.get(t),
                    d = o.length > 1;
                if (d)
                    for (let t = 0; t < o.length; t++)
                        n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                        n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                n.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer);
                const p = t.texture.mipmaps;
                p && p.length > 0 ? n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer[0]) : n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < o.length; n++) {
                    if (t.resolveDepthBuffer && (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (s |= e.STENCIL_BUFFER_BIT)), d) {
                        e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[n]);
                        const t = r.get(o[n]).__webglTexture;
                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                    }
                    e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, s, e.NEAREST),
                    !0 === l && (F.length = 0, U.length = 0, F.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (F.push(c), U.push(c), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, U)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F))
                }
                if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), d)
                    for (let t = 0; t < o.length; t++) {
                        n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]);
                        const i = r.get(o[t]).__webglTexture;
                        n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                        e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, i, 0)
                    }
                n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
            } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
            }
    },
    this.setupDepthRenderbuffer = N,
    this.setupFrameBufferTexture = P,
    this.useMultisampledRTT = Q
}
function nm(e, t) {
    return {
        convert: function(n, r="") {
            let o;
            const i = Sl.getTransfer(r);
            if (n === Da)
                return e.UNSIGNED_BYTE;
            if (n === Ua)
                return e.UNSIGNED_SHORT_4_4_4_4;
            if (n === za)
                return e.UNSIGNED_SHORT_5_5_5_1;
            if (n === Ga)
                return e.UNSIGNED_INT_5_9_9_9_REV;
            if (n === ja)
                return e.UNSIGNED_INT_10F_11F_11F_REV;
            if (1010 === n)
                return e.BYTE;
            if (1011 === n)
                return e.SHORT;
            if (n === Pa)
                return e.UNSIGNED_SHORT;
            if (n === Oa)
                return e.INT;
            if (n === La)
                return e.UNSIGNED_INT;
            if (n === Na)
                return e.FLOAT;
            if (n === Fa)
                return e.HALF_FLOAT;
            if (n === Va)
                return e.ALPHA;
            if (n === Ha)
                return e.RGB;
            if (n === $a)
                return e.RGBA;
            if (n === Wa)
                return e.DEPTH_COMPONENT;
            if (n === Ka)
                return e.DEPTH_STENCIL;
            if (n === qa)
                return e.RED;
            if (n === Xa)
                return e.RED_INTEGER;
            if (n === Ya)
                return e.RG;
            if (n === Ja)
                return e.RG_INTEGER;
            if (n === Za)
                return e.RGBA_INTEGER;
            if (n === es || n === ts || n === ns || n === rs)
                if (i === Us) {
                    if (o = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === o)
                        return null;
                    if (n === es)
                        return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === ts)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === ns)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === rs)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else {
                    if (o = t.get("WEBGL_compressed_texture_s3tc"), null === o)
                        return null;
                    if (n === es)
                        return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (n === ts)
                        return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (n === ns)
                        return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (n === rs)
                        return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
            if (n === os || n === is || n === as || n === ss) {
                if (o = t.get("WEBGL_compressed_texture_pvrtc"), null === o)
                    return null;
                if (n === os)
                    return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === is)
                    return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === as)
                    return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === ss)
                    return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (n === ls || n === cs || n === us) {
                if (o = t.get("WEBGL_compressed_texture_etc"), null === o)
                    return null;
                if (n === ls || n === cs)
                    return i === Us ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
                if (n === us)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC
            }
            if (n === ds || n === ps || n === hs || n === fs || n === gs || n === ms || n === bs || n === As || n === ys || n === vs || n === _s || n === xs || n === ws || n === Cs) {
                if (o = t.get("WEBGL_compressed_texture_astc"), null === o)
                    return null;
                if (n === ds)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === ps)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === hs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === fs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === gs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === ms)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === bs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === As)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === ys)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === vs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === _s)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === xs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === ws)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === Cs)
                    return i === Us ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
            }
            if (n === Es || n === Ss || n === Is) {
                if (o = t.get("EXT_texture_compression_bptc"), null === o)
                    return null;
                if (n === Es)
                    return i === Us ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Ss)
                    return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Is)
                    return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            }
            if (n === Ts || n === Ms || n === Rs || n === Bs) {
                if (o = t.get("EXT_texture_compression_rgtc"), null === o)
                    return null;
                if (n === Ts)
                    return o.COMPRESSED_RED_RGTC1_EXT;
                if (n === Ms)
                    return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Rs)
                    return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Bs)
                    return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            }
            return n === Qa ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
        }
    }
}
class rm {
    constructor()
    {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t)
    {
        if (null === this.texture) {
            const n = new gp(e.texture);
            e.depthNear === t.depthNear && e.depthFar === t.depthFar || (this.depthNear = e.depthNear, this.depthFar = e.depthFar),
            this.texture = n
        }
    }
    getMesh(e)
    {
        if (null !== this.texture && null === this.mesh) {
            const t = e.cameras[0].viewport,
                n = new Ku({
                    vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                    fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: t.z
                        },
                        depthHeight: {
                            value: t.w
                        }
                    }
                });
            this.mesh = new Qu(new mp(20, 20), n)
        }
        return this.mesh
    }
    reset()
    {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture()
    {
        return this.texture
    }
}
class om extends Zs {
    constructor(e, t)
    {
        super();
        const n = this;
        let r = null,
            o = 1,
            i = null,
            a = "local-floor",
            s = 1,
            l = null,
            c = null,
            u = null,
            d = null,
            p = null,
            h = null;
        const f = "undefined" != typeof XRWebGLBinding,
            g = new rm,
            m = {},
            b = t.getContextAttributes();
        let A = null,
            y = null;
        const v = [],
            _ = [],
            x = new dl;
        let w = null;
        const C = new Zu;
        C.viewport = new Nl;
        const E = new Zu;
        E.viewport = new Nl;
        const S = [C, E],
            I = new mh;
        let T = null,
            M = null;
        function R(e) {
            const t = _.indexOf(e.inputSource);
            if (-1 === t)
                return;
            const n = v[t];
            void 0 !== n && (n.update(e.inputSource, e.frame, l || i), n.dispatchEvent({
                type: e.type,
                data: e.inputSource
            }))
        }
        function B() {
            r.removeEventListener("select", R),
            r.removeEventListener("selectstart", R),
            r.removeEventListener("selectend", R),
            r.removeEventListener("squeeze", R),
            r.removeEventListener("squeezestart", R),
            r.removeEventListener("squeezeend", R),
            r.removeEventListener("end", B),
            r.removeEventListener("inputsourceschange", k);
            for (let e = 0; e < v.length; e++) {
                const t = _[e];
                null !== t && (_[e] = null, v[e].disconnect(t))
            }
            T = null,
            M = null,
            g.reset();
            for (const e in m)
                delete m[e];
            e.setRenderTarget(A),
            p = null,
            d = null,
            u = null,
            r = null,
            y = null,
            N.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(w),
            e.setSize(x.width, x.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        function k(e) {
            for (let t = 0; t < e.removed.length; t++) {
                const n = e.removed[t],
                    r = _.indexOf(n);
                r >= 0 && (_[r] = null, v[r].disconnect(n))
            }
            for (let t = 0; t < e.added.length; t++) {
                const n = e.added[t];
                let r = _.indexOf(n);
                if (-1 === r) {
                    for (let e = 0; e < v.length; e++) {
                        if (e >= _.length) {
                            _.push(n),
                            r = e;
                            break
                        }
                        if (null === _[e]) {
                            _[e] = n,
                            r = e;
                            break
                        }
                    }
                    if (-1 === r)
                        break
                }
                const o = v[r];
                o && o.connect(n)
            }
        }
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(e) {
            let t = v[e];
            return void 0 === t && (t = new ad, v[e] = t), t.getTargetRaySpace()
        },
        this.getControllerGrip = function(e) {
            let t = v[e];
            return void 0 === t && (t = new ad, v[e] = t), t.getGripSpace()
        },
        this.getHand = function(e) {
            let t = v[e];
            return void 0 === t && (t = new ad, v[e] = t), t.getHandSpace()
        },
        this.setFramebufferScaleFactor = function(e) {
            o = e,
            n.isPresenting
        },
        this.setReferenceSpaceType = function(e) {
            a = e,
            n.isPresenting
        },
        this.getReferenceSpace = function() {
            return l || i
        },
        this.setReferenceSpace = function(e) {
            l = e
        },
        this.getBaseLayer = function() {
            return null !== d ? d : p
        },
        this.getBinding = function() {
            return null === u && f && (u = new XRWebGLBinding(r, t)), u
        },
        this.getFrame = function() {
            return h
        },
        this.getSession = function() {
            return r
        },
        this.setSession = async function(c) {
            if (r = c, null !== r) {
                if (A = e.getRenderTarget(), r.addEventListener("select", R), r.addEventListener("selectstart", R), r.addEventListener("selectend", R), r.addEventListener("squeeze", R), r.addEventListener("squeezestart", R), r.addEventListener("squeezeend", R), r.addEventListener("end", B), r.addEventListener("inputsourceschange", k), !0 !== b.xrCompatible && await t.makeXRCompatible(), w = e.getPixelRatio(), e.getSize(x), f && "createProjectionLayer" in XRWebGLBinding.prototype) {
                    let n = null,
                        i = null,
                        a = null;
                    b.depth && (a = b.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = b.stencil ? Ka : Wa, i = b.stencil ? Qa : La);
                    const s = {
                        colorFormat: t.RGBA8,
                        depthFormat: a,
                        scaleFactor: o
                    };
                    u = this.getBinding(),
                    d = u.createProjectionLayer(s),
                    r.updateRenderState({
                        layers: [d]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.textureWidth, d.textureHeight, !1),
                    y = new Ul(d.textureWidth, d.textureHeight, {
                        format: $a,
                        type: Da,
                        depthTexture: new fp(d.textureWidth, d.textureHeight, i, void 0, void 0, void 0, void 0, void 0, void 0, n),
                        stencilBuffer: b.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: b.antialias ? 4 : 0,
                        resolveDepthBuffer: !1 === d.ignoreDepthValues,
                        resolveStencilBuffer: !1 === d.ignoreDepthValues
                    })
                } else {
                    const n = {
                        antialias: b.antialias,
                        alpha: !0,
                        depth: b.depth,
                        stencil: b.stencil,
                        framebufferScaleFactor: o
                    };
                    p = new XRWebGLLayer(r, t, n),
                    r.updateRenderState({
                        baseLayer: p
                    }),
                    e.setPixelRatio(1),
                    e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
                    y = new Ul(p.framebufferWidth, p.framebufferHeight, {
                        format: $a,
                        type: Da,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: b.stencil,
                        resolveDepthBuffer: !1 === p.ignoreDepthValues,
                        resolveStencilBuffer: !1 === p.ignoreDepthValues
                    })
                }
                y.isXRRenderTarget = !0,
                this.setFoveation(s),
                l = null,
                i = await r.requestReferenceSpace(a),
                N.setContext(r),
                N.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        },
        this.getEnvironmentBlendMode = function() {
            if (null !== r)
                return r.environmentBlendMode
        },
        this.getDepthTexture = function() {
            return g.getDepthTexture()
        };
        const D = new hl,
            P = new hl;
        function O(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert()
        }
        this.updateCamera = function(e) {
            if (null === r)
                return;
            let t = e.near,
                n = e.far;
            null !== g.texture && (g.depthNear > 0 && (t = g.depthNear), g.depthFar > 0 && (n = g.depthFar)),
            I.near = E.near = C.near = t,
            I.far = E.far = C.far = n,
            T === I.near && M === I.far || (r.updateRenderState({
                depthNear: I.near,
                depthFar: I.far
            }), T = I.near, M = I.far),
            I.layers.mask = 6 | e.layers.mask,
            C.layers.mask = 3 & I.layers.mask,
            E.layers.mask = 5 & I.layers.mask;
            const o = e.parent,
                i = I.cameras;
            O(I, o);
            for (let r = 0; r < i.length; r++)
                O(i[r], o);
            2 === i.length ? function(e, t, n) {
                D.setFromMatrixPosition(t.matrixWorld),
                P.setFromMatrixPosition(n.matrixWorld);
                const r = D.distanceTo(P),
                    o = t.projectionMatrix.elements,
                    i = n.projectionMatrix.elements,
                    a = o[14] / (o[10] - 1),
                    s = o[14] / (o[10] + 1),
                    l = (o[9] + 1) / o[5],
                    c = (o[9] - 1) / o[5],
                    u = (o[8] - 1) / o[0],
                    d = (i[8] + 1) / i[0],
                    p = a * u,
                    h = a * d,
                    f = r / (-u + d),
                    g = f * -u;
                if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(g), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), -1 === o[10])
                    e.projectionMatrix.copy(t.projectionMatrix),
                    e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                else {
                    const t = a + f,
                        n = s + f,
                        o = p - g,
                        i = h + (r - g),
                        u = l * s / n * t,
                        d = c * s / n * t;
                    e.projectionMatrix.makePerspective(o, i, u, d, t, n),
                    e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                }
            }(I, C, E) : I.projectionMatrix.copy(C.projectionMatrix),
            function(e, t, n) {
                null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld)),
                e.matrix.decompose(e.position, e.quaternion, e.scale),
                e.updateMatrixWorld(!0),
                e.projectionMatrix.copy(t.projectionMatrix),
                e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                e.isPerspectiveCamera && (e.fov = 2 * rl * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
            }(e, I, o)
        },
        this.getCamera = function() {
            return I
        },
        this.getFoveation = function() {
            if (null !== d || null !== p)
                return s
        },
        this.setFoveation = function(e) {
            s = e,
            null !== d && (d.fixedFoveation = e),
            null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e)
        },
        this.hasDepthSensing = function() {
            return null !== g.texture
        },
        this.getDepthSensingMesh = function() {
            return g.getMesh(I)
        },
        this.getCameraTexture = function(e) {
            return m[e]
        };
        let L = null;
        const N = new Mh;
        N.setAnimationLoop(function(t, o) {
            if (c = o.getViewerPose(l || i), h = o, null !== c) {
                const t = c.views;
                null !== p && (e.setRenderTargetFramebuffer(y, p.framebuffer), e.setRenderTarget(y));
                let o = !1;
                t.length !== I.cameras.length && (I.cameras.length = 0, o = !0);
                for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    let i = null;
                    if (null !== p)
                        i = p.getViewport(r);
                    else {
                        const t = u.getViewSubImage(d, r);
                        i = t.viewport,
                        0 === n && (e.setRenderTargetTextures(y, t.colorTexture, t.depthStencilTexture), e.setRenderTarget(y))
                    }
                    let a = S[n];
                    void 0 === a && (a = new Zu, a.layers.enable(n), a.viewport = new Nl, S[n] = a),
                    a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.quaternion, a.scale),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                    a.viewport.set(i.x, i.y, i.width, i.height),
                    0 === n && (I.matrix.copy(a.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale)),
                    !0 === o && I.cameras.push(a)
                }
                const i = r.enabledFeatures;
                if (i && i.includes("depth-sensing") && "gpu-optimized" == r.depthUsage && f) {
                    u = n.getBinding();
                    const e = u.getDepthInformation(t[0]);
                    e && e.isValid && e.texture && g.init(e, r.renderState)
                }
                if (i && i.includes("camera-access") && f) {
                    e.state.unbindTexture(),
                    u = n.getBinding();
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e].camera;
                        if (n) {
                            let e = m[n];
                            e || (e = new gp, m[n] = e);
                            const t = u.getCameraImage(n);
                            e.sourceTexture = t
                        }
                    }
                }
            }
            for (let e = 0; e < v.length; e++) {
                const t = _[e],
                    n = v[e];
                null !== t && void 0 !== n && n.update(t, o, l || i)
            }
            L && L(t, o),
            o.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: o
            }),
            h = null
        }),
        this.setAnimationLoop = function(e) {
            L = e
        },
        this.dispose = function() {}
    }
}
const im = new Ec,
    am = new gc;
function sm(e, t) {
    function n(e, t) {
        !0 === e.matrixAutoUpdate && e.updateMatrix(),
        t.value.copy(e.matrix)
    }
    function r(e, r) {
        e.opacity.value = r.opacity,
        r.color && e.diffuse.value.copy(r.color),
        r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
        r.map && (e.map.value = r.map, n(r.map, e.mapTransform)),
        r.alphaMap && (e.alphaMap.value = r.alphaMap, n(r.alphaMap, e.alphaMapTransform)),
        r.bumpMap && (e.bumpMap.value = r.bumpMap, n(r.bumpMap, e.bumpMapTransform), e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)),
        r.normalMap && (e.normalMap.value = r.normalMap, n(r.normalMap, e.normalMapTransform), e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()),
        r.displacementMap && (e.displacementMap.value = r.displacementMap, n(r.displacementMap, e.displacementMapTransform), e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias),
        r.emissiveMap && (e.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, e.emissiveMapTransform)),
        r.specularMap && (e.specularMap.value = r.specularMap, n(r.specularMap, e.specularMapTransform)),
        r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest);
        const o = t.get(r),
            i = o.envMap,
            a = o.envMapRotation;
        i && (e.envMap.value = i, im.copy(a), im.x *= -1, im.y *= -1, im.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (im.y *= -1, im.z *= -1), e.envMapRotation.value.setFromMatrix4(am.makeRotationFromEuler(im)), e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = r.reflectivity, e.ior.value = r.ior, e.refractionRatio.value = r.refractionRatio),
        r.lightMap && (e.lightMap.value = r.lightMap, e.lightMapIntensity.value = r.lightMapIntensity, n(r.lightMap, e.lightMapTransform)),
        r.aoMap && (e.aoMap.value = r.aoMap, e.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, e.aoMapTransform))
    }
    return {
        refreshFogUniforms: function(t, n) {
            n.color.getRGB(t.fogColor.value, $u(e)),
            n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
        },
        refreshMaterialUniforms: function(e, o, i, a, s) {
            o.isMeshBasicMaterial || o.isMeshLambertMaterial ? r(e, o) : o.isMeshToonMaterial ? (r(e, o), function(e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(e, o)) : o.isMeshPhongMaterial ? (r(e, o), function(e, t) {
                e.specular.value.copy(t.specular),
                e.shininess.value = Math.max(t.shininess, 1e-4)
            }(e, o)) : o.isMeshStandardMaterial ? (r(e, o), function(e, t) {
                e.metalness.value = t.metalness,
                t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, e.metalnessMapTransform)),
                e.roughness.value = t.roughness,
                t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, e.roughnessMapTransform)),
                t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
            }(e, o), o.isMeshPhysicalMaterial && function(e, t, r) {
                e.ior.value = t.ior,
                t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))),
                t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && e.clearcoatNormalScale.value.negate())),
                t.dispersion > 0 && (e.dispersion.value = t.dispersion),
                t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform))),
                t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)),
                t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform))),
                e.specularIntensity.value = t.specularIntensity,
                e.specularColor.value.copy(t.specularColor),
                t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform)),
                t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
            }(e, o, s)) : o.isMeshMatcapMaterial ? (r(e, o), function(e, t) {
                t.matcap && (e.matcap.value = t.matcap)
            }(e, o)) : o.isMeshDepthMaterial ? r(e, o) : o.isMeshDistanceMaterial ? (r(e, o), function(e, n) {
                const r = t.get(n).light;
                e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),
                e.nearDistance.value = r.shadow.camera.near,
                e.farDistance.value = r.shadow.camera.far
            }(e, o)) : o.isMeshNormalMaterial ? r(e, o) : o.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
            }(e, o), o.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(e, o)) : o.isPointsMaterial ? function(e, t, r, o) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.size.value = t.size * r,
                e.scale.value = .5 * o,
                t.map && (e.map.value = t.map, n(t.map, e.uvTransform)),
                t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
            }(e, o, i, a) : o.isSpriteMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                t.map && (e.map.value = t.map, n(t.map, e.mapTransform)),
                t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform)),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
            }(e, o) : o.isShadowMaterial ? (e.color.value.copy(o.color), e.opacity.value = o.opacity) : o.isShaderMaterial && (o.uniformsNeedUpdate = !1)
        }
    }
}
function lm(e, t, n, r) {
    let o = {},
        i = {},
        a = [];
    const s = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(e, t, n, r) {
        const o = e.value,
            i = t + "_" + n;
        if (void 0 === r[i])
            return r[i] = "number" == typeof o || "boolean" == typeof o ? o : o.clone(), !0;
        {
            const e = r[i];
            if ("number" == typeof o || "boolean" == typeof o) {
                if (e !== o)
                    return r[i] = o, !0
            } else if (!1 === e.equals(o))
                return e.copy(o), !0
        }
        return !1
    }
    function c(e) {
        const t = {
            boundary: 0,
            storage: 0
        };
        return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture, t
    }
    function u(t) {
        const n = t.target;
        n.removeEventListener("dispose", u);
        const r = a.indexOf(n.__bindingPointIndex);
        a.splice(r, 1),
        e.deleteBuffer(o[n.id]),
        delete o[n.id],
        delete i[n.id]
    }
    return {
        bind: function(e, t) {
            const n = t.program;
            r.uniformBlockBinding(e, n)
        },
        update: function(n, d) {
            let p = o[n.id];
            void 0 === p && (function(e) {
                const t = e.uniforms;
                let n = 0;
                for (let o = 0, i = t.length; o < i; o++) {
                    const e = Array.isArray(t[o]) ? t[o] : [t[o]];
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t],
                            o = Array.isArray(r.value) ? r.value : [r.value];
                        for (let e = 0, t = o.length; e < t; e++) {
                            const t = c(o[e]),
                                i = n % 16,
                                a = i % t.boundary,
                                s = i + a;
                            n += a,
                            0 !== s && 16 - s < t.storage && (n += 16 - s),
                            r.__data = new Float32Array(t.storage / Float32Array.BYTES_PER_ELEMENT),
                            r.__offset = n,
                            n += t.storage
                        }
                    }
                }
                const r = n % 16;
                r > 0 && (n += 16 - r),
                e.__size = n,
                e.__cache = {}
            }(n), p = function(t) {
                const n = function() {
                    for (let e = 0; e < s; e++)
                        if (-1 === a.indexOf(e))
                            return a.push(e), e;
                    return 0
                }();
                t.__bindingPointIndex = n;
                const r = e.createBuffer(),
                    o = t.__size,
                    i = t.usage;
                return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, o, i), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, r), r
            }(n), o[n.id] = p, n.addEventListener("dispose", u));
            const h = d.program;
            r.updateUBOMapping(n, h);
            const f = t.render.frame;
            i[n.id] !== f && (function(t) {
                const n = o[t.id],
                    r = t.uniforms,
                    i = t.__cache;
                e.bindBuffer(e.UNIFORM_BUFFER, n);
                for (let o = 0, a = r.length; o < a; o++) {
                    const t = Array.isArray(r[o]) ? r[o] : [r[o]];
                    for (let n = 0, r = t.length; n < r; n++) {
                        const r = t[n];
                        if (!0 === l(r, o, n, i)) {
                            const t = r.__offset,
                                n = Array.isArray(r.value) ? r.value : [r.value];
                            let o = 0;
                            for (let i = 0; i < n.length; i++) {
                                const a = n[i],
                                    s = c(a);
                                "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a, e.bufferSubData(e.UNIFORM_BUFFER, t + o, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0], r.__data[1] = a.elements[1], r.__data[2] = a.elements[2], r.__data[3] = 0, r.__data[4] = a.elements[3], r.__data[5] = a.elements[4], r.__data[6] = a.elements[5], r.__data[7] = 0, r.__data[8] = a.elements[6], r.__data[9] = a.elements[7], r.__data[10] = a.elements[8], r.__data[11] = 0) : (a.toArray(r.__data, o), o += s.storage / Float32Array.BYTES_PER_ELEMENT)
                            }
                            e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                        }
                    }
                }
                e.bindBuffer(e.UNIFORM_BUFFER, null)
            }(n), i[n.id] = f)
        },
        dispose: function() {
            for (const t in o)
                e.deleteBuffer(o[t]);
            a = [],
            o = {},
            i = {}
        }
    }
}
class cm {
    constructor(e={})
    {
        const {canvas: t=vl(), context: n=null, depth: r=!0, stencil: o=!1, alpha: i=!1, antialias: a=!1, premultipliedAlpha: s=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: u=!1, reversedDepthBuffer: d=!1} = e;
        let p;
        if (this.isWebGLRenderer = !0, null !== n) {
            if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            p = n.getContextAttributes().alpha
        } else
            p = i;
        const h = new Uint32Array(4),
            f = new Int32Array(4);
        let g = null,
            m = null;
        const b = [],
            A = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = 0,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const y = this;
        let v = !1;
        this._outputColorSpace = Ls;
        let _ = 0,
            x = 0,
            w = null,
            C = -1,
            E = null;
        const S = new Nl,
            I = new Nl;
        let T = null;
        const M = new su(0);
        let R = 0,
            B = t.width,
            k = t.height,
            D = 1,
            P = null,
            O = null;
        const L = new Nl(0, 0, B, k),
            N = new Nl(0, 0, B, k);
        let F = !1;
        const U = new Gd;
        let z = !1,
            Q = !1;
        const G = new gc,
            j = new hl,
            V = new Nl,
            H = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
        let $ = !1;
        function W() {
            return null === w ? D : 1
        }
        let K,
            q,
            X,
            Y,
            J,
            Z,
            ee,
            te,
            ne,
            re,
            oe,
            ie,
            ae,
            se,
            le,
            ce,
            ue,
            de,
            pe,
            he,
            fe,
            ge,
            me,
            be,
            Ae = n;
        function ye(e, n) {
            return t.getContext(e, n)
        }
        try {
            const e = {
                alpha: !0,
                depth: r,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: u
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${ji}`), t.addEventListener("webglcontextlost", xe, !1), t.addEventListener("webglcontextrestored", we, !1), t.addEventListener("webglcontextcreationerror", Ce, !1), null === Ae) {
                const t = "webgl2";
                if (Ae = ye(t, e), null === Ae)
                    throw ye(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (Ge) {
            throw Ge
        }
        function ve() {
            K = new sf(Ae),
            K.init(),
            ge = new nm(Ae, K),
            q = new zh(Ae, K, e, ge),
            X = new em(Ae, K),
            q.reversedDepthBuffer && d && X.buffers.depth.setReversed(!0),
            Y = new uf(Ae),
            J = new Qg,
            Z = new tm(Ae, K, X, J, q, ge, Y),
            ee = new Gh(y),
            te = new af(y),
            ne = new Rh(Ae),
            me = new Fh(Ae, ne),
            re = new lf(Ae, ne, Y, me),
            oe = new pf(Ae, re, ne, Y),
            pe = new df(Ae, q, Z),
            ce = new Qh(J),
            ie = new zg(y, ee, te, K, q, me, ce),
            ae = new sm(y, J),
            se = new Hg,
            le = new Yg(K),
            de = new Nh(y, ee, te, X, oe, p, s),
            ue = new Jg(y, oe, q),
            be = new lm(Ae, Y, q, X),
            he = new Uh(Ae, K, Y),
            fe = new cf(Ae, K, Y),
            Y.programs = ie.programs,
            y.capabilities = q,
            y.extensions = K,
            y.properties = J,
            y.renderLists = se,
            y.shadowMap = ue,
            y.state = X,
            y.info = Y
        }
        ve();
        const _e = new om(y, Ae);
        function xe(e) {
            e.preventDefault(),
            v = !0
        }
        function we() {
            v = !1;
            const e = Y.autoReset,
                t = ue.enabled,
                n = ue.autoUpdate,
                r = ue.needsUpdate,
                o = ue.type;
            ve(),
            Y.autoReset = e,
            ue.enabled = t,
            ue.autoUpdate = n,
            ue.needsUpdate = r,
            ue.type = o
        }
        function Ce(e) {}
        function Ee(e) {
            const t = e.target;
            t.removeEventListener("dispose", Ee),
            function(e) {
                (function(e) {
                    const t = J.get(e).programs;
                    void 0 !== t && (t.forEach(function(e) {
                        ie.releaseProgram(e)
                    }), e.isShaderMaterial && ie.releaseShaderCache(e))
                })(e),
                J.remove(e)
            }(t)
        }
        function Se(e, t, n) {
            !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1, e.needsUpdate = !0, Le(e, t, n), e.side = 0, e.needsUpdate = !0, Le(e, t, n), e.side = 2) : Le(e, t, n)
        }
        this.xr = _e,
        this.getContext = function() {
            return Ae
        },
        this.getContextAttributes = function() {
            return Ae.getContextAttributes()
        },
        this.forceContextLoss = function() {
            const e = K.get("WEBGL_lose_context");
            e && e.loseContext()
        },
        this.forceContextRestore = function() {
            const e = K.get("WEBGL_lose_context");
            e && e.restoreContext()
        },
        this.getPixelRatio = function() {
            return D
        },
        this.setPixelRatio = function(e) {
            void 0 !== e && (D = e, this.setSize(B, k, !1))
        },
        this.getSize = function(e) {
            return e.set(B, k)
        },
        this.setSize = function(e, n, r=!0) {
            _e.isPresenting || (B = e, k = n, t.width = Math.floor(e * D), t.height = Math.floor(n * D), !0 === r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
        },
        this.getDrawingBufferSize = function(e) {
            return e.set(B * D, k * D).floor()
        },
        this.setDrawingBufferSize = function(e, n, r) {
            B = e,
            k = n,
            D = r,
            t.width = Math.floor(e * r),
            t.height = Math.floor(n * r),
            this.setViewport(0, 0, e, n)
        },
        this.getCurrentViewport = function(e) {
            return e.copy(S)
        },
        this.getViewport = function(e) {
            return e.copy(L)
        },
        this.setViewport = function(e, t, n, r) {
            e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, r),
            X.viewport(S.copy(L).multiplyScalar(D).round())
        },
        this.getScissor = function(e) {
            return e.copy(N)
        },
        this.setScissor = function(e, t, n, r) {
            e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, r),
            X.scissor(I.copy(N).multiplyScalar(D).round())
        },
        this.getScissorTest = function() {
            return F
        },
        this.setScissorTest = function(e) {
            X.setScissorTest(F = e)
        },
        this.setOpaqueSort = function(e) {
            P = e
        },
        this.setTransparentSort = function(e) {
            O = e
        },
        this.getClearColor = function(e) {
            return e.copy(de.getClearColor())
        },
        this.setClearColor = function() {
            de.setClearColor(...arguments)
        },
        this.getClearAlpha = function() {
            return de.getClearAlpha()
        },
        this.setClearAlpha = function() {
            de.setClearAlpha(...arguments)
        },
        this.clear = function(e=!0, t=!0, n=!0) {
            let r = 0;
            if (e) {
                let e = !1;
                if (null !== w) {
                    const t = w.texture.format;
                    e = t === Za || t === Ja || t === Xa
                }
                if (e) {
                    const e = w.texture.type,
                        t = e === Da || e === La || e === Pa || e === Qa || e === Ua || e === za,
                        n = de.getClearColor(),
                        r = de.getClearAlpha(),
                        o = n.r,
                        i = n.g,
                        a = n.b;
                    t ? (h[0] = o, h[1] = i, h[2] = a, h[3] = r, Ae.clearBufferuiv(Ae.COLOR, 0, h)) : (f[0] = o, f[1] = i, f[2] = a, f[3] = r, Ae.clearBufferiv(Ae.COLOR, 0, f))
                } else
                    r |= Ae.COLOR_BUFFER_BIT
            }
            t && (r |= Ae.DEPTH_BUFFER_BIT),
            n && (r |= Ae.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)),
            Ae.clear(r)
        },
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        },
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        },
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        },
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", xe, !1),
            t.removeEventListener("webglcontextrestored", we, !1),
            t.removeEventListener("webglcontextcreationerror", Ce, !1),
            de.dispose(),
            se.dispose(),
            le.dispose(),
            J.dispose(),
            ee.dispose(),
            te.dispose(),
            oe.dispose(),
            me.dispose(),
            be.dispose(),
            ie.dispose(),
            _e.dispose(),
            _e.removeEventListener("sessionstart", Te),
            _e.removeEventListener("sessionend", Me),
            Re.stop()
        },
        this.renderBufferDirect = function(e, t, n, r, o, i) {
            null === t && (t = H);
            const a = o.isMesh && o.matrixWorld.determinant() < 0,
                s = function(e, t, n, r, o) {
                    !0 !== t.isScene && (t = H),
                    Z.resetTextureUnits();
                    const i = t.fog,
                        a = r.isMeshStandardMaterial ? t.environment : null,
                        s = null === w ? y.outputColorSpace : !0 === w.isXRRenderTarget ? w.texture.colorSpace : Ns,
                        l = (r.isMeshStandardMaterial ? te : ee).get(r.envMap || a),
                        c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                        u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0),
                        d = !!n.morphAttributes.position,
                        p = !!n.morphAttributes.normal,
                        h = !!n.morphAttributes.color;
                    let f = 0;
                    r.toneMapped && (null !== w && !0 !== w.isXRRenderTarget || (f = y.toneMapping));
                    const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                        b = void 0 !== g ? g.length : 0,
                        A = J.get(r),
                        v = m.state.lights;
                    if (!0 === z && (!0 === Q || e !== E)) {
                        const t = e === E && r.id === C;
                        ce.setState(r, e, t)
                    }
                    let _ = !1;
                    r.version === A.__version ? A.needsLights && A.lightsStateVersion !== v.state.version || A.outputColorSpace !== s || o.isBatchedMesh && !1 === A.batching ? _ = !0 : o.isBatchedMesh || !0 !== A.batching ? o.isBatchedMesh && !0 === A.batchingColor && null === o.colorTexture || o.isBatchedMesh && !1 === A.batchingColor && null !== o.colorTexture || o.isInstancedMesh && !1 === A.instancing ? _ = !0 : o.isInstancedMesh || !0 !== A.instancing ? o.isSkinnedMesh && !1 === A.skinning ? _ = !0 : o.isSkinnedMesh || !0 !== A.skinning ? o.isInstancedMesh && !0 === A.instancingColor && null === o.instanceColor || o.isInstancedMesh && !1 === A.instancingColor && null !== o.instanceColor || o.isInstancedMesh && !0 === A.instancingMorph && null === o.morphTexture || o.isInstancedMesh && !1 === A.instancingMorph && null !== o.morphTexture || A.envMap !== l || !0 === r.fog && A.fog !== i ? _ = !0 : void 0 === A.numClippingPlanes || A.numClippingPlanes === ce.numPlanes && A.numIntersection === ce.numIntersection ? (A.vertexAlphas !== c || A.vertexTangents !== u || A.morphTargets !== d || A.morphNormals !== p || A.morphColors !== h || A.toneMapping !== f || A.morphTargetsCount !== b) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : _ = !0 : (_ = !0, A.__version = r.version);
                    let x = A.currentProgram;
                    !0 === _ && (x = Le(r, t, o));
                    let S = !1,
                        I = !1,
                        T = !1;
                    const M = x.getUniforms(),
                        R = A.uniforms;
                    if (X.useProgram(x.program) && (S = !0, I = !0, T = !0), r.id !== C && (C = r.id, I = !0), S || E !== e) {
                        X.buffers.depth.getReversed() && !0 !== e.reversedDepth && (e._reversedDepth = !0, e.updateProjectionMatrix()),
                        M.setValue(Ae, "projectionMatrix", e.projectionMatrix),
                        M.setValue(Ae, "viewMatrix", e.matrixWorldInverse);
                        const t = M.map.cameraPosition;
                        void 0 !== t && t.setValue(Ae, j.setFromMatrixPosition(e.matrixWorld)),
                        q.logarithmicDepthBuffer && M.setValue(Ae, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                        (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && M.setValue(Ae, "isOrthographic", !0 === e.isOrthographicCamera),
                        E !== e && (E = e, I = !0, T = !0)
                    }
                    if (o.isSkinnedMesh) {
                        M.setOptional(Ae, o, "bindMatrix"),
                        M.setOptional(Ae, o, "bindMatrixInverse");
                        const e = o.skeleton;
                        e && (null === e.boneTexture && e.computeBoneTexture(), M.setValue(Ae, "boneTexture", e.boneTexture, Z))
                    }
                    o.isBatchedMesh && (M.setOptional(Ae, o, "batchingTexture"), M.setValue(Ae, "batchingTexture", o._matricesTexture, Z), M.setOptional(Ae, o, "batchingIdTexture"), M.setValue(Ae, "batchingIdTexture", o._indirectTexture, Z), M.setOptional(Ae, o, "batchingColorTexture"), null !== o._colorsTexture && M.setValue(Ae, "batchingColorTexture", o._colorsTexture, Z));
                    const B = n.morphAttributes;
                    var P,
                        O;
                    if (void 0 === B.position && void 0 === B.normal && void 0 === B.color || pe.update(o, n, x), (I || A.receiveShadow !== o.receiveShadow) && (A.receiveShadow = o.receiveShadow, M.setValue(Ae, "receiveShadow", o.receiveShadow)), r.isMeshGouraudMaterial && null !== r.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), r.isMeshStandardMaterial && null === r.envMap && null !== t.environment && (R.envMapIntensity.value = t.environmentIntensity), I && (M.setValue(Ae, "toneMappingExposure", y.toneMappingExposure), A.needsLights && (O = T, (P = R).ambientLightColor.needsUpdate = O, P.lightProbe.needsUpdate = O, P.directionalLights.needsUpdate = O, P.directionalLightShadows.needsUpdate = O, P.pointLights.needsUpdate = O, P.pointLightShadows.needsUpdate = O, P.spotLights.needsUpdate = O, P.spotLightShadows.needsUpdate = O, P.rectAreaLights.needsUpdate = O, P.hemisphereLights.needsUpdate = O), i && !0 === r.fog && ae.refreshFogUniforms(R, i), ae.refreshMaterialUniforms(R, r, D, k, m.state.transmissionRenderTarget[e.id]), bg.upload(Ae, Ne(A), R, Z)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (bg.upload(Ae, Ne(A), R, Z), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && M.setValue(Ae, "center", o.center), M.setValue(Ae, "modelViewMatrix", o.modelViewMatrix), M.setValue(Ae, "normalMatrix", o.normalMatrix), M.setValue(Ae, "modelMatrix", o.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) {
                        const e = r.uniformsGroups;
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            be.update(n, x),
                            be.bind(n, x)
                        }
                    }
                    return x
                }(e, t, n, r, o);
            X.setMaterial(r, a);
            let l = n.index,
                c = 1;
            if (!0 === r.wireframe) {
                if (l = re.getWireframeAttribute(n), void 0 === l)
                    return;
                c = 2
            }
            const u = n.drawRange,
                d = n.attributes.position;
            let p = u.start * c,
                h = (u.start + u.count) * c;
            null !== i && (p = Math.max(p, i.start * c), h = Math.min(h, (i.start + i.count) * c)),
            null !== l ? (p = Math.max(p, 0), h = Math.min(h, l.count)) : null != d && (p = Math.max(p, 0), h = Math.min(h, d.count));
            const f = h - p;
            if (f < 0 || f === 1 / 0)
                return;
            let g;
            me.setup(o, r, s, n, l);
            let b = he;
            if (null !== l && (g = ne.get(l), b = fe, b.setIndex(g)), o.isMesh)
                !0 === r.wireframe ? (X.setLineWidth(r.wireframeLinewidth * W()), b.setMode(Ae.LINES)) : b.setMode(Ae.TRIANGLES);
            else if (o.isLine) {
                let e = r.linewidth;
                void 0 === e && (e = 1),
                X.setLineWidth(e * W()),
                o.isLineSegments ? b.setMode(Ae.LINES) : o.isLineLoop ? b.setMode(Ae.LINE_LOOP) : b.setMode(Ae.LINE_STRIP)
            } else
                o.isPoints ? b.setMode(Ae.POINTS) : o.isSprite && b.setMode(Ae.TRIANGLES);
            if (o.isBatchedMesh)
                if (null !== o._multiDrawInstances)
                    xl("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    b.renderMultiDrawInstances(o._multiDrawStarts, o._multiDrawCounts, o._multiDrawCount, o._multiDrawInstances);
                else if (K.get("WEBGL_multi_draw"))
                    b.renderMultiDraw(o._multiDrawStarts, o._multiDrawCounts, o._multiDrawCount);
                else {
                    const e = o._multiDrawStarts,
                        t = o._multiDrawCounts,
                        n = o._multiDrawCount,
                        i = l ? ne.get(l).bytesPerElement : 1,
                        a = J.get(r).currentProgram.getUniforms();
                    for (let r = 0; r < n; r++)
                        a.setValue(Ae, "_gl_DrawID", r),
                        b.render(e[r] / i, t[r])
                }
            else if (o.isInstancedMesh)
                b.renderInstances(p, f, o.count);
            else if (n.isInstancedBufferGeometry) {
                const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                    t = Math.min(n.instanceCount, e);
                b.renderInstances(p, f, t)
            } else
                b.render(p, f)
        },
        this.compile = function(e, t, n=null) {
            null === n && (n = e),
            m = le.get(n),
            m.init(t),
            A.push(m),
            n.traverseVisible(function(e) {
                e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e))
            }),
            e !== n && e.traverseVisible(function(e) {
                e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e))
            }),
            m.setupLights();
            const r = new Set;
            return e.traverse(function(e) {
                if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                    return;
                const t = e.material;
                if (t)
                    if (Array.isArray(t))
                        for (let o = 0; o < t.length; o++) {
                            const i = t[o];
                            Se(i, n, e),
                            r.add(i)
                        }
                    else
                        Se(t, n, e),
                        r.add(t)
            }), m = A.pop(), r
        },
        this.compileAsync = function(e, t, n=null) {
            const r = this.compile(e, t, n);
            return new Promise(t => {
                function n() {
                    r.forEach(function(e) {
                        J.get(e).currentProgram.isReady() && r.delete(e)
                    }),
                    0 !== r.size ? setTimeout(n, 10) : t(e)
                }
                null !== K.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
            })
        };
        let Ie = null;
        function Te() {
            Re.stop()
        }
        function Me() {
            Re.start()
        }
        const Re = new Mh;
        function Be(e, t, n, r) {
            if (!1 === e.visible)
                return;
            if (e.layers.test(t.layers))
                if (e.isGroup)
                    n = e.renderOrder;
                else if (e.isLOD)
                    !0 === e.autoUpdate && e.update(t);
                else if (e.isLight)
                    m.pushLight(e),
                    e.castShadow && m.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || U.intersectsSprite(e)) {
                        r && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(G);
                        const t = oe.update(e),
                            o = e.material;
                        o.visible && g.push(e, t, o, n, V.z, null)
                    }
                } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || U.intersectsObject(e))) {
                    const t = oe.update(e),
                        o = e.material;
                    if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), V.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), V.copy(t.boundingSphere.center)), V.applyMatrix4(e.matrixWorld).applyMatrix4(G)), Array.isArray(o)) {
                        const r = t.groups;
                        for (let i = 0, a = r.length; i < a; i++) {
                            const a = r[i],
                                s = o[a.materialIndex];
                            s && s.visible && g.push(e, t, s, n, V.z, a)
                        }
                    } else
                        o.visible && g.push(e, t, o, n, V.z, null)
                }
            const o = e.children;
            for (let i = 0, a = o.length; i < a; i++)
                Be(o[i], t, n, r)
        }
        function ke(e, t, n, r) {
            const o = e.opaque,
                i = e.transmissive,
                a = e.transparent;
            m.setupLightsView(n),
            !0 === z && ce.setGlobalState(y.clippingPlanes, n),
            r && X.viewport(S.copy(r)),
            o.length > 0 && Pe(o, t, n),
            i.length > 0 && Pe(i, t, n),
            a.length > 0 && Pe(a, t, n),
            X.buffers.depth.setTest(!0),
            X.buffers.depth.setMask(!0),
            X.buffers.color.setMask(!0),
            X.setPolygonOffset(!1)
        }
        function De(e, t, n, r) {
            if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                return;
            void 0 === m.state.transmissionRenderTarget[r.id] && (m.state.transmissionRenderTarget[r.id] = new Ul(1, 1, {
                generateMipmaps: !0,
                type: K.has("EXT_color_buffer_half_float") || K.has("EXT_color_buffer_float") ? Fa : Da,
                minFilter: ka,
                samples: 4,
                stencilBuffer: o,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Sl.workingColorSpace
            }));
            const i = m.state.transmissionRenderTarget[r.id],
                a = r.viewport || S;
            i.setSize(a.z * y.transmissionResolutionScale, a.w * y.transmissionResolutionScale);
            const s = y.getRenderTarget(),
                l = y.getActiveCubeFace(),
                c = y.getActiveMipmapLevel();
            y.setRenderTarget(i),
            y.getClearColor(M),
            R = y.getClearAlpha(),
            R < 1 && y.setClearColor(16777215, .5),
            y.clear(),
            $ && de.render(n);
            const u = y.toneMapping;
            y.toneMapping = 0;
            const d = r.viewport;
            if (void 0 !== r.viewport && (r.viewport = void 0), m.setupLightsView(r), !0 === z && ce.setGlobalState(y.clippingPlanes, r), Pe(e, n, r), Z.updateMultisampleRenderTarget(i), Z.updateRenderTargetMipmap(i), !1 === K.has("WEBGL_multisampled_render_to_texture")) {
                let e = !1;
                for (let o = 0, i = t.length; o < i; o++) {
                    const i = t[o],
                        a = i.object,
                        s = i.geometry,
                        l = i.material,
                        c = i.group;
                    if (2 === l.side && a.layers.test(r.layers)) {
                        const t = l.side;
                        l.side = 1,
                        l.needsUpdate = !0,
                        Oe(a, n, r, s, l, c),
                        l.side = t,
                        l.needsUpdate = !0,
                        e = !0
                    }
                }
                !0 === e && (Z.updateMultisampleRenderTarget(i), Z.updateRenderTargetMipmap(i))
            }
            y.setRenderTarget(s, l, c),
            y.setClearColor(M, R),
            void 0 !== d && (r.viewport = d),
            y.toneMapping = u
        }
        function Pe(e, t, n) {
            const r = !0 === t.isScene ? t.overrideMaterial : null;
            for (let o = 0, i = e.length; o < i; o++) {
                const i = e[o],
                    a = i.object,
                    s = i.geometry,
                    l = i.group;
                let c = i.material;
                !0 === c.allowOverride && null !== r && (c = r),
                a.layers.test(n.layers) && Oe(a, t, n, s, c, l)
            }
        }
        function Oe(e, t, n, r, o, i) {
            e.onBeforeRender(y, t, n, r, o, i),
            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            o.onBeforeRender(y, t, n, r, e, i),
            !0 === o.transparent && 2 === o.side && !1 === o.forceSinglePass ? (o.side = 1, o.needsUpdate = !0, y.renderBufferDirect(n, t, r, o, e, i), o.side = 0, o.needsUpdate = !0, y.renderBufferDirect(n, t, r, o, e, i), o.side = 2) : y.renderBufferDirect(n, t, r, o, e, i),
            e.onAfterRender(y, t, n, r, o, i)
        }
        function Le(e, t, n) {
            !0 !== t.isScene && (t = H);
            const r = J.get(e),
                o = m.state.lights,
                i = m.state.shadowsArray,
                a = o.state.version,
                s = ie.getParameters(e, o.state, i, t, n),
                l = ie.getProgramCacheKey(s);
            let c = r.programs;
            r.environment = e.isMeshStandardMaterial ? t.environment : null,
            r.fog = t.fog,
            r.envMap = (e.isMeshStandardMaterial ? te : ee).get(e.envMap || r.environment),
            r.envMapRotation = null !== r.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
            void 0 === c && (e.addEventListener("dispose", Ee), c = new Map, r.programs = c);
            let u = c.get(l);
            if (void 0 !== u) {
                if (r.currentProgram === u && r.lightsStateVersion === a)
                    return Fe(e, s), u
            } else
                s.uniforms = ie.getUniforms(e),
                e.onBeforeCompile(s, y),
                u = ie.acquireProgram(s, l),
                c.set(l, u),
                r.uniforms = s.uniforms;
            const d = r.uniforms;
            return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = ce.uniform), Fe(e, s), r.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e), r.lightsStateVersion = a, r.needsLights && (d.ambientLightColor.value = o.state.ambient, d.lightProbe.value = o.state.probe, d.directionalLights.value = o.state.directional, d.directionalLightShadows.value = o.state.directionalShadow, d.spotLights.value = o.state.spot, d.spotLightShadows.value = o.state.spotShadow, d.rectAreaLights.value = o.state.rectArea, d.ltc_1.value = o.state.rectAreaLTC1, d.ltc_2.value = o.state.rectAreaLTC2, d.pointLights.value = o.state.point, d.pointLightShadows.value = o.state.pointShadow, d.hemisphereLights.value = o.state.hemi, d.directionalShadowMap.value = o.state.directionalShadowMap, d.directionalShadowMatrix.value = o.state.directionalShadowMatrix, d.spotShadowMap.value = o.state.spotShadowMap, d.spotLightMatrix.value = o.state.spotLightMatrix, d.spotLightMap.value = o.state.spotLightMap, d.pointShadowMap.value = o.state.pointShadowMap, d.pointShadowMatrix.value = o.state.pointShadowMatrix), r.currentProgram = u, r.uniformsList = null, u
        }
        function Ne(e) {
            if (null === e.uniformsList) {
                const t = e.currentProgram.getUniforms();
                e.uniformsList = bg.seqWithValue(t.seq, e.uniforms)
            }
            return e.uniformsList
        }
        function Fe(e, t) {
            const n = J.get(e);
            n.outputColorSpace = t.outputColorSpace,
            n.batching = t.batching,
            n.batchingColor = t.batchingColor,
            n.instancing = t.instancing,
            n.instancingColor = t.instancingColor,
            n.instancingMorph = t.instancingMorph,
            n.skinning = t.skinning,
            n.morphTargets = t.morphTargets,
            n.morphNormals = t.morphNormals,
            n.morphColors = t.morphColors,
            n.morphTargetsCount = t.morphTargetsCount,
            n.numClippingPlanes = t.numClippingPlanes,
            n.numIntersection = t.numClipIntersection,
            n.vertexAlphas = t.vertexAlphas,
            n.vertexTangents = t.vertexTangents,
            n.toneMapping = t.toneMapping
        }
        Re.setAnimationLoop(function(e) {
            Ie && Ie(e)
        }),
        "undefined" != typeof self && Re.setContext(self),
        this.setAnimationLoop = function(e) {
            Ie = e,
            _e.setAnimationLoop(e),
            null === e ? Re.stop() : Re.start()
        },
        _e.addEventListener("sessionstart", Te),
        _e.addEventListener("sessionend", Me),
        this.render = function(e, t) {
            if (void 0 !== t && !0 !== t.isCamera)
                return;
            if (!0 === v)
                return;
            if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === _e.enabled && !0 === _e.isPresenting && (!0 === _e.cameraAutoUpdate && _e.updateCamera(t), t = _e.getCamera()), !0 === e.isScene && e.onBeforeRender(y, e, t, w), m = le.get(e, A.length), m.init(t), A.push(m), G.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), U.setFromProjectionMatrix(G, Ys, t.reversedDepth), Q = this.localClippingEnabled, z = ce.init(this.clippingPlanes, Q), g = se.get(e, b.length), g.init(), b.push(g), !0 === _e.enabled && !0 === _e.isPresenting) {
                const e = y.xr.getDepthSensingMesh();
                null !== e && Be(e, t, -1 / 0, y.sortObjects)
            }
            Be(e, t, 0, y.sortObjects),
            g.finish(),
            !0 === y.sortObjects && g.sort(P, O),
            $ = !1 === _e.enabled || !1 === _e.isPresenting || !1 === _e.hasDepthSensing(),
            $ && de.addToRenderList(g, e),
            this.info.render.frame++,
            !0 === z && ce.beginShadows();
            const n = m.state.shadowsArray;
            ue.render(n, e, t),
            !0 === z && ce.endShadows(),
            !0 === this.info.autoReset && this.info.reset();
            const r = g.opaque,
                o = g.transmissive;
            if (m.setupLights(), t.isArrayCamera) {
                const n = t.cameras;
                if (o.length > 0)
                    for (let t = 0, i = n.length; t < i; t++)
                        De(r, o, e, n[t]);
                $ && de.render(e);
                for (let t = 0, r = n.length; t < r; t++) {
                    const r = n[t];
                    ke(g, e, r, r.viewport)
                }
            } else
                o.length > 0 && De(r, o, e, t),
                $ && de.render(e),
                ke(g, e, t);
            null !== w && 0 === x && (Z.updateMultisampleRenderTarget(w), Z.updateRenderTargetMipmap(w)),
            !0 === e.isScene && e.onAfterRender(y, e, t),
            me.resetDefaultState(),
            C = -1,
            E = null,
            A.pop(),
            A.length > 0 ? (m = A[A.length - 1], !0 === z && ce.setGlobalState(y.clippingPlanes, m.state.camera)) : m = null,
            b.pop(),
            g = b.length > 0 ? b[b.length - 1] : null
        },
        this.getActiveCubeFace = function() {
            return _
        },
        this.getActiveMipmapLevel = function() {
            return x
        },
        this.getRenderTarget = function() {
            return w
        },
        this.setRenderTargetTextures = function(e, t, n) {
            const r = J.get(e);
            r.__autoAllocateDepthBuffer = !1 === e.resolveDepthBuffer,
            !1 === r.__autoAllocateDepthBuffer && (r.__useRenderToTexture = !1),
            J.get(e.texture).__webglTexture = t,
            J.get(e.depthTexture).__webglTexture = r.__autoAllocateDepthBuffer ? void 0 : n,
            r.__hasExternalTextures = !0
        },
        this.setRenderTargetFramebuffer = function(e, t) {
            const n = J.get(e);
            n.__webglFramebuffer = t,
            n.__useDefaultFramebuffer = void 0 === t
        };
        const Ue = Ae.createFramebuffer();
        this.setRenderTarget = function(e, t=0, n=0) {
            w = e,
            _ = t,
            x = n;
            let r = !0,
                o = null,
                i = !1,
                a = !1;
            if (e) {
                const s = J.get(e);
                if (void 0 !== s.__useDefaultFramebuffer)
                    X.bindFramebuffer(Ae.FRAMEBUFFER, null),
                    r = !1;
                else if (void 0 === s.__webglFramebuffer)
                    Z.setupRenderTarget(e);
                else if (s.__hasExternalTextures)
                    Z.rebindTextures(e, J.get(e.texture).__webglTexture, J.get(e.depthTexture).__webglTexture);
                else if (e.depthBuffer) {
                    const t = e.depthTexture;
                    if (s.__boundDepthTexture !== t) {
                        if (null !== t && J.has(t) && (e.width !== t.image.width || e.height !== t.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        Z.setupDepthRenderbuffer(e)
                    }
                }
                const l = e.texture;
                (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                const c = J.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (o = Array.isArray(c[t]) ? c[t][n] : c[t], i = !0) : o = e.samples > 0 && !1 === Z.useMultisampledRTT(e) ? J.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                S.copy(e.viewport),
                I.copy(e.scissor),
                T = e.scissorTest
            } else
                S.copy(L).multiplyScalar(D).floor(),
                I.copy(N).multiplyScalar(D).floor(),
                T = F;
            if (0 !== n && (o = Ue), X.bindFramebuffer(Ae.FRAMEBUFFER, o) && r && X.drawBuffers(e, o), X.viewport(S), X.scissor(I), X.setScissorTest(T), i) {
                const r = J.get(e.texture);
                Ae.framebufferTexture2D(Ae.FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, Ae.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n)
            } else if (a) {
                const r = t;
                for (let t = 0; t < e.textures.length; t++) {
                    const o = J.get(e.textures[t]);
                    Ae.framebufferTextureLayer(Ae.FRAMEBUFFER, Ae.COLOR_ATTACHMENT0 + t, o.__webglTexture, n, r)
                }
            } else if (null !== e && 0 !== n) {
                const t = J.get(e.texture);
                Ae.framebufferTexture2D(Ae.FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, Ae.TEXTURE_2D, t.__webglTexture, n)
            }
            C = -1
        },
        this.readRenderTargetPixels = function(e, t, n, r, o, i, a, s=0) {
            if (!e || !e.isWebGLRenderTarget)
                return;
            let l = J.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== a && (l = l[a]), l) {
                X.bindFramebuffer(Ae.FRAMEBUFFER, l);
                try {
                    const a = e.textures[s],
                        l = a.format,
                        c = a.type;
                    if (!q.textureFormatReadable(l))
                        return;
                    if (!q.textureTypeReadable(c))
                        return;
                    t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - o && (e.textures.length > 1 && Ae.readBuffer(Ae.COLOR_ATTACHMENT0 + s), Ae.readPixels(t, n, r, o, ge.convert(l), ge.convert(c), i))
                } finally {
                    const e = null !== w ? J.get(w).__webglFramebuffer : null;
                    X.bindFramebuffer(Ae.FRAMEBUFFER, e)
                }
            }
        },
        this.readRenderTargetPixelsAsync = async function(e, t, n, r, o, i, a, s=0) {
            if (!e || !e.isWebGLRenderTarget)
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let l = J.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== a && (l = l[a]), l) {
                if (t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - o) {
                    X.bindFramebuffer(Ae.FRAMEBUFFER, l);
                    const a = e.textures[s],
                        c = a.format,
                        u = a.type;
                    if (!q.textureFormatReadable(c))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!q.textureTypeReadable(u))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const d = Ae.createBuffer();
                    Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, d),
                    Ae.bufferData(Ae.PIXEL_PACK_BUFFER, i.byteLength, Ae.STREAM_READ),
                    e.textures.length > 1 && Ae.readBuffer(Ae.COLOR_ATTACHMENT0 + s),
                    Ae.readPixels(t, n, r, o, ge.convert(c), ge.convert(u), 0);
                    const p = null !== w ? J.get(w).__webglFramebuffer : null;
                    X.bindFramebuffer(Ae.FRAMEBUFFER, p);
                    const h = Ae.fenceSync(Ae.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return Ae.flush(), await function(e, t) {
                        return new Promise(function(n, r) {
                            setTimeout(function o() {
                                switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                case e.WAIT_FAILED:
                                    r();
                                    break;
                                case e.TIMEOUT_EXPIRED:
                                    setTimeout(o, 4);
                                    break;
                                default:
                                    n()
                                }
                            }, 4)
                        })
                    }(Ae, h), Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, d), Ae.getBufferSubData(Ae.PIXEL_PACK_BUFFER, 0, i), Ae.deleteBuffer(d), Ae.deleteSync(h), i
                }
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
            }
        },
        this.copyFramebufferToTexture = function(e, t=null, n=0) {
            const r = Math.pow(2, -n),
                o = Math.floor(e.image.width * r),
                i = Math.floor(e.image.height * r),
                a = null !== t ? t.x : 0,
                s = null !== t ? t.y : 0;
            Z.setTexture2D(e, 0),
            Ae.copyTexSubImage2D(Ae.TEXTURE_2D, n, 0, 0, a, s, o, i),
            X.unbindTexture()
        };
        const ze = Ae.createFramebuffer(),
            Qe = Ae.createFramebuffer();
        this.copyTextureToTexture = function(e, t, n=null, r=null, o=0, i=null) {
            let a,
                s,
                l,
                c,
                u,
                d,
                p,
                h,
                f;
            null === i && (0 !== o ? (xl("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), i = o, o = 0) : i = 0);
            const g = e.isCompressedTexture ? e.mipmaps[i] : e.image;
            if (null !== n)
                a = n.max.x - n.min.x,
                s = n.max.y - n.min.y,
                l = n.isBox3 ? n.max.z - n.min.z : 1,
                c = n.min.x,
                u = n.min.y,
                d = n.isBox3 ? n.min.z : 0;
            else {
                const t = Math.pow(2, -o);
                a = Math.floor(g.width * t),
                s = Math.floor(g.height * t),
                l = e.isDataArrayTexture ? g.depth : e.isData3DTexture ? Math.floor(g.depth * t) : 1,
                c = 0,
                u = 0,
                d = 0
            }
            null !== r ? (p = r.x, h = r.y, f = r.z) : (p = 0, h = 0, f = 0);
            const m = ge.convert(t.format),
                b = ge.convert(t.type);
            let A;
            t.isData3DTexture ? (Z.setTexture3D(t, 0), A = Ae.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (Z.setTexture2DArray(t, 0), A = Ae.TEXTURE_2D_ARRAY) : (Z.setTexture2D(t, 0), A = Ae.TEXTURE_2D),
            Ae.pixelStorei(Ae.UNPACK_FLIP_Y_WEBGL, t.flipY),
            Ae.pixelStorei(Ae.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
            Ae.pixelStorei(Ae.UNPACK_ALIGNMENT, t.unpackAlignment);
            const y = Ae.getParameter(Ae.UNPACK_ROW_LENGTH),
                v = Ae.getParameter(Ae.UNPACK_IMAGE_HEIGHT),
                _ = Ae.getParameter(Ae.UNPACK_SKIP_PIXELS),
                x = Ae.getParameter(Ae.UNPACK_SKIP_ROWS),
                w = Ae.getParameter(Ae.UNPACK_SKIP_IMAGES);
            Ae.pixelStorei(Ae.UNPACK_ROW_LENGTH, g.width),
            Ae.pixelStorei(Ae.UNPACK_IMAGE_HEIGHT, g.height),
            Ae.pixelStorei(Ae.UNPACK_SKIP_PIXELS, c),
            Ae.pixelStorei(Ae.UNPACK_SKIP_ROWS, u),
            Ae.pixelStorei(Ae.UNPACK_SKIP_IMAGES, d);
            const C = e.isDataArrayTexture || e.isData3DTexture,
                E = t.isDataArrayTexture || t.isData3DTexture;
            if (e.isDepthTexture) {
                const n = J.get(e),
                    r = J.get(t),
                    g = J.get(n.__renderTarget),
                    m = J.get(r.__renderTarget);
                X.bindFramebuffer(Ae.READ_FRAMEBUFFER, g.__webglFramebuffer),
                X.bindFramebuffer(Ae.DRAW_FRAMEBUFFER, m.__webglFramebuffer);
                for (let b = 0; b < l; b++)
                    C && (Ae.framebufferTextureLayer(Ae.READ_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, J.get(e).__webglTexture, o, d + b), Ae.framebufferTextureLayer(Ae.DRAW_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, J.get(t).__webglTexture, i, f + b)),
                    Ae.blitFramebuffer(c, u, a, s, p, h, a, s, Ae.DEPTH_BUFFER_BIT, Ae.NEAREST);
                X.bindFramebuffer(Ae.READ_FRAMEBUFFER, null),
                X.bindFramebuffer(Ae.DRAW_FRAMEBUFFER, null)
            } else if (0 !== o || e.isRenderTargetTexture || J.has(e)) {
                const n = J.get(e),
                    r = J.get(t);
                X.bindFramebuffer(Ae.READ_FRAMEBUFFER, ze),
                X.bindFramebuffer(Ae.DRAW_FRAMEBUFFER, Qe);
                for (let e = 0; e < l; e++)
                    C ? Ae.framebufferTextureLayer(Ae.READ_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, n.__webglTexture, o, d + e) : Ae.framebufferTexture2D(Ae.READ_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, Ae.TEXTURE_2D, n.__webglTexture, o),
                    E ? Ae.framebufferTextureLayer(Ae.DRAW_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, r.__webglTexture, i, f + e) : Ae.framebufferTexture2D(Ae.DRAW_FRAMEBUFFER, Ae.COLOR_ATTACHMENT0, Ae.TEXTURE_2D, r.__webglTexture, i),
                    0 !== o ? Ae.blitFramebuffer(c, u, a, s, p, h, a, s, Ae.COLOR_BUFFER_BIT, Ae.NEAREST) : E ? Ae.copyTexSubImage3D(A, i, p, h, f + e, c, u, a, s) : Ae.copyTexSubImage2D(A, i, p, h, c, u, a, s);
                X.bindFramebuffer(Ae.READ_FRAMEBUFFER, null),
                X.bindFramebuffer(Ae.DRAW_FRAMEBUFFER, null)
            } else
                E ? e.isDataTexture || e.isData3DTexture ? Ae.texSubImage3D(A, i, p, h, f, a, s, l, m, b, g.data) : t.isCompressedArrayTexture ? Ae.compressedTexSubImage3D(A, i, p, h, f, a, s, l, m, g.data) : Ae.texSubImage3D(A, i, p, h, f, a, s, l, m, b, g) : e.isDataTexture ? Ae.texSubImage2D(Ae.TEXTURE_2D, i, p, h, a, s, m, b, g.data) : e.isCompressedTexture ? Ae.compressedTexSubImage2D(Ae.TEXTURE_2D, i, p, h, g.width, g.height, m, g.data) : Ae.texSubImage2D(Ae.TEXTURE_2D, i, p, h, a, s, m, b, g);
            Ae.pixelStorei(Ae.UNPACK_ROW_LENGTH, y),
            Ae.pixelStorei(Ae.UNPACK_IMAGE_HEIGHT, v),
            Ae.pixelStorei(Ae.UNPACK_SKIP_PIXELS, _),
            Ae.pixelStorei(Ae.UNPACK_SKIP_ROWS, x),
            Ae.pixelStorei(Ae.UNPACK_SKIP_IMAGES, w),
            0 === i && t.generateMipmaps && Ae.generateMipmap(A),
            X.unbindTexture()
        },
        this.initRenderTarget = function(e) {
            void 0 === J.get(e).__webglFramebuffer && Z.setupRenderTarget(e)
        },
        this.initTexture = function(e) {
            e.isCubeTexture ? Z.setTextureCube(e, 0) : e.isData3DTexture ? Z.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? Z.setTexture2DArray(e, 0) : Z.setTexture2D(e, 0),
            X.unbindTexture()
        },
        this.resetState = function() {
            _ = 0,
            x = 0,
            w = null,
            X.reset(),
            me.reset()
        },
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem()
    {
        return Ys
    }
    get outputColorSpace()
    {
        return this._outputColorSpace
    }
    set outputColorSpace(e)
    {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = Sl._getDrawingBufferColorSpace(e),
        t.unpackColorSpace = Sl._getUnpackColorSpace()
    }
}
const um = {
        type: "change"
    },
    dm = {
        type: "start"
    },
    pm = {
        type: "end"
    },
    hm = new fc,
    fm = new Fd,
    gm = Math.cos(70 * ul.DEG2RAD),
    mm = new hl,
    bm = 2 * Math.PI,
    Am = -1,
    ym = 1e-6;
class vm extends Ih {
    constructor(e, t=null)
    {
        super(e, t),
        this.state = Am,
        this.target = new hl,
        this.cursor = new hl,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minTargetRadius = 0,
        this.maxTargetRadius = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.keyRotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        this.touches = {
            ONE: 0,
            TWO: 2
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this._lastPosition = new hl,
        this._lastQuaternion = new pl,
        this._lastTargetPosition = new hl,
        this._quat = (new pl).setFromUnitVectors(e.up, new hl(0, 1, 0)),
        this._quatInverse = this._quat.clone().invert(),
        this._spherical = new Sh,
        this._sphericalDelta = new Sh,
        this._scale = 1,
        this._panOffset = new hl,
        this._rotateStart = new dl,
        this._rotateEnd = new dl,
        this._rotateDelta = new dl,
        this._panStart = new dl,
        this._panEnd = new dl,
        this._panDelta = new dl,
        this._dollyStart = new dl,
        this._dollyEnd = new dl,
        this._dollyDelta = new dl,
        this._dollyDirection = new hl,
        this._mouse = new dl,
        this._performCursorZoom = !1,
        this._pointers = [],
        this._pointerPositions = {},
        this._controlActive = !1,
        this._onPointerMove = xm.bind(this),
        this._onPointerDown = _m.bind(this),
        this._onPointerUp = wm.bind(this),
        this._onContextMenu = Rm.bind(this),
        this._onMouseWheel = Sm.bind(this),
        this._onKeyDown = Im.bind(this),
        this._onTouchStart = Tm.bind(this),
        this._onTouchMove = Mm.bind(this),
        this._onMouseDown = Cm.bind(this),
        this._onMouseMove = Em.bind(this),
        this._interceptControlDown = Bm.bind(this),
        this._interceptControlUp = km.bind(this),
        null !== this.domElement && this.connect(this.domElement),
        this.update()
    }
    connect(e)
    {
        super.connect(e),
        this.domElement.addEventListener("pointerdown", this._onPointerDown),
        this.domElement.addEventListener("pointercancel", this._onPointerUp),
        this.domElement.addEventListener("contextmenu", this._onContextMenu),
        this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: !1
        }),
        this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: !0,
            capture: !0
        }),
        this.domElement.style.touchAction = "none"
    }
    disconnect()
    {
        this.domElement.removeEventListener("pointerdown", this._onPointerDown),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.domElement.removeEventListener("pointercancel", this._onPointerUp),
        this.domElement.removeEventListener("wheel", this._onMouseWheel),
        this.domElement.removeEventListener("contextmenu", this._onContextMenu),
        this.stopListenToKeyEvents(),
        this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: !0
        }),
        this.domElement.style.touchAction = "auto"
    }
    dispose()
    {
        this.disconnect()
    }
    getPolarAngle()
    {
        return this._spherical.phi
    }
    getAzimuthalAngle()
    {
        return this._spherical.theta
    }
    getDistance()
    {
        return this.object.position.distanceTo(this.target)
    }
    listenToKeyEvents(e)
    {
        e.addEventListener("keydown", this._onKeyDown),
        this._domElementKeyEvents = e
    }
    stopListenToKeyEvents()
    {
        null !== this._domElementKeyEvents && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null)
    }
    saveState()
    {
        this.target0.copy(this.target),
        this.position0.copy(this.object.position),
        this.zoom0 = this.object.zoom
    }
    reset()
    {
        this.target.copy(this.target0),
        this.object.position.copy(this.position0),
        this.object.zoom = this.zoom0,
        this.object.updateProjectionMatrix(),
        this.dispatchEvent(um),
        this.update(),
        this.state = Am
    }
    update(e=null)
    {
        const t = this.object.position;
        mm.copy(t).sub(this.target),
        mm.applyQuaternion(this._quat),
        this._spherical.setFromVector3(mm),
        this.autoRotate && this.state === Am && this._rotateLeft(this._getAutoRotationAngle(e)),
        this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
        let n = this.minAzimuthAngle,
            r = this.maxAzimuthAngle;
        isFinite(n) && isFinite(r) && (n < -Math.PI ? n += bm : n > Math.PI && (n -= bm), r < -Math.PI ? r += bm : r > Math.PI && (r -= bm), this._spherical.theta = n <= r ? Math.max(n, Math.min(r, this._spherical.theta)) : this._spherical.theta > (n + r) / 2 ? Math.max(n, this._spherical.theta) : Math.min(r, this._spherical.theta)),
        this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)),
        this._spherical.makeSafe(),
        !0 === this.enableDamping ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset),
        this.target.sub(this.cursor),
        this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
        this.target.add(this.cursor);
        let o = !1;
        if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
            this._spherical.radius = this._clampDistance(this._spherical.radius);
        else {
            const e = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale),
            o = e != this._spherical.radius
        }
        if (mm.setFromSpherical(this._spherical), mm.applyQuaternion(this._quatInverse), t.copy(this.target).add(mm), this.object.lookAt(this.target), !0 === this.enableDamping ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let e = null;
            if (this.object.isPerspectiveCamera) {
                const t = mm.length();
                e = this._clampDistance(t * this._scale);
                const n = t - e;
                this.object.position.addScaledVector(this._dollyDirection, n),
                this.object.updateMatrixWorld(),
                o = !!n
            } else if (this.object.isOrthographicCamera) {
                const t = new hl(this._mouse.x, this._mouse.y, 0);
                t.unproject(this.object);
                const n = this.object.zoom;
                this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
                this.object.updateProjectionMatrix(),
                o = n !== this.object.zoom;
                const r = new hl(this._mouse.x, this._mouse.y, 0);
                r.unproject(this.object),
                this.object.position.sub(r).add(t),
                this.object.updateMatrixWorld(),
                e = mm.length()
            } else
                this.zoomToCursor = !1;
            null !== e && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(e).add(this.object.position) : (hm.origin.copy(this.object.position), hm.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(hm.direction)) < gm ? this.object.lookAt(this.target) : (fm.setFromNormalAndCoplanarPoint(this.object.up, this.target), hm.intersectPlane(fm, this.target))))
        } else if (this.object.isOrthographicCamera) {
            const e = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
            e !== this.object.zoom && (this.object.updateProjectionMatrix(), o = !0)
        }
        return this._scale = 1, this._performCursorZoom = !1, !!(o || this._lastPosition.distanceToSquared(this.object.position) > ym || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > ym || this._lastTargetPosition.distanceToSquared(this.target) > ym) && (this.dispatchEvent(um), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0)
    }
    _getAutoRotationAngle(e)
    {
        return null !== e ? bm / 60 * this.autoRotateSpeed * e : bm / 60 / 60 * this.autoRotateSpeed
    }
    _getZoomScale(e)
    {
        const t = Math.abs(.01 * e);
        return Math.pow(.95, this.zoomSpeed * t)
    }
    _rotateLeft(e)
    {
        this._sphericalDelta.theta -= e
    }
    _rotateUp(e)
    {
        this._sphericalDelta.phi -= e
    }
    _panLeft(e, t)
    {
        mm.setFromMatrixColumn(t, 0),
        mm.multiplyScalar(-e),
        this._panOffset.add(mm)
    }
    _panUp(e, t)
    {
        !0 === this.screenSpacePanning ? mm.setFromMatrixColumn(t, 1) : (mm.setFromMatrixColumn(t, 0), mm.crossVectors(this.object.up, mm)),
        mm.multiplyScalar(e),
        this._panOffset.add(mm)
    }
    _pan(e, t)
    {
        const n = this.domElement;
        if (this.object.isPerspectiveCamera) {
            const r = this.object.position;
            mm.copy(r).sub(this.target);
            let o = mm.length();
            o *= Math.tan(this.object.fov / 2 * Math.PI / 180),
            this._panLeft(2 * e * o / n.clientHeight, this.object.matrix),
            this._panUp(2 * t * o / n.clientHeight, this.object.matrix)
        } else
            this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : this.enablePan = !1
    }
    _dollyOut(e)
    {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : this.enableZoom = !1
    }
    _dollyIn(e)
    {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : this.enableZoom = !1
    }
    _updateZoomParameters(e, t)
    {
        if (!this.zoomToCursor)
            return;
        this._performCursorZoom = !0;
        const n = this.domElement.getBoundingClientRect(),
            r = e - n.left,
            o = t - n.top,
            i = n.width,
            a = n.height;
        this._mouse.x = r / i * 2 - 1,
        this._mouse.y = -o / a * 2 + 1,
        this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize()
    }
    _clampDistance(e)
    {
        return Math.max(this.minDistance, Math.min(this.maxDistance, e))
    }
    _handleMouseDownRotate(e)
    {
        this._rotateStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownDolly(e)
    {
        this._updateZoomParameters(e.clientX, e.clientX),
        this._dollyStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownPan(e)
    {
        this._panStart.set(e.clientX, e.clientY)
    }
    _handleMouseMoveRotate(e)
    {
        this._rotateEnd.set(e.clientX, e.clientY),
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(bm * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(bm * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd),
        this.update()
    }
    _handleMouseMoveDolly(e)
    {
        this._dollyEnd.set(e.clientX, e.clientY),
        this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
        this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
        this._dollyStart.copy(this._dollyEnd),
        this.update()
    }
    _handleMouseMovePan(e)
    {
        this._panEnd.set(e.clientX, e.clientY),
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd),
        this.update()
    }
    _handleMouseWheel(e)
    {
        this._updateZoomParameters(e.clientX, e.clientY),
        e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
        this.update()
    }
    _handleKeyDown(e)
    {
        let t = !1;
        switch (e.code) {
        case this.keys.UP:
            e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(bm * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.BOTTOM:
            e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-bm * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.LEFT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(bm * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0),
            t = !0;
            break;
        case this.keys.RIGHT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-bm * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0),
            t = !0
        }
        t && (e.preventDefault(), this.update())
    }
    _handleTouchStartRotate(e)
    {
        if (1 === this._pointers.length)
            this._rotateStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
            this._rotateStart.set(n, r)
        }
    }
    _handleTouchStartPan(e)
    {
        if (1 === this._pointers.length)
            this._panStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
            this._panStart.set(n, r)
        }
    }
    _handleTouchStartDolly(e)
    {
        const t = this._getSecondPointerPosition(e),
            n = e.pageX - t.x,
            r = e.pageY - t.y,
            o = Math.sqrt(n * n + r * r);
        this._dollyStart.set(0, o)
    }
    _handleTouchStartDollyPan(e)
    {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enablePan && this._handleTouchStartPan(e)
    }
    _handleTouchStartDollyRotate(e)
    {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enableRotate && this._handleTouchStartRotate(e)
    }
    _handleTouchMoveRotate(e)
    {
        if (1 == this._pointers.length)
            this._rotateEnd.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
            this._rotateEnd.set(n, r)
        }
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(bm * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(bm * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd)
    }
    _handleTouchMovePan(e)
    {
        if (1 === this._pointers.length)
            this._panEnd.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e),
                n = .5 * (e.pageX + t.x),
                r = .5 * (e.pageY + t.y);
            this._panEnd.set(n, r)
        }
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd)
    }
    _handleTouchMoveDolly(e)
    {
        const t = this._getSecondPointerPosition(e),
            n = e.pageX - t.x,
            r = e.pageY - t.y,
            o = Math.sqrt(n * n + r * r);
        this._dollyEnd.set(0, o),
        this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)),
        this._dollyOut(this._dollyDelta.y),
        this._dollyStart.copy(this._dollyEnd);
        const i = .5 * (e.pageX + t.x),
            a = .5 * (e.pageY + t.y);
        this._updateZoomParameters(i, a)
    }
    _handleTouchMoveDollyPan(e)
    {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enablePan && this._handleTouchMovePan(e)
    }
    _handleTouchMoveDollyRotate(e)
    {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enableRotate && this._handleTouchMoveRotate(e)
    }
    _addPointer(e)
    {
        this._pointers.push(e.pointerId)
    }
    _removePointer(e)
    {
        delete this._pointerPositions[e.pointerId];
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId)
                return void this._pointers.splice(t, 1)
    }
    _isTrackingPointer(e)
    {
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId)
                return !0;
        return !1
    }
    _trackPointer(e)
    {
        let t = this._pointerPositions[e.pointerId];
        void 0 === t && (t = new dl, this._pointerPositions[e.pointerId] = t),
        t.set(e.pageX, e.pageY)
    }
    _getSecondPointerPosition(e)
    {
        const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
        return this._pointerPositions[t]
    }
    _customWheelEvent(e)
    {
        const t = e.deltaMode,
            n = {
                clientX: e.clientX,
                clientY: e.clientY,
                deltaY: e.deltaY
            };
        switch (t) {
        case 1:
            n.deltaY *= 16;
            break;
        case 2:
            n.deltaY *= 100
        }
        return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n
    }
}
function _m(e) {
    !1 !== this.enabled && (0 === this._pointers.length && (this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), this._isTrackingPointer(e) || (this._addPointer(e), "touch" === e.pointerType ? this._onTouchStart(e) : this._onMouseDown(e)))
}
function xm(e) {
    !1 !== this.enabled && ("touch" === e.pointerType ? this._onTouchMove(e) : this._onMouseMove(e))
}
function wm(e) {
    switch (this._removePointer(e), this._pointers.length) {
    case 0:
        this.domElement.releasePointerCapture(e.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(pm),
        this.state = Am;
        break;
    case 1:
        const t = this._pointers[0],
            n = this._pointerPositions[t];
        this._onTouchStart({
            pointerId: t,
            pageX: n.x,
            pageY: n.y
        })
    }
}
function Cm(e) {
    let t;
    switch (e.button) {
    case 0:
        t = this.mouseButtons.LEFT;
        break;
    case 1:
        t = this.mouseButtons.MIDDLE;
        break;
    case 2:
        t = this.mouseButtons.RIGHT;
        break;
    default:
        t = -1
    }
    switch (t) {
    case 1:
        if (!1 === this.enableZoom)
            return;
        this._handleMouseDownDolly(e),
        this.state = 1;
        break;
    case 0:
        if (e.ctrlKey || e.metaKey || e.shiftKey) {
            if (!1 === this.enablePan)
                return;
            this._handleMouseDownPan(e),
            this.state = 2
        } else {
            if (!1 === this.enableRotate)
                return;
            this._handleMouseDownRotate(e),
            this.state = 0
        }
        break;
    case 2:
        if (e.ctrlKey || e.metaKey || e.shiftKey) {
            if (!1 === this.enableRotate)
                return;
            this._handleMouseDownRotate(e),
            this.state = 0
        } else {
            if (!1 === this.enablePan)
                return;
            this._handleMouseDownPan(e),
            this.state = 2
        }
        break;
    default:
        this.state = Am
    }
    this.state !== Am && this.dispatchEvent(dm)
}
function Em(e) {
    switch (this.state) {
    case 0:
        if (!1 === this.enableRotate)
            return;
        this._handleMouseMoveRotate(e);
        break;
    case 1:
        if (!1 === this.enableZoom)
            return;
        this._handleMouseMoveDolly(e);
        break;
    case 2:
        if (!1 === this.enablePan)
            return;
        this._handleMouseMovePan(e)
    }
}
function Sm(e) {
    !1 !== this.enabled && !1 !== this.enableZoom && this.state === Am && (e.preventDefault(), this.dispatchEvent(dm), this._handleMouseWheel(this._customWheelEvent(e)), this.dispatchEvent(pm))
}
function Im(e) {
    !1 !== this.enabled && this._handleKeyDown(e)
}
function Tm(e) {
    switch (this._trackPointer(e), this._pointers.length) {
    case 1:
        switch (this.touches.ONE) {
        case 0:
            if (!1 === this.enableRotate)
                return;
            this._handleTouchStartRotate(e),
            this.state = 3;
            break;
        case 1:
            if (!1 === this.enablePan)
                return;
            this._handleTouchStartPan(e),
            this.state = 4;
            break;
        default:
            this.state = Am
        }
        break;
    case 2:
        switch (this.touches.TWO) {
        case 2:
            if (!1 === this.enableZoom && !1 === this.enablePan)
                return;
            this._handleTouchStartDollyPan(e),
            this.state = 5;
            break;
        case 3:
            if (!1 === this.enableZoom && !1 === this.enableRotate)
                return;
            this._handleTouchStartDollyRotate(e),
            this.state = 6;
            break;
        default:
            this.state = Am
        }
        break;
    default:
        this.state = Am
    }
    this.state !== Am && this.dispatchEvent(dm)
}
function Mm(e) {
    switch (this._trackPointer(e), this.state) {
    case 3:
        if (!1 === this.enableRotate)
            return;
        this._handleTouchMoveRotate(e),
        this.update();
        break;
    case 4:
        if (!1 === this.enablePan)
            return;
        this._handleTouchMovePan(e),
        this.update();
        break;
    case 5:
        if (!1 === this.enableZoom && !1 === this.enablePan)
            return;
        this._handleTouchMoveDollyPan(e),
        this.update();
        break;
    case 6:
        if (!1 === this.enableZoom && !1 === this.enableRotate)
            return;
        this._handleTouchMoveDollyRotate(e),
        this.update();
        break;
    default:
        this.state = Am
    }
}
function Rm(e) {
    !1 !== this.enabled && e.preventDefault()
}
function Bm(e) {
    "Control" === e.key && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
function km(e) {
    "Control" === e.key && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
function Dm(e, t) {
    if (0 === t)
        return e;
    if (2 === t || 1 === t) {
        let n = e.getIndex();
        if (null === n) {
            const t = [],
                r = e.getAttribute("position");
            if (void 0 === r)
                return e;
            for (let e = 0; e < r.count; e++)
                t.push(e);
            e.setIndex(t),
            n = e.getIndex()
        }
        const r = n.count - 2,
            o = [];
        if (2 === t)
            for (let e = 1; e <= r; e++)
                o.push(n.getX(0)),
                o.push(n.getX(e)),
                o.push(n.getX(e + 1));
        else
            for (let e = 0; e < r; e++)
                e % 2 == 0 ? (o.push(n.getX(e)), o.push(n.getX(e + 1)), o.push(n.getX(e + 2))) : (o.push(n.getX(e + 2)), o.push(n.getX(e + 1)), o.push(n.getX(e)));
        o.length;
        const i = e.clone();
        return i.setIndex(o), i.clearGroups(), i
    }
    return e
}
class Pm extends jp {
    constructor(e)
    {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(e) {
            return new zm(e)
        }),
        this.register(function(e) {
            return new Qm(e)
        }),
        this.register(function(e) {
            return new Xm(e)
        }),
        this.register(function(e) {
            return new Ym(e)
        }),
        this.register(function(e) {
            return new Jm(e)
        }),
        this.register(function(e) {
            return new jm(e)
        }),
        this.register(function(e) {
            return new Vm(e)
        }),
        this.register(function(e) {
            return new Hm(e)
        }),
        this.register(function(e) {
            return new $m(e)
        }),
        this.register(function(e) {
            return new Um(e)
        }),
        this.register(function(e) {
            return new Wm(e)
        }),
        this.register(function(e) {
            return new Gm(e)
        }),
        this.register(function(e) {
            return new qm(e)
        }),
        this.register(function(e) {
            return new Km(e)
        }),
        this.register(function(e) {
            return new Nm(e)
        }),
        this.register(function(e) {
            return new Zm(e)
        }),
        this.register(function(e) {
            return new eb(e)
        })
    }
    load(e, t, n, r)
    {
        const o = this;
        let i;
        if ("" !== this.resourcePath)
            i = this.resourcePath;
        else if ("" !== this.path) {
            const t = hh.extractUrlBase(e);
            i = hh.resolveURL(t, this.path)
        } else
            i = hh.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(t) {
                r && r(t),
                o.manager.itemError(e),
                o.manager.itemEnd(e)
            },
            s = new $p(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, function(n) {
            try {
                o.parse(n, i, function(n) {
                    t(n),
                    o.manager.itemEnd(e)
                }, a)
            } catch (gL) {
                a(gL)
            }
        }, n, a)
    }
    setDRACOLoader(e)
    {
        return this.dracoLoader = e, this
    }
    setKTX2Loader(e)
    {
        return this.ktx2Loader = e, this
    }
    setMeshoptDecoder(e)
    {
        return this.meshoptDecoder = e, this
    }
    register(e)
    {
        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
    }
    unregister(e)
    {
        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, t, n, r)
    {
        let o;
        const i = {},
            a = {},
            s = new TextDecoder;
        if ("string" == typeof e)
            o = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (s.decode(new Uint8Array(e, 0, 4)) === tb) {
                try {
                    i[Lm.KHR_BINARY_GLTF] = new nb(e)
                } catch (c) {
                    return void (r && r(c))
                }
                o = JSON.parse(i[Lm.KHR_BINARY_GLTF].content)
            } else
                o = JSON.parse(s.decode(e));
        else
            o = e;
        if (void 0 === o.asset || o.asset.version[0] < 2)
            return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const l = new Eb(o, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const e = this.pluginCallbacks[u](l);
            e.name,
            a[e.name] = e,
            i[e.name] = !0
        }
        if (o.extensionsUsed)
            for (let u = 0; u < o.extensionsUsed.length; ++u) {
                const e = o.extensionsUsed[u],
                    t = o.extensionsRequired || [];
                switch (e) {
                case Lm.KHR_MATERIALS_UNLIT:
                    i[e] = new Fm;
                    break;
                case Lm.KHR_DRACO_MESH_COMPRESSION:
                    i[e] = new rb(o, this.dracoLoader);
                    break;
                case Lm.KHR_TEXTURE_TRANSFORM:
                    i[e] = new ob;
                    break;
                case Lm.KHR_MESH_QUANTIZATION:
                    i[e] = new ib;
                    break;
                default:
                    t.indexOf(e) >= 0 && a[e]
                }
            }
        l.setExtensions(i),
        l.setPlugins(a),
        l.parse(n, r)
    }
    parseAsync(e, t)
    {
        const n = this;
        return new Promise(function(r, o) {
            n.parse(e, t, r, o)
        })
    }
}
function Om() {
    let e = {};
    return {
        get: function(t) {
            return e[t]
        },
        add: function(t, n) {
            e[t] = n
        },
        remove: function(t) {
            delete e[t]
        },
        removeAll: function() {
            e = {}
        }
    }
}
const Lm = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Nm {
    constructor(e)
    {
        this.parser = e,
        this.name = Lm.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs()
    {
        const e = this.parser,
            t = this.parser.json.nodes || [];
        for (let n = 0, r = t.length; n < r; n++) {
            const r = t[n];
            r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }
    _loadLight(e)
    {
        const t = this.parser,
            n = "light:" + e;
        let r = t.cache.get(n);
        if (r)
            return r;
        const o = t.json,
            i = ((o.extensions && o.extensions[this.name] || {}).lights || [])[e];
        let a;
        const s = new su(16777215);
        void 0 !== i.color && s.setRGB(i.color[0], i.color[1], i.color[2], Ns);
        const l = void 0 !== i.range ? i.range : 0;
        switch (i.type) {
        case "directional":
            a = new ph(s),
            a.target.position.set(0, 0, -1),
            a.add(a.target);
            break;
        case "point":
            a = new ch(s),
            a.distance = l;
            break;
        case "spot":
            a = new oh(s),
            a.distance = l,
            i.spot = i.spot || {},
            i.spot.innerConeAngle = void 0 !== i.spot.innerConeAngle ? i.spot.innerConeAngle : 0,
            i.spot.outerConeAngle = void 0 !== i.spot.outerConeAngle ? i.spot.outerConeAngle : Math.PI / 4,
            a.angle = i.spot.outerConeAngle,
            a.penumbra = 1 - i.spot.innerConeAngle / i.spot.outerConeAngle,
            a.target.position.set(0, 0, -1),
            a.add(a.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + i.type)
        }
        return a.position.set(0, 0, 0), yb(a, i), void 0 !== i.intensity && (a.intensity = i.intensity), a.name = t.createUniqueName(i.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r
    }
    getDependency(e, t)
    {
        if ("light" === e)
            return this._loadLight(t)
    }
    createNodeAttachment(e)
    {
        const t = this,
            n = this.parser,
            r = n.json.nodes[e],
            o = (r.extensions && r.extensions[this.name] || {}).light;
        return void 0 === o ? null : this._loadLight(o).then(function(e) {
            return n._getNodeRef(t.cache, o, e)
        })
    }
}
let Fm = class {
        constructor()
        {
            this.name = Lm.KHR_MATERIALS_UNLIT
        }
        getMaterialType()
        {
            return du
        }
        extendParams(e, t, n)
        {
            const r = [];
            e.color = new su(1, 1, 1),
            e.opacity = 1;
            const o = t.pbrMetallicRoughness;
            if (o) {
                if (Array.isArray(o.baseColorFactor)) {
                    const t = o.baseColorFactor;
                    e.color.setRGB(t[0], t[1], t[2], Ns),
                    e.opacity = t[3]
                }
                void 0 !== o.baseColorTexture && r.push(n.assignTexture(e, "map", o.baseColorTexture, Ls))
            }
            return Promise.all(r)
        }
    }
    ,
    Um = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_EMISSIVE_STRENGTH
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
                return Promise.resolve();
            const r = n.extensions[this.name].emissiveStrength;
            return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
        }
    }
    ,
    zm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            if (void 0 !== i.clearcoatFactor && (t.clearcoat = i.clearcoatFactor), void 0 !== i.clearcoatTexture && o.push(n.assignTexture(t, "clearcoatMap", i.clearcoatTexture)), void 0 !== i.clearcoatRoughnessFactor && (t.clearcoatRoughness = i.clearcoatRoughnessFactor), void 0 !== i.clearcoatRoughnessTexture && o.push(n.assignTexture(t, "clearcoatRoughnessMap", i.clearcoatRoughnessTexture)), void 0 !== i.clearcoatNormalTexture && (o.push(n.assignTexture(t, "clearcoatNormalMap", i.clearcoatNormalTexture)), void 0 !== i.clearcoatNormalTexture.scale)) {
                const e = i.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new dl(e, e)
            }
            return Promise.all(o)
        }
    }
    ,
    Qm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_DISPERSION
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
                return Promise.resolve();
            const r = n.extensions[this.name];
            return t.dispersion = void 0 !== r.dispersion ? r.dispersion : 0, Promise.resolve()
        }
    }
    ,
    Gm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_IRIDESCENCE
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            return void 0 !== i.iridescenceFactor && (t.iridescence = i.iridescenceFactor), void 0 !== i.iridescenceTexture && o.push(n.assignTexture(t, "iridescenceMap", i.iridescenceTexture)), void 0 !== i.iridescenceIor && (t.iridescenceIOR = i.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== i.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = i.iridescenceThicknessMinimum), void 0 !== i.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = i.iridescenceThicknessMaximum), void 0 !== i.iridescenceThicknessTexture && o.push(n.assignTexture(t, "iridescenceThicknessMap", i.iridescenceThicknessTexture)), Promise.all(o)
        }
    }
    ,
    jm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [];
            t.sheenColor = new su(0, 0, 0),
            t.sheenRoughness = 0,
            t.sheen = 1;
            const i = r.extensions[this.name];
            if (void 0 !== i.sheenColorFactor) {
                const e = i.sheenColorFactor;
                t.sheenColor.setRGB(e[0], e[1], e[2], Ns)
            }
            return void 0 !== i.sheenRoughnessFactor && (t.sheenRoughness = i.sheenRoughnessFactor), void 0 !== i.sheenColorTexture && o.push(n.assignTexture(t, "sheenColorMap", i.sheenColorTexture, Ls)), void 0 !== i.sheenRoughnessTexture && o.push(n.assignTexture(t, "sheenRoughnessMap", i.sheenRoughnessTexture)), Promise.all(o)
        }
    }
    ,
    Vm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            return void 0 !== i.transmissionFactor && (t.transmission = i.transmissionFactor), void 0 !== i.transmissionTexture && o.push(n.assignTexture(t, "transmissionMap", i.transmissionTexture)), Promise.all(o)
        }
    }
    ,
    Hm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            t.thickness = void 0 !== i.thicknessFactor ? i.thicknessFactor : 0,
            void 0 !== i.thicknessTexture && o.push(n.assignTexture(t, "thicknessMap", i.thicknessTexture)),
            t.attenuationDistance = i.attenuationDistance || 1 / 0;
            const a = i.attenuationColor || [1, 1, 1];
            return t.attenuationColor = (new su).setRGB(a[0], a[1], a[2], Ns), Promise.all(o)
        }
    }
    ,
    $m = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_IOR
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
                return Promise.resolve();
            const r = n.extensions[this.name];
            return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
        }
    }
    ,
    Wm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            t.specularIntensity = void 0 !== i.specularFactor ? i.specularFactor : 1,
            void 0 !== i.specularTexture && o.push(n.assignTexture(t, "specularIntensityMap", i.specularTexture));
            const a = i.specularColorFactor || [1, 1, 1];
            return t.specularColor = (new su).setRGB(a[0], a[1], a[2], Ns), void 0 !== i.specularColorTexture && o.push(n.assignTexture(t, "specularColorMap", i.specularColorTexture, Ls)), Promise.all(o)
        }
    }
    ,
    Km = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.EXT_MATERIALS_BUMP
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            return t.bumpScale = void 0 !== i.bumpFactor ? i.bumpFactor : 1, void 0 !== i.bumpTexture && o.push(n.assignTexture(t, "bumpMap", i.bumpTexture)), Promise.all(o)
        }
    }
    ,
    qm = class {
        constructor(e)
        {
            this.parser = e,
            this.name = Lm.KHR_MATERIALS_ANISOTROPY
        }
        getMaterialType(e)
        {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? yp : null
        }
        extendMaterialParams(e, t)
        {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name])
                return Promise.resolve();
            const o = [],
                i = r.extensions[this.name];
            return void 0 !== i.anisotropyStrength && (t.anisotropy = i.anisotropyStrength), void 0 !== i.anisotropyRotation && (t.anisotropyRotation = i.anisotropyRotation), void 0 !== i.anisotropyTexture && o.push(n.assignTexture(t, "anisotropyMap", i.anisotropyTexture)), Promise.all(o)
        }
    }
    ;
class Xm {
    constructor(e)
    {
        this.parser = e,
        this.name = Lm.KHR_TEXTURE_BASISU
    }
    loadTexture(e)
    {
        const t = this.parser,
            n = t.json,
            r = n.textures[e];
        if (!r.extensions || !r.extensions[this.name])
            return null;
        const o = r.extensions[this.name],
            i = t.options.ktx2Loader;
        if (!i) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, o.source, i)
    }
}
class Ym {
    constructor(e)
    {
        this.parser = e,
        this.name = Lm.EXT_TEXTURE_WEBP
    }
    loadTexture(e)
    {
        const t = this.name,
            n = this.parser,
            r = n.json,
            o = r.textures[e];
        if (!o.extensions || !o.extensions[t])
            return null;
        const i = o.extensions[t],
            a = r.images[i.source];
        let s = n.textureLoader;
        if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (s = e)
        }
        return n.loadTextureImage(e, i.source, s)
    }
}
class Jm {
    constructor(e)
    {
        this.parser = e,
        this.name = Lm.EXT_TEXTURE_AVIF
    }
    loadTexture(e)
    {
        const t = this.name,
            n = this.parser,
            r = n.json,
            o = r.textures[e];
        if (!o.extensions || !o.extensions[t])
            return null;
        const i = o.extensions[t],
            a = r.images[i.source];
        let s = n.textureLoader;
        if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (s = e)
        }
        return n.loadTextureImage(e, i.source, s)
    }
}
class Zm {
    constructor(e)
    {
        this.name = Lm.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e)
    {
        const t = this.parser.json,
            n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const e = n.extensions[this.name],
                r = this.parser.getDependency("buffer", e.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function(t) {
                const n = e.byteOffset || 0,
                    r = e.byteLength || 0,
                    i = e.count,
                    a = e.byteStride,
                    s = new Uint8Array(t, n, r);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(i, a, s, e.mode, e.filter).then(function(e) {
                    return e.buffer
                }) : o.ready.then(function() {
                    const t = new ArrayBuffer(i * a);
                    return o.decodeGltfBuffer(new Uint8Array(t), i, a, s, e.mode, e.filter), t
                })
            })
        }
        return null
    }
}
let eb = class {
    constructor(e)
    {
        this.name = Lm.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e)
    {
        const t = this.parser.json,
            n = t.nodes[e];
        if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
            return null;
        const r = t.meshes[n.mesh];
        for (const s of r.primitives)
            if (s.mode !== cb.TRIANGLES && s.mode !== cb.TRIANGLE_STRIP && s.mode !== cb.TRIANGLE_FAN && void 0 !== s.mode)
                return null;
        const o = n.extensions[this.name].attributes,
            i = [],
            a = {};
        for (const s in o)
            i.push(this.parser.getDependency("accessor", o[s]).then(e => (a[s] = e, a[s])));
        return i.length < 1 ? null : (i.push(this.parser.createNodeMesh(e)), Promise.all(i).then(e => {
            const t = e.pop(),
                n = t.isGroup ? t.children : [t],
                r = e[0].count,
                o = [];
            for (const i of n) {
                const e = new gc,
                    t = new hl,
                    n = new pl,
                    s = new hl(1, 1, 1),
                    l = new Pd(i.geometry, i.material, r);
                for (let o = 0; o < r; o++)
                    a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, o),
                    a.ROTATION && n.fromBufferAttribute(a.ROTATION, o),
                    a.SCALE && s.fromBufferAttribute(a.SCALE, o),
                    l.setMatrixAt(o, e.compose(t, n, s));
                for (const r in a)
                    if ("_COLOR_0" === r) {
                        const e = a[r];
                        l.instanceColor = new Sd(e.array, e.itemSize, e.normalized)
                    } else
                        "TRANSLATION" !== r && "ROTATION" !== r && "SCALE" !== r && i.geometry.setAttribute(r, a[r]);
                Gc.prototype.copy.call(l, i),
                this.parser.assignFinalMaterial(l),
                o.push(l)
            }
            return t.isGroup ? (t.clear(), t.add(...o), t) : o[0]
        }))
    }
}
;
const tb = "glTF";
class nb {
    constructor(e)
    {
        this.name = Lm.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e, 0, 12),
            n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        }, this.header.magic !== tb)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const r = this.header.length - 12,
            o = new DataView(e, 12);
        let i = 0;
        for (; i < r;) {
            const t = o.getUint32(i, !0);
            i += 4;
            const r = o.getUint32(i, !0);
            if (i += 4, 1313821514 === r) {
                const r = new Uint8Array(e, 12 + i, t);
                this.content = n.decode(r)
            } else if (5130562 === r) {
                const n = 12 + i;
                this.body = e.slice(n, n + t)
            }
            i += t
        }
        if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class rb {
    constructor(e, t)
    {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Lm.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t)
    {
        const n = this.json,
            r = this.dracoLoader,
            o = e.extensions[this.name].bufferView,
            i = e.extensions[this.name].attributes,
            a = {},
            s = {},
            l = {};
        for (const c in i) {
            const e = fb[c] || c.toLowerCase();
            a[e] = i[c]
        }
        for (const c in e.attributes) {
            const t = fb[c] || c.toLowerCase();
            if (void 0 !== i[c]) {
                const r = n.accessors[e.attributes[c]],
                    o = ub[r.componentType];
                l[t] = o.name,
                s[t] = !0 === r.normalized
            }
        }
        return t.getDependency("bufferView", o).then(function(e) {
            return new Promise(function(t, n) {
                r.decodeDracoFile(e, function(e) {
                    for (const t in e.attributes) {
                        const n = e.attributes[t],
                            r = s[t];
                        void 0 !== r && (n.normalized = r)
                    }
                    t(e)
                }, a, l, Ns, n)
            })
        })
    }
}
class ob {
    constructor()
    {
        this.name = Lm.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t)
    {
        return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
    }
}
class ib {
    constructor()
    {
        this.name = Lm.KHR_MESH_QUANTIZATION
    }
}
class ab extends Sp {
    constructor(e, t, n, r)
    {
        super(e, t, n, r)
    }
    copySampleValue_(e)
    {
        const t = this.resultBuffer,
            n = this.sampleValues,
            r = this.valueSize,
            o = e * r * 3 + r;
        for (let i = 0; i !== r; i++)
            t[i] = n[o + i];
        return t
    }
    interpolate_(e, t, n, r)
    {
        const o = this.resultBuffer,
            i = this.sampleValues,
            a = this.valueSize,
            s = 2 * a,
            l = 3 * a,
            c = r - t,
            u = (n - t) / c,
            d = u * u,
            p = d * u,
            h = e * l,
            f = h - l,
            g = -2 * p + 3 * d,
            m = p - d,
            b = 1 - g,
            A = m - d + u;
        for (let y = 0; y !== a; y++) {
            const e = i[f + y + a],
                t = i[f + y + s] * c,
                n = i[h + y + a],
                r = i[h + y] * c;
            o[y] = b * e + A * t + g * n + m * r
        }
        return o
    }
}
const sb = new pl;
class lb extends ab {
    interpolate_(e, t, n, r)
    {
        const o = super.interpolate_(e, t, n, r);
        return sb.fromArray(o).normalize().toArray(o), o
    }
}
const cb = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    },
    ub = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    db = {
        9728: Ia,
        9729: Ra,
        9984: Ta,
        9985: Ba,
        9986: Ma,
        9987: ka
    },
    pb = {
        33071: Ea,
        33648: Sa,
        10497: Ca
    },
    hb = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    fb = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    gb = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    mb = {
        CUBICSPLINE: void 0,
        LINEAR: Ds,
        STEP: ks
    };
function bb(e) {
    return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new Ap({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: 0
    })), e.DefaultMaterial
}
function Ab(e, t, n) {
    for (const r in n.extensions)
        void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
}
function yb(e, t) {
    void 0 !== t.extras && "object" == typeof t.extras && Object.assign(e.userData, t.extras)
}
function vb(e, t) {
    if (e.updateMorphTargets(), void 0 !== t.weights)
        for (let n = 0, r = t.weights.length; n < r; n++)
            e.morphTargetInfluences[n] = t.weights[n];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
        const n = t.extras.targetNames;
        if (e.morphTargetInfluences.length === n.length) {
            e.morphTargetDictionary = {};
            for (let t = 0, r = n.length; t < r; t++)
                e.morphTargetDictionary[n[t]] = t
        }
    }
}
function _b(e) {
    let t;
    const n = e.extensions && e.extensions[Lm.KHR_DRACO_MESH_COMPRESSION];
    if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + xb(n.attributes) : e.indices + ":" + xb(e.attributes) + ":" + e.mode, void 0 !== e.targets)
        for (let r = 0, o = e.targets.length; r < o; r++)
            t += ":" + xb(e.targets[r]);
    return t
}
function xb(e) {
    let t = "";
    const n = Object.keys(e).sort();
    for (let r = 0, o = n.length; r < o; r++)
        t += n[r] + ":" + e[n[r]] + ";";
    return t
}
function wb(e) {
    switch (e) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
const Cb = new gc;
class Eb {
    constructor(e={}, t={})
    {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new Om,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let n = !1,
            r = -1,
            o = !1,
            i = -1;
        if ("undefined" != typeof navigator) {
            const e = navigator.userAgent;
            n = !0 === /^((?!chrome|android).)*safari/i.test(e);
            const t = e.match(/Version\/(\d+)/);
            r = n && t ? parseInt(t[1], 10) : -1,
            o = e.indexOf("Firefox") > -1,
            i = o ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        "undefined" == typeof createImageBitmap || n && r < 17 || o && i < 98 ? this.textureLoader = new Xp(this.options.manager) : this.textureLoader = new gh(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new $p(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e)
    {
        this.extensions = e
    }
    setPlugins(e)
    {
        this.plugins = e
    }
    parse(e, t)
    {
        const n = this,
            r = this.json,
            o = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(e) {
            return e._markDefs && e._markDefs()
        }),
        Promise.all(this._invokeAll(function(e) {
            return e.beforeRoot && e.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(t) {
            const i = {
                scene: t[0][r.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: r.asset,
                parser: n,
                userData: {}
            };
            return Ab(o, i, r), yb(i, r), Promise.all(n._invokeAll(function(e) {
                return e.afterRoot && e.afterRoot(i)
            })).then(function() {
                for (const e of i.scenes)
                    e.updateMatrixWorld();
                e(i)
            })
        }).catch(t)
    }
    _markDefs()
    {
        const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
        for (let r = 0, o = t.length; r < o; r++) {
            const n = t[r].joints;
            for (let t = 0, r = n.length; t < r; t++)
                e[n[t]].isBone = !0
        }
        for (let r = 0, o = e.length; r < o; r++) {
            const t = e[r];
            void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh), void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)),
            void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
        }
    }
    _addNodeRef(e, t)
    {
        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
    }
    _getNodeRef(e, t, n)
    {
        if (e.refs[t] <= 1)
            return n;
        const r = n.clone(),
            o = (e, t) => {
                const n = this.associations.get(e);
                null != n && this.associations.set(t, n);
                for (const [r, i] of e.children.entries())
                    o(i, t.children[r])
            };
        return o(n, r), r.name += "_instance_" + e.uses[t]++, r
    }
    _invokeOne(e)
    {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const r = e(t[n]);
            if (r)
                return r
        }
        return null
    }
    _invokeAll(e)
    {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let r = 0; r < t.length; r++) {
            const o = e(t[r]);
            o && n.push(o)
        }
        return n
    }
    getDependency(e, t)
    {
        const n = e + ":" + t;
        let r = this.cache.get(n);
        if (!r) {
            switch (e) {
            case "scene":
                r = this.loadScene(t);
                break;
            case "node":
                r = this._invokeOne(function(e) {
                    return e.loadNode && e.loadNode(t)
                });
                break;
            case "mesh":
                r = this._invokeOne(function(e) {
                    return e.loadMesh && e.loadMesh(t)
                });
                break;
            case "accessor":
                r = this.loadAccessor(t);
                break;
            case "bufferView":
                r = this._invokeOne(function(e) {
                    return e.loadBufferView && e.loadBufferView(t)
                });
                break;
            case "buffer":
                r = this.loadBuffer(t);
                break;
            case "material":
                r = this._invokeOne(function(e) {
                    return e.loadMaterial && e.loadMaterial(t)
                });
                break;
            case "texture":
                r = this._invokeOne(function(e) {
                    return e.loadTexture && e.loadTexture(t)
                });
                break;
            case "skin":
                r = this.loadSkin(t);
                break;
            case "animation":
                r = this._invokeOne(function(e) {
                    return e.loadAnimation && e.loadAnimation(t)
                });
                break;
            case "camera":
                r = this.loadCamera(t);
                break;
            default:
                if (r = this._invokeOne(function(n) {
                    return n != this && n.getDependency && n.getDependency(e, t)
                }), !r)
                    throw new Error("Unknown type: " + e)
            }
            this.cache.add(n, r)
        }
        return r
    }
    getDependencies(e)
    {
        let t = this.cache.get(e);
        if (!t) {
            const n = this,
                r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
            t = Promise.all(r.map(function(t, r) {
                return n.getDependency(e, r)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e)
    {
        const t = this.json.buffers[e],
            n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (void 0 === t.uri && 0 === e)
            return Promise.resolve(this.extensions[Lm.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function(e, o) {
            n.load(hh.resolveURL(t.uri, r.path), e, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        })
    }
    loadBufferView(e)
    {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(e) {
            const n = t.byteLength || 0,
                r = t.byteOffset || 0;
            return e.slice(r, r + n)
        })
    }
    loadAccessor(e)
    {
        const t = this,
            n = this.json,
            r = this.json.accessors[e];
        if (void 0 === r.bufferView && void 0 === r.sparse) {
            const e = hb[r.type],
                t = ub[r.componentType],
                n = !0 === r.normalized,
                o = new t(r.count * e);
            return Promise.resolve(new Au(o, e, n))
        }
        const o = [];
        return void 0 !== r.bufferView ? o.push(this.getDependency("bufferView", r.bufferView)) : o.push(null), void 0 !== r.sparse && (o.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(o).then(function(e) {
            const o = e[0],
                i = hb[r.type],
                a = ub[r.componentType],
                s = a.BYTES_PER_ELEMENT,
                l = s * i,
                c = r.byteOffset || 0,
                u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                d = !0 === r.normalized;
            let p,
                h;
            if (u && u !== l) {
                const e = Math.floor(c / u),
                    n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                let l = t.cache.get(n);
                l || (p = new a(o, e * u, r.count * u / s), l = new ld(p, u / s), t.cache.add(n, l)),
                h = new ud(l, i, c % u / s, d)
            } else
                p = null === o ? new a(r.count * i) : new a(o, c, r.count * i),
                h = new Au(p, i, d);
            if (void 0 !== r.sparse) {
                const t = hb.SCALAR,
                    n = ub[r.sparse.indices.componentType],
                    s = r.sparse.indices.byteOffset || 0,
                    l = r.sparse.values.byteOffset || 0,
                    c = new n(e[1], s, r.sparse.count * t),
                    u = new a(e[2], l, r.sparse.count * i);
                null !== o && (h = new Au(h.array.slice(), h.itemSize, h.normalized)),
                h.normalized = !1;
                for (let e = 0, r = c.length; e < r; e++) {
                    const t = c[e];
                    if (h.setX(t, u[e * i]), i >= 2 && h.setY(t, u[e * i + 1]), i >= 3 && h.setZ(t, u[e * i + 2]), i >= 4 && h.setW(t, u[e * i + 3]), i >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
                h.normalized = d
            }
            return h
        })
    }
    loadTexture(e)
    {
        const t = this.json,
            n = this.options,
            r = t.textures[e].source,
            o = t.images[r];
        let i = this.textureLoader;
        if (o.uri) {
            const e = n.manager.getHandler(o.uri);
            null !== e && (i = e)
        }
        return this.loadTextureImage(e, r, i)
    }
    loadTextureImage(e, t, n)
    {
        const r = this,
            o = this.json,
            i = o.textures[e],
            a = o.images[t],
            s = (a.uri || a.bufferView) + ":" + i.sampler;
        if (this.textureCache[s])
            return this.textureCache[s];
        const l = this.loadImageSource(t, n).then(function(t) {
            t.flipY = !1,
            t.name = i.name || a.name || "",
            "" === t.name && "string" == typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri);
            const n = (o.samplers || {})[i.sampler] || {};
            return t.magFilter = db[n.magFilter] || Ra, t.minFilter = db[n.minFilter] || ka, t.wrapS = pb[n.wrapS] || Ca, t.wrapT = pb[n.wrapT] || Ca, t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== Ia && t.minFilter !== Ra, r.associations.set(t, {
                textures: e
            }), t
        }).catch(function() {
            return null
        });
        return this.textureCache[s] = l, l
    }
    loadImageSource(e, t)
    {
        const n = this.json,
            r = this.options;
        if (void 0 !== this.sourceCache[e])
            return this.sourceCache[e].then(e => e.clone());
        const o = n.images[e],
            i = self.URL || self.webkitURL;
        let a = o.uri || "",
            s = !1;
        if (void 0 !== o.bufferView)
            a = this.getDependency("bufferView", o.bufferView).then(function(e) {
                s = !0;
                const t = new Blob([e], {
                    type: o.mimeType
                });
                return a = i.createObjectURL(t), a
            });
        else if (void 0 === o.uri)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const l = Promise.resolve(a).then(function(e) {
            return new Promise(function(n, o) {
                let i = n;
                !0 === t.isImageBitmapLoader && (i = function(e) {
                    const t = new Ll(e);
                    t.needsUpdate = !0,
                    n(t)
                }),
                t.load(hh.resolveURL(e, r.path), i, void 0, o)
            })
        }).then(function(e) {
            var t;
            return !0 === s && i.revokeObjectURL(a), yb(e, o), e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"), e
        }).catch(function(e) {
            throw e
        });
        return this.sourceCache[e] = l, l
    }
    assignTexture(e, t, n, r)
    {
        const o = this;
        return this.getDependency("texture", n.index).then(function(i) {
            if (!i)
                return null;
            if (void 0 !== n.texCoord && n.texCoord > 0 && ((i = i.clone()).channel = n.texCoord), o.extensions[Lm.KHR_TEXTURE_TRANSFORM]) {
                const e = void 0 !== n.extensions ? n.extensions[Lm.KHR_TEXTURE_TRANSFORM] : void 0;
                if (e) {
                    const t = o.associations.get(i);
                    i = o.extensions[Lm.KHR_TEXTURE_TRANSFORM].extendTexture(i, e),
                    o.associations.set(i, t)
                }
            }
            return void 0 !== r && (i.colorSpace = r), e[t] = i, i
        })
    }
    assignFinalMaterial(e)
    {
        const t = e.geometry;
        let n = e.material;
        const r = void 0 === t.attributes.tangent,
            o = void 0 !== t.attributes.color,
            i = void 0 === t.attributes.normal;
        if (e.isPoints) {
            const e = "PointsMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t || (t = new rp, uu.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)),
            n = t
        } else if (e.isLine) {
            const e = "LineBasicMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t || (t = new jd, uu.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)),
            n = t
        }
        if (r || o || i) {
            let e = "ClonedMaterial:" + n.uuid + ":";
            r && (e += "derivative-tangents:"),
            o && (e += "vertex-colors:"),
            i && (e += "flat-shading:");
            let t = this.cache.get(e);
            t || (t = n.clone(), o && (t.vertexColors = !0), i && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))),
            n = t
        }
        e.material = n
    }
    getMaterialType()
    {
        return Ap
    }
    loadMaterial(e)
    {
        const t = this,
            n = this.json,
            r = this.extensions,
            o = n.materials[e];
        let i;
        const a = {},
            s = [];
        if ((o.extensions || {})[Lm.KHR_MATERIALS_UNLIT]) {
            const e = r[Lm.KHR_MATERIALS_UNLIT];
            i = e.getMaterialType(),
            s.push(e.extendParams(a, o, t))
        } else {
            const n = o.pbrMetallicRoughness || {};
            if (a.color = new su(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                const e = n.baseColorFactor;
                a.color.setRGB(e[0], e[1], e[2], Ns),
                a.opacity = e[3]
            }
            void 0 !== n.baseColorTexture && s.push(t.assignTexture(a, "map", n.baseColorTexture, Ls)),
            a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
            a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
            void 0 !== n.metallicRoughnessTexture && (s.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), s.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))),
            i = this._invokeOne(function(t) {
                return t.getMaterialType && t.getMaterialType(e)
            }),
            s.push(Promise.all(this._invokeAll(function(t) {
                return t.extendMaterialParams && t.extendMaterialParams(e, a)
            })))
        }
        !0 === o.doubleSided && (a.side = 2);
        const l = o.alphaMode || "OPAQUE";
        if ("BLEND" === l ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === l && (a.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && i !== du && (s.push(t.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new dl(1, 1), void 0 !== o.normalTexture.scale)) {
            const e = o.normalTexture.scale;
            a.normalScale.set(e, e)
        }
        if (void 0 !== o.occlusionTexture && i !== du && (s.push(t.assignTexture(a, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (a.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && i !== du) {
            const e = o.emissiveFactor;
            a.emissive = (new su).setRGB(e[0], e[1], e[2], Ns)
        }
        return void 0 !== o.emissiveTexture && i !== du && s.push(t.assignTexture(a, "emissiveMap", o.emissiveTexture, Ls)), Promise.all(s).then(function() {
            const n = new i(a);
            return o.name && (n.name = o.name), yb(n, o), t.associations.set(n, {
                materials: e
            }), o.extensions && Ab(r, n, o), n
        })
    }
    createUniqueName(e)
    {
        const t = Ch.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
    }
    loadGeometries(e)
    {
        const t = this,
            n = this.extensions,
            r = this.primitiveCache;
        function o(e) {
            return n[Lm.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function(n) {
                return Sb(n, e, t)
            })
        }
        const i = [];
        for (let a = 0, s = e.length; a < s; a++) {
            const n = e[a],
                s = _b(n),
                l = r[s];
            if (l)
                i.push(l.promise);
            else {
                let e;
                e = n.extensions && n.extensions[Lm.KHR_DRACO_MESH_COMPRESSION] ? o(n) : Sb(new Mu, n, t),
                r[s] = {
                    primitive: n,
                    promise: e
                },
                i.push(e)
            }
        }
        return Promise.all(i)
    }
    loadMesh(e)
    {
        const t = this,
            n = this.json,
            r = this.extensions,
            o = n.meshes[e],
            i = o.primitives,
            a = [];
        for (let s = 0, l = i.length; s < l; s++) {
            const e = void 0 === i[s].material ? bb(this.cache) : this.getDependency("material", i[s].material);
            a.push(e)
        }
        return a.push(t.loadGeometries(i)), Promise.all(a).then(function(n) {
            const a = n.slice(0, n.length - 1),
                s = n[n.length - 1],
                l = [];
            for (let u = 0, d = s.length; u < d; u++) {
                const n = s[u],
                    c = i[u];
                let d;
                const p = a[u];
                if (c.mode === cb.TRIANGLES || c.mode === cb.TRIANGLE_STRIP || c.mode === cb.TRIANGLE_FAN || void 0 === c.mode)
                    d = !0 === o.isSkinnedMesh ? new vd(n, p) : new Qu(n, p),
                    !0 === d.isSkinnedMesh && d.normalizeSkinWeights(),
                    c.mode === cb.TRIANGLE_STRIP ? d.geometry = Dm(d.geometry, 1) : c.mode === cb.TRIANGLE_FAN && (d.geometry = Dm(d.geometry, 2));
                else if (c.mode === cb.LINES)
                    d = new tp(n, p);
                else if (c.mode === cb.LINE_STRIP)
                    d = new Yd(n, p);
                else if (c.mode === cb.LINE_LOOP)
                    d = new np(n, p);
                else {
                    if (c.mode !== cb.POINTS)
                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                    d = new lp(n, p)
                }
                Object.keys(d.geometry.morphAttributes).length > 0 && vb(d, o),
                d.name = t.createUniqueName(o.name || "mesh_" + e),
                yb(d, o),
                c.extensions && Ab(r, d, c),
                t.assignFinalMaterial(d),
                l.push(d)
            }
            for (let r = 0, o = l.length; r < o; r++)
                t.associations.set(l[r], {
                    meshes: e,
                    primitives: r
                });
            if (1 === l.length)
                return o.extensions && Ab(r, l[0], o), l[0];
            const c = new od;
            o.extensions && Ab(r, c, o),
            t.associations.set(c, {
                meshes: e
            });
            for (let e = 0, t = l.length; e < t; e++)
                c.add(l[e]);
            return c
        })
    }
    loadCamera(e)
    {
        let t;
        const n = this.json.cameras[e],
            r = n[n.type];
        if (r)
            return "perspective" === n.type ? t = new Zu(ul.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new uh(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), yb(t, n), Promise.resolve(t)
    }
    loadSkin(e)
    {
        const t = this.json.skins[e],
            n = [];
        for (let r = 0, o = t.joints.length; r < o; r++)
            n.push(this._loadNodeShallow(t.joints[r]));
        return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(e) {
            const t = e.pop(),
                n = e,
                r = [],
                o = [];
            for (let i = 0, a = n.length; i < a; i++) {
                const e = n[i];
                if (e) {
                    r.push(e);
                    const n = new gc;
                    null !== t && n.fromArray(t.array, 16 * i),
                    o.push(n)
                }
            }
            return new Ed(r, o)
        })
    }
    loadAnimation(e)
    {
        const t = this.json,
            n = this,
            r = t.animations[e],
            o = r.name ? r.name : "animation_" + e,
            i = [],
            a = [],
            s = [],
            l = [],
            c = [];
        for (let u = 0, d = r.channels.length; u < d; u++) {
            const e = r.channels[u],
                t = r.samplers[e.sampler],
                n = e.target,
                o = n.node,
                d = void 0 !== r.parameters ? r.parameters[t.input] : t.input,
                p = void 0 !== r.parameters ? r.parameters[t.output] : t.output;
            void 0 !== n.node && (i.push(this.getDependency("node", o)), a.push(this.getDependency("accessor", d)), s.push(this.getDependency("accessor", p)), l.push(t), c.push(n))
        }
        return Promise.all([Promise.all(i), Promise.all(a), Promise.all(s), Promise.all(l), Promise.all(c)]).then(function(e) {
            const t = e[0],
                i = e[1],
                a = e[2],
                s = e[3],
                l = e[4],
                c = [];
            for (let r = 0, o = t.length; r < o; r++) {
                const e = t[r],
                    o = i[r],
                    u = a[r],
                    d = s[r],
                    p = l[r];
                if (void 0 === e)
                    continue;
                e.updateMatrix && e.updateMatrix();
                const h = n._createAnimationTracks(e, o, u, d, p);
                if (h)
                    for (let t = 0; t < h.length; t++)
                        c.push(h[t])
            }
            const u = new Fp(o, void 0, c);
            return yb(u, r), u
        })
    }
    createNodeMesh(e)
    {
        const t = this.json,
            n = this,
            r = t.nodes[e];
        return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then(function(e) {
            const t = n._getNodeRef(n.meshCache, r.mesh, e);
            return void 0 !== r.weights && t.traverse(function(e) {
                if (e.isMesh)
                    for (let t = 0, n = r.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = r.weights[t]
            }), t
        })
    }
    loadNode(e)
    {
        const t = this,
            n = this.json.nodes[e],
            r = t._loadNodeShallow(e),
            o = [],
            i = n.children || [];
        for (let s = 0, l = i.length; s < l; s++)
            o.push(t.getDependency("node", i[s]));
        const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
        return Promise.all([r, Promise.all(o), a]).then(function(e) {
            const t = e[0],
                n = e[1],
                r = e[2];
            null !== r && t.traverse(function(e) {
                e.isSkinnedMesh && e.bind(r, Cb)
            });
            for (let o = 0, i = n.length; o < i; o++)
                t.add(n[o]);
            return t
        })
    }
    _loadNodeShallow(e)
    {
        const t = this.json,
            n = this.extensions,
            r = this;
        if (void 0 !== this.nodeCache[e])
            return this.nodeCache[e];
        const o = t.nodes[e],
            i = o.name ? r.createUniqueName(o.name) : "",
            a = [],
            s = r._invokeOne(function(t) {
                return t.createNodeMesh && t.createNodeMesh(e)
            });
        return s && a.push(s), void 0 !== o.camera && a.push(r.getDependency("camera", o.camera).then(function(e) {
            return r._getNodeRef(r.cameraCache, o.camera, e)
        })), r._invokeAll(function(t) {
            return t.createNodeAttachment && t.createNodeAttachment(e)
        }).forEach(function(e) {
            a.push(e)
        }), this.nodeCache[e] = Promise.all(a).then(function(t) {
            let a;
            if (a = !0 === o.isBone ? new _d : t.length > 1 ? new od : 1 === t.length ? t[0] : new Gc, a !== t[0])
                for (let e = 0, n = t.length; e < n; e++)
                    a.add(t[e]);
            if (o.name && (a.userData.name = o.name, a.name = i), yb(a, o), o.extensions && Ab(n, a, o), void 0 !== o.matrix) {
                const e = new gc;
                e.fromArray(o.matrix),
                a.applyMatrix4(e)
            } else
                void 0 !== o.translation && a.position.fromArray(o.translation),
                void 0 !== o.rotation && a.quaternion.fromArray(o.rotation),
                void 0 !== o.scale && a.scale.fromArray(o.scale);
            if (r.associations.has(a)) {
                if (void 0 !== o.mesh && r.meshCache.refs[o.mesh] > 1) {
                    const e = r.associations.get(a);
                    r.associations.set(a, {
                        ...e
                    })
                }
            } else
                r.associations.set(a, {});
            return r.associations.get(a).nodes = e, a
        }), this.nodeCache[e]
    }
    loadScene(e)
    {
        const t = this.extensions,
            n = this.json.scenes[e],
            r = this,
            o = new od;
        n.name && (o.name = r.createUniqueName(n.name)),
        yb(o, n),
        n.extensions && Ab(t, o, n);
        const i = n.nodes || [],
            a = [];
        for (let s = 0, l = i.length; s < l; s++)
            a.push(r.getDependency("node", i[s]));
        return Promise.all(a).then(function(e) {
            for (let t = 0, n = e.length; t < n; t++)
                o.add(e[t]);
            return r.associations = (e => {
                const t = new Map;
                for (const [n, o] of r.associations)
                    (n instanceof uu || n instanceof Ll) && t.set(n, o);
                return e.traverse(e => {
                    const n = r.associations.get(e);
                    null != n && t.set(e, n)
                }), t
            })(o), o
        })
    }
    _createAnimationTracks(e, t, n, r, o)
    {
        const i = [],
            a = e.name ? e.name : e.uuid,
            s = [];
        let l;
        switch (gb[o.path] === gb.weights ? e.traverse(function(e) {
            e.morphTargetInfluences && s.push(e.name ? e.name : e.uuid)
        }) : s.push(a), gb[o.path]) {
        case gb.weights:
            l = Dp;
            break;
        case gb.rotation:
            l = Op;
            break;
        case gb.translation:
        case gb.scale:
            l = Np;
            break;
        default:
            l = 1 === n.itemSize ? Dp : Np
        }
        const c = void 0 !== r.interpolation ? mb[r.interpolation] : Ds,
            u = this._getArrayFromAccessor(n);
        for (let d = 0, p = s.length; d < p; d++) {
            const e = new l(s[d] + "." + gb[o.path], t.array, u, c);
            "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(e),
            i.push(e)
        }
        return i
    }
    _getArrayFromAccessor(e)
    {
        let t = e.array;
        if (e.normalized) {
            const e = wb(t.constructor),
                n = new Float32Array(t.length);
            for (let r = 0, o = t.length; r < o; r++)
                n[r] = t[r] * e;
            t = n
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e)
    {
        e.createInterpolant = function(e) {
            return new (this instanceof Op ? lb : ab)(this.times, this.values, this.getValueSize() / 3, e)
        },
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function Sb(e, t, n) {
    const r = t.attributes,
        o = [];
    function i(t, r) {
        return n.getDependency("accessor", t).then(function(t) {
            e.setAttribute(r, t)
        })
    }
    for (const a in r) {
        const t = fb[a] || a.toLowerCase();
        t in e.attributes || o.push(i(r[a], t))
    }
    if (void 0 !== t.indices && !e.index) {
        const r = n.getDependency("accessor", t.indices).then(function(t) {
            e.setIndex(t)
        });
        o.push(r)
    }
    return Sl.workingColorSpace, yb(e, t), function(e, t, n) {
        const r = t.attributes,
            o = new Gl;
        if (void 0 === r.POSITION)
            return;
        {
            const e = n.json.accessors[r.POSITION],
                t = e.min,
                i = e.max;
            if (void 0 === t || void 0 === i)
                return;
            if (o.set(new hl(t[0], t[1], t[2]), new hl(i[0], i[1], i[2])), e.normalized) {
                const t = wb(ub[e.componentType]);
                o.min.multiplyScalar(t),
                o.max.multiplyScalar(t)
            }
        }
        const i = t.targets;
        if (void 0 !== i) {
            const e = new hl,
                t = new hl;
            for (let r = 0, o = i.length; r < o; r++) {
                const o = i[r];
                if (void 0 !== o.POSITION) {
                    const r = n.json.accessors[o.POSITION],
                        i = r.min,
                        a = r.max;
                    if (void 0 !== i && void 0 !== a) {
                        if (t.setX(Math.max(Math.abs(i[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(i[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(i[2]), Math.abs(a[2]))), r.normalized) {
                            const e = wb(ub[r.componentType]);
                            t.multiplyScalar(e)
                        }
                        e.max(t)
                    }
                }
            }
            o.expandByVector(e)
        }
        e.boundingBox = o;
        const a = new ac;
        o.getCenter(a.center),
        a.radius = o.min.distanceTo(o.max) / 2,
        e.boundingSphere = a
    }(e, t, n), Promise.all(o).then(function() {
        return void 0 !== t.targets ? function(e, t, n) {
            let r = !1,
                o = !1,
                i = !1;
            for (let c = 0, u = t.length; c < u; c++) {
                const e = t[c];
                if (void 0 !== e.POSITION && (r = !0), void 0 !== e.NORMAL && (o = !0), void 0 !== e.COLOR_0 && (i = !0), r && o && i)
                    break
            }
            if (!r && !o && !i)
                return Promise.resolve(e);
            const a = [],
                s = [],
                l = [];
            for (let c = 0, u = t.length; c < u; c++) {
                const u = t[c];
                if (r) {
                    const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                    a.push(t)
                }
                if (o) {
                    const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                    s.push(t)
                }
                if (i) {
                    const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                    l.push(t)
                }
            }
            return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then(function(t) {
                const n = t[0],
                    a = t[1],
                    s = t[2];
                return r && (e.morphAttributes.position = n), o && (e.morphAttributes.normal = a), i && (e.morphAttributes.color = s), e.morphTargetsRelative = !0, e
            })
        }(e, t.targets, n) : e
    })
}
const Ib = {
    POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
    NORMAL: ["byte normalized", "short normalized"],
    TANGENT: ["byte normalized", "short normalized"],
    TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class Tb {
    constructor()
    {
        this.textureUtils = null,
        this.pluginCallbacks = [],
        this.register(function(e) {
            return new jb(e)
        }),
        this.register(function(e) {
            return new Vb(e)
        }),
        this.register(function(e) {
            return new Kb(e)
        }),
        this.register(function(e) {
            return new qb(e)
        }),
        this.register(function(e) {
            return new Xb(e)
        }),
        this.register(function(e) {
            return new Yb(e)
        }),
        this.register(function(e) {
            return new Hb(e)
        }),
        this.register(function(e) {
            return new $b(e)
        }),
        this.register(function(e) {
            return new Wb(e)
        }),
        this.register(function(e) {
            return new Jb(e)
        }),
        this.register(function(e) {
            return new Zb(e)
        }),
        this.register(function(e) {
            return new eA(e)
        }),
        this.register(function(e) {
            return new tA(e)
        }),
        this.register(function(e) {
            return new nA(e)
        })
    }
    register(e)
    {
        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
    }
    unregister(e)
    {
        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    setTextureUtils(e)
    {
        return this.textureUtils = e, this
    }
    parse(e, t, n, r)
    {
        const o = new Gb,
            i = [];
        for (let a = 0, s = this.pluginCallbacks.length; a < s; a++)
            i.push(this.pluginCallbacks[a](o));
        o.setPlugins(i),
        o.setTextureUtils(this.textureUtils),
        o.writeAsync(e, t, r).catch(n)
    }
    parseAsync(e, t)
    {
        const n = this;
        return new Promise(function(r, o) {
            n.parse(e, r, o, t)
        })
    }
}
const Mb = 5120,
    Rb = 5121,
    Bb = 5122,
    kb = 5123,
    Db = 34962,
    Pb = "KHR_mesh_quantization",
    Ob = {
        1003: 9728,
        1004: 9984,
        1005: 9986,
        1006: 9729,
        1007: 9985,
        1008: 9987,
        1001: 33071,
        1e3: 10497,
        1002: 33648
    },
    Lb = {
        scale: "scale",
        position: "translation",
        quaternion: "rotation",
        morphTargetInfluences: "weights"
    },
    Nb = new su;
function Fb(e, t) {
    return e.length === t.length && e.every(function(e, n) {
            return e === t[n]
        })
}
function Ub(e) {
    return 4 * Math.ceil(e / 4)
}
function zb(e, t=0) {
    const n = Ub(e.byteLength);
    if (n !== e.byteLength) {
        const r = new Uint8Array(n);
        if (r.set(new Uint8Array(e)), 0 !== t)
            for (let o = e.byteLength; o < n; o++)
                r[o] = t;
        return r.buffer
    }
    return e
}
function Qb() {
    return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas")
}
let Gb = class {
    constructor()
    {
        this.plugins = [],
        this.options = {},
        this.pending = [],
        this.buffers = [],
        this.byteOffset = 0,
        this.buffers = [],
        this.nodeMap = new Map,
        this.skins = [],
        this.extensionsUsed = {},
        this.extensionsRequired = {},
        this.uids = new Map,
        this.uid = 0,
        this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter r" + ji
            }
        },
        this.cache = {
            meshes: new Map,
            attributes: new Map,
            attributesNormalized: new Map,
            materials: new Map,
            textures: new Map,
            images: new Map
        },
        this.textureUtils = null
    }
    setPlugins(e)
    {
        this.plugins = e
    }
    setTextureUtils(e)
    {
        this.textureUtils = e
    }
    async writeAsync(e, t, n={})
    {
        this.options = Object.assign({
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1
        }, n),
        this.options.animations.length > 0 && (this.options.trs = !0),
        await this.processInputAsync(e),
        await Promise.all(this.pending);
        const r = this,
            o = r.buffers,
            i = r.json;
        n = r.options;
        const a = r.extensionsUsed,
            s = r.extensionsRequired,
            l = new Blob(o, {
                type: "application/octet-stream"
            }),
            c = Object.keys(a),
            u = Object.keys(s);
        if (c.length > 0 && (i.extensionsUsed = c), u.length > 0 && (i.extensionsRequired = u), i.buffers && i.buffers.length > 0 && (i.buffers[0].byteLength = l.size), !0 === n.binary) {
            const e = new FileReader;
            e.readAsArrayBuffer(l),
            e.onloadend = function() {
                const n = zb(e.result),
                    r = new DataView(new ArrayBuffer(8));
                r.setUint32(0, n.byteLength, !0),
                r.setUint32(4, 5130562, !0);
                const o = zb((a = JSON.stringify(i), (new TextEncoder).encode(a).buffer), 32);
                var a;
                const s = new DataView(new ArrayBuffer(8));
                s.setUint32(0, o.byteLength, !0),
                s.setUint32(4, 1313821514, !0);
                const l = new ArrayBuffer(12),
                    c = new DataView(l);
                c.setUint32(0, 1179937895, !0),
                c.setUint32(4, 2, !0);
                const u = 12 + s.byteLength + o.byteLength + r.byteLength + n.byteLength;
                c.setUint32(8, u, !0);
                const d = new Blob([l, s, o, r, n], {
                        type: "application/octet-stream"
                    }),
                    p = new FileReader;
                p.readAsArrayBuffer(d),
                p.onloadend = function() {
                    t(p.result)
                }
            }
        } else if (i.buffers && i.buffers.length > 0) {
            const e = new FileReader;
            e.readAsDataURL(l),
            e.onloadend = function() {
                const n = e.result;
                i.buffers[0].uri = n,
                t(i)
            }
        } else
            t(i)
    }
    serializeUserData(e, t)
    {
        if (0 === Object.keys(e.userData).length)
            return;
        const n = this.options,
            r = this.extensionsUsed;
        try {
            const o = JSON.parse(JSON.stringify(e.userData));
            if (n.includeCustomExtensions && o.gltfExtensions) {
                void 0 === t.extensions && (t.extensions = {});
                for (const e in o.gltfExtensions)
                    t.extensions[e] = o.gltfExtensions[e],
                    r[e] = !0;
                delete o.gltfExtensions
            }
            Object.keys(o).length > 0 && (t.extras = o)
        } catch (o) {}
    }
    getUID(e, t=!1)
    {
        if (!1 === this.uids.has(e)) {
            const t = new Map;
            t.set(!0, this.uid++),
            t.set(!1, this.uid++),
            this.uids.set(e, t)
        }
        return this.uids.get(e).get(t)
    }
    isNormalizedNormalAttribute(e)
    {
        if (this.cache.attributesNormalized.has(e))
            return !1;
        const t = new hl;
        for (let n = 0, r = e.count; n < r; n++)
            if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4)
                return !1;
        return !0
    }
    createNormalizedNormalAttribute(e)
    {
        const t = this.cache;
        if (t.attributesNormalized.has(e))
            return t.attributesNormalized.get(e);
        const n = e.clone(),
            r = new hl;
        for (let o = 0, i = n.count; o < i; o++)
            r.fromBufferAttribute(n, o),
            0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(),
            n.setXYZ(o, r.x, r.y, r.z);
        return t.attributesNormalized.set(e, n), n
    }
    applyTextureTransform(e, t)
    {
        let n = !1;
        const r = {};
        0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0),
        0 !== t.rotation && (r.rotation = t.rotation, n = !0),
        1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0),
        n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0)
    }
    async buildMetalRoughTextureAsync(e, t)
    {
        if (e === t)
            return e;
        function n(e) {
            return e.colorSpace === Ls ? function(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            } : function(e) {
                return e
            }
        }
        e instanceof up && (e = await this.decompressTextureAsync(e)),
        t instanceof up && (t = await this.decompressTextureAsync(t));
        const r = e ? e.image : null,
            o = t ? t.image : null,
            i = Math.max(r ? r.width : 0, o ? o.width : 0),
            a = Math.max(r ? r.height : 0, o ? o.height : 0),
            s = Qb();
        s.width = i,
        s.height = a;
        const l = s.getContext("2d", {
            willReadFrequently: !0
        });
        l.fillStyle = "#00ffff",
        l.fillRect(0, 0, i, a);
        const c = l.getImageData(0, 0, i, a);
        if (r) {
            l.drawImage(r, 0, 0, i, a);
            const t = n(e),
                o = l.getImageData(0, 0, i, a).data;
            for (let e = 2; e < o.length; e += 4)
                c.data[e] = 256 * t(o[e] / 256)
        }
        if (o) {
            l.drawImage(o, 0, 0, i, a);
            const e = n(t),
                r = l.getImageData(0, 0, i, a).data;
            for (let t = 1; t < r.length; t += 4)
                c.data[t] = 256 * e(r[t] / 256)
        }
        l.putImageData(c, 0, 0);
        const u = (e || t).clone();
        return u.source = new kl(s), u.colorSpace = Os, u.channel = (e || t).channel, e && t && (e.channel, t.channel), u
    }
    async decompressTextureAsync(e, t=1 / 0)
    {
        if (null === this.textureUtils)
            throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");
        return await this.textureUtils.decompress(e, t)
    }
    processBuffer(e)
    {
        const t = this.json,
            n = this.buffers;
        return t.buffers || (t.buffers = [{
            byteLength: 0
        }]), n.push(e), 0
    }
    processBufferView(e, t, n, r, o)
    {
        const i = this.json;
        let a;
        switch (i.bufferViews || (i.bufferViews = []), t) {
        case Mb:
        case Rb:
            a = 1;
            break;
        case Bb:
        case kb:
            a = 2;
            break;
        default:
            a = 4
        }
        let s = e.itemSize * a;
        o === Db && (s = 4 * Math.ceil(s / 4));
        const l = Ub(r * s),
            c = new DataView(new ArrayBuffer(l));
        let u = 0;
        for (let p = n; p < n + r; p++) {
            for (let n = 0; n < e.itemSize; n++) {
                let r;
                e.itemSize > 4 ? r = e.array[p * e.itemSize + n] : (0 === n ? r = e.getX(p) : 1 === n ? r = e.getY(p) : 2 === n ? r = e.getZ(p) : 3 === n && (r = e.getW(p)), !0 === e.normalized && (r = ul.normalize(r, e.array))),
                5126 === t ? c.setFloat32(u, r, !0) : 5124 === t ? c.setInt32(u, r, !0) : 5125 === t ? c.setUint32(u, r, !0) : t === Bb ? c.setInt16(u, r, !0) : t === kb ? c.setUint16(u, r, !0) : t === Mb ? c.setInt8(u, r) : t === Rb && c.setUint8(u, r),
                u += a
            }
            u % s !== 0 && (u += s - u % s)
        }
        const d = {
            buffer: this.processBuffer(c.buffer),
            byteOffset: this.byteOffset,
            byteLength: l
        };
        return void 0 !== o && (d.target = o), o === Db && (d.byteStride = s), this.byteOffset += l, i.bufferViews.push(d), {
            id: i.bufferViews.length - 1,
            byteLength: 0
        }
    }
    processBufferViewImage(e)
    {
        const t = this,
            n = t.json;
        return n.bufferViews || (n.bufferViews = []), new Promise(function(r) {
            const o = new FileReader;
            o.readAsArrayBuffer(e),
            o.onloadend = function() {
                const e = zb(o.result),
                    i = {
                        buffer: t.processBuffer(e),
                        byteOffset: t.byteOffset,
                        byteLength: e.byteLength
                    };
                t.byteOffset += e.byteLength,
                r(n.bufferViews.push(i) - 1)
            }
        })
    }
    processAccessor(e, t, n, r)
    {
        const o = this.json;
        let i;
        if (e.array.constructor === Float32Array)
            i = 5126;
        else if (e.array.constructor === Int32Array)
            i = 5124;
        else if (e.array.constructor === Uint32Array)
            i = 5125;
        else if (e.array.constructor === Int16Array)
            i = Bb;
        else if (e.array.constructor === Uint16Array)
            i = kb;
        else if (e.array.constructor === Int8Array)
            i = Mb;
        else {
            if (e.array.constructor !== Uint8Array)
                throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
            i = Rb
        }
        if (void 0 === n && (n = 0), void 0 !== r && r !== 1 / 0 || (r = e.count), 0 === r)
            return null;
        const a = function(e, t, n) {
            const r = {
                min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
                max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
            };
            for (let o = t; o < t + n; o++)
                for (let t = 0; t < e.itemSize; t++) {
                    let n;
                    e.itemSize > 4 ? n = e.array[o * e.itemSize + t] : (0 === t ? n = e.getX(o) : 1 === t ? n = e.getY(o) : 2 === t ? n = e.getZ(o) : 3 === t && (n = e.getW(o)), !0 === e.normalized && (n = ul.normalize(n, e.array))),
                    r.min[t] = Math.min(r.min[t], n),
                    r.max[t] = Math.max(r.max[t], n)
                }
            return r
        }(e, n, r);
        let s;
        void 0 !== t && (s = e === t.index ? 34963 : Db);
        const l = this.processBufferView(e, i, n, r, s),
            c = {
                bufferView: l.id,
                byteOffset: l.byteOffset,
                componentType: i,
                count: r,
                max: a.max,
                min: a.min,
                type: {
                    1: "SCALAR",
                    2: "VEC2",
                    3: "VEC3",
                    4: "VEC4",
                    9: "MAT3",
                    16: "MAT4"
                }[e.itemSize]
            };
        return !0 === e.normalized && (c.normalized = !0), o.accessors || (o.accessors = []), o.accessors.push(c) - 1
    }
    processImage(e, t, n, r="image/png")
    {
        if (null !== e) {
            const t = this,
                o = t.cache,
                i = t.json,
                a = t.options,
                s = t.pending;
            o.images.has(e) || o.images.set(e, {});
            const l = o.images.get(e),
                c = r + ":flipY/" + n.toString();
            if (void 0 !== l[c])
                return l[c];
            i.images || (i.images = []);
            const u = {
                    mimeType: r
                },
                d = Qb();
            d.width = Math.min(e.width, a.maxTextureSize),
            d.height = Math.min(e.height, a.maxTextureSize);
            const p = d.getContext("2d", {
                willReadFrequently: !0
            });
            if (!0 === n && (p.translate(0, d.height), p.scale(1, -1)), void 0 !== e.data) {
                e.width > a.maxTextureSize || (e.height, a.maxTextureSize);
                const t = new Uint8ClampedArray(e.height * e.width * 4);
                for (let n = 0; n < t.length; n += 4)
                    t[n + 0] = e.data[n + 0],
                    t[n + 1] = e.data[n + 1],
                    t[n + 2] = e.data[n + 2],
                    t[n + 3] = e.data[n + 3];
                p.putImageData(new ImageData(t, e.width, e.height), 0, 0)
            } else {
                if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas))
                    throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");
                p.drawImage(e, 0, 0, d.width, d.height)
            }
            !0 === a.binary ? s.push(function(e, t) {
                if ("undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas) {
                    let n;
                    return "image/jpeg" === t ? n = .92 : "image/webp" === t && (n = .8), e.convertToBlob({
                        type: t,
                        quality: n
                    })
                }
                return new Promise(n => e.toBlob(n, t))
            }(d, r).then(e => t.processBufferViewImage(e)).then(e => {
                u.bufferView = e
            })) : u.uri = Rl.getDataURL(d, r);
            const h = i.images.push(u) - 1;
            return l[c] = h, h
        }
        throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
    }
    processSampler(e)
    {
        const t = this.json;
        t.samplers || (t.samplers = []);
        const n = {
            magFilter: Ob[e.magFilter],
            minFilter: Ob[e.minFilter],
            wrapS: Ob[e.wrapS],
            wrapT: Ob[e.wrapT]
        };
        return t.samplers.push(n) - 1
    }
    async processTextureAsync(e)
    {
        const t = this.options,
            n = this.cache,
            r = this.json;
        if (n.textures.has(e))
            return n.textures.get(e);
        r.textures || (r.textures = []),
        e instanceof up && (e = await this.decompressTextureAsync(e, t.maxTextureSize));
        let o = e.userData.mimeType;
        "image/webp" === o && (o = "image/png");
        const i = {
            sampler: this.processSampler(e),
            source: this.processImage(e.image, e.format, e.flipY, o)
        };
        e.name && (i.name = e.name),
        await this._invokeAllAsync(async function(t) {
            t.writeTexture && await t.writeTexture(e, i)
        });
        const a = r.textures.push(i) - 1;
        return n.textures.set(e, a), a
    }
    async processMaterialAsync(e)
    {
        const t = this.cache,
            n = this.json;
        if (t.materials.has(e))
            return t.materials.get(e);
        if (e.isShaderMaterial)
            return null;
        n.materials || (n.materials = []);
        const r = {
            pbrMetallicRoughness: {}
        };
        !0 !== e.isMeshStandardMaterial && e.isMeshBasicMaterial;
        const o = e.color.toArray().concat([e.opacity]);
        if (Fb(o, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = o), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = 0, r.pbrMetallicRoughness.roughnessFactor = 1), e.metalnessMap || e.roughnessMap) {
            const t = await this.buildMetalRoughTextureAsync(e.metalnessMap, e.roughnessMap),
                n = {
                    index: await this.processTextureAsync(t),
                    texCoord: t.channel
                };
            this.applyTextureTransform(n, t),
            r.pbrMetallicRoughness.metallicRoughnessTexture = n
        }
        if (e.map) {
            const t = {
                index: await this.processTextureAsync(e.map),
                texCoord: e.map.channel
            };
            this.applyTextureTransform(t, e.map),
            r.pbrMetallicRoughness.baseColorTexture = t
        }
        if (e.emissive) {
            const t = e.emissive;
            if (Math.max(t.r, t.g, t.b) > 0 && (r.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
                const t = {
                    index: await this.processTextureAsync(e.emissiveMap),
                    texCoord: e.emissiveMap.channel
                };
                this.applyTextureTransform(t, e.emissiveMap),
                r.emissiveTexture = t
            }
        }
        if (e.normalMap) {
            const t = {
                index: await this.processTextureAsync(e.normalMap),
                texCoord: e.normalMap.channel
            };
            e.normalScale && 1 !== e.normalScale.x && (t.scale = e.normalScale.x),
            this.applyTextureTransform(t, e.normalMap),
            r.normalTexture = t
        }
        if (e.aoMap) {
            const t = {
                index: await this.processTextureAsync(e.aoMap),
                texCoord: e.aoMap.channel
            };
            1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity),
            this.applyTextureTransform(t, e.aoMap),
            r.occlusionTexture = t
        }
        e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest),
        2 === e.side && (r.doubleSided = !0),
        "" !== e.name && (r.name = e.name),
        this.serializeUserData(e, r),
        await this._invokeAllAsync(async function(t) {
            t.writeMaterialAsync && await t.writeMaterialAsync(e, r)
        });
        const i = n.materials.push(r) - 1;
        return t.materials.set(e, i), i
    }
    async processMeshAsync(e)
    {
        const t = this.cache,
            n = this.json,
            r = [e.geometry.uuid];
        if (Array.isArray(e.material))
            for (let y = 0, v = e.material.length; y < v; y++)
                r.push(e.material[y].uuid);
        else
            r.push(e.material.uuid);
        const o = r.join(":");
        if (t.meshes.has(o))
            return t.meshes.get(o);
        const i = e.geometry;
        let a;
        a = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4;
        const s = {},
            l = {},
            c = [],
            u = [],
            d = {
                uv: "TEXCOORD_0",
                uv1: "TEXCOORD_1",
                uv2: "TEXCOORD_2",
                uv3: "TEXCOORD_3",
                color: "COLOR_0",
                skinWeight: "WEIGHTS_0",
                skinIndex: "JOINTS_0"
            },
            p = i.getAttribute("normal");
        void 0 === p || this.isNormalizedNormalAttribute(p) || i.setAttribute("normal", this.createNormalizedNormalAttribute(p));
        let h = null;
        for (let y in i.attributes) {
            if ("morph" === y.slice(0, 5))
                continue;
            const e = i.attributes[y];
            if (y = d[y] || y.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y) || (y = "_" + y), t.attributes.has(this.getUID(e))) {
                l[y] = t.attributes.get(this.getUID(e));
                continue
            }
            h = null;
            const n = e.array;
            "JOINTS_0" !== y || n instanceof Uint16Array || n instanceof Uint8Array ? (n instanceof Uint32Array || n instanceof Int32Array) && !y.startsWith("_") && (h = Tb.Utils.toFloat32BufferAttribute(e)) : h = new Au(new Uint16Array(n), e.itemSize, e.normalized);
            const r = this.processAccessor(h || e, i);
            null !== r && (y.startsWith("_") || this.detectMeshQuantization(y, e), l[y] = r, t.attributes.set(this.getUID(e), r))
        }
        if (void 0 !== p && i.setAttribute("normal", p), 0 === Object.keys(l).length)
            return null;
        if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
            const n = [],
                r = [],
                o = {};
            if (void 0 !== e.morphTargetDictionary)
                for (const t in e.morphTargetDictionary)
                    o[e.morphTargetDictionary[t]] = t;
            for (let a = 0; a < e.morphTargetInfluences.length; ++a) {
                const s = {};
                let l = !1;
                for (const e in i.morphAttributes) {
                    if ("position" !== e && "normal" !== e) {
                        l || (l = !0);
                        continue
                    }
                    const n = i.morphAttributes[e][a],
                        r = e.toUpperCase(),
                        o = i.attributes[e];
                    if (t.attributes.has(this.getUID(n, !0))) {
                        s[r] = t.attributes.get(this.getUID(n, !0));
                        continue
                    }
                    const c = n.clone();
                    if (!i.morphTargetsRelative)
                        for (let e = 0, t = n.count; e < t; e++)
                            for (let r = 0; r < n.itemSize; r++)
                                0 === r && c.setX(e, n.getX(e) - o.getX(e)),
                                1 === r && c.setY(e, n.getY(e) - o.getY(e)),
                                2 === r && c.setZ(e, n.getZ(e) - o.getZ(e)),
                                3 === r && c.setW(e, n.getW(e) - o.getW(e));
                    s[r] = this.processAccessor(c, i),
                    t.attributes.set(this.getUID(o, !0), s[r])
                }
                u.push(s),
                n.push(e.morphTargetInfluences[a]),
                void 0 !== e.morphTargetDictionary && r.push(o[a])
            }
            s.weights = n,
            r.length > 0 && (s.extras = {}, s.extras.targetNames = r)
        }
        const f = Array.isArray(e.material);
        if (f && 0 === i.groups.length)
            return null;
        let g = !1;
        if (f && null === i.index) {
            const e = [];
            for (let t = 0, n = i.attributes.position.count; t < n; t++)
                e[t] = t;
            i.setIndex(e),
            g = !0
        }
        const m = f ? e.material : [e.material],
            b = f ? i.groups : [{
                materialIndex: 0,
                start: void 0,
                count: void 0
            }];
        for (let y = 0, v = b.length; y < v; y++) {
            const e = {
                mode: a,
                attributes: l
            };
            if (this.serializeUserData(i, e), u.length > 0 && (e.targets = u), null !== i.index) {
                let n = this.getUID(i.index);
                void 0 === b[y].start && void 0 === b[y].count || (n += ":" + b[y].start + ":" + b[y].count),
                t.attributes.has(n) ? e.indices = t.attributes.get(n) : (e.indices = this.processAccessor(i.index, i, b[y].start, b[y].count), t.attributes.set(n, e.indices)),
                null === e.indices && delete e.indices
            }
            const n = await this.processMaterialAsync(m[b[y].materialIndex]);
            null !== n && (e.material = n),
            c.push(e)
        }
        !0 === g && i.setIndex(null),
        s.primitives = c,
        n.meshes || (n.meshes = []),
        await this._invokeAllAsync(function(t) {
            t.writeMesh && t.writeMesh(e, s)
        });
        const A = n.meshes.push(s) - 1;
        return t.meshes.set(o, A), A
    }
    detectMeshQuantization(e, t)
    {
        if (this.extensionsUsed[Pb])
            return;
        let n;
        switch (t.array.constructor) {
        case Int8Array:
            n = "byte";
            break;
        case Uint8Array:
            n = "unsigned byte";
            break;
        case Int16Array:
            n = "short";
            break;
        case Uint16Array:
            n = "unsigned short";
            break;
        default:
            return
        }
        t.normalized && (n += " normalized");
        const r = e.split("_", 1)[0];
        Ib[r] && Ib[r].includes(n) && (this.extensionsUsed[Pb] = !0, this.extensionsRequired[Pb] = !0)
    }
    processCamera(e)
    {
        const t = this.json;
        t.cameras || (t.cameras = []);
        const n = e.isOrthographicCamera,
            r = {
                type: n ? "orthographic" : "perspective"
            };
        return n ? r.orthographic = {
            xmag: 2 * e.right,
            ymag: 2 * e.top,
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        } : r.perspective = {
            aspectRatio: e.aspect,
            yfov: ul.degToRad(e.fov),
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1
    }
    processAnimation(e, t)
    {
        const n = this.json,
            r = this.nodeMap;
        n.animations || (n.animations = []);
        const o = (e = Tb.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks,
            i = [],
            a = [];
        for (let l = 0; l < o.length; ++l) {
            const e = o[l],
                n = Ch.parseTrackName(e.name);
            let s = Ch.findNode(t, n.nodeName);
            const c = Lb[n.propertyName];
            if ("bones" === n.objectName && (s = !0 === s.isSkinnedMesh ? s.skeleton.getBoneByName(n.objectIndex) : void 0), !s || !c)
                continue;
            const u = 1;
            let d,
                p = e.values.length / e.times.length;
            c === Lb.morphTargetInfluences && (p /= s.morphTargetInfluences.length),
            !0 === e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d = "CUBICSPLINE", p /= 3) : d = e.getInterpolation() === ks ? "STEP" : "LINEAR",
            a.push({
                input: this.processAccessor(new Au(e.times, u)),
                output: this.processAccessor(new Au(e.values, p)),
                interpolation: d
            }),
            i.push({
                sampler: a.length - 1,
                target: {
                    node: r.get(s),
                    path: c
                }
            })
        }
        const s = {
            name: e.name || "clip_" + n.animations.length,
            samplers: a,
            channels: i
        };
        return this.serializeUserData(e, s), n.animations.push(s), n.animations.length - 1
    }
    processSkin(e)
    {
        const t = this.json,
            n = this.nodeMap,
            r = t.nodes[n.get(e)],
            o = e.skeleton;
        if (void 0 === o)
            return null;
        const i = e.skeleton.bones[0];
        if (void 0 === i)
            return null;
        const a = [],
            s = new Float32Array(16 * o.bones.length),
            l = new gc;
        for (let c = 0; c < o.bones.length; ++c)
            a.push(n.get(o.bones[c])),
            l.copy(o.boneInverses[c]),
            l.multiply(e.bindMatrix).toArray(s, 16 * c);
        return void 0 === t.skins && (t.skins = []), t.skins.push({
            inverseBindMatrices: this.processAccessor(new Au(s, 16)),
            joints: a,
            skeleton: n.get(i)
        }), r.skin = t.skins.length - 1
    }
    async processNodeAsync(e)
    {
        const t = this.json,
            n = this.options,
            r = this.nodeMap;
        t.nodes || (t.nodes = []);
        const o = {};
        if (n.trs) {
            const t = e.quaternion.toArray(),
                n = e.position.toArray(),
                r = e.scale.toArray();
            Fb(t, [0, 0, 0, 1]) || (o.rotation = t),
            Fb(n, [0, 0, 0]) || (o.translation = n),
            Fb(r, [1, 1, 1]) || (o.scale = r)
        } else
            e.matrixAutoUpdate && e.updateMatrix(),
            !1 === Fb(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (o.matrix = e.matrix.elements);
        if ("" !== e.name && (o.name = String(e.name)), this.serializeUserData(e, o), e.isMesh || e.isLine || e.isPoints) {
            const t = await this.processMeshAsync(e);
            null !== t && (o.mesh = t)
        } else
            e.isCamera && (o.camera = this.processCamera(e));
        e.isSkinnedMesh && this.skins.push(e);
        const i = t.nodes.push(o) - 1;
        if (r.set(e, i), e.children.length > 0) {
            const t = [];
            for (let r = 0, o = e.children.length; r < o; r++) {
                const o = e.children[r];
                if (o.visible || !1 === n.onlyVisible) {
                    const e = await this.processNodeAsync(o);
                    null !== e && t.push(e)
                }
            }
            t.length > 0 && (o.children = t)
        }
        return await this._invokeAllAsync(function(t) {
            t.writeNode && t.writeNode(e, o)
        }), i
    }
    async processSceneAsync(e)
    {
        const t = this.json,
            n = this.options;
        t.scenes || (t.scenes = [], t.scene = 0);
        const r = {};
        "" !== e.name && (r.name = e.name),
        t.scenes.push(r);
        const o = [];
        for (let i = 0, a = e.children.length; i < a; i++) {
            const t = e.children[i];
            if (t.visible || !1 === n.onlyVisible) {
                const e = await this.processNodeAsync(t);
                null !== e && o.push(e)
            }
        }
        o.length > 0 && (r.nodes = o),
        this.serializeUserData(e, r)
    }
    async processObjectsAsync(e)
    {
        const t = new sd;
        t.name = "AuxScene";
        for (let n = 0; n < e.length; n++)
            t.children.push(e[n]);
        await this.processSceneAsync(t)
    }
    async processInputAsync(e)
    {
        const t = this.options;
        e = e instanceof Array ? e : [e],
        await this._invokeAllAsync(function(t) {
            t.beforeParse && t.beforeParse(e)
        });
        const n = [];
        for (let r = 0; r < e.length; r++)
            e[r] instanceof sd ? await this.processSceneAsync(e[r]) : n.push(e[r]);
        n.length > 0 && await this.processObjectsAsync(n);
        for (let r = 0; r < this.skins.length; ++r)
            this.processSkin(this.skins[r]);
        for (let r = 0; r < t.animations.length; ++r)
            this.processAnimation(t.animations[r], e[0]);
        await this._invokeAllAsync(function(t) {
            t.afterParse && t.afterParse(e)
        })
    }
    async _invokeAllAsync(e)
    {
        for (let t = 0, n = this.plugins.length; t < n; t++)
            await e(this.plugins[t])
    }
}
;
class jb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_lights_punctual"
    }
    writeNode(e, t)
    {
        if (!e.isLight)
            return;
        if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight)
            return;
        const n = this.writer,
            r = n.json,
            o = n.extensionsUsed,
            i = {};
        e.name && (i.name = e.name),
        i.color = e.color.toArray(),
        i.intensity = e.intensity,
        e.isDirectionalLight ? i.type = "directional" : e.isPointLight ? (i.type = "point", e.distance > 0 && (i.range = e.distance)) : e.isSpotLight && (i.type = "spot", e.distance > 0 && (i.range = e.distance), i.spot = {}, i.spot.innerConeAngle = (1 - e.penumbra) * e.angle, i.spot.outerConeAngle = e.angle),
        void 0 !== e.decay && e.decay,
        e.target && (e.target.parent !== e || 0 !== e.target.position.x || 0 !== e.target.position.y || e.target.position.z),
        o[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
            lights: []
        }, o[this.name] = !0);
        const a = r.extensions[this.name].lights;
        a.push(i),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {
            light: a.length - 1
        }
    }
}
class Vb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_unlit"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshBasicMaterial)
            return;
        const n = this.writer.extensionsUsed;
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {},
        n[this.name] = !0,
        t.pbrMetallicRoughness.metallicFactor = 0,
        t.pbrMetallicRoughness.roughnessFactor = .9
    }
}
class Hb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_clearcoat"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 === e.clearcoat)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (o.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
            const t = {
                index: await n.processTextureAsync(e.clearcoatMap),
                texCoord: e.clearcoatMap.channel
            };
            n.applyTextureTransform(t, e.clearcoatMap),
            o.clearcoatTexture = t
        }
        if (o.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
            const t = {
                index: await n.processTextureAsync(e.clearcoatRoughnessMap),
                texCoord: e.clearcoatRoughnessMap.channel
            };
            n.applyTextureTransform(t, e.clearcoatRoughnessMap),
            o.clearcoatRoughnessTexture = t
        }
        if (e.clearcoatNormalMap) {
            const t = {
                index: await n.processTextureAsync(e.clearcoatNormalMap),
                texCoord: e.clearcoatNormalMap.channel
            };
            1 !== e.clearcoatNormalScale.x && (t.scale = e.clearcoatNormalScale.x),
            n.applyTextureTransform(t, e.clearcoatNormalMap),
            o.clearcoatNormalTexture = t
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class $b {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_dispersion"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 === e.dispersion)
            return;
        const n = this.writer.extensionsUsed,
            r = {};
        r.dispersion = e.dispersion,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = r,
        n[this.name] = !0
    }
}
class Wb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_iridescence"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 === e.iridescence)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (o.iridescenceFactor = e.iridescence, e.iridescenceMap) {
            const t = {
                index: await n.processTextureAsync(e.iridescenceMap),
                texCoord: e.iridescenceMap.channel
            };
            n.applyTextureTransform(t, e.iridescenceMap),
            o.iridescenceTexture = t
        }
        if (o.iridescenceIor = e.iridescenceIOR, o.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], o.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
            const t = {
                index: await n.processTextureAsync(e.iridescenceThicknessMap),
                texCoord: e.iridescenceThicknessMap.channel
            };
            n.applyTextureTransform(t, e.iridescenceThicknessMap),
            o.iridescenceThicknessTexture = t
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class Kb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_transmission"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 === e.transmission)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (o.transmissionFactor = e.transmission, e.transmissionMap) {
            const t = {
                index: await n.processTextureAsync(e.transmissionMap),
                texCoord: e.transmissionMap.channel
            };
            n.applyTextureTransform(t, e.transmissionMap),
            o.transmissionTexture = t
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class qb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_volume"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 === e.transmission)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (o.thicknessFactor = e.thickness, e.thicknessMap) {
            const t = {
                index: await n.processTextureAsync(e.thicknessMap),
                texCoord: e.thicknessMap.channel
            };
            n.applyTextureTransform(t, e.thicknessMap),
            o.thicknessTexture = t
        }
        e.attenuationDistance !== 1 / 0 && (o.attenuationDistance = e.attenuationDistance),
        o.attenuationColor = e.attenuationColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class Xb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_ior"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 1.5 === e.ior)
            return;
        const n = this.writer.extensionsUsed,
            r = {};
        r.ior = e.ior,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = r,
        n[this.name] = !0
    }
}
class Yb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_specular"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 1 === e.specularIntensity && e.specularColor.equals(Nb) && !e.specularIntensityMap && !e.specularColorMap)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (e.specularIntensityMap) {
            const t = {
                index: await n.processTextureAsync(e.specularIntensityMap),
                texCoord: e.specularIntensityMap.channel
            };
            n.applyTextureTransform(t, e.specularIntensityMap),
            o.specularTexture = t
        }
        if (e.specularColorMap) {
            const t = {
                index: await n.processTextureAsync(e.specularColorMap),
                texCoord: e.specularColorMap.channel
            };
            n.applyTextureTransform(t, e.specularColorMap),
            o.specularColorTexture = t
        }
        o.specularFactor = e.specularIntensity,
        o.specularColorFactor = e.specularColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class Jb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_sheen"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 == e.sheen)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (e.sheenRoughnessMap) {
            const t = {
                index: await n.processTextureAsync(e.sheenRoughnessMap),
                texCoord: e.sheenRoughnessMap.channel
            };
            n.applyTextureTransform(t, e.sheenRoughnessMap),
            o.sheenRoughnessTexture = t
        }
        if (e.sheenColorMap) {
            const t = {
                index: await n.processTextureAsync(e.sheenColorMap),
                texCoord: e.sheenColorMap.channel
            };
            n.applyTextureTransform(t, e.sheenColorMap),
            o.sheenColorTexture = t
        }
        o.sheenRoughnessFactor = e.sheenRoughness,
        o.sheenColorFactor = e.sheenColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class Zb {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_anisotropy"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshPhysicalMaterial || 0 == e.anisotropy)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (e.anisotropyMap) {
            const t = {
                index: await n.processTextureAsync(e.anisotropyMap)
            };
            n.applyTextureTransform(t, e.anisotropyMap),
            o.anisotropyTexture = t
        }
        o.anisotropyStrength = e.anisotropy,
        o.anisotropyRotation = e.anisotropyRotation,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class eA {
    constructor(e)
    {
        this.writer = e,
        this.name = "KHR_materials_emissive_strength"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshStandardMaterial || 1 === e.emissiveIntensity)
            return;
        const n = this.writer.extensionsUsed,
            r = {};
        r.emissiveStrength = e.emissiveIntensity,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = r,
        n[this.name] = !0
    }
}
class tA {
    constructor(e)
    {
        this.writer = e,
        this.name = "EXT_materials_bump"
    }
    async writeMaterialAsync(e, t)
    {
        if (!e.isMeshStandardMaterial || 1 === e.bumpScale && !e.bumpMap)
            return;
        const n = this.writer,
            r = n.extensionsUsed,
            o = {};
        if (e.bumpMap) {
            const t = {
                index: await n.processTextureAsync(e.bumpMap),
                texCoord: e.bumpMap.channel
            };
            n.applyTextureTransform(t, e.bumpMap),
            o.bumpTexture = t
        }
        o.bumpFactor = e.bumpScale,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = o,
        r[this.name] = !0
    }
}
class nA {
    constructor(e)
    {
        this.writer = e,
        this.name = "EXT_mesh_gpu_instancing"
    }
    writeNode(e, t)
    {
        if (!e.isInstancedMesh)
            return;
        const n = this.writer,
            r = e,
            o = new Float32Array(3 * r.count),
            i = new Float32Array(4 * r.count),
            a = new Float32Array(3 * r.count),
            s = new gc,
            l = new hl,
            c = new pl,
            u = new hl;
        for (let p = 0; p < r.count; p++)
            r.getMatrixAt(p, s),
            s.decompose(l, c, u),
            l.toArray(o, 3 * p),
            c.toArray(i, 4 * p),
            u.toArray(a, 3 * p);
        const d = {
            TRANSLATION: n.processAccessor(new Au(o, 3)),
            ROTATION: n.processAccessor(new Au(i, 4)),
            SCALE: n.processAccessor(new Au(a, 3))
        };
        r.instanceColor && (d._COLOR_0 = n.processAccessor(r.instanceColor)),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {
            attributes: d
        },
        n.extensionsUsed[this.name] = !0,
        n.extensionsRequired[this.name] = !0
    }
}
Tb.Utils = {
    insertKeyframe: function(e, t) {
        const n = .001,
            r = e.getValueSize(),
            o = new e.TimeBufferType(e.times.length + 1),
            i = new e.ValueBufferType(e.values.length + r),
            a = e.createInterpolant(new e.ValueBufferType(r));
        let s;
        if (0 === e.times.length) {
            o[0] = t;
            for (let e = 0; e < r; e++)
                i[e] = 0;
            s = 0
        } else if (t < e.times[0]) {
            if (Math.abs(e.times[0] - t) < n)
                return 0;
            o[0] = t,
            o.set(e.times, 1),
            i.set(a.evaluate(t), 0),
            i.set(e.values, r),
            s = 0
        } else if (t > e.times[e.times.length - 1]) {
            if (Math.abs(e.times[e.times.length - 1] - t) < n)
                return e.times.length - 1;
            o[o.length - 1] = t,
            o.set(e.times, 0),
            i.set(e.values, 0),
            i.set(a.evaluate(t), e.values.length),
            s = o.length - 1
        } else
            for (let l = 0; l < e.times.length; l++) {
                if (Math.abs(e.times[l] - t) < n)
                    return l;
                if (e.times[l] < t && e.times[l + 1] > t) {
                    o.set(e.times.slice(0, l + 1), 0),
                    o[l + 1] = t,
                    o.set(e.times.slice(l + 1), l + 2),
                    i.set(e.values.slice(0, (l + 1) * r), 0),
                    i.set(a.evaluate(t), (l + 1) * r),
                    i.set(e.values.slice((l + 1) * r), (l + 2) * r),
                    s = l + 1;
                    break
                }
            }
        return e.times = o, e.values = i, s
    },
    mergeMorphTargetTracks: function(e, t) {
        const n = [],
            r = {},
            o = e.tracks;
        for (let i = 0; i < o.length; ++i) {
            let e = o[i];
            const a = Ch.parseTrackName(e.name),
                s = Ch.findNode(t, a.nodeName);
            if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
                n.push(e);
                continue
            }
            if (e.createInterpolant !== e.InterpolantFactoryMethodDiscrete && e.createInterpolant !== e.InterpolantFactoryMethodLinear) {
                if (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                    throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                e = e.clone(),
                e.setInterpolation(Ds)
            }
            const l = s.morphTargetInfluences.length,
                c = s.morphTargetDictionary[a.propertyIndex];
            if (void 0 === c)
                throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
            let u;
            if (void 0 === r[s.uuid]) {
                u = e.clone();
                const t = new u.ValueBufferType(l * u.times.length);
                for (let e = 0; e < u.times.length; e++)
                    t[e * l + c] = u.values[e];
                u.name = (a.nodeName || "") + ".morphTargetInfluences",
                u.values = t,
                r[s.uuid] = u,
                n.push(u);
                continue
            }
            const d = e.createInterpolant(new e.ValueBufferType(1));
            u = r[s.uuid];
            for (let t = 0; t < u.times.length; t++)
                u.values[t * l + c] = d.evaluate(u.times[t]);
            for (let t = 0; t < e.times.length; t++) {
                const n = this.insertKeyframe(u, e.times[t]);
                u.values[n * l + c] = e.values[t]
            }
        }
        return e.tracks = n, e
    },
    toFloat32BufferAttribute: function(e) {
        const t = new Au(new Float32Array(e.count * e.itemSize), e.itemSize, !1);
        if (!e.normalized && !e.isInterleavedBufferAttribute)
            return t.array.set(e.array), t;
        for (let n = 0, r = e.count; n < r; n++)
            for (let o = 0; o < e.itemSize; o++)
                t.setComponent(n, o, e.getComponent(n, o));
        return t
    }
};
const rA = new WeakMap;
class oA extends jp {
    constructor(e)
    {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e)
    {
        return this.decoderPath = e, this
    }
    setDecoderConfig(e)
    {
        return this.decoderConfig = e, this
    }
    setWorkerLimit(e)
    {
        return this.workerLimit = e, this
    }
    load(e, t, n, r)
    {
        const o = new $p(this.manager);
        o.setPath(this.path),
        o.setResponseType("arraybuffer"),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, e => {
            this.parse(e, t, r)
        }, n, r)
    }
    parse(e, t, n=() => {})
    {
        this.decodeDracoFile(e, t, null, null, Ls, n).catch(n)
    }
    decodeDracoFile(e, t, n, r, o=Ns, i=() => {})
    {
        const a = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!n,
            vertexColorSpace: o
        };
        return this.decodeGeometry(e, a).then(t).catch(i)
    }
    decodeGeometry(e, t)
    {
        const n = JSON.stringify(t);
        if (rA.has(e)) {
            const t = rA.get(e);
            if (t.key === n)
                return t.promise;
            if (0 === e.byteLength)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let r;
        const o = this.workerNextTaskID++,
            i = e.byteLength,
            a = this._getWorker(o, i).then(n => (r = n, new Promise((n, i) => {
                r._callbacks[o] = {
                    resolve: n,
                    reject: i
                },
                r.postMessage({
                    type: "decode",
                    id: o,
                    taskConfig: t,
                    buffer: e
                }, [e])
            }))).then(e => this._createGeometry(e.geometry));
        return a.catch(() => !0).then(() => {
            r && o && this._releaseTask(r, o)
        }), rA.set(e, {
            key: n,
            promise: a
        }), a
    }
    _createGeometry(e)
    {
        const t = new Mu;
        e.index && t.setIndex(new Au(e.index.array, 1));
        for (let n = 0; n < e.attributes.length; n++) {
            const r = e.attributes[n],
                o = r.name,
                i = r.array,
                a = r.itemSize,
                s = new Au(i, a);
            "color" === o && (this._assignVertexColorSpace(s, r.vertexColorSpace), s.normalized = i instanceof Float32Array == 0),
            t.setAttribute(o, s)
        }
        return t
    }
    _assignVertexColorSpace(e, t)
    {
        if (t !== Ls)
            return;
        const n = new su;
        for (let r = 0, o = e.count; r < o; r++)
            n.fromBufferAttribute(e, r),
            Sl.colorSpaceToWorking(n, Ls),
            e.setXYZ(r, n.r, n.g, n.b)
    }
    _loadLibrary(e, t)
    {
        const n = new $p(this.manager);
        return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((t, r) => {
            n.load(e, t, void 0, r)
        })
    }
    preload()
    {
        return this._initDecoder(), this
    }
    _initDecoder()
    {
        if (this.decoderPending)
            return this.decoderPending;
        const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
            t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(t => {
            const n = t[0];
            e || (this.decoderConfig.wasmBinary = t[1]);
            const r = iA.toString(),
                o = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }
    _getWorker(e, t)
    {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const e = new Worker(this.workerSourceURL);
                e._callbacks = {},
                e._taskCosts = {},
                e._taskLoad = 0,
                e.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                e.onmessage = function(t) {
                    const n = t.data;
                    switch (n.type) {
                    case "decode":
                        e._callbacks[n.id].resolve(n);
                        break;
                    case "error":
                        e._callbacks[n.id].reject(n)
                    }
                },
                this.workerPool.push(e)
            } else
                this.workerPool.sort(function(e, t) {
                    return e._taskLoad > t._taskLoad ? -1 : 1
                });
            const n = this.workerPool[this.workerPool.length - 1];
            return n._taskCosts[e] = t, n._taskLoad += t, n
        })
    }
    _releaseTask(e, t)
    {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {}
    dispose()
    {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
    }
}
function iA() {
    let e,
        t;
    function n(e, t, n, r, o, i) {
        const a = i.num_components(),
            s = n.num_points() * a,
            l = s * o.BYTES_PER_ELEMENT,
            c = function(e, t) {
                switch (t) {
                case Float32Array:
                    return e.DT_FLOAT32;
                case Int8Array:
                    return e.DT_INT8;
                case Int16Array:
                    return e.DT_INT16;
                case Int32Array:
                    return e.DT_INT32;
                case Uint8Array:
                    return e.DT_UINT8;
                case Uint16Array:
                    return e.DT_UINT16;
                case Uint32Array:
                    return e.DT_UINT32
                }
            }(e, o),
            u = e._malloc(l);
        t.GetAttributeDataArrayForAllPoints(n, i, c, l, u);
        const d = new o(e.HEAPF32.buffer, u, s).slice();
        return e._free(u), {
            name: r,
            array: d,
            itemSize: a
        }
    }
    onmessage = function(r) {
        const o = r.data;
        switch (o.type) {
        case "init":
            e = o.decoderConfig,
            t = new Promise(function(t) {
                e.onModuleLoaded = function(e) {
                    t({
                        draco: e
                    })
                },
                DracoDecoderModule(e)
            });
            break;
        case "decode":
            const r = o.buffer,
                i = o.taskConfig;
            t.then(e => {
                const t = e.draco,
                    a = new t.Decoder;
                try {
                    const e = function(e, t, r, o) {
                            const i = o.attributeIDs,
                                a = o.attributeTypes;
                            let s,
                                l;
                            const c = t.GetEncodedGeometryType(r);
                            if (c === e.TRIANGULAR_MESH)
                                s = new e.Mesh,
                                l = t.DecodeArrayToMesh(r, r.byteLength, s);
                            else {
                                if (c !== e.POINT_CLOUD)
                                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                s = new e.PointCloud,
                                l = t.DecodeArrayToPointCloud(r, r.byteLength, s)
                            }
                            if (!l.ok() || 0 === s.ptr)
                                throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                            const u = {
                                index: null,
                                attributes: []
                            };
                            for (const d in i) {
                                const r = self[a[d]];
                                let l,
                                    c;
                                if (o.useUniqueIDs)
                                    c = i[d],
                                    l = t.GetAttributeByUniqueId(s, c);
                                else {
                                    if (c = t.GetAttributeId(s, e[i[d]]), -1 === c)
                                        continue;
                                    l = t.GetAttribute(s, c)
                                }
                                const p = n(e, t, s, d, r, l);
                                "color" === d && (p.vertexColorSpace = o.vertexColorSpace),
                                u.attributes.push(p)
                            }
                            return c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                const r = 3 * n.num_faces(),
                                    o = 4 * r,
                                    i = e._malloc(o);
                                t.GetTrianglesUInt32Array(n, o, i);
                                const a = new Uint32Array(e.HEAPF32.buffer, i, r).slice();
                                return e._free(i), {
                                    array: a,
                                    itemSize: 1
                                }
                            }(e, t, s)), e.destroy(s), u
                        }(t, a, new Int8Array(r), i),
                        s = e.attributes.map(e => e.array.buffer);
                    e.index && s.push(e.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: o.id,
                        geometry: e
                    }, s)
                } catch (s) {
                    self.postMessage({
                        type: "error",
                        id: o.id,
                        error: s.message
                    })
                } finally {
                    t.destroy(a)
                }
            })
        }
    }
}
class aA {
    constructor(e=4)
    {
        this.pool = e,
        this.queue = [],
        this.workers = [],
        this.workersResolve = [],
        this.workerStatus = 0,
        this.workerCreator = null
    }
    _initWorker(e)
    {
        if (!this.workers[e]) {
            const t = this.workerCreator();
            t.addEventListener("message", this._onMessage.bind(this, e)),
            this.workers[e] = t
        }
    }
    _getIdleWorker()
    {
        for (let e = 0; e < this.pool; e++)
            if (!(this.workerStatus & 1 << e))
                return e;
        return -1
    }
    _onMessage(e, t)
    {
        const n = this.workersResolve[e];
        if (n && n(t), this.queue.length) {
            const {resolve: t, msg: n, transfer: r} = this.queue.shift();
            this.workersResolve[e] = t,
            this.workers[e].postMessage(n, r)
        } else
            this.workerStatus ^= 1 << e
    }
    setWorkerCreator(e)
    {
        this.workerCreator = e
    }
    setWorkerLimit(e)
    {
        this.pool = e
    }
    postMessage(e, t)
    {
        return new Promise(n => {
            const r = this._getIdleWorker();
            -1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(e, t)) : this.queue.push({
                resolve: n,
                msg: e,
                transfer: t
            })
        })
    }
    dispose()
    {
        this.workers.forEach(e => e.terminate()),
        this.workersResolve.length = 0,
        this.workers.length = 0,
        this.queue.length = 0,
        this.workerStatus = 0
    }
}
const sA = 9,
    lA = 15,
    cA = 16,
    uA = 22,
    dA = 37,
    pA = 43,
    hA = 76,
    fA = 83,
    gA = 97,
    mA = 100,
    bA = 103,
    AA = 109,
    yA = 122,
    vA = 123,
    _A = 131,
    xA = 132,
    wA = 133,
    CA = 134,
    EA = 137,
    SA = 138,
    IA = 139,
    TA = 140,
    MA = 141,
    RA = 142,
    BA = 145,
    kA = 146,
    DA = 148,
    PA = 152,
    OA = 157,
    LA = 158,
    NA = 165,
    FA = 166,
    UA = 1000054e3,
    zA = 1000054001,
    QA = 1000054004,
    GA = 1000054005,
    jA = 1000066e3,
    VA = 1000066004;
class HA {
    constructor(e, t, n, r)
    {
        this._dataView = void 0,
        this._littleEndian = void 0,
        this._offset = void 0,
        this._dataView = new DataView(e.buffer, e.byteOffset + t, n),
        this._littleEndian = r,
        this._offset = 0
    }
    _nextUint8()
    {
        const e = this._dataView.getUint8(this._offset);
        return this._offset += 1, e
    }
    _nextUint16()
    {
        const e = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, e
    }
    _nextUint32()
    {
        const e = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _nextUint64()
    {
        const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, e
    }
    _nextInt32()
    {
        const e = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _nextUint8Array(e)
    {
        const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
        return this._offset += e, t
    }
    _skip(e)
    {
        return this._offset += e, this
    }
    _scan(e, t=0)
    {
        const n = this._offset;
        let r = 0;
        for (; this._dataView.getUint8(this._offset) !== t && r < e;)
            r++,
            this._offset++;
        return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
    }
}
const $A = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function WA(e) {
    return (new TextDecoder).decode(e)
}
let KA,
    qA,
    XA;
const YA = {
    env: {
        emscripten_notify_memory_growth: function(e) {
            XA = new Uint8Array(qA.exports.memory.buffer)
        }
    }
};
let JA = class {
    init()
    {
        return KA || (KA = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + ZA).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, YA)).then(this._init) : WebAssembly.instantiate(Buffer.from(ZA, "base64"), YA).then(this._init), KA)
    }
    _init(e)
    {
        qA = e.instance,
        YA.env.emscripten_notify_memory_growth(0)
    }
    decode(e, t=0)
    {
        if (!qA)
            throw new Error("ZSTDDecoder: Await .init() before decoding.");
        const n = e.byteLength,
            r = qA.exports.malloc(n);
        XA.set(e, r),
        t = t || Number(qA.exports.ZSTD_findDecompressedSize(r, n));
        const o = qA.exports.malloc(t),
            i = qA.exports.ZSTD_decompress(o, t, r, n),
            a = XA.slice(o, o + i);
        return qA.exports.free(r), qA.exports.free(o), a
    }
}
;
const ZA = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
Sl.spaces[Ls];
const ey = new WeakMap;
let ty;
class ny extends jp {
    constructor(e)
    {
        super(e),
        this.transcoderPath = "",
        this.transcoderBinary = null,
        this.transcoderPending = null,
        this.workerPool = new aA,
        this.workerSourceURL = "",
        this.workerConfig = null
    }
    setTranscoderPath(e)
    {
        return this.transcoderPath = e, this
    }
    setWorkerLimit(e)
    {
        return this.workerPool.setWorkerLimit(e), this
    }
    async detectSupportAsync(e)
    {
        return this.workerConfig = {
            astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
            astcHDRSupported: !1,
            etc1Supported: await e.hasFeatureAsync("texture-compression-etc2"),
            etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
            dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
            bptcSupported: await e.hasFeatureAsync("texture-compression-bc"),
            pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
        }, this
    }
    detectSupport(e)
    {
        return !0 === e.isWebGPURenderer ? this.workerConfig = {
            astcSupported: e.hasFeature("texture-compression-astc"),
            astcHDRSupported: !1,
            etc1Supported: e.hasFeature("texture-compression-etc2"),
            etc2Supported: e.hasFeature("texture-compression-etc2"),
            dxtSupported: e.hasFeature("texture-compression-bc"),
            bptcSupported: e.hasFeature("texture-compression-bc"),
            pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
        } : this.workerConfig = {
            astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
            astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
            etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
        }, this
    }
    init()
    {
        if (!this.transcoderPending) {
            const e = new $p(this.manager);
            e.setPath(this.transcoderPath),
            e.setWithCredentials(this.withCredentials);
            const t = e.loadAsync("basis_transcoder.js"),
                n = new $p(this.manager);
            n.setPath(this.transcoderPath),
            n.setResponseType("arraybuffer"),
            n.setWithCredentials(this.withCredentials);
            const r = n.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([t, r]).then(([e, t]) => {
                const n = ny.BasisWorker.toString(),
                    r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(ny.EngineFormat), "let _EngineType = " + JSON.stringify(ny.EngineType), "let _TranscoderFormat = " + JSON.stringify(ny.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(ny.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([r])),
                this.transcoderBinary = t,
                this.workerPool.setWorkerCreator(() => {
                    const e = new Worker(this.workerSourceURL),
                        t = this.transcoderBinary.slice(0);
                    return e.postMessage({
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: t
                    }, [t]), e
                })
            })
        }
        return this.transcoderPending
    }
    load(e, t, n, r)
    {
        if (null === this.workerConfig)
            throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        const o = new $p(this.manager);
        o.setPath(this.path),
        o.setCrossOrigin(this.crossOrigin),
        o.setWithCredentials(this.withCredentials),
        o.setResponseType("arraybuffer"),
        o.load(e, e => {
            this.parse(e, t, r)
        }, n, r)
    }
    parse(e, t, n)
    {
        if (null === this.workerConfig)
            throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        if (ey.has(e))
            return ey.get(e).promise.then(t).catch(n);
        this._createTexture(e).then(e => t ? t(e) : null).catch(n)
    }
    _createTextureFrom(e, t)
    {
        const {type: n, error: r, data: {faces: o, width: i, height: a, format: s, type: l, dfdFlags: c}} = e;
        if ("error" === n)
            return Promise.reject(r);
        let u;
        if (6 === t.faceCount)
            u = new pp(o, s, l);
        else {
            const e = o[0].mipmaps;
            u = t.layerCount > 1 ? new dp(e, i, a, t.layerCount, s, l) : new up(e, i, a, s, l)
        }
        return u.minFilter = 1 === o[0].mipmaps.length ? Ra : ka, u.magFilter = Ra, u.generateMipmaps = !1, u.needsUpdate = !0, u.colorSpace = ay(t), u.premultiplyAlpha = !!(1 & c), u
    }
    async _createTexture(e, t={})
    {
        const n = function(e) {
                const t = new Uint8Array(e.buffer, e.byteOffset, $A.length);
                if (t[0] !== $A[0] || t[1] !== $A[1] || t[2] !== $A[2] || t[3] !== $A[3] || t[4] !== $A[4] || t[5] !== $A[5] || t[6] !== $A[6] || t[7] !== $A[7] || t[8] !== $A[8] || t[9] !== $A[9] || t[10] !== $A[10] || t[11] !== $A[11])
                    throw new Error("Missing KTX 2.0 identifier.");
                const n = {
                        vkFormat: 0,
                        typeSize: 1,
                        pixelWidth: 0,
                        pixelHeight: 0,
                        pixelDepth: 0,
                        layerCount: 0,
                        faceCount: 1,
                        levelCount: 0,
                        supercompressionScheme: 0,
                        levels: [],
                        dataFormatDescriptor: [{
                            vendorId: 0,
                            descriptorType: 0,
                            versionNumber: 2,
                            colorModel: 0,
                            colorPrimaries: 1,
                            transferFunction: 2,
                            flags: 0,
                            texelBlockDimension: [0, 0, 0, 0],
                            bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                            samples: []
                        }],
                        keyValue: {},
                        globalData: null
                    },
                    r = 17 * Uint32Array.BYTES_PER_ELEMENT,
                    o = new HA(e, $A.length, r, !0);
                n.vkFormat = o._nextUint32(),
                n.typeSize = o._nextUint32(),
                n.pixelWidth = o._nextUint32(),
                n.pixelHeight = o._nextUint32(),
                n.pixelDepth = o._nextUint32(),
                n.layerCount = o._nextUint32(),
                n.faceCount = o._nextUint32(),
                n.levelCount = o._nextUint32(),
                n.supercompressionScheme = o._nextUint32();
                const i = o._nextUint32(),
                    a = o._nextUint32(),
                    s = o._nextUint32(),
                    l = o._nextUint32(),
                    c = o._nextUint64(),
                    u = o._nextUint64(),
                    d = 3 * Math.max(n.levelCount, 1) * 8,
                    p = new HA(e, $A.length + r, d, !0);
                for (let N = 0, F = Math.max(n.levelCount, 1); N < F; N++)
                    n.levels.push({
                        levelData: new Uint8Array(e.buffer, e.byteOffset + p._nextUint64(), p._nextUint64()),
                        uncompressedByteLength: p._nextUint64()
                    });
                const h = new HA(e, i, a, !0);
                h._skip(4);
                const f = h._nextUint16(),
                    g = h._nextUint16(),
                    m = h._nextUint16(),
                    b = h._nextUint16(),
                    A = {
                        vendorId: f,
                        descriptorType: g,
                        versionNumber: m,
                        colorModel: h._nextUint8(),
                        colorPrimaries: h._nextUint8(),
                        transferFunction: h._nextUint8(),
                        flags: h._nextUint8(),
                        texelBlockDimension: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
                        bytesPlane: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
                        samples: []
                    },
                    y = (b / 4 - 6) / 4;
                for (let N = 0; N < y; N++) {
                    const e = {
                        bitOffset: h._nextUint16(),
                        bitLength: h._nextUint8(),
                        channelType: h._nextUint8(),
                        samplePosition: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
                        sampleLower: Number.NEGATIVE_INFINITY,
                        sampleUpper: Number.POSITIVE_INFINITY
                    };
                    64 & e.channelType ? (e.sampleLower = h._nextInt32(), e.sampleUpper = h._nextInt32()) : (e.sampleLower = h._nextUint32(), e.sampleUpper = h._nextUint32()),
                    A.samples[N] = e
                }
                n.dataFormatDescriptor.length = 0,
                n.dataFormatDescriptor.push(A);
                const v = new HA(e, s, l, !0);
                for (; v._offset < l;) {
                    const e = v._nextUint32(),
                        t = v._scan(e),
                        r = WA(t);
                    if (n.keyValue[r] = v._nextUint8Array(e - t.byteLength - 1), r.match(/^ktx/i)) {
                        const e = WA(n.keyValue[r]);
                        n.keyValue[r] = e.substring(0, e.lastIndexOf("\0"))
                    }
                    v._skip(e % 4 ? 4 - e % 4 : 0)
                }
                if (u <= 0)
                    return n;
                const _ = new HA(e, c, u, !0),
                    x = _._nextUint16(),
                    w = _._nextUint16(),
                    C = _._nextUint32(),
                    E = _._nextUint32(),
                    S = _._nextUint32(),
                    I = _._nextUint32(),
                    T = [];
                for (let N = 0, F = Math.max(n.levelCount, 1); N < F; N++)
                    T.push({
                        imageFlags: _._nextUint32(),
                        rgbSliceByteOffset: _._nextUint32(),
                        rgbSliceByteLength: _._nextUint32(),
                        alphaSliceByteOffset: _._nextUint32(),
                        alphaSliceByteLength: _._nextUint32()
                    });
                const M = c + _._offset,
                    R = M + C,
                    B = R + E,
                    k = B + S,
                    D = new Uint8Array(e.buffer, e.byteOffset + M, C),
                    P = new Uint8Array(e.buffer, e.byteOffset + R, E),
                    O = new Uint8Array(e.buffer, e.byteOffset + B, S),
                    L = new Uint8Array(e.buffer, e.byteOffset + k, I);
                return n.globalData = {
                    endpointCount: x,
                    selectorCount: w,
                    imageDescs: T,
                    endpointsData: D,
                    selectorsData: P,
                    tablesData: O,
                    extendedData: L
                }, n
            }(new Uint8Array(e)),
            r = n.vkFormat === jA && 167 === n.dataFormatDescriptor[0].colorModel;
        if (0 !== n.vkFormat && (!r || this.workerConfig.astcHDRSupported))
            return async function(e) {
                const {vkFormat: t} = e;
                if (void 0 === oy[t])
                    throw new Error("THREE.KTX2Loader: Unsupported vkFormat: " + t);
                let n;
                iy[t],
                2 === e.supercompressionScheme && (ty || (ty = new Promise(async e => {
                    const t = new JA;
                    await t.init(),
                    e(t)
                })), n = await ty);
                const r = [];
                for (let a = 0; a < e.levels.length; a++) {
                    const o = Math.max(1, e.pixelWidth >> a),
                        i = Math.max(1, e.pixelHeight >> a),
                        s = e.pixelDepth ? Math.max(1, e.pixelDepth >> a) : 0,
                        l = e.levels[a];
                    let c,
                        u;
                    if (0 === e.supercompressionScheme)
                        c = l.levelData;
                    else {
                        if (2 !== e.supercompressionScheme)
                            throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                        c = n.decode(l.levelData, l.uncompressedByteLength)
                    }
                    u = iy[t] === Na ? new Float32Array(c.buffer, c.byteOffset, c.byteLength / Float32Array.BYTES_PER_ELEMENT) : iy[t] === Fa ? new Uint16Array(c.buffer, c.byteOffset, c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : iy[t] === Ga || iy[t] === ja ? new Uint32Array(c.buffer, c.byteOffset, c.byteLength / Uint32Array.BYTES_PER_ELEMENT) : c,
                    r.push({
                        data: u,
                        width: o,
                        height: i,
                        depth: s
                    })
                }
                const o = 0 === e.levelCount || r.length > 1;
                let i;
                if (ry.has(oy[t]))
                    i = 0 === e.pixelDepth ? new xd(r[0].data, e.pixelWidth, e.pixelHeight) : new Ql(r[0].data, e.pixelWidth, e.pixelHeight, e.pixelDepth),
                    i.minFilter = o ? Ta : Ia,
                    i.magFilter = Ia,
                    i.generateMipmaps = 0 === e.levelCount;
                else {
                    if (e.pixelDepth > 0)
                        throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                    i = new up(r, e.pixelWidth, e.pixelHeight),
                    i.minFilter = o ? ka : Ra,
                    i.magFilter = Ra
                }
                return i.mipmaps = r, i.type = iy[t], i.format = oy[t], i.colorSpace = ay(e), i.needsUpdate = !0, Promise.resolve(i)
            }(n);
        const o = t,
            i = this.init().then(() => this.workerPool.postMessage({
                type: "transcode",
                buffer: e,
                taskConfig: o
            }, [e])).then(e => this._createTextureFrom(e.data, n));
        return ey.set(e, {
            promise: i
        }), i
    }
    dispose()
    {
        this.workerPool.dispose(),
        this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL)
    }
}
ny.BasisFormat = {
    ETC1S: 0,
    UASTC: 1,
    UASTC_HDR: 2
},
ny.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16,
    BC6H: 22,
    RGB_HALF: 24,
    RGBA_HALF: 25
},
ny.EngineFormat = {
    RGBAFormat: $a,
    RGBA_ASTC_4x4_Format: ds,
    RGB_BPTC_UNSIGNED_Format: Is,
    RGBA_BPTC_Format: Es,
    RGBA_ETC2_EAC_Format: us,
    RGBA_PVRTC_4BPPV1_Format: as,
    RGBA_S3TC_DXT5_Format: rs,
    RGB_ETC1_Format: ls,
    RGB_ETC2_Format: cs,
    RGB_PVRTC_4BPPV1_Format: os,
    RGBA_S3TC_DXT1_Format: ts
},
ny.EngineType = {
    UnsignedByteType: Da,
    HalfFloatType: Fa,
    FloatType: Na
},
ny.BasisWorker = function() {
    let e,
        t,
        n;
    const r = _EngineFormat,
        o = _EngineType,
        i = _TranscoderFormat,
        a = _BasisFormat;
    self.addEventListener("message", function(r) {
        const i = r.data;
        switch (i.type) {
        case "init":
            e = i.config,
            s = i.transcoderBinary,
            t = new Promise(e => {
                n = {
                    wasmBinary: s,
                    onRuntimeInitialized: e
                },
                BASIS(n)
            }).then(() => {
                n.initializeBasis(),
                n.KTX2File
            });
            break;
        case "transcode":
            t.then(() => {
                try {
                    const {faces: t, buffers: r, width: s, height: d, hasAlpha: p, format: h, type: f, dfdFlags: g} = function(t) {
                        const r = new n.KTX2File(new Uint8Array(t));
                        function i() {
                            r.close(),
                            r.delete()
                        }
                        if (!r.isValid())
                            throw i(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                        let s;
                        if (r.isUASTC())
                            s = a.UASTC;
                        else if (r.isETC1S())
                            s = a.ETC1S;
                        else {
                            if (!r.isHDR())
                                throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
                            s = a.UASTC_HDR
                        }
                        const d = r.getWidth(),
                            p = r.getHeight(),
                            h = r.getLayers() || 1,
                            f = r.getLevels(),
                            g = r.getFaces(),
                            m = r.getHasAlpha(),
                            b = r.getDFDFlags(),
                            {transcoderFormat: A, engineFormat: y, engineType: v} = function(t, n, r, o) {
                                const i = l[t];
                                for (let a = 0; a < i.length; a++) {
                                    const s = i[a];
                                    if ((!s.if || e[s.if]) && (s.basisFormat.includes(t) && !(o && s.transcoderFormat.length < 2) && (!s.needsPowerOfTwo || c(n) && c(r))))
                                        return {
                                            transcoderFormat: s.transcoderFormat[o ? 1 : 0],
                                            engineFormat: s.engineFormat[o ? 1 : 0],
                                            engineType: s.engineType[0]
                                        }
                                }
                                throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")
                            }(s, d, p, m);
                        if (!d || !p || !f)
                            throw i(), new Error("THREE.KTX2Loader:\tInvalid texture");
                        if (!r.startTranscoding())
                            throw i(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                        const _ = [],
                            x = [];
                        for (let e = 0; e < g; e++) {
                            const t = [];
                            for (let n = 0; n < f; n++) {
                                const a = [];
                                let s,
                                    l;
                                for (let t = 0; t < h; t++) {
                                    const c = r.getImageLevelInfo(n, t, e);
                                    0 === e && 0 === n && 0 === t && (c.origWidth % 4 != 0 || c.origHeight),
                                    f > 1 ? (s = c.origWidth, l = c.origHeight) : (s = c.width, l = c.height);
                                    let u = new Uint8Array(r.getImageTranscodedSizeInBytes(n, t, 0, A));
                                    const d = r.transcodeImage(u, n, t, e, A, 0, -1, -1);
                                    if (v === o.HalfFloatType && (u = new Uint16Array(u.buffer, u.byteOffset, u.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !d)
                                        throw i(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                    a.push(u)
                                }
                                const c = u(a);
                                t.push({
                                    data: c,
                                    width: s,
                                    height: l
                                }),
                                x.push(c.buffer)
                            }
                            _.push({
                                mipmaps: t,
                                width: d,
                                height: p,
                                format: y,
                                type: v
                            })
                        }
                        return i(), {
                            faces: _,
                            buffers: x,
                            width: d,
                            height: p,
                            hasAlpha: m,
                            dfdFlags: b,
                            format: y,
                            type: v
                        }
                    }(i.buffer);
                    self.postMessage({
                        type: "transcode",
                        id: i.id,
                        data: {
                            faces: t,
                            width: s,
                            height: d,
                            hasAlpha: p,
                            format: h,
                            type: f,
                            dfdFlags: g
                        }
                    }, r)
                } catch (t) {
                    self.postMessage({
                        type: "error",
                        id: i.id,
                        error: t.message
                    })
                }
            })
        }
        var s
    });
    const s = [{
            if: "astcSupported",
            basisFormat: [a.UASTC],
            transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
            engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 1 / 0,
            priorityUASTC: 1,
            needsPowerOfTwo: !1
        }, {
            if: "bptcSupported",
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.BC7_M5, i.BC7_M5],
            engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: !1
        }, {
            if: "dxtSupported",
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.BC1, i.BC3],
            engineFormat: [r.RGBA_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: !1
        }, {
            if: "etc2Supported",
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.ETC1, i.ETC2],
            engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: !1
        }, {
            if: "etc1Supported",
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.ETC1],
            engineFormat: [r.RGB_ETC1_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: !1
        }, {
            if: "pvrtcSupported",
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
            engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
            engineType: [o.UnsignedByteType],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: !0
        }, {
            if: "bptcSupported",
            basisFormat: [a.UASTC_HDR],
            transcoderFormat: [i.BC6H],
            engineFormat: [r.RGB_BPTC_UNSIGNED_Format],
            engineType: [o.HalfFloatType],
            priorityHDR: 1,
            needsPowerOfTwo: !1
        }, {
            basisFormat: [a.ETC1S, a.UASTC],
            transcoderFormat: [i.RGBA32, i.RGBA32],
            engineFormat: [r.RGBAFormat, r.RGBAFormat],
            engineType: [o.UnsignedByteType, o.UnsignedByteType],
            priorityETC1S: 100,
            priorityUASTC: 100,
            needsPowerOfTwo: !1
        }, {
            basisFormat: [a.UASTC_HDR],
            transcoderFormat: [i.RGBA_HALF],
            engineFormat: [r.RGBAFormat],
            engineType: [o.HalfFloatType],
            priorityHDR: 100,
            needsPowerOfTwo: !1
        }],
        l = {
            [a.ETC1S]: s.filter(e => e.basisFormat.includes(a.ETC1S)).sort((e, t) => e.priorityUASTC - t.priorityUASTC),
            [a.UASTC]: s.filter(e => e.basisFormat.includes(a.UASTC)).sort((e, t) => e.priorityUASTC - t.priorityUASTC),
            [a.UASTC_HDR]: s.filter(e => e.basisFormat.includes(a.UASTC_HDR)).sort((e, t) => e.priorityHDR - t.priorityHDR)
        };
    function c(e) {
        return e <= 2 || !(e & e - 1) && 0 !== e
    }
    function u(e) {
        if (1 === e.length)
            return e[0];
        let t = 0;
        for (let o = 0; o < e.length; o++)
            t += e[o].byteLength;
        const n = new Uint8Array(t);
        let r = 0;
        for (let o = 0; o < e.length; o++) {
            const t = e[o];
            n.set(t, r),
            r += t.byteLength
        }
        return n
    }
};
const ry = new Set([$a, Ha, Ya, qa]),
    oy = {
        [AA]: $a,
        [bA]: Ya,
        [mA]: qa,
        [gA]: $a,
        [fA]: Ya,
        [hA]: qa,
        [pA]: $a,
        [dA]: $a,
        [uA]: Ya,
        [cA]: Ya,
        [lA]: qa,
        [sA]: qa,
        [vA]: Ha,
        [yA]: Ha,
        [PA]: us,
        [DA]: cs,
        [jA]: ds,
        [LA]: ds,
        [OA]: ds,
        [VA]: gs,
        [FA]: gs,
        [NA]: gs,
        [CA]: ts,
        [wA]: ts,
        [xA]: es,
        [_A]: es,
        [SA]: ns,
        [EA]: ns,
        [TA]: Ms,
        [IA]: Ts,
        [RA]: Bs,
        [MA]: Rs,
        [kA]: Es,
        [BA]: Es,
        [GA]: as,
        [zA]: as,
        [QA]: ss,
        [UA]: ss
    },
    iy = {
        [AA]: Na,
        [bA]: Na,
        [mA]: Na,
        [gA]: Fa,
        [fA]: Fa,
        [hA]: Fa,
        [pA]: Da,
        [dA]: Da,
        [uA]: Da,
        [cA]: Da,
        [lA]: Da,
        [sA]: Da,
        [vA]: Ga,
        [yA]: ja,
        [PA]: Da,
        [DA]: Da,
        [jA]: Fa,
        [LA]: Da,
        [OA]: Da,
        [VA]: Fa,
        [FA]: Da,
        [NA]: Da,
        [CA]: Da,
        [wA]: Da,
        [xA]: Da,
        [_A]: Da,
        [SA]: Da,
        [EA]: Da,
        [TA]: Da,
        [IA]: Da,
        [RA]: Da,
        [MA]: Da,
        [kA]: Da,
        [BA]: Da,
        [GA]: Da,
        [zA]: Da,
        [QA]: Da,
        [UA]: Da
    };
function ay(e) {
    const t = e.dataFormatDescriptor[0];
    return 1 === t.colorPrimaries ? 2 === t.transferFunction ? Ls : Ns : 10 === t.colorPrimaries ? 2 === t.transferFunction ? "display-p3" : "display-p3-linear" : (t.colorPrimaries, Os)
}
class sy extends qp {
    constructor(e)
    {
        super(e),
        this.type = Fa
    }
    parse(e)
    {
        const t = function(e, t) {
                switch (e) {
                case 1:
                    throw new Error("THREE.HDRLoader: Read Error: " + (t || ""));
                case 2:
                    throw new Error("THREE.HDRLoader: Write Error: " + (t || ""));
                case 3:
                    throw new Error("THREE.HDRLoader: Bad File Format: " + (t || ""));
                default:
                    throw new Error("THREE.HDRLoader: Memory Error: " + (t || ""))
                }
            },
            n = function(e, t, n) {
                t = t || 1024;
                let r = e.pos,
                    o = -1,
                    i = 0,
                    a = "",
                    s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                for (; 0 > (o = s.indexOf("\n")) && i < t && r < e.byteLength;)
                    a += s,
                    i += s.length,
                    r += 128,
                    s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                return -1 < o && (e.pos += i + o + 1, a + s.slice(0, o))
            },
            r = function(e, t, n, r) {
                const o = e[t + 3],
                    i = Math.pow(2, o - 128) / 255;
                n[r + 0] = e[t + 0] * i,
                n[r + 1] = e[t + 1] * i,
                n[r + 2] = e[t + 2] * i,
                n[r + 3] = 1
            },
            o = function(e, t, n, r) {
                const o = e[t + 3],
                    i = Math.pow(2, o - 128) / 255;
                n[r + 0] = fu.toHalfFloat(Math.min(e[t + 0] * i, 65504)),
                n[r + 1] = fu.toHalfFloat(Math.min(e[t + 1] * i, 65504)),
                n[r + 2] = fu.toHalfFloat(Math.min(e[t + 2] * i, 65504)),
                n[r + 3] = fu.toHalfFloat(1)
            },
            i = new Uint8Array(e);
        i.pos = 0;
        const a = function(e) {
                const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    o = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    i = /^\s*FORMAT=(\S+)\s*$/,
                    a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    s = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                let l,
                    c;
                for ((e.pos >= e.byteLength || !(l = n(e))) && t(1, "no header found"), (c = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"), s.valid |= 1, s.programtype = c[1], s.string += l + "\n"; l = n(e), !1 !== l;)
                    if (s.string += l + "\n", "#" !== l.charAt(0)) {
                        if ((c = l.match(r)) && (s.gamma = parseFloat(c[1])), (c = l.match(o)) && (s.exposure = parseFloat(c[1])), (c = l.match(i)) && (s.valid |= 2, s.format = c[1]), (c = l.match(a)) && (s.valid |= 4, s.height = parseInt(c[1], 10), s.width = parseInt(c[2], 10)), 2 & s.valid && 4 & s.valid)
                            break
                    } else
                        s.comments += l + "\n";
                return 2 & s.valid || t(3, "missing format specifier"), 4 & s.valid || t(3, "missing image size specifier"), s
            }(i),
            s = a.width,
            l = a.height,
            c = function(e, n, r) {
                const o = n;
                if (o < 8 || o > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
                    return new Uint8Array(e);
                o !== (e[2] << 8 | e[3]) && t(3, "wrong scanline width");
                const i = new Uint8Array(4 * n * r);
                i.length || t(4, "unable to allocate buffer space");
                let a = 0,
                    s = 0;
                const l = 4 * o,
                    c = new Uint8Array(4),
                    u = new Uint8Array(l);
                let d = r;
                for (; d > 0 && s < e.byteLength;) {
                    s + 4 > e.byteLength && t(1),
                    c[0] = e[s++],
                    c[1] = e[s++],
                    c[2] = e[s++],
                    c[3] = e[s++],
                    2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == o || t(3, "bad rgbe scanline format");
                    let n,
                        r = 0;
                    for (; r < l && s < e.byteLength;) {
                        n = e[s++];
                        const o = n > 128;
                        if (o && (n -= 128), (0 === n || r + n > l) && t(3, "bad scanline data"), o) {
                            const t = e[s++];
                            for (let e = 0; e < n; e++)
                                u[r++] = t
                        } else
                            u.set(e.subarray(s, s + n), r),
                            r += n,
                            s += n
                    }
                    const p = o;
                    for (let e = 0; e < p; e++) {
                        let t = 0;
                        i[a] = u[e + t],
                        t += o,
                        i[a + 1] = u[e + t],
                        t += o,
                        i[a + 2] = u[e + t],
                        t += o,
                        i[a + 3] = u[e + t],
                        a += 4
                    }
                    d--
                }
                return i
            }(i.subarray(i.pos), s, l);
        let u,
            d,
            p;
        switch (this.type) {
        case Na:
            p = c.length / 4;
            const e = new Float32Array(4 * p);
            for (let n = 0; n < p; n++)
                r(c, 4 * n, e, 4 * n);
            u = e,
            d = Na;
            break;
        case Fa:
            p = c.length / 4;
            const t = new Uint16Array(4 * p);
            for (let n = 0; n < p; n++)
                o(c, 4 * n, t, 4 * n);
            u = t,
            d = Fa;
            break;
        default:
            throw new Error("THREE.HDRLoader: Unsupported type: " + this.type)
        }
        return {
            width: s,
            height: l,
            data: u,
            header: a.string,
            gamma: a.gamma,
            exposure: a.exposure,
            type: d
        }
    }
    setDataType(e)
    {
        return this.type = e, this
    }
    load(e, t, n, r)
    {
        return super.load(e, function(e, n) {
            switch (e.type) {
            case Na:
            case Fa:
                e.colorSpace = Ns,
                e.minFilter = Ra,
                e.magFilter = Ra,
                e.generateMipmaps = !1,
                e.flipY = !0
            }
            t && t(e, n)
        }, n, r)
    }
}
let ly,
    cy,
    uy,
    dy;
const py = Object.freeze(Object.defineProperty({
    __proto__: null,
    decompress: function(e, t=1 / 0, n=null) {
        cy || (cy = new mp(2, 2, 1, 1)),
        uy || (uy = new Ku({
            uniforms: {
                blitTexture: new Eh(e)
            },
            vertexShader: "\n\t\t\tvarying vec2 vUv;\n\t\t\tvoid main(){\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = vec4(position.xy * 1.0,0.,.999999);\n\t\t\t}",
            fragmentShader: "\n\t\t\tuniform sampler2D blitTexture; \n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main(){ \n\t\t\t\tgl_FragColor = vec4(vUv.xy, 0, 1);\n\t\t\t\t\n\t\t\t\t#ifdef IS_SRGB\n\t\t\t\tgl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );\n\t\t\t\t#else\n\t\t\t\tgl_FragColor = texture2D( blitTexture, vUv);\n\t\t\t\t#endif\n\t\t\t}"
        })),
        uy.uniforms.blitTexture.value = e,
        uy.defines.IS_SRGB = e.colorSpace == Ls,
        uy.needsUpdate = !0,
        dy || (dy = new Qu(cy, uy), dy.frustumCulled = !1);
        const r = new Zu,
            o = new sd;
        o.add(dy),
        null === n && (n = ly = new cm({
            antialias: !1
        }));
        const i = Math.min(e.image.width, t),
            a = Math.min(e.image.height, t);
        n.setSize(i, a),
        n.clear(),
        n.render(o, r);
        const s = document.createElement("canvas"),
            l = s.getContext("2d");
        s.width = i,
        s.height = a,
        l.drawImage(n.domElement, 0, 0, i, a);
        const c = new hp(s);
        return c.minFilter = e.minFilter, c.magFilter = e.magFilter, c.wrapS = e.wrapS, c.wrapT = e.wrapT, c.colorSpace = e.colorSpace, c.name = e.name, ly && (ly.forceContextLoss(), ly.dispose(), ly = null), c
    }
}, Symbol.toStringTag, {
    value: "Module"
}));
var hy = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function fy(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function gy(e) {
    if (Object.prototype.hasOwnProperty.call(e, "__esModule"))
        return e;
    var t = e.default;
    if ("function" == typeof t) {
        var n = function e() {
            var n = !1;
            try {
                n = this instanceof e
            } catch {}
            return n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(t) {
        var r = Object.getOwnPropertyDescriptor(e, t);
        Object.defineProperty(n, t, r.get ? r : {
            enumerable: !0,
            get: function() {
                return e[t]
            }
        })
    }), n
}
var my = {
    exports: {}
};
const by = gy(Object.freeze(Object.defineProperty({
    __proto__: null,
    default: {}
}, Symbol.toStringTag, {
    value: "Module"
})));
var Ay,
    yy = my.exports;
var vy,
    _y,
    xy,
    wy = {
        exports: {}
    },
    Cy = wy.exports;
const Ey = fy(function() {
    if (xy)
        return _y;
    xy = 1;
    var e = (Ay || (Ay = 1, function(e) {
            var t = t || {};
            t.scope = {},
            t.arrayIteratorImpl = function(e) {
                var t = 0;
                return function() {
                    return t < e.length ? {
                        done: !1,
                        value: e[t++]
                    } : {
                        done: !0
                    }
                }
            },
            t.arrayIterator = function(e) {
                return {
                    next: t.arrayIteratorImpl(e)
                }
            },
            t.makeIterator = function(e) {
                var n = "undefined" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];
                return n ? n.call(e) : t.arrayIterator(e)
            },
            t.ASSUME_ES5 = !1,
            t.ASSUME_NO_NATIVE_MAP = !1,
            t.ASSUME_NO_NATIVE_SET = !1,
            t.SIMPLE_FROUND_POLYFILL = !1,
            t.ISOLATE_POLYFILLS = !1,
            t.FORCE_POLYFILL_PROMISE = !1,
            t.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1,
            t.getGlobal = function(e) {
                e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof hy && hy];
                for (var t = 0; t < e.length; ++t) {
                    var n = e[t];
                    if (n && n.Math == Math)
                        return n
                }
                throw Error("Cannot find global object")
            },
            t.global = t.getGlobal(yy),
            t.defineProperty = t.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(e, t, n) {
                return e == Array.prototype || e == Object.prototype || (e[t] = n.value), e
            },
            t.IS_SYMBOL_NATIVE = "function" == typeof Symbol && "symbol" == typeof Symbol("x"),
            t.TRUST_ES6_POLYFILLS = !t.ISOLATE_POLYFILLS || t.IS_SYMBOL_NATIVE,
            t.polyfills = {},
            t.propertyToPolyfillSymbol = {},
            t.POLYFILL_PREFIX = "$jscp$",
            t.polyfill = function(e, n, r, o) {
                n && (t.ISOLATE_POLYFILLS ? t.polyfillIsolated(e, n, r, o) : t.polyfillUnisolated(e, n, r, o))
            },
            t.polyfillUnisolated = function(e, n, r, o) {
                for (r = t.global, e = e.split("."), o = 0; o < e.length - 1; o++) {
                    var i = e[o];
                    if (!(i in r))
                        return;
                    r = r[i]
                }
                (n = n(o = r[e = e[e.length - 1]])) != o && null != n && t.defineProperty(r, e, {
                    configurable: !0,
                    writable: !0,
                    value: n
                })
            },
            t.polyfillIsolated = function(e, n, r, o) {
                var i = e.split(".");
                e = 1 === i.length,
                o = i[0],
                o = !e && o in t.polyfills ? t.polyfills : t.global;
                for (var a = 0; a < i.length - 1; a++) {
                    var s = i[a];
                    if (!(s in o))
                        return;
                    o = o[s]
                }
                i = i[i.length - 1],
                null != (n = n(r = t.IS_SYMBOL_NATIVE && "es6" === r ? o[i] : null)) && (e ? t.defineProperty(t.polyfills, i, {
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : n !== r && (void 0 === t.propertyToPolyfillSymbol[i] && (r = 1e9 * Math.random() >>> 0, t.propertyToPolyfillSymbol[i] = t.IS_SYMBOL_NATIVE ? t.global.Symbol(i) : t.POLYFILL_PREFIX + r + "$" + i), t.defineProperty(o, t.propertyToPolyfillSymbol[i], {
                    configurable: !0,
                    writable: !0,
                    value: n
                })))
            },
            t.polyfill("Promise", function(e) {
                function n() {
                    this.batch_ = null
                }
                function r(e) {
                    return e instanceof i ? e : new i(function(t, n) {
                        t(e)
                    })
                }
                if (e && (!(t.FORCE_POLYFILL_PROMISE || t.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && void 0 === t.global.PromiseRejectionEvent) || !t.global.Promise || -1 === t.global.Promise.toString().indexOf("[native code]")))
                    return e;
                n.prototype.asyncExecute = function(e) {
                    if (null == this.batch_) {
                        this.batch_ = [];
                        var t = this;
                        this.asyncExecuteFunction(function() {
                            t.executeBatch_()
                        })
                    }
                    this.batch_.push(e)
                };
                var o = t.global.setTimeout;
                n.prototype.asyncExecuteFunction = function(e) {
                    o(e, 0)
                },
                n.prototype.executeBatch_ = function() {
                    for (; this.batch_ && this.batch_.length;) {
                        var e = this.batch_;
                        this.batch_ = [];
                        for (var t = 0; t < e.length; ++t) {
                            var n = e[t];
                            e[t] = null;
                            try {
                                n()
                            } catch (r) {
                                this.asyncThrow_(r)
                            }
                        }
                    }
                    this.batch_ = null
                },
                n.prototype.asyncThrow_ = function(e) {
                    this.asyncExecuteFunction(function() {
                        throw e
                    })
                };
                var i = function(e) {
                    this.state_ = 0,
                    this.result_ = void 0,
                    this.onSettledCallbacks_ = [],
                    this.isRejectionHandled_ = !1;
                    var t = this.createResolveAndReject_();
                    try {
                        e(t.resolve, t.reject)
                    } catch (n) {
                        t.reject(n)
                    }
                };
                i.prototype.createResolveAndReject_ = function() {
                    function e(e) {
                        return function(r) {
                            n || (n = !0, e.call(t, r))
                        }
                    }
                    var t = this,
                        n = !1;
                    return {
                        resolve: e(this.resolveTo_),
                        reject: e(this.reject_)
                    }
                },
                i.prototype.resolveTo_ = function(e) {
                    if (e === this)
                        this.reject_(new TypeError("A Promise cannot resolve to itself"));
                    else if (e instanceof i)
                        this.settleSameAsPromise_(e);
                    else {
                        e:
                        switch (typeof e) {
                        case "object":
                            var t = null != e;
                            break e;
                        case "function":
                            t = !0;
                            break e;
                        default:
                            t = !1
                        }
                        t ? this.resolveToNonPromiseObj_(e) : this.fulfill_(e)
                    }
                },
                i.prototype.resolveToNonPromiseObj_ = function(e) {
                    var t = void 0;
                    try {
                        t = e.then
                    } catch (n) {
                        return void this.reject_(n)
                    }
                    "function" == typeof t ? this.settleSameAsThenable_(t, e) : this.fulfill_(e)
                },
                i.prototype.reject_ = function(e) {
                    this.settle_(2, e)
                },
                i.prototype.fulfill_ = function(e) {
                    this.settle_(1, e)
                },
                i.prototype.settle_ = function(e, t) {
                    if (0 != this.state_)
                        throw Error("Cannot settle(" + e + ", " + t + "): Promise already settled in state" + this.state_);
                    this.state_ = e,
                    this.result_ = t,
                    2 === this.state_ && this.scheduleUnhandledRejectionCheck_(),
                    this.executeOnSettledCallbacks_()
                },
                i.prototype.scheduleUnhandledRejectionCheck_ = function() {
                    var e = this;
                    o(function() {
                        if (e.notifyUnhandledRejection_()) {
                            var n = t.global.console;
                            void 0 !== n && n.error(e.result_)
                        }
                    }, 1)
                },
                i.prototype.notifyUnhandledRejection_ = function() {
                    if (this.isRejectionHandled_)
                        return !1;
                    var e = t.global.CustomEvent,
                        n = t.global.Event,
                        r = t.global.dispatchEvent;
                    return void 0 === r || ("function" == typeof e ? e = new e("unhandledrejection", {
                            cancelable: !0
                        }) : "function" == typeof n ? e = new n("unhandledrejection", {
                            cancelable: !0
                        }) : (e = t.global.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", !1, !0, e), e.promise = this, e.reason = this.result_, r(e))
                },
                i.prototype.executeOnSettledCallbacks_ = function() {
                    if (null != this.onSettledCallbacks_) {
                        for (var e = 0; e < this.onSettledCallbacks_.length; ++e)
                            a.asyncExecute(this.onSettledCallbacks_[e]);
                        this.onSettledCallbacks_ = null
                    }
                };
                var a = new n;
                return i.prototype.settleSameAsPromise_ = function(e) {
                    var t = this.createResolveAndReject_();
                    e.callWhenSettled_(t.resolve, t.reject)
                }, i.prototype.settleSameAsThenable_ = function(e, t) {
                    var n = this.createResolveAndReject_();
                    try {
                        e.call(t, n.resolve, n.reject)
                    } catch (r) {
                        n.reject(r)
                    }
                }, i.prototype.then = function(e, t) {
                    function n(e, t) {
                        return "function" == typeof e ? function(t) {
                            try {
                                r(e(t))
                            } catch (n) {
                                o(n)
                            }
                        } : t
                    }
                    var r,
                        o,
                        a = new i(function(e, t) {
                            r = e,
                            o = t
                        });
                    return this.callWhenSettled_(n(e, r), n(t, o)), a
                }, i.prototype.catch = function(e) {
                    return this.then(void 0, e)
                }, i.prototype.callWhenSettled_ = function(e, t) {
                    function n() {
                        switch (r.state_) {
                        case 1:
                            e(r.result_);
                            break;
                        case 2:
                            t(r.result_);
                            break;
                        default:
                            throw Error("Unexpected state: " + r.state_)
                        }
                    }
                    var r = this;
                    null == this.onSettledCallbacks_ ? a.asyncExecute(n) : this.onSettledCallbacks_.push(n),
                    this.isRejectionHandled_ = !0
                }, i.resolve = r, i.reject = function(e) {
                    return new i(function(t, n) {
                        n(e)
                    })
                }, i.race = function(e) {
                    return new i(function(n, o) {
                        for (var i = t.makeIterator(e), a = i.next(); !a.done; a = i.next())
                            r(a.value).callWhenSettled_(n, o)
                    })
                }, i.all = function(e) {
                    var n = t.makeIterator(e),
                        o = n.next();
                    return o.done ? r([]) : new i(function(e, t) {
                        function i(t) {
                            return function(n) {
                                a[t] = n,
                                0 == --s && e(a)
                            }
                        }
                        var a = [],
                            s = 0;
                        do {
                            a.push(void 0),
                            s++,
                            r(o.value).callWhenSettled_(i(a.length - 1), t),
                            o = n.next()
                        } while (!o.done)
                    })
                }, i
            }, "es6", "es3"),
            t.owns = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            },
            t.assign = t.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign ? Object.assign : function(e, n) {
                for (var r = 1; r < arguments.length; r++) {
                    var o = arguments[r];
                    if (o)
                        for (var i in o)
                            t.owns(o, i) && (e[i] = o[i])
                }
                return e
            },
            t.polyfill("Object.assign", function(e) {
                return e || t.assign
            }, "es6", "es3"),
            t.checkStringArgs = function(e, t, n) {
                if (null == e)
                    throw new TypeError("The 'this' value for String.prototype." + n + " must not be null or undefined");
                if (t instanceof RegExp)
                    throw new TypeError("First argument to String.prototype." + n + " must not be a regular expression");
                return e + ""
            },
            t.polyfill("String.prototype.startsWith", function(e) {
                return e || function(e, n) {
                        var r = t.checkStringArgs(this, e, "startsWith");
                        e += "";
                        var o = r.length,
                            i = e.length;
                        n = Math.max(0, Math.min(0 | n, r.length));
                        for (var a = 0; a < i && n < o;)
                            if (r[n++] != e[a++])
                                return !1;
                        return a >= i
                    }
            }, "es6", "es3"),
            t.polyfill("Array.prototype.copyWithin", function(e) {
                function t(e) {
                    return 1 / 0 === (e = Number(e)) || -1 / 0 === e ? e : 0 | e
                }
                return e || function(e, n, r) {
                        var o = this.length;
                        if (e = t(e), n = t(n), r = void 0 === r ? o : t(r), e = 0 > e ? Math.max(o + e, 0) : Math.min(e, o), n = 0 > n ? Math.max(o + n, 0) : Math.min(n, o), r = 0 > r ? Math.max(o + r, 0) : Math.min(r, o), e < n)
                            for (; n < r;)
                                n in this ? this[e++] = this[n++] : (delete this[e++], n++);
                        else
                            for (e += (r = Math.min(r, o + n - e)) - n; r > n;)
                                --r in this ? this[--e] = this[r] : delete this[--e];
                        return this
                    }
            }, "es6", "es3"),
            t.typedArrayCopyWithin = function(e) {
                return e || Array.prototype.copyWithin
            },
            t.polyfill("Int8Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint8Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint8ClampedArray.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Int16Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint16Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Int32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Float32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Float64Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5");
            var n,
                r = (n = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (n = n || __filename), function(e) {
                    function t() {
                        var e = H.buffer;
                        R.HEAP8 = $ = new Int8Array(e),
                        R.HEAP16 = K = new Int16Array(e),
                        R.HEAP32 = q = new Int32Array(e),
                        R.HEAPU8 = W = new Uint8Array(e),
                        R.HEAPU16 = new Uint16Array(e),
                        R.HEAPU32 = X = new Uint32Array(e),
                        R.HEAPF32 = Y = new Float32Array(e),
                        R.HEAPF64 = new Float64Array(e)
                    }
                    function r(e) {
                        throw R.onAbort && R.onAbort(e), V(e = "Aborted(" + e + ")"), Z = !0, e = new WebAssembly.RuntimeError(e + ". Build with -sASSERTIONS for more info."), M(e), e
                    }
                    function o(e) {
                        try {
                            if (e == ae && j)
                                return new Uint8Array(j);
                            if (Q)
                                return Q(e);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (t) {
                            r(t)
                        }
                    }
                    function i(e) {
                        for (; 0 < e.length;)
                            e.shift()(R)
                    }
                    function a(e) {
                        this.excPtr = e,
                        this.ptr = e - 24,
                        this.set_type = function(e) {
                            X[this.ptr + 4 >> 2] = e
                        },
                        this.get_type = function() {
                            return X[this.ptr + 4 >> 2]
                        },
                        this.set_destructor = function(e) {
                            X[this.ptr + 8 >> 2] = e
                        },
                        this.get_destructor = function() {
                            return X[this.ptr + 8 >> 2]
                        },
                        this.set_refcount = function(e) {
                            q[this.ptr >> 2] = e
                        },
                        this.set_caught = function(e) {
                            $[this.ptr + 12 | 0] = e ? 1 : 0
                        },
                        this.get_caught = function() {
                            return 0 != $[this.ptr + 12 | 0]
                        },
                        this.set_rethrown = function(e) {
                            $[this.ptr + 13 | 0] = e ? 1 : 0
                        },
                        this.get_rethrown = function() {
                            return 0 != $[this.ptr + 13 | 0]
                        },
                        this.init = function(e, t) {
                            this.set_adjusted_ptr(0),
                            this.set_type(e),
                            this.set_destructor(t),
                            this.set_refcount(0),
                            this.set_caught(!1),
                            this.set_rethrown(!1)
                        },
                        this.add_ref = function() {
                            q[this.ptr >> 2] += 1
                        },
                        this.release_ref = function() {
                            var e = q[this.ptr >> 2];
                            return q[this.ptr >> 2] = e - 1, 1 === e
                        },
                        this.set_adjusted_ptr = function(e) {
                            X[this.ptr + 16 >> 2] = e
                        },
                        this.get_adjusted_ptr = function() {
                            return X[this.ptr + 16 >> 2]
                        },
                        this.get_exception_ptr = function() {
                            if (Xt(this.get_type()))
                                return X[this.excPtr >> 2];
                            var e = this.get_adjusted_ptr();
                            return 0 !== e ? e : this.excPtr
                        }
                    }
                    function s() {
                        function e() {
                            if (!qt && (qt = !0, R.calledRun = !0, !Z)) {
                                if (re = !0, i(te), T(R), R.onRuntimeInitialized && R.onRuntimeInitialized(), R.postRun)
                                    for ("function" == typeof R.postRun && (R.postRun = [R.postRun]); R.postRun.length;)
                                        ne.unshift(R.postRun.shift());
                                i(ne)
                            }
                        }
                        if (!(0 < oe)) {
                            if (R.preRun)
                                for ("function" == typeof R.preRun && (R.preRun = [R.preRun]); R.preRun.length;)
                                    ee.unshift(R.preRun.shift());
                            i(ee),
                            0 < oe || (R.setStatus ? (R.setStatus("Running..."), setTimeout(function() {
                                setTimeout(function() {
                                    R.setStatus("")
                                }, 1),
                                e()
                            }, 1)) : e())
                        }
                    }
                    function l() {}
                    function c(e) {
                        return (e || l).__cache__
                    }
                    function u(e, t) {
                        var n = c(t),
                            r = n[e];
                        return r || ((r = Object.create((t || l).prototype)).ptr = e, n[e] = r)
                    }
                    function d(e) {
                        if ("string" == typeof e) {
                            for (var t = 0, n = 0; n < e.length; ++n) {
                                var r = e.charCodeAt(n);
                                127 >= r ? t++ : 2047 >= r ? t += 2 : 55296 <= r && 57343 >= r ? (t += 4, ++n) : t += 3
                            }
                            if (n = 0, 0 < (r = (t = Array(t + 1)).length)) {
                                r = n + r - 1;
                                for (var o = 0; o < e.length; ++o) {
                                    var i = e.charCodeAt(o);
                                    if (55296 <= i && 57343 >= i && (i = 65536 + ((1023 & i) << 10) | 1023 & e.charCodeAt(++o)), 127 >= i) {
                                        if (n >= r)
                                            break;
                                        t[n++] = i
                                    } else {
                                        if (2047 >= i) {
                                            if (n + 1 >= r)
                                                break;
                                            t[n++] = 192 | i >> 6
                                        } else {
                                            if (65535 >= i) {
                                                if (n + 2 >= r)
                                                    break;
                                                t[n++] = 224 | i >> 12
                                            } else {
                                                if (n + 3 >= r)
                                                    break;
                                                t[n++] = 240 | i >> 18,
                                                t[n++] = 128 | i >> 12 & 63
                                            }
                                            t[n++] = 128 | i >> 6 & 63
                                        }
                                        t[n++] = 128 | 63 & i
                                    }
                                }
                                t[n] = 0
                            }
                            return e = Yt.alloc(t, $), Yt.copy(t, $, e), e
                        }
                        return e
                    }
                    function p(e) {
                        if ("object" == typeof e) {
                            var t = Yt.alloc(e, $);
                            return Yt.copy(e, $, t), t
                        }
                        return e
                    }
                    function h(e) {
                        if ("object" == typeof e) {
                            var t = Yt.alloc(e, K);
                            return Yt.copy(e, K, t), t
                        }
                        return e
                    }
                    function f(e) {
                        if ("object" == typeof e) {
                            var t = Yt.alloc(e, q);
                            return Yt.copy(e, q, t), t
                        }
                        return e
                    }
                    function g(e) {
                        if ("object" == typeof e) {
                            var t = Yt.alloc(e, Y);
                            return Yt.copy(e, Y, t), t
                        }
                        return e
                    }
                    function m() {
                        throw "cannot construct a VoidPtr, no constructor in IDL"
                    }
                    function b() {
                        this.ptr = ce(),
                        c(b)[this.ptr] = this
                    }
                    function A() {
                        this.ptr = de(),
                        c(A)[this.ptr] = this
                    }
                    function y() {
                        this.ptr = _e(),
                        c(y)[this.ptr] = this
                    }
                    function v() {
                        this.ptr = Ee(),
                        c(v)[this.ptr] = this
                    }
                    function _() {
                        this.ptr = Be(),
                        c(_)[this.ptr] = this
                    }
                    function x() {
                        this.ptr = De(),
                        c(x)[this.ptr] = this
                    }
                    function w() {
                        this.ptr = Ne(),
                        c(w)[this.ptr] = this
                    }
                    function C() {
                        this.ptr = je(),
                        c(C)[this.ptr] = this
                    }
                    function E() {
                        this.ptr = tt(),
                        c(E)[this.ptr] = this
                    }
                    function S() {
                        this.ptr = bt(),
                        c(S)[this.ptr] = this
                    }
                    function I(e) {
                        e && "object" == typeof e && (e = e.ptr),
                        this.ptr = Tt(e),
                        c(I)[this.ptr] = this
                    }
                    var T,
                        M,
                        R = void 0 !== (e = void 0 === e ? {} : e) ? e : {};
                    R.ready = new Promise(function(e, t) {
                        T = e,
                        M = t
                    });
                    var B = !1,
                        k = !1;
                    R.onRuntimeInitialized = function() {
                        B = !0,
                        k && "function" == typeof R.onModuleLoaded && R.onModuleLoaded(R)
                    },
                    R.onModuleParsed = function() {
                        k = !0,
                        B && "function" == typeof R.onModuleLoaded && R.onModuleLoaded(R)
                    },
                    R.isVersionSupported = function(e) {
                        return "string" == typeof e && !(2 > (e = e.split(".")).length || 3 < e.length) && (1 == e[0] && 0 <= e[1] && 5 >= e[1] || !(0 != e[0] || 10 < e[1]))
                    };
                    var D = Object.assign({}, R),
                        P = "object" == typeof window,
                        O = "function" == typeof importScripts,
                        L = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node,
                        N = "";
                    if (L) {
                        var F = by,
                            U = by;
                        N = O ? U.dirname(N) + "/" : __dirname + "/";
                        var z = function(e, t) {
                                return e = e.startsWith("file://") ? new URL(e) : U.normalize(e), F.readFileSync(e, t ? void 0 : "utf8")
                            },
                            Q = function(e) {
                                return (e = z(e, !0)).buffer || (e = new Uint8Array(e)), e
                            },
                            G = function(e, t, n) {
                                e = e.startsWith("file://") ? new URL(e) : U.normalize(e),
                                F.readFile(e, function(e, r) {
                                    e ? n(e) : t(r.buffer)
                                })
                            };
                        1 < process.argv.length && process.argv[1].replace(/\\/g, "/"),
                        process.argv.slice(2),
                        R.inspect = function() {
                            return "[Emscripten Module object]"
                        }
                    } else
                        (P || O) && (O ? N = self.location.href : "undefined" != typeof document && document.currentScript && (N = document.currentScript.src), n && (N = n), N = 0 !== N.indexOf("blob:") ? N.substr(0, N.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", z = function(e) {
                            var t = new XMLHttpRequest;
                            return t.open("GET", e, !1), t.send(null), t.responseText
                        }, O && (Q = function(e) {
                            var t = new XMLHttpRequest;
                            return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response)
                        }), G = function(e, t, n) {
                            var r = new XMLHttpRequest;
                            r.open("GET", e, !0),
                            r.responseType = "arraybuffer",
                            r.onload = function() {
                                200 == r.status || 0 == r.status && r.response ? t(r.response) : n()
                            },
                            r.onerror = n,
                            r.send(null)
                        });
                    R.print || function() {}.bind();
                    var j,
                        V = R.printErr || function() {}.bind();
                    Object.assign(R, D),
                    D = null,
                    R.wasmBinary && (j = R.wasmBinary),
                    "object" != typeof WebAssembly && r("no native wasm support detected");
                    var H,
                        $,
                        W,
                        K,
                        q,
                        X,
                        Y,
                        J,
                        Z = !1,
                        ee = [],
                        te = [],
                        ne = [],
                        re = !1,
                        oe = 0,
                        ie = null,
                        ae = "draco_encoder.wasm";
                    ae.startsWith("data:application/octet-stream;base64,") || (J = ae, ae = R.locateFile ? R.locateFile(J, N) : N + J);
                    var se = {
                        b: function(e, t, n) {
                            throw new a(e).init(t, n), e
                        },
                        a: function() {
                            r("")
                        },
                        d: function(e, t, n) {
                            W.copyWithin(e, t, t + n)
                        },
                        c: function(e) {
                            var n = W.length;
                            if (2147483648 < (e >>>= 0))
                                return !1;
                            for (var r = 1; 4 >= r; r *= 2) {
                                var o = n * (1 + .2 / r);
                                o = Math.min(o, e + 100663296);
                                var i = Math;
                                o = Math.max(e, o),
                                i = i.min.call(i, 2147483648, o + (65536 - o % 65536) % 65536);
                                e:
                                {
                                    o = H.buffer;
                                    try {
                                        H.grow(i - o.byteLength + 65535 >>> 16),
                                        t();
                                        var a = 1;
                                        break e
                                    } catch (s) {}
                                    a = void 0
                                }if (a)
                                    return !0
                            }
                            return !1
                        }
                    };
                    !function() {
                        function e(e, n) {
                            R.asm = e.exports,
                            H = R.asm.e,
                            t(),
                            te.unshift(R.asm.f),
                            oe--,
                            R.monitorRunDependencies && R.monitorRunDependencies(oe),
                            0 == oe && ie && (e = ie, ie = null, e())
                        }
                        function n(t) {
                            e(t.instance)
                        }
                        function i(e) {
                            return function() {
                                if (!j && (P || O)) {
                                    if ("function" == typeof fetch && !ae.startsWith("file://"))
                                        return fetch(ae, {
                                            credentials: "same-origin"
                                        }).then(function(e) {
                                            if (!e.ok)
                                                throw "failed to load wasm binary file at '" + ae + "'";
                                            return e.arrayBuffer()
                                        }).catch(function() {
                                            return o(ae)
                                        });
                                    if (G)
                                        return new Promise(function(e, t) {
                                            G(ae, function(t) {
                                                e(new Uint8Array(t))
                                            }, t)
                                        })
                                }
                                return Promise.resolve().then(function() {
                                    return o(ae)
                                })
                            }().then(function(e) {
                                return WebAssembly.instantiate(e, a)
                            }).then(function(e) {
                                return e
                            }).then(e, function(e) {
                                V("failed to asynchronously prepare wasm: " + e),
                                r(e)
                            })
                        }
                        var a = {
                            a: se
                        };
                        if (oe++, R.monitorRunDependencies && R.monitorRunDependencies(oe), R.instantiateWasm)
                            try {
                                return R.instantiateWasm(a, e)
                            } catch (gL) {
                                V("Module.instantiateWasm callback failed with error: " + gL),
                                M(gL)
                            }
                        (j || "function" != typeof WebAssembly.instantiateStreaming || ae.startsWith("data:application/octet-stream;base64,") || ae.startsWith("file://") || L || "function" != typeof fetch ? i(n) : fetch(ae, {
                            credentials: "same-origin"
                        }).then(function(e) {
                            return WebAssembly.instantiateStreaming(e, a).then(n, function(e) {
                                return V("wasm streaming compile failed: " + e), V("falling back to ArrayBuffer instantiation"), i(n)
                            })
                        })).catch(M)
                    }();
                    var le = R._emscripten_bind_VoidPtr___destroy___0 = function() {
                            return (le = R._emscripten_bind_VoidPtr___destroy___0 = R.asm.h).apply(null, arguments)
                        },
                        ce = R._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
                            return (ce = R._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = R.asm.i).apply(null, arguments)
                        },
                        ue = R._emscripten_bind_GeometryAttribute___destroy___0 = function() {
                            return (ue = R._emscripten_bind_GeometryAttribute___destroy___0 = R.asm.j).apply(null, arguments)
                        },
                        de = R._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
                            return (de = R._emscripten_bind_PointAttribute_PointAttribute_0 = R.asm.k).apply(null, arguments)
                        },
                        pe = R._emscripten_bind_PointAttribute_size_0 = function() {
                            return (pe = R._emscripten_bind_PointAttribute_size_0 = R.asm.l).apply(null, arguments)
                        },
                        he = R._emscripten_bind_PointAttribute_attribute_type_0 = function() {
                            return (he = R._emscripten_bind_PointAttribute_attribute_type_0 = R.asm.m).apply(null, arguments)
                        },
                        fe = R._emscripten_bind_PointAttribute_data_type_0 = function() {
                            return (fe = R._emscripten_bind_PointAttribute_data_type_0 = R.asm.n).apply(null, arguments)
                        },
                        ge = R._emscripten_bind_PointAttribute_num_components_0 = function() {
                            return (ge = R._emscripten_bind_PointAttribute_num_components_0 = R.asm.o).apply(null, arguments)
                        },
                        me = R._emscripten_bind_PointAttribute_normalized_0 = function() {
                            return (me = R._emscripten_bind_PointAttribute_normalized_0 = R.asm.p).apply(null, arguments)
                        },
                        be = R._emscripten_bind_PointAttribute_byte_stride_0 = function() {
                            return (be = R._emscripten_bind_PointAttribute_byte_stride_0 = R.asm.q).apply(null, arguments)
                        },
                        Ae = R._emscripten_bind_PointAttribute_byte_offset_0 = function() {
                            return (Ae = R._emscripten_bind_PointAttribute_byte_offset_0 = R.asm.r).apply(null, arguments)
                        },
                        ye = R._emscripten_bind_PointAttribute_unique_id_0 = function() {
                            return (ye = R._emscripten_bind_PointAttribute_unique_id_0 = R.asm.s).apply(null, arguments)
                        },
                        ve = R._emscripten_bind_PointAttribute___destroy___0 = function() {
                            return (ve = R._emscripten_bind_PointAttribute___destroy___0 = R.asm.t).apply(null, arguments)
                        },
                        _e = R._emscripten_bind_PointCloud_PointCloud_0 = function() {
                            return (_e = R._emscripten_bind_PointCloud_PointCloud_0 = R.asm.u).apply(null, arguments)
                        },
                        xe = R._emscripten_bind_PointCloud_num_attributes_0 = function() {
                            return (xe = R._emscripten_bind_PointCloud_num_attributes_0 = R.asm.v).apply(null, arguments)
                        },
                        we = R._emscripten_bind_PointCloud_num_points_0 = function() {
                            return (we = R._emscripten_bind_PointCloud_num_points_0 = R.asm.w).apply(null, arguments)
                        },
                        Ce = R._emscripten_bind_PointCloud___destroy___0 = function() {
                            return (Ce = R._emscripten_bind_PointCloud___destroy___0 = R.asm.x).apply(null, arguments)
                        },
                        Ee = R._emscripten_bind_Mesh_Mesh_0 = function() {
                            return (Ee = R._emscripten_bind_Mesh_Mesh_0 = R.asm.y).apply(null, arguments)
                        },
                        Se = R._emscripten_bind_Mesh_num_faces_0 = function() {
                            return (Se = R._emscripten_bind_Mesh_num_faces_0 = R.asm.z).apply(null, arguments)
                        },
                        Ie = R._emscripten_bind_Mesh_num_attributes_0 = function() {
                            return (Ie = R._emscripten_bind_Mesh_num_attributes_0 = R.asm.A).apply(null, arguments)
                        },
                        Te = R._emscripten_bind_Mesh_num_points_0 = function() {
                            return (Te = R._emscripten_bind_Mesh_num_points_0 = R.asm.B).apply(null, arguments)
                        },
                        Me = R._emscripten_bind_Mesh_set_num_points_1 = function() {
                            return (Me = R._emscripten_bind_Mesh_set_num_points_1 = R.asm.C).apply(null, arguments)
                        },
                        Re = R._emscripten_bind_Mesh___destroy___0 = function() {
                            return (Re = R._emscripten_bind_Mesh___destroy___0 = R.asm.D).apply(null, arguments)
                        },
                        Be = R._emscripten_bind_Metadata_Metadata_0 = function() {
                            return (Be = R._emscripten_bind_Metadata_Metadata_0 = R.asm.E).apply(null, arguments)
                        },
                        ke = R._emscripten_bind_Metadata___destroy___0 = function() {
                            return (ke = R._emscripten_bind_Metadata___destroy___0 = R.asm.F).apply(null, arguments)
                        },
                        De = R._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
                            return (De = R._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = R.asm.G).apply(null, arguments)
                        },
                        Pe = R._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
                            return (Pe = R._emscripten_bind_DracoInt8Array_GetValue_1 = R.asm.H).apply(null, arguments)
                        },
                        Oe = R._emscripten_bind_DracoInt8Array_size_0 = function() {
                            return (Oe = R._emscripten_bind_DracoInt8Array_size_0 = R.asm.I).apply(null, arguments)
                        },
                        Le = R._emscripten_bind_DracoInt8Array___destroy___0 = function() {
                            return (Le = R._emscripten_bind_DracoInt8Array___destroy___0 = R.asm.J).apply(null, arguments)
                        },
                        Ne = R._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = function() {
                            return (Ne = R._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = R.asm.K).apply(null, arguments)
                        },
                        Fe = R._emscripten_bind_MetadataBuilder_AddStringEntry_3 = function() {
                            return (Fe = R._emscripten_bind_MetadataBuilder_AddStringEntry_3 = R.asm.L).apply(null, arguments)
                        },
                        Ue = R._emscripten_bind_MetadataBuilder_AddIntEntry_3 = function() {
                            return (Ue = R._emscripten_bind_MetadataBuilder_AddIntEntry_3 = R.asm.M).apply(null, arguments)
                        },
                        ze = R._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = function() {
                            return (ze = R._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = R.asm.N).apply(null, arguments)
                        },
                        Qe = R._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = function() {
                            return (Qe = R._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = R.asm.O).apply(null, arguments)
                        },
                        Ge = R._emscripten_bind_MetadataBuilder___destroy___0 = function() {
                            return (Ge = R._emscripten_bind_MetadataBuilder___destroy___0 = R.asm.P).apply(null, arguments)
                        },
                        je = R._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = function() {
                            return (je = R._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = R.asm.Q).apply(null, arguments)
                        },
                        Ve = R._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = function() {
                            return (Ve = R._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = R.asm.R).apply(null, arguments)
                        },
                        He = R._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = function() {
                            return (He = R._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = R.asm.S).apply(null, arguments)
                        },
                        $e = R._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = function() {
                            return ($e = R._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = R.asm.T).apply(null, arguments)
                        },
                        We = R._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = function() {
                            return (We = R._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = R.asm.U).apply(null, arguments)
                        },
                        Ke = R._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = function() {
                            return (Ke = R._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = R.asm.V).apply(null, arguments)
                        },
                        qe = R._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = function() {
                            return (qe = R._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = R.asm.W).apply(null, arguments)
                        },
                        Xe = R._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = function() {
                            return (Xe = R._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = R.asm.X).apply(null, arguments)
                        },
                        Ye = R._emscripten_bind_PointCloudBuilder_AddMetadata_2 = function() {
                            return (Ye = R._emscripten_bind_PointCloudBuilder_AddMetadata_2 = R.asm.Y).apply(null, arguments)
                        },
                        Je = R._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = function() {
                            return (Je = R._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = R.asm.Z).apply(null, arguments)
                        },
                        Ze = R._emscripten_bind_PointCloudBuilder_SetNormalizedFlagForAttribute_3 = function() {
                            return (Ze = R._emscripten_bind_PointCloudBuilder_SetNormalizedFlagForAttribute_3 = R.asm._).apply(null, arguments)
                        },
                        et = R._emscripten_bind_PointCloudBuilder___destroy___0 = function() {
                            return (et = R._emscripten_bind_PointCloudBuilder___destroy___0 = R.asm.$).apply(null, arguments)
                        },
                        tt = R._emscripten_bind_MeshBuilder_MeshBuilder_0 = function() {
                            return (tt = R._emscripten_bind_MeshBuilder_MeshBuilder_0 = R.asm.aa).apply(null, arguments)
                        },
                        nt = R._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = function() {
                            return (nt = R._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = R.asm.ba).apply(null, arguments)
                        },
                        rt = R._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = function() {
                            return (rt = R._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = R.asm.ca).apply(null, arguments)
                        },
                        ot = R._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = function() {
                            return (ot = R._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = R.asm.da).apply(null, arguments)
                        },
                        it = R._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = function() {
                            return (it = R._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = R.asm.ea).apply(null, arguments)
                        },
                        at = R._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = function() {
                            return (at = R._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = R.asm.fa).apply(null, arguments)
                        },
                        st = R._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = function() {
                            return (st = R._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = R.asm.ga).apply(null, arguments)
                        },
                        lt = R._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = function() {
                            return (lt = R._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = R.asm.ha).apply(null, arguments)
                        },
                        ct = R._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = function() {
                            return (ct = R._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = R.asm.ia).apply(null, arguments)
                        },
                        ut = R._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = function() {
                            return (ut = R._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = R.asm.ja).apply(null, arguments)
                        },
                        dt = R._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = function() {
                            return (dt = R._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = R.asm.ka).apply(null, arguments)
                        },
                        pt = R._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = function() {
                            return (pt = R._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = R.asm.la).apply(null, arguments)
                        },
                        ht = R._emscripten_bind_MeshBuilder_AddMetadata_2 = function() {
                            return (ht = R._emscripten_bind_MeshBuilder_AddMetadata_2 = R.asm.ma).apply(null, arguments)
                        },
                        ft = R._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = function() {
                            return (ft = R._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = R.asm.na).apply(null, arguments)
                        },
                        gt = R._emscripten_bind_MeshBuilder_SetNormalizedFlagForAttribute_3 = function() {
                            return (gt = R._emscripten_bind_MeshBuilder_SetNormalizedFlagForAttribute_3 = R.asm.oa).apply(null, arguments)
                        },
                        mt = R._emscripten_bind_MeshBuilder___destroy___0 = function() {
                            return (mt = R._emscripten_bind_MeshBuilder___destroy___0 = R.asm.pa).apply(null, arguments)
                        },
                        bt = R._emscripten_bind_Encoder_Encoder_0 = function() {
                            return (bt = R._emscripten_bind_Encoder_Encoder_0 = R.asm.qa).apply(null, arguments)
                        },
                        At = R._emscripten_bind_Encoder_SetEncodingMethod_1 = function() {
                            return (At = R._emscripten_bind_Encoder_SetEncodingMethod_1 = R.asm.ra).apply(null, arguments)
                        },
                        yt = R._emscripten_bind_Encoder_SetAttributeQuantization_2 = function() {
                            return (yt = R._emscripten_bind_Encoder_SetAttributeQuantization_2 = R.asm.sa).apply(null, arguments)
                        },
                        vt = R._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = function() {
                            return (vt = R._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = R.asm.ta).apply(null, arguments)
                        },
                        _t = R._emscripten_bind_Encoder_SetSpeedOptions_2 = function() {
                            return (_t = R._emscripten_bind_Encoder_SetSpeedOptions_2 = R.asm.ua).apply(null, arguments)
                        },
                        xt = R._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = function() {
                            return (xt = R._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = R.asm.va).apply(null, arguments)
                        },
                        wt = R._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = function() {
                            return (wt = R._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = R.asm.wa).apply(null, arguments)
                        },
                        Ct = R._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = function() {
                            return (Ct = R._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = R.asm.xa).apply(null, arguments)
                        },
                        Et = R._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = function() {
                            return (Et = R._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = R.asm.ya).apply(null, arguments)
                        },
                        St = R._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = function() {
                            return (St = R._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = R.asm.za).apply(null, arguments)
                        },
                        It = R._emscripten_bind_Encoder___destroy___0 = function() {
                            return (It = R._emscripten_bind_Encoder___destroy___0 = R.asm.Aa).apply(null, arguments)
                        },
                        Tt = R._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = function() {
                            return (Tt = R._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = R.asm.Ba).apply(null, arguments)
                        },
                        Mt = R._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = function() {
                            return (Mt = R._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = R.asm.Ca).apply(null, arguments)
                        },
                        Rt = R._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = function() {
                            return (Rt = R._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = R.asm.Da).apply(null, arguments)
                        },
                        Bt = R._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = function() {
                            return (Bt = R._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = R.asm.Ea).apply(null, arguments)
                        },
                        kt = R._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = function() {
                            return (kt = R._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = R.asm.Fa).apply(null, arguments)
                        },
                        Dt = R._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = function() {
                            return (Dt = R._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = R.asm.Ga).apply(null, arguments)
                        },
                        Pt = R._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = function() {
                            return (Pt = R._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = R.asm.Ha).apply(null, arguments)
                        },
                        Ot = R._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = function() {
                            return (Ot = R._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = R.asm.Ia).apply(null, arguments)
                        },
                        Lt = R._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = function() {
                            return (Lt = R._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = R.asm.Ja).apply(null, arguments)
                        },
                        Nt = R._emscripten_bind_ExpertEncoder___destroy___0 = function() {
                            return (Nt = R._emscripten_bind_ExpertEncoder___destroy___0 = R.asm.Ka).apply(null, arguments)
                        },
                        Ft = R._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
                            return (Ft = R._emscripten_enum_draco_GeometryAttribute_Type_INVALID = R.asm.La).apply(null, arguments)
                        },
                        Ut = R._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
                            return (Ut = R._emscripten_enum_draco_GeometryAttribute_Type_POSITION = R.asm.Ma).apply(null, arguments)
                        },
                        zt = R._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
                            return (zt = R._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = R.asm.Na).apply(null, arguments)
                        },
                        Qt = R._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
                            return (Qt = R._emscripten_enum_draco_GeometryAttribute_Type_COLOR = R.asm.Oa).apply(null, arguments)
                        },
                        Gt = R._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
                            return (Gt = R._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = R.asm.Pa).apply(null, arguments)
                        },
                        jt = R._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
                            return (jt = R._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = R.asm.Qa).apply(null, arguments)
                        },
                        Vt = R._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
                            return (Vt = R._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = R.asm.Ra).apply(null, arguments)
                        },
                        Ht = R._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
                            return (Ht = R._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = R.asm.Sa).apply(null, arguments)
                        },
                        $t = R._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
                            return ($t = R._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = R.asm.Ta).apply(null, arguments)
                        },
                        Wt = R._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = function() {
                            return (Wt = R._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = R.asm.Ua).apply(null, arguments)
                        },
                        Kt = R._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = function() {
                            return (Kt = R._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = R.asm.Va).apply(null, arguments)
                        };
                    R._malloc = function() {
                        return (R._malloc = R.asm.Wa).apply(null, arguments)
                    },
                    R._free = function() {
                        return (R._free = R.asm.Xa).apply(null, arguments)
                    };
                    var qt,
                        Xt = function() {
                            return (Xt = R.asm.Ya).apply(null, arguments)
                        };
                    if (R.___start_em_js = 19116, R.___stop_em_js = 19214, ie = function e() {
                        qt || s(),
                        qt || (ie = e)
                    }, R.preInit)
                        for ("function" == typeof R.preInit && (R.preInit = [R.preInit]); 0 < R.preInit.length;)
                            R.preInit.pop()();
                    s(),
                    l.prototype = Object.create(l.prototype),
                    l.prototype.constructor = l,
                    l.prototype.__class__ = l,
                    l.__cache__ = {},
                    R.WrapperObject = l,
                    R.getCache = c,
                    R.wrapPointer = u,
                    R.castObject = function(e, t) {
                        return u(e.ptr, t)
                    },
                    R.NULL = u(0),
                    R.destroy = function(e) {
                        if (!e.__destroy__)
                            throw "Error: Cannot destroy object. (Did you create it yourself?)";
                        e.__destroy__(),
                        delete c(e.__class__)[e.ptr]
                    },
                    R.compare = function(e, t) {
                        return e.ptr === t.ptr
                    },
                    R.getPointer = function(e) {
                        return e.ptr
                    },
                    R.getClass = function(e) {
                        return e.__class__
                    };
                    var Yt = {
                        buffer: 0,
                        size: 0,
                        pos: 0,
                        temps: [],
                        needed: 0,
                        prepare: function() {
                            if (Yt.needed) {
                                for (var e = 0; e < Yt.temps.length; e++)
                                    R._free(Yt.temps[e]);
                                Yt.temps.length = 0,
                                R._free(Yt.buffer),
                                Yt.buffer = 0,
                                Yt.size += Yt.needed,
                                Yt.needed = 0
                            }
                            Yt.buffer || (Yt.size += 128, Yt.buffer = R._malloc(Yt.size), Yt.buffer || r(void 0)),
                            Yt.pos = 0
                        },
                        alloc: function(e, t) {
                            return Yt.buffer || r(void 0), e = 7 + (e = e.length * t.BYTES_PER_ELEMENT) & -8, Yt.pos + e >= Yt.size ? (0 < e || r(void 0), Yt.needed += e, t = R._malloc(e), Yt.temps.push(t)) : (t = Yt.buffer + Yt.pos, Yt.pos += e), t
                        },
                        copy: function(e, t, n) {
                            switch (n >>>= 0, t.BYTES_PER_ELEMENT) {
                            case 2:
                                n >>>= 1;
                                break;
                            case 4:
                                n >>>= 2;
                                break;
                            case 8:
                                n >>>= 3
                            }
                            for (var r = 0; r < e.length; r++)
                                t[n + r] = e[r]
                        }
                    };
                    return m.prototype = Object.create(l.prototype), m.prototype.constructor = m, m.prototype.__class__ = m, m.__cache__ = {}, R.VoidPtr = m, m.prototype.__destroy__ = m.prototype.__destroy__ = function() {
                        le(this.ptr)
                    }, b.prototype = Object.create(l.prototype), b.prototype.constructor = b, b.prototype.__class__ = b, b.__cache__ = {}, R.GeometryAttribute = b, b.prototype.__destroy__ = b.prototype.__destroy__ = function() {
                        ue(this.ptr)
                    }, A.prototype = Object.create(l.prototype), A.prototype.constructor = A, A.prototype.__class__ = A, A.__cache__ = {}, R.PointAttribute = A, A.prototype.size = A.prototype.size = function() {
                        return pe(this.ptr)
                    }, A.prototype.attribute_type = A.prototype.attribute_type = function() {
                        return he(this.ptr)
                    }, A.prototype.data_type = A.prototype.data_type = function() {
                        return fe(this.ptr)
                    }, A.prototype.num_components = A.prototype.num_components = function() {
                        return ge(this.ptr)
                    }, A.prototype.normalized = A.prototype.normalized = function() {
                        return !!me(this.ptr)
                    }, A.prototype.byte_stride = A.prototype.byte_stride = function() {
                        return be(this.ptr)
                    }, A.prototype.byte_offset = A.prototype.byte_offset = function() {
                        return Ae(this.ptr)
                    }, A.prototype.unique_id = A.prototype.unique_id = function() {
                        return ye(this.ptr)
                    }, A.prototype.__destroy__ = A.prototype.__destroy__ = function() {
                        ve(this.ptr)
                    }, y.prototype = Object.create(l.prototype), y.prototype.constructor = y, y.prototype.__class__ = y, y.__cache__ = {}, R.PointCloud = y, y.prototype.num_attributes = y.prototype.num_attributes = function() {
                        return xe(this.ptr)
                    }, y.prototype.num_points = y.prototype.num_points = function() {
                        return we(this.ptr)
                    }, y.prototype.__destroy__ = y.prototype.__destroy__ = function() {
                        Ce(this.ptr)
                    }, v.prototype = Object.create(l.prototype), v.prototype.constructor = v, v.prototype.__class__ = v, v.__cache__ = {}, R.Mesh = v, v.prototype.num_faces = v.prototype.num_faces = function() {
                        return Se(this.ptr)
                    }, v.prototype.num_attributes = v.prototype.num_attributes = function() {
                        return Ie(this.ptr)
                    }, v.prototype.num_points = v.prototype.num_points = function() {
                        return Te(this.ptr)
                    }, v.prototype.set_num_points = v.prototype.set_num_points = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        Me(t, e)
                    }, v.prototype.__destroy__ = v.prototype.__destroy__ = function() {
                        Re(this.ptr)
                    }, _.prototype = Object.create(l.prototype), _.prototype.constructor = _, _.prototype.__class__ = _, _.__cache__ = {}, R.Metadata = _, _.prototype.__destroy__ = _.prototype.__destroy__ = function() {
                        ke(this.ptr)
                    }, x.prototype = Object.create(l.prototype), x.prototype.constructor = x, x.prototype.__class__ = x, x.__cache__ = {}, R.DracoInt8Array = x, x.prototype.GetValue = x.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), Pe(t, e)
                    }, x.prototype.size = x.prototype.size = function() {
                        return Oe(this.ptr)
                    }, x.prototype.__destroy__ = x.prototype.__destroy__ = function() {
                        Le(this.ptr)
                    }, w.prototype = Object.create(l.prototype), w.prototype.constructor = w, w.prototype.__class__ = w, w.__cache__ = {}, R.MetadataBuilder = w, w.prototype.AddStringEntry = w.prototype.AddStringEntry = function(e, t, n) {
                        var r = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : d(t), n = n && "object" == typeof n ? n.ptr : d(n), !!Fe(r, e, t, n)
                    }, w.prototype.AddIntEntry = w.prototype.AddIntEntry = function(e, t, n) {
                        var r = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : d(t), n && "object" == typeof n && (n = n.ptr), !!Ue(r, e, t, n)
                    }, w.prototype.AddIntEntryArray = w.prototype.AddIntEntryArray = function(e, t, n, r) {
                        var o = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : d(t), "object" == typeof n && (n = f(n)), r && "object" == typeof r && (r = r.ptr), !!ze(o, e, t, n, r)
                    }, w.prototype.AddDoubleEntry = w.prototype.AddDoubleEntry = function(e, t, n) {
                        var r = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : d(t), n && "object" == typeof n && (n = n.ptr), !!Qe(r, e, t, n)
                    }, w.prototype.__destroy__ = w.prototype.__destroy__ = function() {
                        Ge(this.ptr)
                    }, C.prototype = Object.create(l.prototype), C.prototype.constructor = C, C.prototype.__class__ = C, C.__cache__ = {}, R.PointCloudBuilder = C, C.prototype.AddFloatAttribute = C.prototype.AddFloatAttribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = g(o)), Ve(i, e, t, n, r, o)
                    }, C.prototype.AddInt8Attribute = C.prototype.AddInt8Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = p(o)), He(i, e, t, n, r, o)
                    }, C.prototype.AddUInt8Attribute = C.prototype.AddUInt8Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = p(o)), $e(i, e, t, n, r, o)
                    }, C.prototype.AddInt16Attribute = C.prototype.AddInt16Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = h(o)), We(i, e, t, n, r, o)
                    }, C.prototype.AddUInt16Attribute = C.prototype.AddUInt16Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = h(o)), Ke(i, e, t, n, r, o)
                    }, C.prototype.AddInt32Attribute = C.prototype.AddInt32Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = f(o)), qe(i, e, t, n, r, o)
                    }, C.prototype.AddUInt32Attribute = C.prototype.AddUInt32Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = f(o)), Xe(i, e, t, n, r, o)
                    }, C.prototype.AddMetadata = C.prototype.AddMetadata = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), !!Ye(n, e, t)
                    }, C.prototype.SetMetadataForAttribute = C.prototype.SetMetadataForAttribute = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!Je(r, e, t, n)
                    }, C.prototype.SetNormalizedFlagForAttribute = C.prototype.SetNormalizedFlagForAttribute = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!Ze(r, e, t, n)
                    }, C.prototype.__destroy__ = C.prototype.__destroy__ = function() {
                        et(this.ptr)
                    }, E.prototype = Object.create(l.prototype), E.prototype.constructor = E, E.prototype.__class__ = E, E.__cache__ = {}, R.MeshBuilder = E, E.prototype.AddFacesToMesh = E.prototype.AddFacesToMesh = function(e, t, n) {
                        var r = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), "object" == typeof n && (n = f(n)), !!nt(r, e, t, n)
                    }, E.prototype.AddFloatAttributeToMesh = E.prototype.AddFloatAttributeToMesh = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = g(o)), rt(i, e, t, n, r, o)
                    }, E.prototype.AddInt32AttributeToMesh = E.prototype.AddInt32AttributeToMesh = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = f(o)), ot(i, e, t, n, r, o)
                    }, E.prototype.AddMetadataToMesh = E.prototype.AddMetadataToMesh = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), !!it(n, e, t)
                    }, E.prototype.AddFloatAttribute = E.prototype.AddFloatAttribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = g(o)), at(i, e, t, n, r, o)
                    }, E.prototype.AddInt8Attribute = E.prototype.AddInt8Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = p(o)), st(i, e, t, n, r, o)
                    }, E.prototype.AddUInt8Attribute = E.prototype.AddUInt8Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = p(o)), lt(i, e, t, n, r, o)
                    }, E.prototype.AddInt16Attribute = E.prototype.AddInt16Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = h(o)), ct(i, e, t, n, r, o)
                    }, E.prototype.AddUInt16Attribute = E.prototype.AddUInt16Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = h(o)), ut(i, e, t, n, r, o)
                    }, E.prototype.AddInt32Attribute = E.prototype.AddInt32Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = f(o)), dt(i, e, t, n, r, o)
                    }, E.prototype.AddUInt32Attribute = E.prototype.AddUInt32Attribute = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return Yt.prepare(), e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), "object" == typeof o && (o = f(o)), pt(i, e, t, n, r, o)
                    }, E.prototype.AddMetadata = E.prototype.AddMetadata = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), !!ht(n, e, t)
                    }, E.prototype.SetMetadataForAttribute = E.prototype.SetMetadataForAttribute = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!ft(r, e, t, n)
                    }, E.prototype.SetNormalizedFlagForAttribute = E.prototype.SetNormalizedFlagForAttribute = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!gt(r, e, t, n)
                    }, E.prototype.__destroy__ = E.prototype.__destroy__ = function() {
                        mt(this.ptr)
                    }, S.prototype = Object.create(l.prototype), S.prototype.constructor = S, S.prototype.__class__ = S, S.__cache__ = {}, R.Encoder = S, S.prototype.SetEncodingMethod = S.prototype.SetEncodingMethod = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        At(t, e)
                    }, S.prototype.SetAttributeQuantization = S.prototype.SetAttributeQuantization = function(e, t) {
                        var n = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        yt(n, e, t)
                    }, S.prototype.SetAttributeExplicitQuantization = S.prototype.SetAttributeExplicitQuantization = function(e, t, n, r, o) {
                        var i = this.ptr;
                        Yt.prepare(),
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        n && "object" == typeof n && (n = n.ptr),
                        "object" == typeof r && (r = g(r)),
                        o && "object" == typeof o && (o = o.ptr),
                        vt(i, e, t, n, r, o)
                    }, S.prototype.SetSpeedOptions = S.prototype.SetSpeedOptions = function(e, t) {
                        var n = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        _t(n, e, t)
                    }, S.prototype.SetTrackEncodedProperties = S.prototype.SetTrackEncodedProperties = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        xt(t, e)
                    }, S.prototype.EncodeMeshToDracoBuffer = S.prototype.EncodeMeshToDracoBuffer = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), wt(n, e, t)
                    }, S.prototype.EncodePointCloudToDracoBuffer = S.prototype.EncodePointCloudToDracoBuffer = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), Ct(r, e, t, n)
                    }, S.prototype.GetNumberOfEncodedPoints = S.prototype.GetNumberOfEncodedPoints = function() {
                        return Et(this.ptr)
                    }, S.prototype.GetNumberOfEncodedFaces = S.prototype.GetNumberOfEncodedFaces = function() {
                        return St(this.ptr)
                    }, S.prototype.__destroy__ = S.prototype.__destroy__ = function() {
                        It(this.ptr)
                    }, I.prototype = Object.create(l.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, R.ExpertEncoder = I, I.prototype.SetEncodingMethod = I.prototype.SetEncodingMethod = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        Mt(t, e)
                    }, I.prototype.SetAttributeQuantization = I.prototype.SetAttributeQuantization = function(e, t) {
                        var n = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        Rt(n, e, t)
                    }, I.prototype.SetAttributeExplicitQuantization = I.prototype.SetAttributeExplicitQuantization = function(e, t, n, r, o) {
                        var i = this.ptr;
                        Yt.prepare(),
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        n && "object" == typeof n && (n = n.ptr),
                        "object" == typeof r && (r = g(r)),
                        o && "object" == typeof o && (o = o.ptr),
                        Bt(i, e, t, n, r, o)
                    }, I.prototype.SetSpeedOptions = I.prototype.SetSpeedOptions = function(e, t) {
                        var n = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        t && "object" == typeof t && (t = t.ptr),
                        kt(n, e, t)
                    }, I.prototype.SetTrackEncodedProperties = I.prototype.SetTrackEncodedProperties = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        Dt(t, e)
                    }, I.prototype.EncodeToDracoBuffer = I.prototype.EncodeToDracoBuffer = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), Pt(n, e, t)
                    }, I.prototype.GetNumberOfEncodedPoints = I.prototype.GetNumberOfEncodedPoints = function() {
                        return Ot(this.ptr)
                    }, I.prototype.GetNumberOfEncodedFaces = I.prototype.GetNumberOfEncodedFaces = function() {
                        return Lt(this.ptr)
                    }, I.prototype.__destroy__ = I.prototype.__destroy__ = function() {
                        Nt(this.ptr)
                    }, function() {
                        function e() {
                            R.INVALID = Ft(),
                            R.POSITION = Ut(),
                            R.NORMAL = zt(),
                            R.COLOR = Qt(),
                            R.TEX_COORD = Gt(),
                            R.GENERIC = jt(),
                            R.INVALID_GEOMETRY_TYPE = Vt(),
                            R.POINT_CLOUD = Ht(),
                            R.TRIANGULAR_MESH = $t(),
                            R.MESH_SEQUENTIAL_ENCODING = Wt(),
                            R.MESH_EDGEBREAKER_ENCODING = Kt()
                        }
                        re ? e() : te.unshift(e)
                    }(), "function" == typeof R.onModuleParsed && R.onModuleParsed(), e.ready
                });
            e.exports = r
        }(my)), my.exports),
        t = (vy || (vy = 1, function(e) {
            var t = t || {};
            t.scope = {},
            t.arrayIteratorImpl = function(e) {
                var t = 0;
                return function() {
                    return t < e.length ? {
                        done: !1,
                        value: e[t++]
                    } : {
                        done: !0
                    }
                }
            },
            t.arrayIterator = function(e) {
                return {
                    next: t.arrayIteratorImpl(e)
                }
            },
            t.makeIterator = function(e) {
                var n = "undefined" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];
                return n ? n.call(e) : t.arrayIterator(e)
            },
            t.ASSUME_ES5 = !1,
            t.ASSUME_NO_NATIVE_MAP = !1,
            t.ASSUME_NO_NATIVE_SET = !1,
            t.SIMPLE_FROUND_POLYFILL = !1,
            t.ISOLATE_POLYFILLS = !1,
            t.FORCE_POLYFILL_PROMISE = !1,
            t.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1,
            t.getGlobal = function(e) {
                e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof hy && hy];
                for (var t = 0; t < e.length; ++t) {
                    var n = e[t];
                    if (n && n.Math == Math)
                        return n
                }
                throw Error("Cannot find global object")
            },
            t.global = t.getGlobal(Cy),
            t.defineProperty = t.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(e, t, n) {
                return e == Array.prototype || e == Object.prototype || (e[t] = n.value), e
            },
            t.IS_SYMBOL_NATIVE = "function" == typeof Symbol && "symbol" == typeof Symbol("x"),
            t.TRUST_ES6_POLYFILLS = !t.ISOLATE_POLYFILLS || t.IS_SYMBOL_NATIVE,
            t.polyfills = {},
            t.propertyToPolyfillSymbol = {},
            t.POLYFILL_PREFIX = "$jscp$",
            t.polyfill = function(e, n, r, o) {
                n && (t.ISOLATE_POLYFILLS ? t.polyfillIsolated(e, n, r, o) : t.polyfillUnisolated(e, n, r, o))
            },
            t.polyfillUnisolated = function(e, n, r, o) {
                for (r = t.global, e = e.split("."), o = 0; o < e.length - 1; o++) {
                    var i = e[o];
                    if (!(i in r))
                        return;
                    r = r[i]
                }
                (n = n(o = r[e = e[e.length - 1]])) != o && null != n && t.defineProperty(r, e, {
                    configurable: !0,
                    writable: !0,
                    value: n
                })
            },
            t.polyfillIsolated = function(e, n, r, o) {
                var i = e.split(".");
                e = 1 === i.length,
                o = i[0],
                o = !e && o in t.polyfills ? t.polyfills : t.global;
                for (var a = 0; a < i.length - 1; a++) {
                    var s = i[a];
                    if (!(s in o))
                        return;
                    o = o[s]
                }
                i = i[i.length - 1],
                null != (n = n(r = t.IS_SYMBOL_NATIVE && "es6" === r ? o[i] : null)) && (e ? t.defineProperty(t.polyfills, i, {
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : n !== r && (void 0 === t.propertyToPolyfillSymbol[i] && (r = 1e9 * Math.random() >>> 0, t.propertyToPolyfillSymbol[i] = t.IS_SYMBOL_NATIVE ? t.global.Symbol(i) : t.POLYFILL_PREFIX + r + "$" + i), t.defineProperty(o, t.propertyToPolyfillSymbol[i], {
                    configurable: !0,
                    writable: !0,
                    value: n
                })))
            },
            t.polyfill("Promise", function(e) {
                function n() {
                    this.batch_ = null
                }
                function r(e) {
                    return e instanceof i ? e : new i(function(t, n) {
                        t(e)
                    })
                }
                if (e && (!(t.FORCE_POLYFILL_PROMISE || t.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && void 0 === t.global.PromiseRejectionEvent) || !t.global.Promise || -1 === t.global.Promise.toString().indexOf("[native code]")))
                    return e;
                n.prototype.asyncExecute = function(e) {
                    if (null == this.batch_) {
                        this.batch_ = [];
                        var t = this;
                        this.asyncExecuteFunction(function() {
                            t.executeBatch_()
                        })
                    }
                    this.batch_.push(e)
                };
                var o = t.global.setTimeout;
                n.prototype.asyncExecuteFunction = function(e) {
                    o(e, 0)
                },
                n.prototype.executeBatch_ = function() {
                    for (; this.batch_ && this.batch_.length;) {
                        var e = this.batch_;
                        this.batch_ = [];
                        for (var t = 0; t < e.length; ++t) {
                            var n = e[t];
                            e[t] = null;
                            try {
                                n()
                            } catch (r) {
                                this.asyncThrow_(r)
                            }
                        }
                    }
                    this.batch_ = null
                },
                n.prototype.asyncThrow_ = function(e) {
                    this.asyncExecuteFunction(function() {
                        throw e
                    })
                };
                var i = function(e) {
                    this.state_ = 0,
                    this.result_ = void 0,
                    this.onSettledCallbacks_ = [],
                    this.isRejectionHandled_ = !1;
                    var t = this.createResolveAndReject_();
                    try {
                        e(t.resolve, t.reject)
                    } catch (n) {
                        t.reject(n)
                    }
                };
                i.prototype.createResolveAndReject_ = function() {
                    function e(e) {
                        return function(r) {
                            n || (n = !0, e.call(t, r))
                        }
                    }
                    var t = this,
                        n = !1;
                    return {
                        resolve: e(this.resolveTo_),
                        reject: e(this.reject_)
                    }
                },
                i.prototype.resolveTo_ = function(e) {
                    if (e === this)
                        this.reject_(new TypeError("A Promise cannot resolve to itself"));
                    else if (e instanceof i)
                        this.settleSameAsPromise_(e);
                    else {
                        e:
                        switch (typeof e) {
                        case "object":
                            var t = null != e;
                            break e;
                        case "function":
                            t = !0;
                            break e;
                        default:
                            t = !1
                        }
                        t ? this.resolveToNonPromiseObj_(e) : this.fulfill_(e)
                    }
                },
                i.prototype.resolveToNonPromiseObj_ = function(e) {
                    var t = void 0;
                    try {
                        t = e.then
                    } catch (n) {
                        return void this.reject_(n)
                    }
                    "function" == typeof t ? this.settleSameAsThenable_(t, e) : this.fulfill_(e)
                },
                i.prototype.reject_ = function(e) {
                    this.settle_(2, e)
                },
                i.prototype.fulfill_ = function(e) {
                    this.settle_(1, e)
                },
                i.prototype.settle_ = function(e, t) {
                    if (0 != this.state_)
                        throw Error("Cannot settle(" + e + ", " + t + "): Promise already settled in state" + this.state_);
                    this.state_ = e,
                    this.result_ = t,
                    2 === this.state_ && this.scheduleUnhandledRejectionCheck_(),
                    this.executeOnSettledCallbacks_()
                },
                i.prototype.scheduleUnhandledRejectionCheck_ = function() {
                    var e = this;
                    o(function() {
                        if (e.notifyUnhandledRejection_()) {
                            var n = t.global.console;
                            void 0 !== n && n.error(e.result_)
                        }
                    }, 1)
                },
                i.prototype.notifyUnhandledRejection_ = function() {
                    if (this.isRejectionHandled_)
                        return !1;
                    var e = t.global.CustomEvent,
                        n = t.global.Event,
                        r = t.global.dispatchEvent;
                    return void 0 === r || ("function" == typeof e ? e = new e("unhandledrejection", {
                            cancelable: !0
                        }) : "function" == typeof n ? e = new n("unhandledrejection", {
                            cancelable: !0
                        }) : (e = t.global.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection", !1, !0, e), e.promise = this, e.reason = this.result_, r(e))
                },
                i.prototype.executeOnSettledCallbacks_ = function() {
                    if (null != this.onSettledCallbacks_) {
                        for (var e = 0; e < this.onSettledCallbacks_.length; ++e)
                            a.asyncExecute(this.onSettledCallbacks_[e]);
                        this.onSettledCallbacks_ = null
                    }
                };
                var a = new n;
                return i.prototype.settleSameAsPromise_ = function(e) {
                    var t = this.createResolveAndReject_();
                    e.callWhenSettled_(t.resolve, t.reject)
                }, i.prototype.settleSameAsThenable_ = function(e, t) {
                    var n = this.createResolveAndReject_();
                    try {
                        e.call(t, n.resolve, n.reject)
                    } catch (r) {
                        n.reject(r)
                    }
                }, i.prototype.then = function(e, t) {
                    function n(e, t) {
                        return "function" == typeof e ? function(t) {
                            try {
                                r(e(t))
                            } catch (n) {
                                o(n)
                            }
                        } : t
                    }
                    var r,
                        o,
                        a = new i(function(e, t) {
                            r = e,
                            o = t
                        });
                    return this.callWhenSettled_(n(e, r), n(t, o)), a
                }, i.prototype.catch = function(e) {
                    return this.then(void 0, e)
                }, i.prototype.callWhenSettled_ = function(e, t) {
                    function n() {
                        switch (r.state_) {
                        case 1:
                            e(r.result_);
                            break;
                        case 2:
                            t(r.result_);
                            break;
                        default:
                            throw Error("Unexpected state: " + r.state_)
                        }
                    }
                    var r = this;
                    null == this.onSettledCallbacks_ ? a.asyncExecute(n) : this.onSettledCallbacks_.push(n),
                    this.isRejectionHandled_ = !0
                }, i.resolve = r, i.reject = function(e) {
                    return new i(function(t, n) {
                        n(e)
                    })
                }, i.race = function(e) {
                    return new i(function(n, o) {
                        for (var i = t.makeIterator(e), a = i.next(); !a.done; a = i.next())
                            r(a.value).callWhenSettled_(n, o)
                    })
                }, i.all = function(e) {
                    var n = t.makeIterator(e),
                        o = n.next();
                    return o.done ? r([]) : new i(function(e, t) {
                        function i(t) {
                            return function(n) {
                                a[t] = n,
                                0 == --s && e(a)
                            }
                        }
                        var a = [],
                            s = 0;
                        do {
                            a.push(void 0),
                            s++,
                            r(o.value).callWhenSettled_(i(a.length - 1), t),
                            o = n.next()
                        } while (!o.done)
                    })
                }, i
            }, "es6", "es3"),
            t.owns = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            },
            t.assign = t.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign ? Object.assign : function(e, n) {
                for (var r = 1; r < arguments.length; r++) {
                    var o = arguments[r];
                    if (o)
                        for (var i in o)
                            t.owns(o, i) && (e[i] = o[i])
                }
                return e
            },
            t.polyfill("Object.assign", function(e) {
                return e || t.assign
            }, "es6", "es3"),
            t.checkStringArgs = function(e, t, n) {
                if (null == e)
                    throw new TypeError("The 'this' value for String.prototype." + n + " must not be null or undefined");
                if (t instanceof RegExp)
                    throw new TypeError("First argument to String.prototype." + n + " must not be a regular expression");
                return e + ""
            },
            t.polyfill("String.prototype.startsWith", function(e) {
                return e || function(e, n) {
                        var r = t.checkStringArgs(this, e, "startsWith");
                        e += "";
                        var o = r.length,
                            i = e.length;
                        n = Math.max(0, Math.min(0 | n, r.length));
                        for (var a = 0; a < i && n < o;)
                            if (r[n++] != e[a++])
                                return !1;
                        return a >= i
                    }
            }, "es6", "es3"),
            t.polyfill("Array.prototype.copyWithin", function(e) {
                function t(e) {
                    return 1 / 0 === (e = Number(e)) || -1 / 0 === e ? e : 0 | e
                }
                return e || function(e, n, r) {
                        var o = this.length;
                        if (e = t(e), n = t(n), r = void 0 === r ? o : t(r), e = 0 > e ? Math.max(o + e, 0) : Math.min(e, o), n = 0 > n ? Math.max(o + n, 0) : Math.min(n, o), r = 0 > r ? Math.max(o + r, 0) : Math.min(r, o), e < n)
                            for (; n < r;)
                                n in this ? this[e++] = this[n++] : (delete this[e++], n++);
                        else
                            for (e += (r = Math.min(r, o + n - e)) - n; r > n;)
                                --r in this ? this[--e] = this[r] : delete this[--e];
                        return this
                    }
            }, "es6", "es3"),
            t.typedArrayCopyWithin = function(e) {
                return e || Array.prototype.copyWithin
            },
            t.polyfill("Int8Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint8Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint8ClampedArray.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Int16Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint16Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Int32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Uint32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Float32Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5"),
            t.polyfill("Float64Array.prototype.copyWithin", t.typedArrayCopyWithin, "es6", "es5");
            var n,
                r = (n = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (n = n || __filename), function(e) {
                    function t(e, t, n) {
                        var r = t + n;
                        for (n = t; e[n] && !(n >= r);)
                            ++n;
                        if (16 < n - t && e.buffer && ae)
                            return ae.decode(e.subarray(t, n));
                        for (r = ""; t < n;) {
                            var o = e[t++];
                            if (128 & o) {
                                var i = 63 & e[t++];
                                if (192 == (224 & o))
                                    r += String.fromCharCode((31 & o) << 6 | i);
                                else {
                                    var a = 63 & e[t++];
                                    65536 > (o = 224 == (240 & o) ? (15 & o) << 12 | i << 6 | a : (7 & o) << 18 | i << 12 | a << 6 | 63 & e[t++]) ? r += String.fromCharCode(o) : (o -= 65536, r += String.fromCharCode(55296 | o >> 10, 56320 | 1023 & o))
                                }
                            } else
                                r += String.fromCharCode(o)
                        }
                        return r
                    }
                    function r(e, n) {
                        return e ? t(te, e, n) : ""
                    }
                    function o() {
                        var e = Z.buffer;
                        N.HEAP8 = ee = new Int8Array(e),
                        N.HEAP16 = new Int16Array(e),
                        N.HEAP32 = ne = new Int32Array(e),
                        N.HEAPU8 = te = new Uint8Array(e),
                        N.HEAPU16 = new Uint16Array(e),
                        N.HEAPU32 = re = new Uint32Array(e),
                        N.HEAPF32 = new Float32Array(e),
                        N.HEAPF64 = new Float64Array(e)
                    }
                    function i(e) {
                        throw N.onAbort && N.onAbort(e), J(e = "Aborted(" + e + ")"), ie = !0, e = new WebAssembly.RuntimeError(e + ". Build with -sASSERTIONS for more info."), L(e), e
                    }
                    function a(e) {
                        try {
                            if (e == he && X)
                                return new Uint8Array(X);
                            if (K)
                                return K(e);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (t) {
                            i(t)
                        }
                    }
                    function s(e) {
                        for (; 0 < e.length;)
                            e.shift()(N)
                    }
                    function l(e) {
                        this.excPtr = e,
                        this.ptr = e - 24,
                        this.set_type = function(e) {
                            re[this.ptr + 4 >> 2] = e
                        },
                        this.get_type = function() {
                            return re[this.ptr + 4 >> 2]
                        },
                        this.set_destructor = function(e) {
                            re[this.ptr + 8 >> 2] = e
                        },
                        this.get_destructor = function() {
                            return re[this.ptr + 8 >> 2]
                        },
                        this.set_refcount = function(e) {
                            ne[this.ptr >> 2] = e
                        },
                        this.set_caught = function(e) {
                            ee[this.ptr + 12 | 0] = e ? 1 : 0
                        },
                        this.get_caught = function() {
                            return 0 != ee[this.ptr + 12 | 0]
                        },
                        this.set_rethrown = function(e) {
                            ee[this.ptr + 13 | 0] = e ? 1 : 0
                        },
                        this.get_rethrown = function() {
                            return 0 != ee[this.ptr + 13 | 0]
                        },
                        this.init = function(e, t) {
                            this.set_adjusted_ptr(0),
                            this.set_type(e),
                            this.set_destructor(t),
                            this.set_refcount(0),
                            this.set_caught(!1),
                            this.set_rethrown(!1)
                        },
                        this.add_ref = function() {
                            ne[this.ptr >> 2] += 1
                        },
                        this.release_ref = function() {
                            var e = ne[this.ptr >> 2];
                            return ne[this.ptr >> 2] = e - 1, 1 === e
                        },
                        this.set_adjusted_ptr = function(e) {
                            re[this.ptr + 16 >> 2] = e
                        },
                        this.get_adjusted_ptr = function() {
                            return re[this.ptr + 16 >> 2]
                        },
                        this.get_exception_ptr = function() {
                            if (Zn(this.get_type()))
                                return re[this.excPtr >> 2];
                            var e = this.get_adjusted_ptr();
                            return 0 !== e ? e : this.excPtr
                        }
                    }
                    function c() {
                        function e() {
                            if (!Jn && (Jn = !0, N.calledRun = !0, !ie)) {
                                if (ue = !0, s(le), O(N), N.onRuntimeInitialized && N.onRuntimeInitialized(), N.postRun)
                                    for ("function" == typeof N.postRun && (N.postRun = [N.postRun]); N.postRun.length;)
                                        ce.unshift(N.postRun.shift());
                                s(ce)
                            }
                        }
                        if (!(0 < de)) {
                            if (N.preRun)
                                for ("function" == typeof N.preRun && (N.preRun = [N.preRun]); N.preRun.length;)
                                    se.unshift(N.preRun.shift());
                            s(se),
                            0 < de || (N.setStatus ? (N.setStatus("Running..."), setTimeout(function() {
                                setTimeout(function() {
                                    N.setStatus("")
                                }, 1),
                                e()
                            }, 1)) : e())
                        }
                    }
                    function u() {}
                    function d(e) {
                        return (e || u).__cache__
                    }
                    function p(e, t) {
                        var n = d(t),
                            r = n[e];
                        return r || ((r = Object.create((t || u).prototype)).ptr = e, n[e] = r)
                    }
                    function h(e) {
                        if ("string" == typeof e) {
                            for (var t = 0, n = 0; n < e.length; ++n) {
                                var r = e.charCodeAt(n);
                                127 >= r ? t++ : 2047 >= r ? t += 2 : 55296 <= r && 57343 >= r ? (t += 4, ++n) : t += 3
                            }
                            if (n = 0, 0 < (r = (t = Array(t + 1)).length)) {
                                r = n + r - 1;
                                for (var o = 0; o < e.length; ++o) {
                                    var i = e.charCodeAt(o);
                                    if (55296 <= i && 57343 >= i && (i = 65536 + ((1023 & i) << 10) | 1023 & e.charCodeAt(++o)), 127 >= i) {
                                        if (n >= r)
                                            break;
                                        t[n++] = i
                                    } else {
                                        if (2047 >= i) {
                                            if (n + 1 >= r)
                                                break;
                                            t[n++] = 192 | i >> 6
                                        } else {
                                            if (65535 >= i) {
                                                if (n + 2 >= r)
                                                    break;
                                                t[n++] = 224 | i >> 12
                                            } else {
                                                if (n + 3 >= r)
                                                    break;
                                                t[n++] = 240 | i >> 18,
                                                t[n++] = 128 | i >> 12 & 63
                                            }
                                            t[n++] = 128 | i >> 6 & 63
                                        }
                                        t[n++] = 128 | 63 & i
                                    }
                                }
                                t[n] = 0
                            }
                            return e = er.alloc(t, ee), er.copy(t, ee, e), e
                        }
                        return e
                    }
                    function f(e) {
                        if ("object" == typeof e) {
                            var t = er.alloc(e, ee);
                            return er.copy(e, ee, t), t
                        }
                        return e
                    }
                    function g() {
                        throw "cannot construct a VoidPtr, no constructor in IDL"
                    }
                    function m() {
                        this.ptr = be(),
                        d(m)[this.ptr] = this
                    }
                    function b() {
                        this.ptr = ve(),
                        d(b)[this.ptr] = this
                    }
                    function A() {
                        this.ptr = we(),
                        d(A)[this.ptr] = this
                    }
                    function y() {
                        this.ptr = Ee(),
                        d(y)[this.ptr] = this
                    }
                    function v() {
                        this.ptr = Le(),
                        d(v)[this.ptr] = this
                    }
                    function _() {
                        this.ptr = Ge(),
                        d(_)[this.ptr] = this
                    }
                    function x() {
                        this.ptr = $e(),
                        d(x)[this.ptr] = this
                    }
                    function w() {
                        this.ptr = Xe(),
                        d(w)[this.ptr] = this
                    }
                    function C() {
                        this.ptr = tt(),
                        d(C)[this.ptr] = this
                    }
                    function E() {
                        throw "cannot construct a Status, no constructor in IDL"
                    }
                    function S() {
                        this.ptr = st(),
                        d(S)[this.ptr] = this
                    }
                    function I() {
                        this.ptr = dt(),
                        d(I)[this.ptr] = this
                    }
                    function T() {
                        this.ptr = gt(),
                        d(T)[this.ptr] = this
                    }
                    function M() {
                        this.ptr = yt(),
                        d(M)[this.ptr] = this
                    }
                    function R() {
                        this.ptr = wt(),
                        d(R)[this.ptr] = this
                    }
                    function B() {
                        this.ptr = It(),
                        d(B)[this.ptr] = this
                    }
                    function k() {
                        this.ptr = Bt(),
                        d(k)[this.ptr] = this
                    }
                    function D() {
                        this.ptr = Ot(),
                        d(D)[this.ptr] = this
                    }
                    function P() {
                        this.ptr = Vt(),
                        d(P)[this.ptr] = this
                    }
                    var O,
                        L,
                        N = void 0 !== (e = void 0 === e ? {} : e) ? e : {};
                    N.ready = new Promise(function(e, t) {
                        O = e,
                        L = t
                    });
                    var F = !1,
                        U = !1;
                    N.onRuntimeInitialized = function() {
                        F = !0,
                        U && "function" == typeof N.onModuleLoaded && N.onModuleLoaded(N)
                    },
                    N.onModuleParsed = function() {
                        U = !0,
                        F && "function" == typeof N.onModuleLoaded && N.onModuleLoaded(N)
                    },
                    N.isVersionSupported = function(e) {
                        return "string" == typeof e && !(2 > (e = e.split(".")).length || 3 < e.length) && (1 == e[0] && 0 <= e[1] && 5 >= e[1] || !(0 != e[0] || 10 < e[1]))
                    };
                    var z = Object.assign({}, N),
                        Q = "object" == typeof window,
                        G = "function" == typeof importScripts,
                        j = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node,
                        V = "";
                    if (j) {
                        var H = by,
                            $ = by;
                        V = G ? $.dirname(V) + "/" : __dirname + "/";
                        var W = function(e, t) {
                                return e = e.startsWith("file://") ? new URL(e) : $.normalize(e), H.readFileSync(e, t ? void 0 : "utf8")
                            },
                            K = function(e) {
                                return (e = W(e, !0)).buffer || (e = new Uint8Array(e)), e
                            },
                            q = function(e, t, n) {
                                e = e.startsWith("file://") ? new URL(e) : $.normalize(e),
                                H.readFile(e, function(e, r) {
                                    e ? n(e) : t(r.buffer)
                                })
                            };
                        1 < process.argv.length && process.argv[1].replace(/\\/g, "/"),
                        process.argv.slice(2),
                        N.inspect = function() {
                            return "[Emscripten Module object]"
                        }
                    } else
                        (Q || G) && (G ? V = self.location.href : "undefined" != typeof document && document.currentScript && (V = document.currentScript.src), n && (V = n), V = 0 !== V.indexOf("blob:") ? V.substr(0, V.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", W = function(e) {
                            var t = new XMLHttpRequest;
                            return t.open("GET", e, !1), t.send(null), t.responseText
                        }, G && (K = function(e) {
                            var t = new XMLHttpRequest;
                            return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response)
                        }), q = function(e, t, n) {
                            var r = new XMLHttpRequest;
                            r.open("GET", e, !0),
                            r.responseType = "arraybuffer",
                            r.onload = function() {
                                200 == r.status || 0 == r.status && r.response ? t(r.response) : n()
                            },
                            r.onerror = n,
                            r.send(null)
                        });
                    var X,
                        Y = N.print || function() {}.bind(),
                        J = N.printErr || function() {}.bind();
                    Object.assign(N, z),
                    z = null,
                    N.wasmBinary && (X = N.wasmBinary),
                    "object" != typeof WebAssembly && i("no native wasm support detected");
                    var Z,
                        ee,
                        te,
                        ne,
                        re,
                        oe,
                        ie = !1,
                        ae = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0,
                        se = [],
                        le = [],
                        ce = [],
                        ue = !1,
                        de = 0,
                        pe = null,
                        he = "draco_decoder.wasm";
                    he.startsWith("data:application/octet-stream;base64,") || (oe = he, he = N.locateFile ? N.locateFile(oe, V) : V + oe);
                    var fe = [null, [], []],
                        ge = {
                            b: function(e, t, n) {
                                throw new l(e).init(t, n), e
                            },
                            a: function() {
                                i("")
                            },
                            g: function(e, t, n) {
                                te.copyWithin(e, t, t + n)
                            },
                            e: function(e) {
                                var t = te.length;
                                if (2147483648 < (e >>>= 0))
                                    return !1;
                                for (var n = 1; 4 >= n; n *= 2) {
                                    var r = t * (1 + .2 / n);
                                    r = Math.min(r, e + 100663296);
                                    var i = Math;
                                    r = Math.max(e, r),
                                    i = i.min.call(i, 2147483648, r + (65536 - r % 65536) % 65536);
                                    e:
                                    {
                                        r = Z.buffer;
                                        try {
                                            Z.grow(i - r.byteLength + 65535 >>> 16),
                                            o();
                                            var a = 1;
                                            break e
                                        } catch (s) {}
                                        a = void 0
                                    }if (a)
                                        return !0
                                }
                                return !1
                            },
                            f: function(e) {
                                return 52
                            },
                            d: function(e, t, n, r, o) {
                                return 70
                            },
                            c: function(e, n, r, o) {
                                for (var i = 0, a = 0; a < r; a++) {
                                    var s = re[n >> 2],
                                        l = re[n + 4 >> 2];
                                    n += 8;
                                    for (var c = 0; c < l; c++) {
                                        var u = te[s + c],
                                            d = fe[e];
                                        0 === u || 10 === u ? ((1 === e ? Y : J)(t(d, 0)), d.length = 0) : d.push(u)
                                    }
                                    i += l
                                }
                                return re[o >> 2] = i, 0
                            }
                        };
                    !function() {
                        function e(e, t) {
                            N.asm = e.exports,
                            Z = N.asm.h,
                            o(),
                            le.unshift(N.asm.i),
                            de--,
                            N.monitorRunDependencies && N.monitorRunDependencies(de),
                            0 == de && pe && (e = pe, pe = null, e())
                        }
                        function t(t) {
                            e(t.instance)
                        }
                        function n(e) {
                            return function() {
                                if (!X && (Q || G)) {
                                    if ("function" == typeof fetch && !he.startsWith("file://"))
                                        return fetch(he, {
                                            credentials: "same-origin"
                                        }).then(function(e) {
                                            if (!e.ok)
                                                throw "failed to load wasm binary file at '" + he + "'";
                                            return e.arrayBuffer()
                                        }).catch(function() {
                                            return a(he)
                                        });
                                    if (q)
                                        return new Promise(function(e, t) {
                                            q(he, function(t) {
                                                e(new Uint8Array(t))
                                            }, t)
                                        })
                                }
                                return Promise.resolve().then(function() {
                                    return a(he)
                                })
                            }().then(function(e) {
                                return WebAssembly.instantiate(e, r)
                            }).then(function(e) {
                                return e
                            }).then(e, function(e) {
                                J("failed to asynchronously prepare wasm: " + e),
                                i(e)
                            })
                        }
                        var r = {
                            a: ge
                        };
                        if (de++, N.monitorRunDependencies && N.monitorRunDependencies(de), N.instantiateWasm)
                            try {
                                return N.instantiateWasm(r, e)
                            } catch (s) {
                                J("Module.instantiateWasm callback failed with error: " + s),
                                L(s)
                            }
                        (X || "function" != typeof WebAssembly.instantiateStreaming || he.startsWith("data:application/octet-stream;base64,") || he.startsWith("file://") || j || "function" != typeof fetch ? n(t) : fetch(he, {
                            credentials: "same-origin"
                        }).then(function(e) {
                            return WebAssembly.instantiateStreaming(e, r).then(t, function(e) {
                                return J("wasm streaming compile failed: " + e), J("falling back to ArrayBuffer instantiation"), n(t)
                            })
                        })).catch(L)
                    }();
                    var me = N._emscripten_bind_VoidPtr___destroy___0 = function() {
                            return (me = N._emscripten_bind_VoidPtr___destroy___0 = N.asm.k).apply(null, arguments)
                        },
                        be = N._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = function() {
                            return (be = N._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = N.asm.l).apply(null, arguments)
                        },
                        Ae = N._emscripten_bind_DecoderBuffer_Init_2 = function() {
                            return (Ae = N._emscripten_bind_DecoderBuffer_Init_2 = N.asm.m).apply(null, arguments)
                        },
                        ye = N._emscripten_bind_DecoderBuffer___destroy___0 = function() {
                            return (ye = N._emscripten_bind_DecoderBuffer___destroy___0 = N.asm.n).apply(null, arguments)
                        },
                        ve = N._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = function() {
                            return (ve = N._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = N.asm.o).apply(null, arguments)
                        },
                        _e = N._emscripten_bind_AttributeTransformData_transform_type_0 = function() {
                            return (_e = N._emscripten_bind_AttributeTransformData_transform_type_0 = N.asm.p).apply(null, arguments)
                        },
                        xe = N._emscripten_bind_AttributeTransformData___destroy___0 = function() {
                            return (xe = N._emscripten_bind_AttributeTransformData___destroy___0 = N.asm.q).apply(null, arguments)
                        },
                        we = N._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
                            return (we = N._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = N.asm.r).apply(null, arguments)
                        },
                        Ce = N._emscripten_bind_GeometryAttribute___destroy___0 = function() {
                            return (Ce = N._emscripten_bind_GeometryAttribute___destroy___0 = N.asm.s).apply(null, arguments)
                        },
                        Ee = N._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
                            return (Ee = N._emscripten_bind_PointAttribute_PointAttribute_0 = N.asm.t).apply(null, arguments)
                        },
                        Se = N._emscripten_bind_PointAttribute_size_0 = function() {
                            return (Se = N._emscripten_bind_PointAttribute_size_0 = N.asm.u).apply(null, arguments)
                        },
                        Ie = N._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = function() {
                            return (Ie = N._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = N.asm.v).apply(null, arguments)
                        },
                        Te = N._emscripten_bind_PointAttribute_attribute_type_0 = function() {
                            return (Te = N._emscripten_bind_PointAttribute_attribute_type_0 = N.asm.w).apply(null, arguments)
                        },
                        Me = N._emscripten_bind_PointAttribute_data_type_0 = function() {
                            return (Me = N._emscripten_bind_PointAttribute_data_type_0 = N.asm.x).apply(null, arguments)
                        },
                        Re = N._emscripten_bind_PointAttribute_num_components_0 = function() {
                            return (Re = N._emscripten_bind_PointAttribute_num_components_0 = N.asm.y).apply(null, arguments)
                        },
                        Be = N._emscripten_bind_PointAttribute_normalized_0 = function() {
                            return (Be = N._emscripten_bind_PointAttribute_normalized_0 = N.asm.z).apply(null, arguments)
                        },
                        ke = N._emscripten_bind_PointAttribute_byte_stride_0 = function() {
                            return (ke = N._emscripten_bind_PointAttribute_byte_stride_0 = N.asm.A).apply(null, arguments)
                        },
                        De = N._emscripten_bind_PointAttribute_byte_offset_0 = function() {
                            return (De = N._emscripten_bind_PointAttribute_byte_offset_0 = N.asm.B).apply(null, arguments)
                        },
                        Pe = N._emscripten_bind_PointAttribute_unique_id_0 = function() {
                            return (Pe = N._emscripten_bind_PointAttribute_unique_id_0 = N.asm.C).apply(null, arguments)
                        },
                        Oe = N._emscripten_bind_PointAttribute___destroy___0 = function() {
                            return (Oe = N._emscripten_bind_PointAttribute___destroy___0 = N.asm.D).apply(null, arguments)
                        },
                        Le = N._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = function() {
                            return (Le = N._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = N.asm.E).apply(null, arguments)
                        },
                        Ne = N._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = function() {
                            return (Ne = N._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = N.asm.F).apply(null, arguments)
                        },
                        Fe = N._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = function() {
                            return (Fe = N._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = N.asm.G).apply(null, arguments)
                        },
                        Ue = N._emscripten_bind_AttributeQuantizationTransform_min_value_1 = function() {
                            return (Ue = N._emscripten_bind_AttributeQuantizationTransform_min_value_1 = N.asm.H).apply(null, arguments)
                        },
                        ze = N._emscripten_bind_AttributeQuantizationTransform_range_0 = function() {
                            return (ze = N._emscripten_bind_AttributeQuantizationTransform_range_0 = N.asm.I).apply(null, arguments)
                        },
                        Qe = N._emscripten_bind_AttributeQuantizationTransform___destroy___0 = function() {
                            return (Qe = N._emscripten_bind_AttributeQuantizationTransform___destroy___0 = N.asm.J).apply(null, arguments)
                        },
                        Ge = N._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = function() {
                            return (Ge = N._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = N.asm.K).apply(null, arguments)
                        },
                        je = N._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = function() {
                            return (je = N._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = N.asm.L).apply(null, arguments)
                        },
                        Ve = N._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = function() {
                            return (Ve = N._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = N.asm.M).apply(null, arguments)
                        },
                        He = N._emscripten_bind_AttributeOctahedronTransform___destroy___0 = function() {
                            return (He = N._emscripten_bind_AttributeOctahedronTransform___destroy___0 = N.asm.N).apply(null, arguments)
                        },
                        $e = N._emscripten_bind_PointCloud_PointCloud_0 = function() {
                            return ($e = N._emscripten_bind_PointCloud_PointCloud_0 = N.asm.O).apply(null, arguments)
                        },
                        We = N._emscripten_bind_PointCloud_num_attributes_0 = function() {
                            return (We = N._emscripten_bind_PointCloud_num_attributes_0 = N.asm.P).apply(null, arguments)
                        },
                        Ke = N._emscripten_bind_PointCloud_num_points_0 = function() {
                            return (Ke = N._emscripten_bind_PointCloud_num_points_0 = N.asm.Q).apply(null, arguments)
                        },
                        qe = N._emscripten_bind_PointCloud___destroy___0 = function() {
                            return (qe = N._emscripten_bind_PointCloud___destroy___0 = N.asm.R).apply(null, arguments)
                        },
                        Xe = N._emscripten_bind_Mesh_Mesh_0 = function() {
                            return (Xe = N._emscripten_bind_Mesh_Mesh_0 = N.asm.S).apply(null, arguments)
                        },
                        Ye = N._emscripten_bind_Mesh_num_faces_0 = function() {
                            return (Ye = N._emscripten_bind_Mesh_num_faces_0 = N.asm.T).apply(null, arguments)
                        },
                        Je = N._emscripten_bind_Mesh_num_attributes_0 = function() {
                            return (Je = N._emscripten_bind_Mesh_num_attributes_0 = N.asm.U).apply(null, arguments)
                        },
                        Ze = N._emscripten_bind_Mesh_num_points_0 = function() {
                            return (Ze = N._emscripten_bind_Mesh_num_points_0 = N.asm.V).apply(null, arguments)
                        },
                        et = N._emscripten_bind_Mesh___destroy___0 = function() {
                            return (et = N._emscripten_bind_Mesh___destroy___0 = N.asm.W).apply(null, arguments)
                        },
                        tt = N._emscripten_bind_Metadata_Metadata_0 = function() {
                            return (tt = N._emscripten_bind_Metadata_Metadata_0 = N.asm.X).apply(null, arguments)
                        },
                        nt = N._emscripten_bind_Metadata___destroy___0 = function() {
                            return (nt = N._emscripten_bind_Metadata___destroy___0 = N.asm.Y).apply(null, arguments)
                        },
                        rt = N._emscripten_bind_Status_code_0 = function() {
                            return (rt = N._emscripten_bind_Status_code_0 = N.asm.Z).apply(null, arguments)
                        },
                        ot = N._emscripten_bind_Status_ok_0 = function() {
                            return (ot = N._emscripten_bind_Status_ok_0 = N.asm._).apply(null, arguments)
                        },
                        it = N._emscripten_bind_Status_error_msg_0 = function() {
                            return (it = N._emscripten_bind_Status_error_msg_0 = N.asm.$).apply(null, arguments)
                        },
                        at = N._emscripten_bind_Status___destroy___0 = function() {
                            return (at = N._emscripten_bind_Status___destroy___0 = N.asm.aa).apply(null, arguments)
                        },
                        st = N._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = function() {
                            return (st = N._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = N.asm.ba).apply(null, arguments)
                        },
                        lt = N._emscripten_bind_DracoFloat32Array_GetValue_1 = function() {
                            return (lt = N._emscripten_bind_DracoFloat32Array_GetValue_1 = N.asm.ca).apply(null, arguments)
                        },
                        ct = N._emscripten_bind_DracoFloat32Array_size_0 = function() {
                            return (ct = N._emscripten_bind_DracoFloat32Array_size_0 = N.asm.da).apply(null, arguments)
                        },
                        ut = N._emscripten_bind_DracoFloat32Array___destroy___0 = function() {
                            return (ut = N._emscripten_bind_DracoFloat32Array___destroy___0 = N.asm.ea).apply(null, arguments)
                        },
                        dt = N._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
                            return (dt = N._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = N.asm.fa).apply(null, arguments)
                        },
                        pt = N._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
                            return (pt = N._emscripten_bind_DracoInt8Array_GetValue_1 = N.asm.ga).apply(null, arguments)
                        },
                        ht = N._emscripten_bind_DracoInt8Array_size_0 = function() {
                            return (ht = N._emscripten_bind_DracoInt8Array_size_0 = N.asm.ha).apply(null, arguments)
                        },
                        ft = N._emscripten_bind_DracoInt8Array___destroy___0 = function() {
                            return (ft = N._emscripten_bind_DracoInt8Array___destroy___0 = N.asm.ia).apply(null, arguments)
                        },
                        gt = N._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = function() {
                            return (gt = N._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = N.asm.ja).apply(null, arguments)
                        },
                        mt = N._emscripten_bind_DracoUInt8Array_GetValue_1 = function() {
                            return (mt = N._emscripten_bind_DracoUInt8Array_GetValue_1 = N.asm.ka).apply(null, arguments)
                        },
                        bt = N._emscripten_bind_DracoUInt8Array_size_0 = function() {
                            return (bt = N._emscripten_bind_DracoUInt8Array_size_0 = N.asm.la).apply(null, arguments)
                        },
                        At = N._emscripten_bind_DracoUInt8Array___destroy___0 = function() {
                            return (At = N._emscripten_bind_DracoUInt8Array___destroy___0 = N.asm.ma).apply(null, arguments)
                        },
                        yt = N._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = function() {
                            return (yt = N._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = N.asm.na).apply(null, arguments)
                        },
                        vt = N._emscripten_bind_DracoInt16Array_GetValue_1 = function() {
                            return (vt = N._emscripten_bind_DracoInt16Array_GetValue_1 = N.asm.oa).apply(null, arguments)
                        },
                        _t = N._emscripten_bind_DracoInt16Array_size_0 = function() {
                            return (_t = N._emscripten_bind_DracoInt16Array_size_0 = N.asm.pa).apply(null, arguments)
                        },
                        xt = N._emscripten_bind_DracoInt16Array___destroy___0 = function() {
                            return (xt = N._emscripten_bind_DracoInt16Array___destroy___0 = N.asm.qa).apply(null, arguments)
                        },
                        wt = N._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = function() {
                            return (wt = N._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = N.asm.ra).apply(null, arguments)
                        },
                        Ct = N._emscripten_bind_DracoUInt16Array_GetValue_1 = function() {
                            return (Ct = N._emscripten_bind_DracoUInt16Array_GetValue_1 = N.asm.sa).apply(null, arguments)
                        },
                        Et = N._emscripten_bind_DracoUInt16Array_size_0 = function() {
                            return (Et = N._emscripten_bind_DracoUInt16Array_size_0 = N.asm.ta).apply(null, arguments)
                        },
                        St = N._emscripten_bind_DracoUInt16Array___destroy___0 = function() {
                            return (St = N._emscripten_bind_DracoUInt16Array___destroy___0 = N.asm.ua).apply(null, arguments)
                        },
                        It = N._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = function() {
                            return (It = N._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = N.asm.va).apply(null, arguments)
                        },
                        Tt = N._emscripten_bind_DracoInt32Array_GetValue_1 = function() {
                            return (Tt = N._emscripten_bind_DracoInt32Array_GetValue_1 = N.asm.wa).apply(null, arguments)
                        },
                        Mt = N._emscripten_bind_DracoInt32Array_size_0 = function() {
                            return (Mt = N._emscripten_bind_DracoInt32Array_size_0 = N.asm.xa).apply(null, arguments)
                        },
                        Rt = N._emscripten_bind_DracoInt32Array___destroy___0 = function() {
                            return (Rt = N._emscripten_bind_DracoInt32Array___destroy___0 = N.asm.ya).apply(null, arguments)
                        },
                        Bt = N._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = function() {
                            return (Bt = N._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = N.asm.za).apply(null, arguments)
                        },
                        kt = N._emscripten_bind_DracoUInt32Array_GetValue_1 = function() {
                            return (kt = N._emscripten_bind_DracoUInt32Array_GetValue_1 = N.asm.Aa).apply(null, arguments)
                        },
                        Dt = N._emscripten_bind_DracoUInt32Array_size_0 = function() {
                            return (Dt = N._emscripten_bind_DracoUInt32Array_size_0 = N.asm.Ba).apply(null, arguments)
                        },
                        Pt = N._emscripten_bind_DracoUInt32Array___destroy___0 = function() {
                            return (Pt = N._emscripten_bind_DracoUInt32Array___destroy___0 = N.asm.Ca).apply(null, arguments)
                        },
                        Ot = N._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = function() {
                            return (Ot = N._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = N.asm.Da).apply(null, arguments)
                        },
                        Lt = N._emscripten_bind_MetadataQuerier_HasEntry_2 = function() {
                            return (Lt = N._emscripten_bind_MetadataQuerier_HasEntry_2 = N.asm.Ea).apply(null, arguments)
                        },
                        Nt = N._emscripten_bind_MetadataQuerier_GetIntEntry_2 = function() {
                            return (Nt = N._emscripten_bind_MetadataQuerier_GetIntEntry_2 = N.asm.Fa).apply(null, arguments)
                        },
                        Ft = N._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = function() {
                            return (Ft = N._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = N.asm.Ga).apply(null, arguments)
                        },
                        Ut = N._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = function() {
                            return (Ut = N._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = N.asm.Ha).apply(null, arguments)
                        },
                        zt = N._emscripten_bind_MetadataQuerier_GetStringEntry_2 = function() {
                            return (zt = N._emscripten_bind_MetadataQuerier_GetStringEntry_2 = N.asm.Ia).apply(null, arguments)
                        },
                        Qt = N._emscripten_bind_MetadataQuerier_NumEntries_1 = function() {
                            return (Qt = N._emscripten_bind_MetadataQuerier_NumEntries_1 = N.asm.Ja).apply(null, arguments)
                        },
                        Gt = N._emscripten_bind_MetadataQuerier_GetEntryName_2 = function() {
                            return (Gt = N._emscripten_bind_MetadataQuerier_GetEntryName_2 = N.asm.Ka).apply(null, arguments)
                        },
                        jt = N._emscripten_bind_MetadataQuerier___destroy___0 = function() {
                            return (jt = N._emscripten_bind_MetadataQuerier___destroy___0 = N.asm.La).apply(null, arguments)
                        },
                        Vt = N._emscripten_bind_Decoder_Decoder_0 = function() {
                            return (Vt = N._emscripten_bind_Decoder_Decoder_0 = N.asm.Ma).apply(null, arguments)
                        },
                        Ht = N._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = function() {
                            return (Ht = N._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = N.asm.Na).apply(null, arguments)
                        },
                        $t = N._emscripten_bind_Decoder_DecodeArrayToMesh_3 = function() {
                            return ($t = N._emscripten_bind_Decoder_DecodeArrayToMesh_3 = N.asm.Oa).apply(null, arguments)
                        },
                        Wt = N._emscripten_bind_Decoder_GetAttributeId_2 = function() {
                            return (Wt = N._emscripten_bind_Decoder_GetAttributeId_2 = N.asm.Pa).apply(null, arguments)
                        },
                        Kt = N._emscripten_bind_Decoder_GetAttributeIdByName_2 = function() {
                            return (Kt = N._emscripten_bind_Decoder_GetAttributeIdByName_2 = N.asm.Qa).apply(null, arguments)
                        },
                        qt = N._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = function() {
                            return (qt = N._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = N.asm.Ra).apply(null, arguments)
                        },
                        Xt = N._emscripten_bind_Decoder_GetAttribute_2 = function() {
                            return (Xt = N._emscripten_bind_Decoder_GetAttribute_2 = N.asm.Sa).apply(null, arguments)
                        },
                        Yt = N._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = function() {
                            return (Yt = N._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = N.asm.Ta).apply(null, arguments)
                        },
                        Jt = N._emscripten_bind_Decoder_GetMetadata_1 = function() {
                            return (Jt = N._emscripten_bind_Decoder_GetMetadata_1 = N.asm.Ua).apply(null, arguments)
                        },
                        Zt = N._emscripten_bind_Decoder_GetAttributeMetadata_2 = function() {
                            return (Zt = N._emscripten_bind_Decoder_GetAttributeMetadata_2 = N.asm.Va).apply(null, arguments)
                        },
                        en = N._emscripten_bind_Decoder_GetFaceFromMesh_3 = function() {
                            return (en = N._emscripten_bind_Decoder_GetFaceFromMesh_3 = N.asm.Wa).apply(null, arguments)
                        },
                        tn = N._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = function() {
                            return (tn = N._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = N.asm.Xa).apply(null, arguments)
                        },
                        nn = N._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = function() {
                            return (nn = N._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = N.asm.Ya).apply(null, arguments)
                        },
                        rn = N._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = function() {
                            return (rn = N._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = N.asm.Za).apply(null, arguments)
                        },
                        on = N._emscripten_bind_Decoder_GetAttributeFloat_3 = function() {
                            return (on = N._emscripten_bind_Decoder_GetAttributeFloat_3 = N.asm._a).apply(null, arguments)
                        },
                        an = N._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = function() {
                            return (an = N._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = N.asm.$a).apply(null, arguments)
                        },
                        sn = N._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = function() {
                            return (sn = N._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = N.asm.ab).apply(null, arguments)
                        },
                        ln = N._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = function() {
                            return (ln = N._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = N.asm.bb).apply(null, arguments)
                        },
                        cn = N._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = function() {
                            return (cn = N._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = N.asm.cb).apply(null, arguments)
                        },
                        un = N._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = function() {
                            return (un = N._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = N.asm.db).apply(null, arguments)
                        },
                        dn = N._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = function() {
                            return (dn = N._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = N.asm.eb).apply(null, arguments)
                        },
                        pn = N._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = function() {
                            return (pn = N._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = N.asm.fb).apply(null, arguments)
                        },
                        hn = N._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = function() {
                            return (hn = N._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = N.asm.gb).apply(null, arguments)
                        },
                        fn = N._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = function() {
                            return (fn = N._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = N.asm.hb).apply(null, arguments)
                        },
                        gn = N._emscripten_bind_Decoder_SkipAttributeTransform_1 = function() {
                            return (gn = N._emscripten_bind_Decoder_SkipAttributeTransform_1 = N.asm.ib).apply(null, arguments)
                        },
                        mn = N._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = function() {
                            return (mn = N._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = N.asm.jb).apply(null, arguments)
                        },
                        bn = N._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = function() {
                            return (bn = N._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = N.asm.kb).apply(null, arguments)
                        },
                        An = N._emscripten_bind_Decoder_DecodeBufferToMesh_2 = function() {
                            return (An = N._emscripten_bind_Decoder_DecodeBufferToMesh_2 = N.asm.lb).apply(null, arguments)
                        },
                        yn = N._emscripten_bind_Decoder___destroy___0 = function() {
                            return (yn = N._emscripten_bind_Decoder___destroy___0 = N.asm.mb).apply(null, arguments)
                        },
                        vn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = function() {
                            return (vn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = N.asm.nb).apply(null, arguments)
                        },
                        _n = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = function() {
                            return (_n = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = N.asm.ob).apply(null, arguments)
                        },
                        xn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = function() {
                            return (xn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = N.asm.pb).apply(null, arguments)
                        },
                        wn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = function() {
                            return (wn = N._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = N.asm.qb).apply(null, arguments)
                        },
                        Cn = N._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
                            return (Cn = N._emscripten_enum_draco_GeometryAttribute_Type_INVALID = N.asm.rb).apply(null, arguments)
                        },
                        En = N._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
                            return (En = N._emscripten_enum_draco_GeometryAttribute_Type_POSITION = N.asm.sb).apply(null, arguments)
                        },
                        Sn = N._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
                            return (Sn = N._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = N.asm.tb).apply(null, arguments)
                        },
                        In = N._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
                            return (In = N._emscripten_enum_draco_GeometryAttribute_Type_COLOR = N.asm.ub).apply(null, arguments)
                        },
                        Tn = N._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
                            return (Tn = N._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = N.asm.vb).apply(null, arguments)
                        },
                        Mn = N._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
                            return (Mn = N._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = N.asm.wb).apply(null, arguments)
                        },
                        Rn = N._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
                            return (Rn = N._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = N.asm.xb).apply(null, arguments)
                        },
                        Bn = N._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
                            return (Bn = N._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = N.asm.yb).apply(null, arguments)
                        },
                        kn = N._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
                            return (kn = N._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = N.asm.zb).apply(null, arguments)
                        },
                        Dn = N._emscripten_enum_draco_DataType_DT_INVALID = function() {
                            return (Dn = N._emscripten_enum_draco_DataType_DT_INVALID = N.asm.Ab).apply(null, arguments)
                        },
                        Pn = N._emscripten_enum_draco_DataType_DT_INT8 = function() {
                            return (Pn = N._emscripten_enum_draco_DataType_DT_INT8 = N.asm.Bb).apply(null, arguments)
                        },
                        On = N._emscripten_enum_draco_DataType_DT_UINT8 = function() {
                            return (On = N._emscripten_enum_draco_DataType_DT_UINT8 = N.asm.Cb).apply(null, arguments)
                        },
                        Ln = N._emscripten_enum_draco_DataType_DT_INT16 = function() {
                            return (Ln = N._emscripten_enum_draco_DataType_DT_INT16 = N.asm.Db).apply(null, arguments)
                        },
                        Nn = N._emscripten_enum_draco_DataType_DT_UINT16 = function() {
                            return (Nn = N._emscripten_enum_draco_DataType_DT_UINT16 = N.asm.Eb).apply(null, arguments)
                        },
                        Fn = N._emscripten_enum_draco_DataType_DT_INT32 = function() {
                            return (Fn = N._emscripten_enum_draco_DataType_DT_INT32 = N.asm.Fb).apply(null, arguments)
                        },
                        Un = N._emscripten_enum_draco_DataType_DT_UINT32 = function() {
                            return (Un = N._emscripten_enum_draco_DataType_DT_UINT32 = N.asm.Gb).apply(null, arguments)
                        },
                        zn = N._emscripten_enum_draco_DataType_DT_INT64 = function() {
                            return (zn = N._emscripten_enum_draco_DataType_DT_INT64 = N.asm.Hb).apply(null, arguments)
                        },
                        Qn = N._emscripten_enum_draco_DataType_DT_UINT64 = function() {
                            return (Qn = N._emscripten_enum_draco_DataType_DT_UINT64 = N.asm.Ib).apply(null, arguments)
                        },
                        Gn = N._emscripten_enum_draco_DataType_DT_FLOAT32 = function() {
                            return (Gn = N._emscripten_enum_draco_DataType_DT_FLOAT32 = N.asm.Jb).apply(null, arguments)
                        },
                        jn = N._emscripten_enum_draco_DataType_DT_FLOAT64 = function() {
                            return (jn = N._emscripten_enum_draco_DataType_DT_FLOAT64 = N.asm.Kb).apply(null, arguments)
                        },
                        Vn = N._emscripten_enum_draco_DataType_DT_BOOL = function() {
                            return (Vn = N._emscripten_enum_draco_DataType_DT_BOOL = N.asm.Lb).apply(null, arguments)
                        },
                        Hn = N._emscripten_enum_draco_DataType_DT_TYPES_COUNT = function() {
                            return (Hn = N._emscripten_enum_draco_DataType_DT_TYPES_COUNT = N.asm.Mb).apply(null, arguments)
                        },
                        $n = N._emscripten_enum_draco_StatusCode_OK = function() {
                            return ($n = N._emscripten_enum_draco_StatusCode_OK = N.asm.Nb).apply(null, arguments)
                        },
                        Wn = N._emscripten_enum_draco_StatusCode_DRACO_ERROR = function() {
                            return (Wn = N._emscripten_enum_draco_StatusCode_DRACO_ERROR = N.asm.Ob).apply(null, arguments)
                        },
                        Kn = N._emscripten_enum_draco_StatusCode_IO_ERROR = function() {
                            return (Kn = N._emscripten_enum_draco_StatusCode_IO_ERROR = N.asm.Pb).apply(null, arguments)
                        },
                        qn = N._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = function() {
                            return (qn = N._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = N.asm.Qb).apply(null, arguments)
                        },
                        Xn = N._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = function() {
                            return (Xn = N._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = N.asm.Rb).apply(null, arguments)
                        },
                        Yn = N._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = function() {
                            return (Yn = N._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = N.asm.Sb).apply(null, arguments)
                        };
                    N._malloc = function() {
                        return (N._malloc = N.asm.Tb).apply(null, arguments)
                    },
                    N._free = function() {
                        return (N._free = N.asm.Ub).apply(null, arguments)
                    };
                    var Jn,
                        Zn = function() {
                            return (Zn = N.asm.Vb).apply(null, arguments)
                        };
                    if (N.___start_em_js = 15856, N.___stop_em_js = 15954, pe = function e() {
                        Jn || c(),
                        Jn || (pe = e)
                    }, N.preInit)
                        for ("function" == typeof N.preInit && (N.preInit = [N.preInit]); 0 < N.preInit.length;)
                            N.preInit.pop()();
                    c(),
                    u.prototype = Object.create(u.prototype),
                    u.prototype.constructor = u,
                    u.prototype.__class__ = u,
                    u.__cache__ = {},
                    N.WrapperObject = u,
                    N.getCache = d,
                    N.wrapPointer = p,
                    N.castObject = function(e, t) {
                        return p(e.ptr, t)
                    },
                    N.NULL = p(0),
                    N.destroy = function(e) {
                        if (!e.__destroy__)
                            throw "Error: Cannot destroy object. (Did you create it yourself?)";
                        e.__destroy__(),
                        delete d(e.__class__)[e.ptr]
                    },
                    N.compare = function(e, t) {
                        return e.ptr === t.ptr
                    },
                    N.getPointer = function(e) {
                        return e.ptr
                    },
                    N.getClass = function(e) {
                        return e.__class__
                    };
                    var er = {
                        buffer: 0,
                        size: 0,
                        pos: 0,
                        temps: [],
                        needed: 0,
                        prepare: function() {
                            if (er.needed) {
                                for (var e = 0; e < er.temps.length; e++)
                                    N._free(er.temps[e]);
                                er.temps.length = 0,
                                N._free(er.buffer),
                                er.buffer = 0,
                                er.size += er.needed,
                                er.needed = 0
                            }
                            er.buffer || (er.size += 128, er.buffer = N._malloc(er.size), er.buffer || i(void 0)),
                            er.pos = 0
                        },
                        alloc: function(e, t) {
                            return er.buffer || i(void 0), e = 7 + (e = e.length * t.BYTES_PER_ELEMENT) & -8, er.pos + e >= er.size ? (0 < e || i(void 0), er.needed += e, t = N._malloc(e), er.temps.push(t)) : (t = er.buffer + er.pos, er.pos += e), t
                        },
                        copy: function(e, t, n) {
                            switch (n >>>= 0, t.BYTES_PER_ELEMENT) {
                            case 2:
                                n >>>= 1;
                                break;
                            case 4:
                                n >>>= 2;
                                break;
                            case 8:
                                n >>>= 3
                            }
                            for (var r = 0; r < e.length; r++)
                                t[n + r] = e[r]
                        }
                    };
                    return g.prototype = Object.create(u.prototype), g.prototype.constructor = g, g.prototype.__class__ = g, g.__cache__ = {}, N.VoidPtr = g, g.prototype.__destroy__ = g.prototype.__destroy__ = function() {
                        me(this.ptr)
                    }, m.prototype = Object.create(u.prototype), m.prototype.constructor = m, m.prototype.__class__ = m, m.__cache__ = {}, N.DecoderBuffer = m, m.prototype.Init = m.prototype.Init = function(e, t) {
                        var n = this.ptr;
                        er.prepare(),
                        "object" == typeof e && (e = f(e)),
                        t && "object" == typeof t && (t = t.ptr),
                        Ae(n, e, t)
                    }, m.prototype.__destroy__ = m.prototype.__destroy__ = function() {
                        ye(this.ptr)
                    }, b.prototype = Object.create(u.prototype), b.prototype.constructor = b, b.prototype.__class__ = b, b.__cache__ = {}, N.AttributeTransformData = b, b.prototype.transform_type = b.prototype.transform_type = function() {
                        return _e(this.ptr)
                    }, b.prototype.__destroy__ = b.prototype.__destroy__ = function() {
                        xe(this.ptr)
                    }, A.prototype = Object.create(u.prototype), A.prototype.constructor = A, A.prototype.__class__ = A, A.__cache__ = {}, N.GeometryAttribute = A, A.prototype.__destroy__ = A.prototype.__destroy__ = function() {
                        Ce(this.ptr)
                    }, y.prototype = Object.create(u.prototype), y.prototype.constructor = y, y.prototype.__class__ = y, y.__cache__ = {}, N.PointAttribute = y, y.prototype.size = y.prototype.size = function() {
                        return Se(this.ptr)
                    }, y.prototype.GetAttributeTransformData = y.prototype.GetAttributeTransformData = function() {
                        return p(Ie(this.ptr), b)
                    }, y.prototype.attribute_type = y.prototype.attribute_type = function() {
                        return Te(this.ptr)
                    }, y.prototype.data_type = y.prototype.data_type = function() {
                        return Me(this.ptr)
                    }, y.prototype.num_components = y.prototype.num_components = function() {
                        return Re(this.ptr)
                    }, y.prototype.normalized = y.prototype.normalized = function() {
                        return !!Be(this.ptr)
                    }, y.prototype.byte_stride = y.prototype.byte_stride = function() {
                        return ke(this.ptr)
                    }, y.prototype.byte_offset = y.prototype.byte_offset = function() {
                        return De(this.ptr)
                    }, y.prototype.unique_id = y.prototype.unique_id = function() {
                        return Pe(this.ptr)
                    }, y.prototype.__destroy__ = y.prototype.__destroy__ = function() {
                        Oe(this.ptr)
                    }, v.prototype = Object.create(u.prototype), v.prototype.constructor = v, v.prototype.__class__ = v, v.__cache__ = {}, N.AttributeQuantizationTransform = v, v.prototype.InitFromAttribute = v.prototype.InitFromAttribute = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), !!Ne(t, e)
                    }, v.prototype.quantization_bits = v.prototype.quantization_bits = function() {
                        return Fe(this.ptr)
                    }, v.prototype.min_value = v.prototype.min_value = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), Ue(t, e)
                    }, v.prototype.range = v.prototype.range = function() {
                        return ze(this.ptr)
                    }, v.prototype.__destroy__ = v.prototype.__destroy__ = function() {
                        Qe(this.ptr)
                    }, _.prototype = Object.create(u.prototype), _.prototype.constructor = _, _.prototype.__class__ = _, _.__cache__ = {}, N.AttributeOctahedronTransform = _, _.prototype.InitFromAttribute = _.prototype.InitFromAttribute = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), !!je(t, e)
                    }, _.prototype.quantization_bits = _.prototype.quantization_bits = function() {
                        return Ve(this.ptr)
                    }, _.prototype.__destroy__ = _.prototype.__destroy__ = function() {
                        He(this.ptr)
                    }, x.prototype = Object.create(u.prototype), x.prototype.constructor = x, x.prototype.__class__ = x, x.__cache__ = {}, N.PointCloud = x, x.prototype.num_attributes = x.prototype.num_attributes = function() {
                        return We(this.ptr)
                    }, x.prototype.num_points = x.prototype.num_points = function() {
                        return Ke(this.ptr)
                    }, x.prototype.__destroy__ = x.prototype.__destroy__ = function() {
                        qe(this.ptr)
                    }, w.prototype = Object.create(u.prototype), w.prototype.constructor = w, w.prototype.__class__ = w, w.__cache__ = {}, N.Mesh = w, w.prototype.num_faces = w.prototype.num_faces = function() {
                        return Ye(this.ptr)
                    }, w.prototype.num_attributes = w.prototype.num_attributes = function() {
                        return Je(this.ptr)
                    }, w.prototype.num_points = w.prototype.num_points = function() {
                        return Ze(this.ptr)
                    }, w.prototype.__destroy__ = w.prototype.__destroy__ = function() {
                        et(this.ptr)
                    }, C.prototype = Object.create(u.prototype), C.prototype.constructor = C, C.prototype.__class__ = C, C.__cache__ = {}, N.Metadata = C, C.prototype.__destroy__ = C.prototype.__destroy__ = function() {
                        nt(this.ptr)
                    }, E.prototype = Object.create(u.prototype), E.prototype.constructor = E, E.prototype.__class__ = E, E.__cache__ = {}, N.Status = E, E.prototype.code = E.prototype.code = function() {
                        return rt(this.ptr)
                    }, E.prototype.ok = E.prototype.ok = function() {
                        return !!ot(this.ptr)
                    }, E.prototype.error_msg = E.prototype.error_msg = function() {
                        return r(it(this.ptr))
                    }, E.prototype.__destroy__ = E.prototype.__destroy__ = function() {
                        at(this.ptr)
                    }, S.prototype = Object.create(u.prototype), S.prototype.constructor = S, S.prototype.__class__ = S, S.__cache__ = {}, N.DracoFloat32Array = S, S.prototype.GetValue = S.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), lt(t, e)
                    }, S.prototype.size = S.prototype.size = function() {
                        return ct(this.ptr)
                    }, S.prototype.__destroy__ = S.prototype.__destroy__ = function() {
                        ut(this.ptr)
                    }, I.prototype = Object.create(u.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, N.DracoInt8Array = I, I.prototype.GetValue = I.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), pt(t, e)
                    }, I.prototype.size = I.prototype.size = function() {
                        return ht(this.ptr)
                    }, I.prototype.__destroy__ = I.prototype.__destroy__ = function() {
                        ft(this.ptr)
                    }, T.prototype = Object.create(u.prototype), T.prototype.constructor = T, T.prototype.__class__ = T, T.__cache__ = {}, N.DracoUInt8Array = T, T.prototype.GetValue = T.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), mt(t, e)
                    }, T.prototype.size = T.prototype.size = function() {
                        return bt(this.ptr)
                    }, T.prototype.__destroy__ = T.prototype.__destroy__ = function() {
                        At(this.ptr)
                    }, M.prototype = Object.create(u.prototype), M.prototype.constructor = M, M.prototype.__class__ = M, M.__cache__ = {}, N.DracoInt16Array = M, M.prototype.GetValue = M.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), vt(t, e)
                    }, M.prototype.size = M.prototype.size = function() {
                        return _t(this.ptr)
                    }, M.prototype.__destroy__ = M.prototype.__destroy__ = function() {
                        xt(this.ptr)
                    }, R.prototype = Object.create(u.prototype), R.prototype.constructor = R, R.prototype.__class__ = R, R.__cache__ = {}, N.DracoUInt16Array = R, R.prototype.GetValue = R.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), Ct(t, e)
                    }, R.prototype.size = R.prototype.size = function() {
                        return Et(this.ptr)
                    }, R.prototype.__destroy__ = R.prototype.__destroy__ = function() {
                        St(this.ptr)
                    }, B.prototype = Object.create(u.prototype), B.prototype.constructor = B, B.prototype.__class__ = B, B.__cache__ = {}, N.DracoInt32Array = B, B.prototype.GetValue = B.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), Tt(t, e)
                    }, B.prototype.size = B.prototype.size = function() {
                        return Mt(this.ptr)
                    }, B.prototype.__destroy__ = B.prototype.__destroy__ = function() {
                        Rt(this.ptr)
                    }, k.prototype = Object.create(u.prototype), k.prototype.constructor = k, k.prototype.__class__ = k, k.__cache__ = {}, N.DracoUInt32Array = k, k.prototype.GetValue = k.prototype.GetValue = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), kt(t, e)
                    }, k.prototype.size = k.prototype.size = function() {
                        return Dt(this.ptr)
                    }, k.prototype.__destroy__ = k.prototype.__destroy__ = function() {
                        Pt(this.ptr)
                    }, D.prototype = Object.create(u.prototype), D.prototype.constructor = D, D.prototype.__class__ = D, D.__cache__ = {}, N.MetadataQuerier = D, D.prototype.HasEntry = D.prototype.HasEntry = function(e, t) {
                        var n = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), !!Lt(n, e, t)
                    }, D.prototype.GetIntEntry = D.prototype.GetIntEntry = function(e, t) {
                        var n = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), Nt(n, e, t)
                    }, D.prototype.GetIntEntryArray = D.prototype.GetIntEntryArray = function(e, t, n) {
                        var r = this.ptr;
                        er.prepare(),
                        e && "object" == typeof e && (e = e.ptr),
                        t = t && "object" == typeof t ? t.ptr : h(t),
                        n && "object" == typeof n && (n = n.ptr),
                        Ft(r, e, t, n)
                    }, D.prototype.GetDoubleEntry = D.prototype.GetDoubleEntry = function(e, t) {
                        var n = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), Ut(n, e, t)
                    }, D.prototype.GetStringEntry = D.prototype.GetStringEntry = function(e, t) {
                        var n = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), r(zt(n, e, t))
                    }, D.prototype.NumEntries = D.prototype.NumEntries = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), Qt(t, e)
                    }, D.prototype.GetEntryName = D.prototype.GetEntryName = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), r(Gt(n, e, t))
                    }, D.prototype.__destroy__ = D.prototype.__destroy__ = function() {
                        jt(this.ptr)
                    }, P.prototype = Object.create(u.prototype), P.prototype.constructor = P, P.prototype.__class__ = P, P.__cache__ = {}, N.Decoder = P, P.prototype.DecodeArrayToPointCloud = P.prototype.DecodeArrayToPointCloud = function(e, t, n) {
                        var r = this.ptr;
                        return er.prepare(), "object" == typeof e && (e = f(e)), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), p(Ht(r, e, t, n), E)
                    }, P.prototype.DecodeArrayToMesh = P.prototype.DecodeArrayToMesh = function(e, t, n) {
                        var r = this.ptr;
                        return er.prepare(), "object" == typeof e && (e = f(e)), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), p($t(r, e, t, n), E)
                    }, P.prototype.GetAttributeId = P.prototype.GetAttributeId = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), Wt(n, e, t)
                    }, P.prototype.GetAttributeIdByName = P.prototype.GetAttributeIdByName = function(e, t) {
                        var n = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), Kt(n, e, t)
                    }, P.prototype.GetAttributeIdByMetadataEntry = P.prototype.GetAttributeIdByMetadataEntry = function(e, t, n) {
                        var r = this.ptr;
                        return er.prepare(), e && "object" == typeof e && (e = e.ptr), t = t && "object" == typeof t ? t.ptr : h(t), n = n && "object" == typeof n ? n.ptr : h(n), qt(r, e, t, n)
                    }, P.prototype.GetAttribute = P.prototype.GetAttribute = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), p(Xt(n, e, t), y)
                    }, P.prototype.GetAttributeByUniqueId = P.prototype.GetAttributeByUniqueId = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), p(Yt(n, e, t), y)
                    }, P.prototype.GetMetadata = P.prototype.GetMetadata = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), p(Jt(t, e), C)
                    }, P.prototype.GetAttributeMetadata = P.prototype.GetAttributeMetadata = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), p(Zt(n, e, t), C)
                    }, P.prototype.GetFaceFromMesh = P.prototype.GetFaceFromMesh = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!en(r, e, t, n)
                    }, P.prototype.GetTriangleStripsFromMesh = P.prototype.GetTriangleStripsFromMesh = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), tn(n, e, t)
                    }, P.prototype.GetTrianglesUInt16Array = P.prototype.GetTrianglesUInt16Array = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!nn(r, e, t, n)
                    }, P.prototype.GetTrianglesUInt32Array = P.prototype.GetTrianglesUInt32Array = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!rn(r, e, t, n)
                    }, P.prototype.GetAttributeFloat = P.prototype.GetAttributeFloat = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!on(r, e, t, n)
                    }, P.prototype.GetAttributeFloatForAllPoints = P.prototype.GetAttributeFloatForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!an(r, e, t, n)
                    }, P.prototype.GetAttributeIntForAllPoints = P.prototype.GetAttributeIntForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!sn(r, e, t, n)
                    }, P.prototype.GetAttributeInt8ForAllPoints = P.prototype.GetAttributeInt8ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!ln(r, e, t, n)
                    }, P.prototype.GetAttributeUInt8ForAllPoints = P.prototype.GetAttributeUInt8ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!cn(r, e, t, n)
                    }, P.prototype.GetAttributeInt16ForAllPoints = P.prototype.GetAttributeInt16ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!un(r, e, t, n)
                    }, P.prototype.GetAttributeUInt16ForAllPoints = P.prototype.GetAttributeUInt16ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!dn(r, e, t, n)
                    }, P.prototype.GetAttributeInt32ForAllPoints = P.prototype.GetAttributeInt32ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!pn(r, e, t, n)
                    }, P.prototype.GetAttributeUInt32ForAllPoints = P.prototype.GetAttributeUInt32ForAllPoints = function(e, t, n) {
                        var r = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), !!hn(r, e, t, n)
                    }, P.prototype.GetAttributeDataArrayForAllPoints = P.prototype.GetAttributeDataArrayForAllPoints = function(e, t, n, r, o) {
                        var i = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), n && "object" == typeof n && (n = n.ptr), r && "object" == typeof r && (r = r.ptr), o && "object" == typeof o && (o = o.ptr), !!fn(i, e, t, n, r, o)
                    }, P.prototype.SkipAttributeTransform = P.prototype.SkipAttributeTransform = function(e) {
                        var t = this.ptr;
                        e && "object" == typeof e && (e = e.ptr),
                        gn(t, e)
                    }, P.prototype.GetEncodedGeometryType_Deprecated = P.prototype.GetEncodedGeometryType_Deprecated = function(e) {
                        var t = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), mn(t, e)
                    }, P.prototype.DecodeBufferToPointCloud = P.prototype.DecodeBufferToPointCloud = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), p(bn(n, e, t), E)
                    }, P.prototype.DecodeBufferToMesh = P.prototype.DecodeBufferToMesh = function(e, t) {
                        var n = this.ptr;
                        return e && "object" == typeof e && (e = e.ptr), t && "object" == typeof t && (t = t.ptr), p(An(n, e, t), E)
                    }, P.prototype.__destroy__ = P.prototype.__destroy__ = function() {
                        yn(this.ptr)
                    }, function() {
                        function e() {
                            N.ATTRIBUTE_INVALID_TRANSFORM = vn(),
                            N.ATTRIBUTE_NO_TRANSFORM = _n(),
                            N.ATTRIBUTE_QUANTIZATION_TRANSFORM = xn(),
                            N.ATTRIBUTE_OCTAHEDRON_TRANSFORM = wn(),
                            N.INVALID = Cn(),
                            N.POSITION = En(),
                            N.NORMAL = Sn(),
                            N.COLOR = In(),
                            N.TEX_COORD = Tn(),
                            N.GENERIC = Mn(),
                            N.INVALID_GEOMETRY_TYPE = Rn(),
                            N.POINT_CLOUD = Bn(),
                            N.TRIANGULAR_MESH = kn(),
                            N.DT_INVALID = Dn(),
                            N.DT_INT8 = Pn(),
                            N.DT_UINT8 = On(),
                            N.DT_INT16 = Ln(),
                            N.DT_UINT16 = Nn(),
                            N.DT_INT32 = Fn(),
                            N.DT_UINT32 = Un(),
                            N.DT_INT64 = zn(),
                            N.DT_UINT64 = Qn(),
                            N.DT_FLOAT32 = Gn(),
                            N.DT_FLOAT64 = jn(),
                            N.DT_BOOL = Vn(),
                            N.DT_TYPES_COUNT = Hn(),
                            N.OK = $n(),
                            N.DRACO_ERROR = Wn(),
                            N.IO_ERROR = Kn(),
                            N.INVALID_PARAMETER = qn(),
                            N.UNSUPPORTED_VERSION = Xn(),
                            N.UNKNOWN_VERSION = Yn()
                        }
                        ue ? e() : le.unshift(e)
                    }(), "function" == typeof N.onModuleParsed && N.onModuleParsed(), N.Decoder.prototype.GetEncodedGeometryType = function(e) {
                        if (e.__class__ && e.__class__ === N.DecoderBuffer)
                            return N.Decoder.prototype.GetEncodedGeometryType_Deprecated(e);
                        if (8 > e.byteLength)
                            return N.INVALID_GEOMETRY_TYPE;
                        switch (e[7]) {
                        case 0:
                            return N.POINT_CLOUD;
                        case 1:
                            return N.TRIANGULAR_MESH;
                        default:
                            return N.INVALID_GEOMETRY_TYPE
                        }
                    }, e.ready
                });
            e.exports = r
        }(wy)), wy.exports);
    return _y = {
        createEncoderModule: e,
        createDecoderModule: t
    }
}());
class Sy {
    constructor()
    {
        this._listeners = {}
    }
    addEventListener(e, t)
    {
        const n = this._listeners;
        return void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t), this
    }
    removeEventListener(e, t)
    {
        const n = this._listeners[e];
        if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1)
        }
        return this
    }
    dispatchEvent(e)
    {
        const t = this._listeners[e.type];
        if (void 0 !== t) {
            const n = t.slice(0);
            for (let t = 0, r = n.length; t < r; t++)
                n[t].call(this, e)
        }
        return this
    }
    dispose()
    {
        for (const e in this._listeners)
            delete this._listeners[e]
    }
}
class Iy {
    constructor(e, t, n, r={})
    {
        if (this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = !1, this._name = e, this._parent = t, this._child = n, this._attributes = r, !t.isOnGraph(n))
            throw new Error("Cannot connect disconnected graphs.")
    }
    getName()
    {
        return this._name
    }
    getParent()
    {
        return this._parent
    }
    getChild()
    {
        return this._child
    }
    setChild(e)
    {
        return this._child = e, this
    }
    getAttributes()
    {
        return this._attributes
    }
    dispose()
    {
        this._disposed || (this._parent._destroyRef(this), this._disposed = !0)
    }
    isDisposed()
    {
        return this._disposed
    }
}
class Ty extends Sy {
    constructor(...e)
    {
        super(...e),
        this._emptySet = new Set,
        this._edges = new Set,
        this._parentEdges = new Map,
        this._childEdges = new Map
    }
    listEdges()
    {
        return Array.from(this._edges)
    }
    listParentEdges(e)
    {
        return Array.from(this._childEdges.get(e) || this._emptySet)
    }
    listParents(e)
    {
        const t = new Set;
        for (const n of this.listParentEdges(e))
            t.add(n.getParent());
        return Array.from(t)
    }
    listChildEdges(e)
    {
        return Array.from(this._parentEdges.get(e) || this._emptySet)
    }
    listChildren(e)
    {
        const t = new Set;
        for (const n of this.listChildEdges(e))
            t.add(n.getChild());
        return Array.from(t)
    }
    disconnectParents(e, t)
    {
        for (const n of this.listParentEdges(e))
            t && !t(n.getParent()) || n.dispose();
        return this
    }
    _createEdge(e, t, n, r)
    {
        const o = new Iy(e, t, n, r);
        this._edges.add(o);
        const i = o.getParent();
        this._parentEdges.has(i) || this._parentEdges.set(i, new Set),
        this._parentEdges.get(i).add(o);
        const a = o.getChild();
        return this._childEdges.has(a) || this._childEdges.set(a, new Set), this._childEdges.get(a).add(o), o
    }
    _destroyEdge(e)
    {
        return this._edges.delete(e), this._parentEdges.get(e.getParent()).delete(e), this._childEdges.get(e.getChild()).delete(e), this
    }
}
function My() {
    return My = Object.assign || function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, My.apply(this, arguments)
}
class Ry {
    constructor(e)
    {
        if (this.list = [], e)
            for (const t of e)
                this.list.push(t)
    }
    add(e)
    {
        this.list.push(e)
    }
    remove(e)
    {
        const t = this.list.indexOf(e);
        t >= 0 && this.list.splice(t, 1)
    }
    removeChild(e)
    {
        const t = [];
        for (const n of this.list)
            n.getChild() === e && t.push(n);
        for (const n of t)
            this.remove(n);
        return t
    }
    listRefsByChild(e)
    {
        const t = [];
        for (const n of this.list)
            n.getChild() === e && t.push(n);
        return t
    }
    values()
    {
        return this.list
    }
}
class By {
    constructor(e)
    {
        if (this.set = new Set, this.map = new Map, e)
            for (const t of e)
                this.add(t)
    }
    add(e)
    {
        const t = e.getChild();
        this.removeChild(t),
        this.set.add(e),
        this.map.set(t, e)
    }
    remove(e)
    {
        this.set.delete(e),
        this.map.delete(e.getChild())
    }
    removeChild(e)
    {
        const t = this.map.get(e) || null;
        return t && this.remove(t), t
    }
    getRefByChild(e)
    {
        return this.map.get(e) || null
    }
    values()
    {
        return Array.from(this.set)
    }
}
class ky {
    constructor(e)
    {
        this.map = {},
        e && Object.assign(this.map, e)
    }
    set(e, t)
    {
        this.map[e] = t
    }
    delete(e)
    {
        delete this.map[e]
    }
    get(e)
    {
        return this.map[e] || null
    }
    keys()
    {
        return Object.keys(this.map)
    }
    values()
    {
        return Object.values(this.map)
    }
}
const Dy = Symbol("attributes"),
    Py = Symbol("immutableKeys");
class Oy extends Sy {
    constructor(e)
    {
        super(),
        this._disposed = !1,
        this.graph = void 0,
        this[Dy] = void 0,
        this[Py] = void 0,
        this.graph = e,
        this[Py] = new Set,
        this[Dy] = this._createAttributes()
    }
    getDefaults()
    {
        return {}
    }
    _createAttributes()
    {
        const e = this.getDefaults(),
            t = {};
        for (const n in e) {
            const r = e[n];
            if (r instanceof Oy) {
                const e = this.graph._createEdge(n, this, r);
                this[Py].add(n),
                t[n] = e
            } else
                t[n] = r
        }
        return t
    }
    isOnGraph(e)
    {
        return this.graph === e.graph
    }
    isDisposed()
    {
        return this._disposed
    }
    dispose()
    {
        this._disposed || (this.graph.listChildEdges(this).forEach(e => e.dispose()), this.graph.disconnectParents(this), this._disposed = !0, this.dispatchEvent({
            type: "dispose"
        }))
    }
    detach()
    {
        return this.graph.disconnectParents(this), this
    }
    swap(e, t)
    {
        for (const n in this[Dy]) {
            const r = this[Dy][n];
            if (r instanceof Iy) {
                const o = r;
                o.getChild() === e && this.setRef(n, t, o.getAttributes())
            } else if (r instanceof Ry)
                for (const o of r.listRefsByChild(e)) {
                    const r = o.getAttributes();
                    this.removeRef(n, e),
                    this.addRef(n, t, r)
                }
            else if (r instanceof By) {
                const o = r.getRefByChild(e);
                if (o) {
                    const r = o.getAttributes();
                    this.removeRef(n, e),
                    this.addRef(n, t, r)
                }
            } else if (r instanceof ky)
                for (const o of r.keys()) {
                    const i = r.get(o);
                    i.getChild() === e && this.setRefMap(n, o, t, i.getAttributes())
                }
        }
        return this
    }
    get(e)
    {
        return this[Dy][e]
    }
    set(e, t)
    {
        return this[Dy][e] = t, this.dispatchEvent({
            type: "change",
            attribute: e
        })
    }
    getRef(e)
    {
        const t = this[Dy][e];
        return t ? t.getChild() : null
    }
    setRef(e, t, n)
    {
        if (this[Py].has(e))
            throw new Error(`Cannot overwrite immutable attribute, "${e}".`);
        const r = this[Dy][e];
        if (r && r.dispose(), !t)
            return this;
        const o = this.graph._createEdge(e, this, t, n);
        return this[Dy][e] = o, this.dispatchEvent({
            type: "change",
            attribute: e
        })
    }
    listRefs(e)
    {
        return this.assertRefList(e).values().map(e => e.getChild())
    }
    addRef(e, t, n)
    {
        const r = this.graph._createEdge(e, this, t, n);
        return this.assertRefList(e).add(r), this.dispatchEvent({
            type: "change",
            attribute: e
        })
    }
    removeRef(e, t)
    {
        const n = this.assertRefList(e);
        if (n instanceof Ry)
            for (const r of n.listRefsByChild(t))
                r.dispose();
        else {
            const e = n.getRefByChild(t);
            e && e.dispose()
        }
        return this
    }
    assertRefList(e)
    {
        const t = this[Dy][e];
        if (t instanceof Ry || t instanceof By)
            return t;
        throw new Error(`Expected RefList or RefSet for attribute "${e}"`)
    }
    listRefMapKeys(e)
    {
        return this.assertRefMap(e).keys()
    }
    listRefMapValues(e)
    {
        return this.assertRefMap(e).values().map(e => e.getChild())
    }
    getRefMap(e, t)
    {
        const n = this.assertRefMap(e).get(t);
        return n ? n.getChild() : null
    }
    setRefMap(e, t, n, r)
    {
        const o = this.assertRefMap(e),
            i = o.get(t);
        if (i && i.dispose(), !n)
            return this;
        r = Object.assign(r || {}, {
            key: t
        });
        const a = this.graph._createEdge(e, this, n, My({}, r, {
            key: t
        }));
        return o.set(t, a), this.dispatchEvent({
            type: "change",
            attribute: e,
            key: t
        })
    }
    assertRefMap(e)
    {
        const t = this[Dy][e];
        if (t instanceof ky)
            return t;
        throw new Error(`Expected RefMap for attribute "${e}"`)
    }
    dispatchEvent(e)
    {
        return super.dispatchEvent(My({}, e, {
            target: this
        })), this.graph.dispatchEvent(My({}, e, {
            target: this,
            type: `node:${e.type}`
        })), this
    }
    _destroyRef(e)
    {
        const t = e.getName();
        if (this[Dy][t] === e)
            this[Dy][t] = null,
            this[Py].has(t) && e.getChild().dispose();
        else if (this[Dy][t] instanceof Ry)
            this[Dy][t].remove(e);
        else if (this[Dy][t] instanceof By)
            this[Dy][t].remove(e);
        else {
            if (!(this[Dy][t] instanceof ky))
                return;
            {
                const n = this[Dy][t];
                for (const t of n.keys())
                    n.get(t) === e && n.delete(t)
            }
        }
        this.graph._destroyEdge(e),
        this.dispatchEvent({
            type: "change",
            attribute: t
        })
    }
}
const Ly = "v4.2.1",
    Ny = "@glb.bin";
var Fy,
    Uy,
    zy,
    Qy,
    Gy,
    jy,
    Vy,
    Hy,
    $y,
    Wy;
(Uy = Fy || (Fy = {})).ACCESSOR = "Accessor",
Uy.ANIMATION = "Animation",
Uy.ANIMATION_CHANNEL = "AnimationChannel",
Uy.ANIMATION_SAMPLER = "AnimationSampler",
Uy.BUFFER = "Buffer",
Uy.CAMERA = "Camera",
Uy.MATERIAL = "Material",
Uy.MESH = "Mesh",
Uy.PRIMITIVE = "Primitive",
Uy.PRIMITIVE_TARGET = "PrimitiveTarget",
Uy.NODE = "Node",
Uy.ROOT = "Root",
Uy.SCENE = "Scene",
Uy.SKIN = "Skin",
Uy.TEXTURE = "Texture",
Uy.TEXTURE_INFO = "TextureInfo",
(Qy = zy || (zy = {})).INTERLEAVED = "interleaved",
Qy.SEPARATE = "separate",
(jy = Gy || (Gy = {})).ARRAY_BUFFER = "ARRAY_BUFFER",
jy.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER",
jy.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES",
jy.OTHER = "OTHER",
jy.SPARSE = "SPARSE",
(Hy = Vy || (Vy = {}))[Hy.R = 4096] = "R",
Hy[Hy.G = 256] = "G",
Hy[Hy.B = 16] = "B",
Hy[Hy.A = 1] = "A",
(Wy = $y || ($y = {})).GLTF = "GLTF",
Wy.GLB = "GLB";
const Ky = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
};
class qy {
    static createBufferFromDataURI(e)
    {
        if ("undefined" == typeof Buffer) {
            const t = atob(e.split(",")[1]),
                n = new Uint8Array(t.length);
            for (let e = 0; e < t.length; e++)
                n[e] = t.charCodeAt(e);
            return n
        }
        {
            const t = e.split(",")[1],
                n = e.indexOf("base64") >= 0;
            return Buffer.from(t, n ? "base64" : "utf8")
        }
    }
    static encodeText(e)
    {
        return (new TextEncoder).encode(e)
    }
    static decodeText(e)
    {
        return (new TextDecoder).decode(e)
    }
    static concat(e)
    {
        let t = 0;
        for (const o of e)
            t += o.byteLength;
        const n = new Uint8Array(t);
        let r = 0;
        for (const o of e)
            n.set(o, r),
            r += o.byteLength;
        return n
    }
    static pad(e, t=0)
    {
        const n = this.padNumber(e.byteLength);
        if (n === e.byteLength)
            return e;
        const r = new Uint8Array(n);
        if (r.set(e), 0 !== t)
            for (let o = e.byteLength; o < n; o++)
                r[o] = t;
        return r
    }
    static padNumber(e)
    {
        return 4 * Math.ceil(e / 4)
    }
    static equals(e, t)
    {
        if (e === t)
            return !0;
        if (e.byteLength !== t.byteLength)
            return !1;
        let n = e.byteLength;
        for (; n--;)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    static toView(e, t=0, n=1 / 0)
    {
        return new Uint8Array(e.buffer, e.byteOffset + t, Math.min(e.byteLength, n))
    }
    static assertView(e)
    {
        if (e && !ArrayBuffer.isView(e))
            throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);
        return e
    }
}
class Xy {
    match(e)
    {
        return e.length >= 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7]
    }
    getSize(e)
    {
        const t = new DataView(e.buffer, e.byteOffset);
        return qy.decodeText(e.slice(12, 16)) === Xy.PNG_FRIED_CHUNK_NAME ? [t.getUint32(32, !1), t.getUint32(36, !1)] : [t.getUint32(16, !1), t.getUint32(20, !1)]
    }
    getChannels(e)
    {
        return 4
    }
}
Xy.PNG_FRIED_CHUNK_NAME = "CgBI";
class Yy {
    static registerFormat(e, t)
    {
        this.impls[e] = t
    }
    static getMimeType(e)
    {
        for (const t in this.impls)
            if (this.impls[t].match(e))
                return t;
        return null
    }
    static getSize(e, t)
    {
        return this.impls[t] ? this.impls[t].getSize(e) : null
    }
    static getChannels(e, t)
    {
        return this.impls[t] ? this.impls[t].getChannels(e) : null
    }
    static getVRAMByteLength(e, t)
    {
        if (!this.impls[t])
            return null;
        if (this.impls[t].getVRAMByteLength)
            return this.impls[t].getVRAMByteLength(e);
        let n = 0;
        const r = this.getSize(e, t);
        if (!r)
            return null;
        for (; r[0] > 1 || r[1] > 1;)
            n += r[0] * r[1] * 4,
            r[0] = Math.max(Math.floor(r[0] / 2), 1),
            r[1] = Math.max(Math.floor(r[1] / 2), 1);
        return n += 4, n
    }
    static mimeTypeToExtension(e)
    {
        return "image/jpeg" === e ? "jpg" : e.split("/").pop()
    }
    static extensionToMimeType(e)
    {
        return "jpg" === e ? "image/jpeg" : e ? `image/${e}` : ""
    }
}
function Jy(e, t) {
    if (t > e.byteLength)
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (255 !== e.getUint8(t))
        throw new TypeError("Invalid JPG, marker table corrupted");
    return e
}
Yy.impls = {
    "image/jpeg": new class {
        match(e)
        {
            return e.length >= 3 && 255 === e[0] && 216 === e[1] && 255 === e[2]
        }
        getSize(e)
        {
            let t,
                n,
                r = new DataView(e.buffer, e.byteOffset + 4);
            for (; r.byteLength;) {
                if (t = r.getUint16(0, !1), Jy(r, t), n = r.getUint8(t + 1), 192 === n || 193 === n || 194 === n)
                    return [r.getUint16(t + 7, !1), r.getUint16(t + 5, !1)];
                r = new DataView(e.buffer, r.byteOffset + t + 2)
            }
            throw new TypeError("Invalid JPG, no size found")
        }
        getChannels(e)
        {
            return 3
        }
    }
    ,
    "image/png": new Xy
};
class Zy {
    static basename(e)
    {
        const t = e.split(/[\\/]/).pop();
        return t.substring(0, t.lastIndexOf("."))
    }
    static extension(e)
    {
        if (e.startsWith("data:image/")) {
            const t = e.match(/data:(image\/\w+)/)[1];
            return Yy.mimeTypeToExtension(t)
        }
        return e.startsWith("data:model/gltf+json") ? "gltf" : e.startsWith("data:model/gltf-binary") ? "glb" : e.startsWith("data:application/") ? "bin" : e.split(/[\\/]/).pop().split(/[.]/).pop()
    }
}
var ev,
    tv = "undefined" != typeof Float32Array ? Float32Array : Array;
function nv(e) {
    var t = e[0],
        n = e[1],
        r = e[2];
    return Math.hypot(t, n, r)
}
function rv(e, t, n) {
    var r = t[0],
        o = t[1],
        i = t[2],
        a = n[3] * r + n[7] * o + n[11] * i + n[15];
    return a = a || 1, e[0] = (n[0] * r + n[4] * o + n[8] * i + n[12]) / a, e[1] = (n[1] * r + n[5] * o + n[9] * i + n[13]) / a, e[2] = (n[2] * r + n[6] * o + n[10] * i + n[14]) / a, e
}
function ov(e) {
    const t = {
            min: [1 / 0, 1 / 0, 1 / 0],
            max: [-1 / 0, -1 / 0, -1 / 0]
        },
        n = e.propertyType === Fy.NODE ? [e] : e.listChildren();
    for (const r of n)
        r.traverse(e => {
            const n = e.getMesh();
            if (!n)
                return;
            const r = iv(n, e.getWorldMatrix());
            r.min.every(isFinite) && r.max.every(isFinite) && (av(r.min, t), av(r.max, t))
        });
    return t
}
function iv(e, t) {
    const n = {
        min: [1 / 0, 1 / 0, 1 / 0],
        max: [-1 / 0, -1 / 0, -1 / 0]
    };
    for (const r of e.listPrimitives()) {
        const e = r.getAttribute("POSITION"),
            o = r.getIndices();
        if (!e)
            continue;
        let i = [0, 0, 0],
            a = [0, 0, 0];
        for (let r = 0, s = o ? o.getCount() : e.getCount(); r < s; r++) {
            const s = o ? o.getScalar(r) : r;
            i = e.getElement(s, i),
            a = rv(a, i, t),
            av(a, n)
        }
    }
    return n
}
function av(e, t) {
    for (let n = 0; n < 3; n++)
        t.min[n] = Math.min(e[n], t.min[n]),
        t.max[n] = Math.max(e[n], t.max[n])
}
Math.hypot || (Math.hypot = function() {
    for (var e = 0, t = arguments.length; t--;)
        e += arguments[t] * arguments[t];
    return Math.sqrt(e)
}),
ev = new tv(3),
tv != Float32Array && (ev[0] = 0, ev[1] = 0, ev[2] = 0);
const sv = "https://null.example";
class lv {
    static dirname(e)
    {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substring(0, t + 1)
    }
    static basename(e)
    {
        return Zy.basename(new URL(e, sv).pathname)
    }
    static extension(e)
    {
        return Zy.extension(new URL(e, sv).pathname)
    }
    static resolve(e, t)
    {
        if (!this.isRelativePath(t))
            return t;
        const n = e.split("/"),
            r = t.split("/");
        n.pop();
        for (let o = 0; o < r.length; o++)
            "." !== r[o] && (".." === r[o] ? n.pop() : n.push(r[o]));
        return n.join("/")
    }
    static isAbsoluteURL(e)
    {
        return this.PROTOCOL_REGEXP.test(e)
    }
    static isRelativePath(e)
    {
        return !/^(?:[a-zA-Z]+:)?\//.test(e)
    }
}
function cv(e) {
    return "[object Object]" === Object.prototype.toString.call(e)
}
function uv(e) {
    if (!1 === cv(e))
        return !1;
    const t = e.constructor;
    if (void 0 === t)
        return !0;
    const n = t.prototype;
    return !1 !== cv(n) && !1 !== Object.hasOwn(n, "isPrototypeOf")
}
var dv,
    pv,
    hv;
lv.DEFAULT_INIT = {},
lv.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//,
(hv = pv || (pv = {}))[hv.SILENT = 4] = "SILENT",
hv[hv.ERROR = 3] = "ERROR",
hv[hv.WARN = 2] = "WARN",
hv[hv.INFO = 1] = "INFO",
hv[hv.DEBUG = 0] = "DEBUG";
class fv {
    constructor(e)
    {
        this.verbosity = void 0,
        this.verbosity = e
    }
    debug(e)
    {
        this.verbosity,
        fv.Verbosity.DEBUG
    }
    info(e)
    {
        this.verbosity,
        fv.Verbosity.INFO
    }
    warn(e)
    {
        this.verbosity,
        fv.Verbosity.WARN
    }
    error(e)
    {
        this.verbosity,
        fv.Verbosity.ERROR
    }
}
function gv(e, t, n) {
    var r = t[0],
        o = t[1],
        i = t[2],
        a = t[3],
        s = t[4],
        l = t[5],
        c = t[6],
        u = t[7],
        d = t[8],
        p = t[9],
        h = t[10],
        f = t[11],
        g = t[12],
        m = t[13],
        b = t[14],
        A = t[15],
        y = n[0],
        v = n[1],
        _ = n[2],
        x = n[3];
    return e[0] = y * r + v * s + _ * d + x * g, e[1] = y * o + v * l + _ * p + x * m, e[2] = y * i + v * c + _ * h + x * b, e[3] = y * a + v * u + _ * f + x * A, y = n[4], v = n[5], _ = n[6], x = n[7], e[4] = y * r + v * s + _ * d + x * g, e[5] = y * o + v * l + _ * p + x * m, e[6] = y * i + v * c + _ * h + x * b, e[7] = y * a + v * u + _ * f + x * A, y = n[8], v = n[9], _ = n[10], x = n[11], e[8] = y * r + v * s + _ * d + x * g, e[9] = y * o + v * l + _ * p + x * m, e[10] = y * i + v * c + _ * h + x * b, e[11] = y * a + v * u + _ * f + x * A, y = n[12], v = n[13], _ = n[14], x = n[15], e[12] = y * r + v * s + _ * d + x * g, e[13] = y * o + v * l + _ * p + x * m, e[14] = y * i + v * c + _ * h + x * b, e[15] = y * a + v * u + _ * f + x * A, e
}
dv = fv,
fv.Verbosity = pv,
fv.DEFAULT_INSTANCE = new dv(dv.Verbosity.INFO);
class mv {
    static identity(e)
    {
        return e
    }
    static eq(e, t, n=1e-5)
    {
        if (e.length !== t.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (Math.abs(e[r] - t[r]) > n)
                return !1;
        return !0
    }
    static clamp(e, t, n)
    {
        return e < t ? t : e > n ? n : e
    }
    static decodeNormalizedInt(e, t)
    {
        switch (t) {
        case 5126:
            return e;
        case 5123:
            return e / 65535;
        case 5121:
            return e / 255;
        case 5122:
            return Math.max(e / 32767, -1);
        case 5120:
            return Math.max(e / 127, -1);
        default:
            throw new Error("Invalid component type.")
        }
    }
    static encodeNormalizedInt(e, t)
    {
        switch (t) {
        case 5126:
            return e;
        case 5123:
            return Math.round(65535 * mv.clamp(e, 0, 1));
        case 5121:
            return Math.round(255 * mv.clamp(e, 0, 1));
        case 5122:
            return Math.round(32767 * mv.clamp(e, -1, 1));
        case 5120:
            return Math.round(127 * mv.clamp(e, -1, 1));
        default:
            throw new Error("Invalid component type.")
        }
    }
    static decompose(e, t, n, r)
    {
        let o = nv([e[0], e[1], e[2]]);
        const i = nv([e[4], e[5], e[6]]),
            a = nv([e[8], e[9], e[10]]);
        var s,
            l,
            c,
            u,
            d,
            p,
            h,
            f,
            g,
            m,
            b,
            A,
            y,
            v,
            _,
            x,
            w;
        l = (s = e)[0],
        c = s[1],
        u = s[2],
        d = s[3],
        p = s[4],
        h = s[5],
        f = s[6],
        g = s[7],
        m = s[8],
        b = s[9],
        A = s[10],
        y = s[11],
        v = s[12],
        _ = s[13],
        x = s[14],
        (l * h - c * p) * (A * (w = s[15]) - y * x) - (l * f - u * p) * (b * w - y * _) + (l * g - d * p) * (b * x - A * _) + (c * f - u * h) * (m * w - y * v) - (c * g - d * h) * (m * x - A * v) + (u * g - d * f) * (m * _ - b * v) < 0 && (o = -o),
        t[0] = e[12],
        t[1] = e[13],
        t[2] = e[14];
        const C = e.slice(),
            E = 1 / o,
            S = 1 / i,
            I = 1 / a;
        C[0] *= E,
        C[1] *= E,
        C[2] *= E,
        C[4] *= S,
        C[5] *= S,
        C[6] *= S,
        C[8] *= I,
        C[9] *= I,
        C[10] *= I,
        function(e, t) {
            var n = new tv(3);
            !function(e, t) {
                var n = t[0],
                    r = t[1],
                    o = t[2],
                    i = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[8],
                    c = t[9],
                    u = t[10];
                e[0] = Math.hypot(n, r, o),
                e[1] = Math.hypot(i, a, s),
                e[2] = Math.hypot(l, c, u)
            }(n, t);
            var r = 1 / n[0],
                o = 1 / n[1],
                i = 1 / n[2],
                a = t[0] * r,
                s = t[1] * o,
                l = t[2] * i,
                c = t[4] * r,
                u = t[5] * o,
                d = t[6] * i,
                p = t[8] * r,
                h = t[9] * o,
                f = t[10] * i,
                g = a + u + f,
                m = 0;
            g > 0 ? (m = 2 * Math.sqrt(g + 1), e[3] = .25 * m, e[0] = (d - h) / m, e[1] = (p - l) / m, e[2] = (s - c) / m) : a > u && a > f ? (m = 2 * Math.sqrt(1 + a - u - f), e[3] = (d - h) / m, e[0] = .25 * m, e[1] = (s + c) / m, e[2] = (p + l) / m) : u > f ? (m = 2 * Math.sqrt(1 + u - a - f), e[3] = (p - l) / m, e[0] = (s + c) / m, e[1] = .25 * m, e[2] = (d + h) / m) : (m = 2 * Math.sqrt(1 + f - a - u), e[3] = (s - c) / m, e[0] = (p + l) / m, e[1] = (d + h) / m, e[2] = .25 * m)
        }(n, C),
        r[0] = o,
        r[1] = i,
        r[2] = a
    }
    static compose(e, t, n, r)
    {
        const o = r,
            i = t[0],
            a = t[1],
            s = t[2],
            l = t[3],
            c = i + i,
            u = a + a,
            d = s + s,
            p = i * c,
            h = i * u,
            f = i * d,
            g = a * u,
            m = a * d,
            b = s * d,
            A = l * c,
            y = l * u,
            v = l * d,
            _ = n[0],
            x = n[1],
            w = n[2];
        return o[0] = (1 - (g + b)) * _, o[1] = (h + v) * _, o[2] = (f - y) * _, o[3] = 0, o[4] = (h - v) * x, o[5] = (1 - (p + b)) * x, o[6] = (m + A) * x, o[7] = 0, o[8] = (f + y) * w, o[9] = (m - A) * w, o[10] = (1 - (p + g)) * w, o[11] = 0, o[12] = e[0], o[13] = e[1], o[14] = e[2], o[15] = 1, o
    }
}
function bv(e, t) {
    if (!!e != !!t)
        return !1;
    const n = e.getChild(),
        r = t.getChild();
    return n === r || n.equals(r)
}
function Av(e, t) {
    if (!!e != !!t)
        return !1;
    const n = e.values(),
        r = t.values();
    if (n.length !== r.length)
        return !1;
    for (let o = 0; o < n.length; o++) {
        const e = n[o],
            t = r[o];
        if (e.getChild() !== t.getChild() && !e.getChild().equals(t.getChild()))
            return !1
    }
    return !0
}
function yv(e, t) {
    if (!!e != !!t)
        return !1;
    const n = e.keys(),
        r = t.keys();
    if (n.length !== r.length)
        return !1;
    for (const o of n) {
        const n = e.get(o),
            r = t.get(o);
        if (!!n != !!r)
            return !1;
        const i = n.getChild(),
            a = r.getChild();
        if (i !== a && !i.equals(a))
            return !1
    }
    return !0
}
function vv(e, t) {
    if (e === t)
        return !0;
    if (!!e != !!t || !e || !t)
        return !1;
    if (e.length !== t.length)
        return !1;
    for (let n = 0; n < e.length; n++)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function _v(e, t) {
    if (e === t)
        return !0;
    if (!!e != !!t)
        return !1;
    if (!uv(e) || !uv(t))
        return e === t;
    const n = e,
        r = t;
    let o,
        i = 0,
        a = 0;
    for (o in n)
        i++;
    for (o in r)
        a++;
    if (i !== a)
        return !1;
    for (o in n) {
        const e = n[o],
            t = r[o];
        if (xv(e) && xv(t)) {
            if (!vv(e, t))
                return !1
        } else if (uv(e) && uv(t)) {
            if (!_v(e, t))
                return !1
        } else if (e !== t)
            return !1
    }
    return !0
}
function xv(e) {
    return Array.isArray(e) || ArrayBuffer.isView(e)
}
const wv = new Set,
    Cv = function() {
        let e = "";
        for (let t = 0; t < 6; t++)
            e += "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ".charAt(Math.floor(42 * Math.random()));
        return e
    },
    Ev = e => e,
    Sv = new Set;
class Iv extends Oy {
    constructor(e, t="")
    {
        super(e),
        this[Dy].name = t,
        this.init(),
        this.dispatchEvent({
            type: "create"
        })
    }
    getGraph()
    {
        return this.graph
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            name: "",
            extras: {}
        })
    }
    set(e, t)
    {
        return Array.isArray(t) && (t = t.slice()), super.set(e, t)
    }
    getName()
    {
        return this.get("name")
    }
    setName(e)
    {
        return this.set("name", e)
    }
    getExtras()
    {
        return this.get("extras")
    }
    setExtras(e)
    {
        return this.set("extras", e)
    }
    clone()
    {
        return new (0, this.constructor)(this.graph).copy(this, Ev)
    }
    copy(e, t=Ev)
    {
        for (const n in this[Dy]) {
            const e = this[Dy][n];
            if (e instanceof Iy)
                this[Py].has(n) || e.dispose();
            else if (e instanceof Ry || e instanceof By)
                for (const t of e.values())
                    t.dispose();
            else if (e instanceof ky)
                for (const t of e.values())
                    t.dispose()
        }
        for (const n in e[Dy]) {
            const r = this[Dy][n],
                o = e[Dy][n];
            if (o instanceof Iy)
                this[Py].has(n) ? r.getChild().copy(t(o.getChild()), t) : this.setRef(n, t(o.getChild()), o.getAttributes());
            else if (o instanceof By || o instanceof Ry)
                for (const e of o.values())
                    this.addRef(n, t(e.getChild()), e.getAttributes());
            else if (o instanceof ky)
                for (const e of o.keys()) {
                    const r = o.get(e);
                    this.setRefMap(n, e, t(r.getChild()), r.getAttributes())
                }
            else
                uv(o) ? this[Dy][n] = JSON.parse(JSON.stringify(o)) : Array.isArray(o) || o instanceof ArrayBuffer || ArrayBuffer.isView(o) ? this[Dy][n] = o.slice() : this[Dy][n] = o
        }
        return this
    }
    equals(e, t=Sv)
    {
        if (this === e)
            return !0;
        if (this.propertyType !== e.propertyType)
            return !1;
        for (const n in this[Dy]) {
            if (t.has(n))
                continue;
            const r = this[Dy][n],
                o = e[Dy][n];
            if (r instanceof Iy || o instanceof Iy) {
                if (!bv(r, o))
                    return !1
            } else if (r instanceof By || o instanceof By || r instanceof Ry || o instanceof Ry) {
                if (!Av(r, o))
                    return !1
            } else if (r instanceof ky || o instanceof ky) {
                if (!yv(r, o))
                    return !1
            } else if (uv(r) || uv(o)) {
                if (!_v(r, o))
                    return !1
            } else if (xv(r) || xv(o)) {
                if (!vv(r, o))
                    return !1
            } else if (r !== o)
                return !1
        }
        return !0
    }
    detach()
    {
        return this.graph.disconnectParents(this, e => "Root" !== e.propertyType), this
    }
    listParents()
    {
        return this.graph.listParents(this)
    }
}
class Tv extends Iv {
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            extensions: new ky
        })
    }
    getExtension(e)
    {
        return this.getRefMap("extensions", e)
    }
    setExtension(e, t)
    {
        return t && t._validateParent(this), this.setRefMap("extensions", e, t)
    }
    listExtensions()
    {
        return this.listRefMapValues("extensions")
    }
}
class Mv extends Tv {
    init()
    {
        this.propertyType = Fy.ACCESSOR
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            array: null,
            type: Mv.Type.SCALAR,
            componentType: Mv.ComponentType.FLOAT,
            normalized: !1,
            sparse: !1,
            buffer: null
        })
    }
    static getElementSize(e)
    {
        switch (e) {
        case Mv.Type.SCALAR:
            return 1;
        case Mv.Type.VEC2:
            return 2;
        case Mv.Type.VEC3:
            return 3;
        case Mv.Type.VEC4:
        case Mv.Type.MAT2:
            return 4;
        case Mv.Type.MAT3:
            return 9;
        case Mv.Type.MAT4:
            return 16;
        default:
            throw new Error("Unexpected type: " + e)
        }
    }
    static getComponentSize(e)
    {
        switch (e) {
        case Mv.ComponentType.BYTE:
        case Mv.ComponentType.UNSIGNED_BYTE:
            return 1;
        case Mv.ComponentType.SHORT:
        case Mv.ComponentType.UNSIGNED_SHORT:
            return 2;
        case Mv.ComponentType.UNSIGNED_INT:
        case Mv.ComponentType.FLOAT:
            return 4;
        default:
            throw new Error("Unexpected component type: " + e)
        }
    }
    getMinNormalized(e)
    {
        const t = this.getNormalized(),
            n = this.getElementSize(),
            r = this.getComponentType();
        if (this.getMin(e), t)
            for (let o = 0; o < n; o++)
                e[o] = mv.decodeNormalizedInt(e[o], r);
        return e
    }
    getMin(e)
    {
        const t = this.getArray(),
            n = this.getCount(),
            r = this.getElementSize();
        for (let o = 0; o < r; o++)
            e[o] = 1 / 0;
        for (let o = 0; o < n * r; o += r)
            for (let n = 0; n < r; n++) {
                const r = t[o + n];
                Number.isFinite(r) && (e[n] = Math.min(e[n], r))
            }
        return e
    }
    getMaxNormalized(e)
    {
        const t = this.getNormalized(),
            n = this.getElementSize(),
            r = this.getComponentType();
        if (this.getMax(e), t)
            for (let o = 0; o < n; o++)
                e[o] = mv.decodeNormalizedInt(e[o], r);
        return e
    }
    getMax(e)
    {
        const t = this.get("array"),
            n = this.getCount(),
            r = this.getElementSize();
        for (let o = 0; o < r; o++)
            e[o] = -1 / 0;
        for (let o = 0; o < n * r; o += r)
            for (let n = 0; n < r; n++) {
                const r = t[o + n];
                Number.isFinite(r) && (e[n] = Math.max(e[n], r))
            }
        return e
    }
    getCount()
    {
        const e = this.get("array");
        return e ? e.length / this.getElementSize() : 0
    }
    getType()
    {
        return this.get("type")
    }
    setType(e)
    {
        return this.set("type", e)
    }
    getElementSize()
    {
        return Mv.getElementSize(this.get("type"))
    }
    getComponentSize()
    {
        return this.get("array").BYTES_PER_ELEMENT
    }
    getComponentType()
    {
        return this.get("componentType")
    }
    getNormalized()
    {
        return this.get("normalized")
    }
    setNormalized(e)
    {
        return this.set("normalized", e)
    }
    getScalar(e)
    {
        const t = this.getElementSize(),
            n = this.getComponentType(),
            r = this.getArray();
        return this.getNormalized() ? mv.decodeNormalizedInt(r[e * t], n) : r[e * t]
    }
    setScalar(e, t)
    {
        const n = this.getElementSize(),
            r = this.getComponentType(),
            o = this.getArray();
        return this.getNormalized() ? o[e * n] = mv.encodeNormalizedInt(t, r) : o[e * n] = t, this
    }
    getElement(e, t)
    {
        const n = this.getNormalized(),
            r = this.getElementSize(),
            o = this.getComponentType(),
            i = this.getArray();
        for (let a = 0; a < r; a++)
            t[a] = n ? mv.decodeNormalizedInt(i[e * r + a], o) : i[e * r + a];
        return t
    }
    setElement(e, t)
    {
        const n = this.getNormalized(),
            r = this.getElementSize(),
            o = this.getComponentType(),
            i = this.getArray();
        for (let a = 0; a < r; a++)
            i[e * r + a] = n ? mv.encodeNormalizedInt(t[a], o) : t[a];
        return this
    }
    getSparse()
    {
        return this.get("sparse")
    }
    setSparse(e)
    {
        return this.set("sparse", e)
    }
    getBuffer()
    {
        return this.getRef("buffer")
    }
    setBuffer(e)
    {
        return this.setRef("buffer", e)
    }
    getArray()
    {
        return this.get("array")
    }
    setArray(e)
    {
        return this.set("componentType", e ? function(e) {
            switch (e.constructor) {
            case Float32Array:
                return Mv.ComponentType.FLOAT;
            case Uint32Array:
                return Mv.ComponentType.UNSIGNED_INT;
            case Uint16Array:
                return Mv.ComponentType.UNSIGNED_SHORT;
            case Uint8Array:
                return Mv.ComponentType.UNSIGNED_BYTE;
            case Int16Array:
                return Mv.ComponentType.SHORT;
            case Int8Array:
                return Mv.ComponentType.BYTE;
            default:
                throw new Error("Unknown accessor componentType.")
            }
        }(e) : Mv.ComponentType.FLOAT), this.set("array", e), this
    }
    getByteLength()
    {
        const e = this.get("array");
        return e ? e.byteLength : 0
    }
}
Mv.Type = {
    SCALAR: "SCALAR",
    VEC2: "VEC2",
    VEC3: "VEC3",
    VEC4: "VEC4",
    MAT2: "MAT2",
    MAT3: "MAT3",
    MAT4: "MAT4"
},
Mv.ComponentType = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_INT: 5125,
    FLOAT: 5126
};
class Rv extends Tv {
    init()
    {
        this.propertyType = Fy.ANIMATION
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            channels: new By,
            samplers: new By
        })
    }
    addChannel(e)
    {
        return this.addRef("channels", e)
    }
    removeChannel(e)
    {
        return this.removeRef("channels", e)
    }
    listChannels()
    {
        return this.listRefs("channels")
    }
    addSampler(e)
    {
        return this.addRef("samplers", e)
    }
    removeSampler(e)
    {
        return this.removeRef("samplers", e)
    }
    listSamplers()
    {
        return this.listRefs("samplers")
    }
}
class Bv extends Tv {
    init()
    {
        this.propertyType = Fy.ANIMATION_CHANNEL
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            targetPath: null,
            targetNode: null,
            sampler: null
        })
    }
    getTargetPath()
    {
        return this.get("targetPath")
    }
    setTargetPath(e)
    {
        return this.set("targetPath", e)
    }
    getTargetNode()
    {
        return this.getRef("targetNode")
    }
    setTargetNode(e)
    {
        return this.setRef("targetNode", e)
    }
    getSampler()
    {
        return this.getRef("sampler")
    }
    setSampler(e)
    {
        return this.setRef("sampler", e)
    }
}
Bv.TargetPath = {
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights"
};
class kv extends Tv {
    init()
    {
        this.propertyType = Fy.ANIMATION_SAMPLER
    }
    getDefaultAttributes()
    {
        return Object.assign(super.getDefaults(), {
            interpolation: kv.Interpolation.LINEAR,
            input: null,
            output: null
        })
    }
    getInterpolation()
    {
        return this.get("interpolation")
    }
    setInterpolation(e)
    {
        return this.set("interpolation", e)
    }
    getInput()
    {
        return this.getRef("input")
    }
    setInput(e)
    {
        return this.setRef("input", e, {
            usage: Gy.OTHER
        })
    }
    getOutput()
    {
        return this.getRef("output")
    }
    setOutput(e)
    {
        return this.setRef("output", e, {
            usage: Gy.OTHER
        })
    }
}
kv.Interpolation = {
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
};
class Dv extends Tv {
    init()
    {
        this.propertyType = Fy.BUFFER
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            uri: ""
        })
    }
    getURI()
    {
        return this.get("uri")
    }
    setURI(e)
    {
        return this.set("uri", e)
    }
}
class Pv extends Tv {
    init()
    {
        this.propertyType = Fy.CAMERA
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            type: Pv.Type.PERSPECTIVE,
            znear: .1,
            zfar: 100,
            aspectRatio: null,
            yfov: 2 * Math.PI * 50 / 360,
            xmag: 1,
            ymag: 1
        })
    }
    getType()
    {
        return this.get("type")
    }
    setType(e)
    {
        return this.set("type", e)
    }
    getZNear()
    {
        return this.get("znear")
    }
    setZNear(e)
    {
        return this.set("znear", e)
    }
    getZFar()
    {
        return this.get("zfar")
    }
    setZFar(e)
    {
        return this.set("zfar", e)
    }
    getAspectRatio()
    {
        return this.get("aspectRatio")
    }
    setAspectRatio(e)
    {
        return this.set("aspectRatio", e)
    }
    getYFov()
    {
        return this.get("yfov")
    }
    setYFov(e)
    {
        return this.set("yfov", e)
    }
    getXMag()
    {
        return this.get("xmag")
    }
    setXMag(e)
    {
        return this.set("xmag", e)
    }
    getYMag()
    {
        return this.get("ymag")
    }
    setYMag(e)
    {
        return this.set("ymag", e)
    }
}
Pv.Type = {
    PERSPECTIVE: "perspective",
    ORTHOGRAPHIC: "orthographic"
};
class Ov extends Iv {
    _validateParent(e)
    {
        if (!this.parentTypes.includes(e.propertyType))
            throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`)
    }
}
Ov.EXTENSION_NAME = void 0;
class Lv extends Tv {
    init()
    {
        this.propertyType = Fy.TEXTURE_INFO
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            texCoord: 0,
            magFilter: null,
            minFilter: null,
            wrapS: Lv.WrapMode.REPEAT,
            wrapT: Lv.WrapMode.REPEAT
        })
    }
    getTexCoord()
    {
        return this.get("texCoord")
    }
    setTexCoord(e)
    {
        return this.set("texCoord", e)
    }
    getMagFilter()
    {
        return this.get("magFilter")
    }
    setMagFilter(e)
    {
        return this.set("magFilter", e)
    }
    getMinFilter()
    {
        return this.get("minFilter")
    }
    setMinFilter(e)
    {
        return this.set("minFilter", e)
    }
    getWrapS()
    {
        return this.get("wrapS")
    }
    setWrapS(e)
    {
        return this.set("wrapS", e)
    }
    getWrapT()
    {
        return this.get("wrapT")
    }
    setWrapT(e)
    {
        return this.set("wrapT", e)
    }
}
Lv.WrapMode = {
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
},
Lv.MagFilter = {
    NEAREST: 9728,
    LINEAR: 9729
},
Lv.MinFilter = {
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987
};
const {R: Nv, G: Fv, B: Uv, A: zv} = Vy;
class Qv extends Tv {
    init()
    {
        this.propertyType = Fy.MATERIAL
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            alphaMode: Qv.AlphaMode.OPAQUE,
            alphaCutoff: .5,
            doubleSided: !1,
            baseColorFactor: [1, 1, 1, 1],
            baseColorTexture: null,
            baseColorTextureInfo: new Lv(this.graph, "baseColorTextureInfo"),
            emissiveFactor: [0, 0, 0],
            emissiveTexture: null,
            emissiveTextureInfo: new Lv(this.graph, "emissiveTextureInfo"),
            normalScale: 1,
            normalTexture: null,
            normalTextureInfo: new Lv(this.graph, "normalTextureInfo"),
            occlusionStrength: 1,
            occlusionTexture: null,
            occlusionTextureInfo: new Lv(this.graph, "occlusionTextureInfo"),
            roughnessFactor: 1,
            metallicFactor: 1,
            metallicRoughnessTexture: null,
            metallicRoughnessTextureInfo: new Lv(this.graph, "metallicRoughnessTextureInfo")
        })
    }
    getDoubleSided()
    {
        return this.get("doubleSided")
    }
    setDoubleSided(e)
    {
        return this.set("doubleSided", e)
    }
    getAlpha()
    {
        return this.get("baseColorFactor")[3]
    }
    setAlpha(e)
    {
        const t = this.get("baseColorFactor").slice();
        return t[3] = e, this.set("baseColorFactor", t)
    }
    getAlphaMode()
    {
        return this.get("alphaMode")
    }
    setAlphaMode(e)
    {
        return this.set("alphaMode", e)
    }
    getAlphaCutoff()
    {
        return this.get("alphaCutoff")
    }
    setAlphaCutoff(e)
    {
        return this.set("alphaCutoff", e)
    }
    getBaseColorFactor()
    {
        return this.get("baseColorFactor")
    }
    setBaseColorFactor(e)
    {
        return this.set("baseColorFactor", e)
    }
    getBaseColorTexture()
    {
        return this.getRef("baseColorTexture")
    }
    getBaseColorTextureInfo()
    {
        return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null
    }
    setBaseColorTexture(e)
    {
        return this.setRef("baseColorTexture", e, {
            channels: Nv | Fv | Uv | zv,
            isColor: !0
        })
    }
    getEmissiveFactor()
    {
        return this.get("emissiveFactor")
    }
    setEmissiveFactor(e)
    {
        return this.set("emissiveFactor", e)
    }
    getEmissiveTexture()
    {
        return this.getRef("emissiveTexture")
    }
    getEmissiveTextureInfo()
    {
        return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null
    }
    setEmissiveTexture(e)
    {
        return this.setRef("emissiveTexture", e, {
            channels: Nv | Fv | Uv,
            isColor: !0
        })
    }
    getNormalScale()
    {
        return this.get("normalScale")
    }
    setNormalScale(e)
    {
        return this.set("normalScale", e)
    }
    getNormalTexture()
    {
        return this.getRef("normalTexture")
    }
    getNormalTextureInfo()
    {
        return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null
    }
    setNormalTexture(e)
    {
        return this.setRef("normalTexture", e, {
            channels: Nv | Fv | Uv
        })
    }
    getOcclusionStrength()
    {
        return this.get("occlusionStrength")
    }
    setOcclusionStrength(e)
    {
        return this.set("occlusionStrength", e)
    }
    getOcclusionTexture()
    {
        return this.getRef("occlusionTexture")
    }
    getOcclusionTextureInfo()
    {
        return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null
    }
    setOcclusionTexture(e)
    {
        return this.setRef("occlusionTexture", e, {
            channels: Nv
        })
    }
    getRoughnessFactor()
    {
        return this.get("roughnessFactor")
    }
    setRoughnessFactor(e)
    {
        return this.set("roughnessFactor", e)
    }
    getMetallicFactor()
    {
        return this.get("metallicFactor")
    }
    setMetallicFactor(e)
    {
        return this.set("metallicFactor", e)
    }
    getMetallicRoughnessTexture()
    {
        return this.getRef("metallicRoughnessTexture")
    }
    getMetallicRoughnessTextureInfo()
    {
        return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null
    }
    setMetallicRoughnessTexture(e)
    {
        return this.setRef("metallicRoughnessTexture", e, {
            channels: Fv | Uv
        })
    }
}
Qv.AlphaMode = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
class Gv extends Tv {
    init()
    {
        this.propertyType = Fy.MESH
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            weights: [],
            primitives: new By
        })
    }
    addPrimitive(e)
    {
        return this.addRef("primitives", e)
    }
    removePrimitive(e)
    {
        return this.removeRef("primitives", e)
    }
    listPrimitives()
    {
        return this.listRefs("primitives")
    }
    getWeights()
    {
        return this.get("weights")
    }
    setWeights(e)
    {
        return this.set("weights", e)
    }
}
class jv extends Tv {
    init()
    {
        this.propertyType = Fy.NODE
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            translation: [0, 0, 0],
            rotation: [0, 0, 0, 1],
            scale: [1, 1, 1],
            weights: [],
            camera: null,
            mesh: null,
            skin: null,
            children: new By
        })
    }
    copy(e, t=Ev)
    {
        if (t === Ev)
            throw new Error("Node cannot be copied.");
        return super.copy(e, t)
    }
    getTranslation()
    {
        return this.get("translation")
    }
    getRotation()
    {
        return this.get("rotation")
    }
    getScale()
    {
        return this.get("scale")
    }
    setTranslation(e)
    {
        return this.set("translation", e)
    }
    setRotation(e)
    {
        return this.set("rotation", e)
    }
    setScale(e)
    {
        return this.set("scale", e)
    }
    getMatrix()
    {
        return mv.compose(this.get("translation"), this.get("rotation"), this.get("scale"), [])
    }
    setMatrix(e)
    {
        const t = this.get("translation").slice(),
            n = this.get("rotation").slice(),
            r = this.get("scale").slice();
        return mv.decompose(e, t, n, r), this.set("translation", t).set("rotation", n).set("scale", r)
    }
    getWorldTranslation()
    {
        const e = [0, 0, 0];
        return mv.decompose(this.getWorldMatrix(), e, [0, 0, 0, 1], [1, 1, 1]), e
    }
    getWorldRotation()
    {
        const e = [0, 0, 0, 1];
        return mv.decompose(this.getWorldMatrix(), [0, 0, 0], e, [1, 1, 1]), e
    }
    getWorldScale()
    {
        const e = [1, 1, 1];
        return mv.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e), e
    }
    getWorldMatrix()
    {
        const e = [];
        for (let r = this; null != r; r = r.getParentNode())
            e.push(r);
        let t;
        const n = e.pop().getMatrix();
        for (; t = e.pop();)
            gv(n, n, t.getMatrix());
        return n
    }
    addChild(e)
    {
        const t = e.getParentNode();
        t && t.removeChild(e);
        for (const n of e.listParents())
            n.propertyType === Fy.SCENE && n.removeChild(e);
        return this.addRef("children", e)
    }
    removeChild(e)
    {
        return this.removeRef("children", e)
    }
    listChildren()
    {
        return this.listRefs("children")
    }
    getParentNode()
    {
        for (const e of this.listParents())
            if (e.propertyType === Fy.NODE)
                return e;
        return null
    }
    getMesh()
    {
        return this.getRef("mesh")
    }
    setMesh(e)
    {
        return this.setRef("mesh", e)
    }
    getCamera()
    {
        return this.getRef("camera")
    }
    setCamera(e)
    {
        return this.setRef("camera", e)
    }
    getSkin()
    {
        return this.getRef("skin")
    }
    setSkin(e)
    {
        return this.setRef("skin", e)
    }
    getWeights()
    {
        return this.get("weights")
    }
    setWeights(e)
    {
        return this.set("weights", e)
    }
    traverse(e)
    {
        e(this);
        for (const t of this.listChildren())
            t.traverse(e);
        return this
    }
}
class Vv extends Tv {
    init()
    {
        this.propertyType = Fy.PRIMITIVE
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            mode: Vv.Mode.TRIANGLES,
            material: null,
            indices: null,
            attributes: new ky,
            targets: new By
        })
    }
    getIndices()
    {
        return this.getRef("indices")
    }
    setIndices(e)
    {
        return this.setRef("indices", e, {
            usage: Gy.ELEMENT_ARRAY_BUFFER
        })
    }
    getAttribute(e)
    {
        return this.getRefMap("attributes", e)
    }
    setAttribute(e, t)
    {
        return this.setRefMap("attributes", e, t, {
            usage: Gy.ARRAY_BUFFER
        })
    }
    listAttributes()
    {
        return this.listRefMapValues("attributes")
    }
    listSemantics()
    {
        return this.listRefMapKeys("attributes")
    }
    getMaterial()
    {
        return this.getRef("material")
    }
    setMaterial(e)
    {
        return this.setRef("material", e)
    }
    getMode()
    {
        return this.get("mode")
    }
    setMode(e)
    {
        return this.set("mode", e)
    }
    listTargets()
    {
        return this.listRefs("targets")
    }
    addTarget(e)
    {
        return this.addRef("targets", e)
    }
    removeTarget(e)
    {
        return this.removeRef("targets", e)
    }
}
Vv.Mode = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};
class Hv extends Iv {
    init()
    {
        this.propertyType = Fy.PRIMITIVE_TARGET
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            attributes: new ky
        })
    }
    getAttribute(e)
    {
        return this.getRefMap("attributes", e)
    }
    setAttribute(e, t)
    {
        return this.setRefMap("attributes", e, t, {
            usage: Gy.ARRAY_BUFFER
        })
    }
    listAttributes()
    {
        return this.listRefMapValues("attributes")
    }
    listSemantics()
    {
        return this.listRefMapKeys("attributes")
    }
}
function $v() {
    return $v = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, $v.apply(null, arguments)
}
class Wv extends Tv {
    init()
    {
        this.propertyType = Fy.SCENE
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            children: new By
        })
    }
    copy(e, t=Ev)
    {
        if (t === Ev)
            throw new Error("Scene cannot be copied.");
        return super.copy(e, t)
    }
    addChild(e)
    {
        const t = e.getParentNode();
        return t && t.removeChild(e), this.addRef("children", e)
    }
    removeChild(e)
    {
        return this.removeRef("children", e)
    }
    listChildren()
    {
        return this.listRefs("children")
    }
    traverse(e)
    {
        for (const t of this.listChildren())
            t.traverse(e);
        return this
    }
}
class Kv extends Tv {
    init()
    {
        this.propertyType = Fy.SKIN
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            skeleton: null,
            inverseBindMatrices: null,
            joints: new By
        })
    }
    getSkeleton()
    {
        return this.getRef("skeleton")
    }
    setSkeleton(e)
    {
        return this.setRef("skeleton", e)
    }
    getInverseBindMatrices()
    {
        return this.getRef("inverseBindMatrices")
    }
    setInverseBindMatrices(e)
    {
        return this.setRef("inverseBindMatrices", e, {
            usage: Gy.INVERSE_BIND_MATRICES
        })
    }
    addJoint(e)
    {
        return this.addRef("joints", e)
    }
    removeJoint(e)
    {
        return this.removeRef("joints", e)
    }
    listJoints()
    {
        return this.listRefs("joints")
    }
}
class qv extends Tv {
    init()
    {
        this.propertyType = Fy.TEXTURE
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            image: null,
            mimeType: "",
            uri: ""
        })
    }
    getMimeType()
    {
        return this.get("mimeType") || Yy.extensionToMimeType(Zy.extension(this.get("uri")))
    }
    setMimeType(e)
    {
        return this.set("mimeType", e)
    }
    getURI()
    {
        return this.get("uri")
    }
    setURI(e)
    {
        this.set("uri", e);
        const t = Yy.extensionToMimeType(Zy.extension(e));
        return t && this.set("mimeType", t), this
    }
    getImage()
    {
        return this.get("image")
    }
    setImage(e)
    {
        return this.set("image", qy.assertView(e))
    }
    getSize()
    {
        const e = this.get("image");
        return e ? Yy.getSize(e, this.getMimeType()) : null
    }
}
class Xv extends Tv {
    init()
    {
        this.propertyType = Fy.ROOT
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            asset: {
                generator: `glTF-Transform ${Ly}`,
                version: "2.0"
            },
            defaultScene: null,
            accessors: new By,
            animations: new By,
            buffers: new By,
            cameras: new By,
            materials: new By,
            meshes: new By,
            nodes: new By,
            scenes: new By,
            skins: new By,
            textures: new By
        })
    }
    constructor(e)
    {
        super(e),
        this._extensions = new Set,
        e.addEventListener("node:create", e => {
            this._addChildOfRoot(e.target)
        })
    }
    clone()
    {
        throw new Error("Root cannot be cloned.")
    }
    copy(e, t=Ev)
    {
        if (t === Ev)
            throw new Error("Root cannot be copied.");
        this.set("asset", $v({}, e.get("asset"))),
        this.setName(e.getName()),
        this.setExtras($v({}, e.getExtras())),
        this.setDefaultScene(e.getDefaultScene() ? t(e.getDefaultScene()) : null);
        for (const n of e.listRefMapKeys("extensions")) {
            const r = e.getExtension(n);
            this.setExtension(n, t(r))
        }
        return this
    }
    _addChildOfRoot(e)
    {
        return e instanceof Wv ? this.addRef("scenes", e) : e instanceof jv ? this.addRef("nodes", e) : e instanceof Pv ? this.addRef("cameras", e) : e instanceof Kv ? this.addRef("skins", e) : e instanceof Gv ? this.addRef("meshes", e) : e instanceof Qv ? this.addRef("materials", e) : e instanceof qv ? this.addRef("textures", e) : e instanceof Rv ? this.addRef("animations", e) : e instanceof Mv ? this.addRef("accessors", e) : e instanceof Dv && this.addRef("buffers", e), this
    }
    getAsset()
    {
        return this.get("asset")
    }
    listExtensionsUsed()
    {
        return Array.from(this._extensions)
    }
    listExtensionsRequired()
    {
        return this.listExtensionsUsed().filter(e => e.isRequired())
    }
    _enableExtension(e)
    {
        return this._extensions.add(e), this
    }
    _disableExtension(e)
    {
        return this._extensions.delete(e), this
    }
    listScenes()
    {
        return this.listRefs("scenes")
    }
    setDefaultScene(e)
    {
        return this.setRef("defaultScene", e)
    }
    getDefaultScene()
    {
        return this.getRef("defaultScene")
    }
    listNodes()
    {
        return this.listRefs("nodes")
    }
    listCameras()
    {
        return this.listRefs("cameras")
    }
    listSkins()
    {
        return this.listRefs("skins")
    }
    listMeshes()
    {
        return this.listRefs("meshes")
    }
    listMaterials()
    {
        return this.listRefs("materials")
    }
    listTextures()
    {
        return this.listRefs("textures")
    }
    listAnimations()
    {
        return this.listRefs("animations")
    }
    listAccessors()
    {
        return this.listRefs("accessors")
    }
    listBuffers()
    {
        return this.listRefs("buffers")
    }
}
class Yv {
    static fromGraph(e)
    {
        return Yv._GRAPH_DOCUMENTS.get(e) || null
    }
    constructor()
    {
        this._graph = new Ty,
        this._root = new Xv(this._graph),
        this._logger = fv.DEFAULT_INSTANCE,
        Yv._GRAPH_DOCUMENTS.set(this._graph, this)
    }
    getRoot()
    {
        return this._root
    }
    getGraph()
    {
        return this._graph
    }
    getLogger()
    {
        return this._logger
    }
    setLogger(e)
    {
        return this._logger = e, this
    }
    clone()
    {
        throw new Error("Use 'cloneDocument(source)' from '@gltf-transform/functions'.")
    }
    merge(e)
    {
        throw new Error("Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.")
    }
    async transform(...e)
    {
        const t = e.map(e => e.name);
        for (const n of e)
            await n(this, {
                stack: t
            });
        return this
    }
    createExtension(e)
    {
        const t = e.EXTENSION_NAME;
        return this.getRoot().listExtensionsUsed().find(e => e.extensionName === t) || new e(this)
    }
    createScene(e="")
    {
        return new Wv(this._graph, e)
    }
    createNode(e="")
    {
        return new jv(this._graph, e)
    }
    createCamera(e="")
    {
        return new Pv(this._graph, e)
    }
    createSkin(e="")
    {
        return new Kv(this._graph, e)
    }
    createMesh(e="")
    {
        return new Gv(this._graph, e)
    }
    createPrimitive()
    {
        return new Vv(this._graph)
    }
    createPrimitiveTarget(e="")
    {
        return new Hv(this._graph, e)
    }
    createMaterial(e="")
    {
        return new Qv(this._graph, e)
    }
    createTexture(e="")
    {
        return new qv(this._graph, e)
    }
    createAnimation(e="")
    {
        return new Rv(this._graph, e)
    }
    createAnimationChannel(e="")
    {
        return new Bv(this._graph, e)
    }
    createAnimationSampler(e="")
    {
        return new kv(this._graph, e)
    }
    createAccessor(e="", t=null)
    {
        return t || (t = this.getRoot().listBuffers()[0]), new Mv(this._graph, e).setBuffer(t)
    }
    createBuffer(e="")
    {
        return new Dv(this._graph, e)
    }
}
Yv._GRAPH_DOCUMENTS = new WeakMap;
class Jv {
    constructor(e)
    {
        this.extensionName = "",
        this.prereadTypes = [],
        this.prewriteTypes = [],
        this.readDependencies = [],
        this.writeDependencies = [],
        this.document = void 0,
        this.required = !1,
        this.properties = new Set,
        this._listener = void 0,
        this.document = e,
        e.getRoot()._enableExtension(this),
        this._listener = e => {
            const t = e,
                n = t.target;
            n instanceof Ov && n.extensionName === this.extensionName && ("node:create" === t.type && this._addExtensionProperty(n), "node:dispose" === t.type && this._removeExtensionProperty(n))
        };
        const t = e.getGraph();
        t.addEventListener("node:create", this._listener),
        t.addEventListener("node:dispose", this._listener)
    }
    dispose()
    {
        this.document.getRoot()._disableExtension(this);
        const e = this.document.getGraph();
        e.removeEventListener("node:create", this._listener),
        e.removeEventListener("node:dispose", this._listener);
        for (const t of this.properties)
            t.dispose()
    }
    static register() {}
    isRequired()
    {
        return this.required
    }
    setRequired(e)
    {
        return this.required = e, this
    }
    listProperties()
    {
        return Array.from(this.properties)
    }
    _addExtensionProperty(e)
    {
        return this.properties.add(e), this
    }
    _removeExtensionProperty(e)
    {
        return this.properties.delete(e), this
    }
    install(e, t)
    {
        return this
    }
    preread(e, t)
    {
        return this
    }
    prewrite(e, t)
    {
        return this
    }
}
Jv.EXTENSION_NAME = void 0;
class Zv {
    constructor(e)
    {
        this.jsonDoc = void 0,
        this.buffers = [],
        this.bufferViews = [],
        this.bufferViewBuffers = [],
        this.accessors = [],
        this.textures = [],
        this.textureInfos = new Map,
        this.materials = [],
        this.meshes = [],
        this.cameras = [],
        this.nodes = [],
        this.skins = [],
        this.animations = [],
        this.scenes = [],
        this.jsonDoc = e
    }
    setTextureInfo(e, t)
    {
        this.textureInfos.set(e, t),
        void 0 !== t.texCoord && e.setTexCoord(t.texCoord),
        void 0 !== t.extras && e.setExtras(t.extras);
        const n = this.jsonDoc.json.textures[t.index];
        if (void 0 === n.sampler)
            return;
        const r = this.jsonDoc.json.samplers[n.sampler];
        void 0 !== r.magFilter && e.setMagFilter(r.magFilter),
        void 0 !== r.minFilter && e.setMinFilter(r.minFilter),
        void 0 !== r.wrapS && e.setWrapS(r.wrapS),
        void 0 !== r.wrapT && e.setWrapT(r.wrapT)
    }
}
const e_ = {
        logger: fv.DEFAULT_INSTANCE,
        extensions: [],
        dependencies: {}
    },
    t_ = new Set([Fy.BUFFER, Fy.TEXTURE, Fy.MATERIAL, Fy.MESH, Fy.PRIMITIVE, Fy.NODE, Fy.SCENE]);
class n_ {
    static read(e, t=e_)
    {
        const n = $v({}, e_, t),
            {json: r} = e,
            o = (new Yv).setLogger(n.logger);
        this.validate(e, n);
        const i = new Zv(e),
            a = r.asset,
            s = o.getRoot().getAsset();
        a.copyright && (s.copyright = a.copyright),
        a.extras && (s.extras = a.extras),
        void 0 !== r.extras && o.getRoot().setExtras($v({}, r.extras));
        const l = r.extensionsUsed || [],
            c = r.extensionsRequired || [];
        n.extensions.sort((e, t) => e.EXTENSION_NAME > t.EXTENSION_NAME ? 1 : -1);
        for (const x of n.extensions)
            if (l.includes(x.EXTENSION_NAME)) {
                const e = o.createExtension(x).setRequired(c.includes(x.EXTENSION_NAME)),
                    t = e.prereadTypes.filter(e => !t_.has(e));
                t.length && n.logger.warn(`Preread hooks for some types (${t.join()}), requested by extension ${e.extensionName}, are unsupported. Please file an issue or a PR.`);
                for (const r of e.readDependencies)
                    e.install(r, n.dependencies[r])
            }
        const u = r.buffers || [];
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.BUFFER)).forEach(e => e.preread(i, Fy.BUFFER)),
        i.buffers = u.map(e => {
            const t = o.createBuffer(e.name);
            return e.extras && t.setExtras(e.extras), e.uri && 0 !== e.uri.indexOf("__") && t.setURI(e.uri), t
        });
        const d = r.bufferViews || [];
        i.bufferViewBuffers = d.map((t, n) => {
            if (!i.bufferViews[n]) {
                const r = e.json.buffers[t.buffer],
                    o = r.uri ? e.resources[r.uri] : e.resources[Ny],
                    a = t.byteOffset || 0;
                i.bufferViews[n] = qy.toView(o, a, t.byteLength)
            }
            return i.buffers[t.buffer]
        });
        const p = r.accessors || [];
        i.accessors = p.map(e => {
            const t = i.bufferViewBuffers[e.bufferView],
                n = o.createAccessor(e.name, t).setType(e.type);
            return e.extras && n.setExtras(e.extras), void 0 !== e.normalized && n.setNormalized(e.normalized), void 0 === e.bufferView || n.setArray(r_(e, i)), n
        });
        const h = r.images || [],
            f = r.textures || [];
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.TEXTURE)).forEach(e => e.preread(i, Fy.TEXTURE)),
        i.textures = h.map(t => {
            const n = o.createTexture(t.name);
            if (t.extras && n.setExtras(t.extras), void 0 !== t.bufferView) {
                const o = r.bufferViews[t.bufferView],
                    i = e.json.buffers[o.buffer],
                    a = i.uri ? e.resources[i.uri] : e.resources[Ny],
                    s = o.byteOffset || 0,
                    l = o.byteLength,
                    c = a.slice(s, s + l);
                n.setImage(c)
            } else
                void 0 !== t.uri && (n.setImage(e.resources[t.uri]), 0 !== t.uri.indexOf("__") && n.setURI(t.uri));
            if (void 0 !== t.mimeType)
                n.setMimeType(t.mimeType);
            else if (t.uri) {
                const e = Zy.extension(t.uri);
                n.setMimeType(Yy.extensionToMimeType(e))
            }
            return n
        }),
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.MATERIAL)).forEach(e => e.preread(i, Fy.MATERIAL));
        const g = r.materials || [];
        i.materials = g.map(e => {
            const t = o.createMaterial(e.name);
            e.extras && t.setExtras(e.extras),
            void 0 !== e.alphaMode && t.setAlphaMode(e.alphaMode),
            void 0 !== e.alphaCutoff && t.setAlphaCutoff(e.alphaCutoff),
            void 0 !== e.doubleSided && t.setDoubleSided(e.doubleSided);
            const n = e.pbrMetallicRoughness || {};
            if (void 0 !== n.baseColorFactor && t.setBaseColorFactor(n.baseColorFactor), void 0 !== e.emissiveFactor && t.setEmissiveFactor(e.emissiveFactor), void 0 !== n.metallicFactor && t.setMetallicFactor(n.metallicFactor), void 0 !== n.roughnessFactor && t.setRoughnessFactor(n.roughnessFactor), void 0 !== n.baseColorTexture) {
                const e = n.baseColorTexture,
                    r = i.textures[f[e.index].source];
                t.setBaseColorTexture(r),
                i.setTextureInfo(t.getBaseColorTextureInfo(), e)
            }
            if (void 0 !== e.emissiveTexture) {
                const n = e.emissiveTexture,
                    r = i.textures[f[n.index].source];
                t.setEmissiveTexture(r),
                i.setTextureInfo(t.getEmissiveTextureInfo(), n)
            }
            if (void 0 !== e.normalTexture) {
                const n = e.normalTexture,
                    r = i.textures[f[n.index].source];
                t.setNormalTexture(r),
                i.setTextureInfo(t.getNormalTextureInfo(), n),
                void 0 !== e.normalTexture.scale && t.setNormalScale(e.normalTexture.scale)
            }
            if (void 0 !== e.occlusionTexture) {
                const n = e.occlusionTexture,
                    r = i.textures[f[n.index].source];
                t.setOcclusionTexture(r),
                i.setTextureInfo(t.getOcclusionTextureInfo(), n),
                void 0 !== e.occlusionTexture.strength && t.setOcclusionStrength(e.occlusionTexture.strength)
            }
            if (void 0 !== n.metallicRoughnessTexture) {
                const e = n.metallicRoughnessTexture,
                    r = i.textures[f[e.index].source];
                t.setMetallicRoughnessTexture(r),
                i.setTextureInfo(t.getMetallicRoughnessTextureInfo(), e)
            }
            return t
        }),
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.MESH)).forEach(e => e.preread(i, Fy.MESH));
        const m = r.meshes || [];
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.PRIMITIVE)).forEach(e => e.preread(i, Fy.PRIMITIVE)),
        i.meshes = m.map(e => {
            const t = o.createMesh(e.name);
            return e.extras && t.setExtras(e.extras), void 0 !== e.weights && t.setWeights(e.weights), (e.primitives || []).forEach(n => {
                const r = o.createPrimitive();
                n.extras && r.setExtras(n.extras),
                void 0 !== n.material && r.setMaterial(i.materials[n.material]),
                void 0 !== n.mode && r.setMode(n.mode);
                for (const [e, t] of Object.entries(n.attributes || {}))
                    r.setAttribute(e, i.accessors[t]);
                void 0 !== n.indices && r.setIndices(i.accessors[n.indices]);
                const a = e.extras && e.extras.targetNames || [];
                (n.targets || []).forEach((e, t) => {
                    const n = a[t] || t.toString(),
                        s = o.createPrimitiveTarget(n);
                    for (const [r, o] of Object.entries(e))
                        s.setAttribute(r, i.accessors[o]);
                    r.addTarget(s)
                }),
                t.addPrimitive(r)
            }), t
        });
        const b = r.cameras || [];
        i.cameras = b.map(e => {
            const t = o.createCamera(e.name).setType(e.type);
            if (e.extras && t.setExtras(e.extras), e.type === Pv.Type.PERSPECTIVE) {
                const n = e.perspective;
                t.setYFov(n.yfov),
                t.setZNear(n.znear),
                void 0 !== n.zfar && t.setZFar(n.zfar),
                void 0 !== n.aspectRatio && t.setAspectRatio(n.aspectRatio)
            } else {
                const n = e.orthographic;
                t.setZNear(n.znear).setZFar(n.zfar).setXMag(n.xmag).setYMag(n.ymag)
            }
            return t
        });
        const A = r.nodes || [];
        o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.NODE)).forEach(e => e.preread(i, Fy.NODE)),
        i.nodes = A.map(e => {
            const t = o.createNode(e.name);
            if (e.extras && t.setExtras(e.extras), void 0 !== e.translation && t.setTranslation(e.translation), void 0 !== e.rotation && t.setRotation(e.rotation), void 0 !== e.scale && t.setScale(e.scale), void 0 !== e.matrix) {
                const n = [0, 0, 0],
                    r = [0, 0, 0, 1],
                    o = [1, 1, 1];
                mv.decompose(e.matrix, n, r, o),
                t.setTranslation(n),
                t.setRotation(r),
                t.setScale(o)
            }
            return void 0 !== e.weights && t.setWeights(e.weights), t
        });
        const y = r.skins || [];
        i.skins = y.map(e => {
            const t = o.createSkin(e.name);
            e.extras && t.setExtras(e.extras),
            void 0 !== e.inverseBindMatrices && t.setInverseBindMatrices(i.accessors[e.inverseBindMatrices]),
            void 0 !== e.skeleton && t.setSkeleton(i.nodes[e.skeleton]);
            for (const n of e.joints)
                t.addJoint(i.nodes[n]);
            return t
        }),
        A.map((e, t) => {
            const n = i.nodes[t];
            (e.children || []).forEach(e => n.addChild(i.nodes[e])),
            void 0 !== e.mesh && n.setMesh(i.meshes[e.mesh]),
            void 0 !== e.camera && n.setCamera(i.cameras[e.camera]),
            void 0 !== e.skin && n.setSkin(i.skins[e.skin])
        });
        const v = r.animations || [];
        i.animations = v.map(e => {
            const t = o.createAnimation(e.name);
            e.extras && t.setExtras(e.extras);
            const n = (e.samplers || []).map(e => {
                const n = o.createAnimationSampler().setInput(i.accessors[e.input]).setOutput(i.accessors[e.output]).setInterpolation(e.interpolation || kv.Interpolation.LINEAR);
                return e.extras && n.setExtras(e.extras), t.addSampler(n), n
            });
            return (e.channels || []).forEach(e => {
                const r = o.createAnimationChannel().setSampler(n[e.sampler]).setTargetPath(e.target.path);
                void 0 !== e.target.node && r.setTargetNode(i.nodes[e.target.node]),
                e.extras && r.setExtras(e.extras),
                t.addChannel(r)
            }), t
        });
        const _ = r.scenes || [];
        return o.getRoot().listExtensionsUsed().filter(e => e.prereadTypes.includes(Fy.SCENE)).forEach(e => e.preread(i, Fy.SCENE)), i.scenes = _.map(e => {
            const t = o.createScene(e.name);
            return e.extras && t.setExtras(e.extras), (e.nodes || []).map(e => i.nodes[e]).forEach(e => t.addChild(e)), t
        }), void 0 !== r.scene && o.getRoot().setDefaultScene(i.scenes[r.scene]), o.getRoot().listExtensionsUsed().forEach(e => e.read(i)), p.forEach((e, t) => {
            const n = i.accessors[t],
                r = !!e.sparse,
                o = !e.bufferView && !n.getArray();
            (r || o) && n.setSparse(!0).setArray(function(e, t) {
                const n = Ky[e.componentType],
                    r = Mv.getElementSize(e.type);
                let o;
                o = void 0 !== e.bufferView ? r_(e, t) : new n(e.count * r);
                const i = e.sparse;
                if (!i)
                    return o;
                const a = i.count,
                    s = $v({}, e, i.indices, {
                        count: a,
                        type: "SCALAR"
                    }),
                    l = $v({}, e, i.values, {
                        count: a
                    }),
                    c = r_(s, t),
                    u = r_(l, t);
                for (let d = 0; d < s.count; d++)
                    for (let e = 0; e < r; e++)
                        o[c[d] * r + e] = u[d * r + e];
                return o
            }(e, i))
        }), o
    }
    static validate(e, t)
    {
        const n = e.json;
        if ("2.0" !== n.asset.version)
            throw new Error(`Unsupported glTF version, "${n.asset.version}".`);
        if (n.extensionsRequired)
            for (const r of n.extensionsRequired)
                if (!t.extensions.find(e => e.EXTENSION_NAME === r))
                    throw new Error(`Missing required extension, "${r}".`);
        if (n.extensionsUsed)
            for (const r of n.extensionsUsed)
                t.extensions.find(e => e.EXTENSION_NAME === r) || t.logger.warn(`Missing optional extension, "${r}".`)
    }
}
function r_(e, t) {
    const n = t.jsonDoc,
        r = t.bufferViews[e.bufferView],
        o = n.json.bufferViews[e.bufferView],
        i = Ky[e.componentType],
        a = Mv.getElementSize(e.type),
        s = i.BYTES_PER_ELEMENT,
        l = a * s;
    if (void 0 !== o.byteStride && o.byteStride !== l)
        return function(e, t) {
            const n = t.jsonDoc,
                r = t.bufferViews[e.bufferView],
                o = n.json.bufferViews[e.bufferView],
                i = Ky[e.componentType],
                a = Mv.getElementSize(e.type),
                s = i.BYTES_PER_ELEMENT,
                l = e.byteOffset || 0,
                c = new i(e.count * a),
                u = new DataView(r.buffer, r.byteOffset, r.byteLength),
                d = o.byteStride;
            for (let p = 0; p < e.count; p++)
                for (let t = 0; t < a; t++) {
                    const n = l + p * d + t * s;
                    let r;
                    switch (e.componentType) {
                    case Mv.ComponentType.FLOAT:
                        r = u.getFloat32(n, !0);
                        break;
                    case Mv.ComponentType.UNSIGNED_INT:
                        r = u.getUint32(n, !0);
                        break;
                    case Mv.ComponentType.UNSIGNED_SHORT:
                        r = u.getUint16(n, !0);
                        break;
                    case Mv.ComponentType.UNSIGNED_BYTE:
                        r = u.getUint8(n);
                        break;
                    case Mv.ComponentType.SHORT:
                        r = u.getInt16(n, !0);
                        break;
                    case Mv.ComponentType.BYTE:
                        r = u.getInt8(n);
                        break;
                    default:
                        throw new Error(`Unexpected componentType "${e.componentType}".`)
                    }
                    c[p * a + t] = r
                }
            return c
        }(e, t);
    const c = r.byteOffset + (e.byteOffset || 0),
        u = e.count * a * s;
    return new i(r.buffer.slice(c, c + u))
}
var o_,
    i_;
(i_ = o_ || (o_ = {}))[i_.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
i_[i_.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
class a_ {
    constructor(e, t, n)
    {
        this._doc = void 0,
        this.jsonDoc = void 0,
        this.options = void 0,
        this.accessorIndexMap = new Map,
        this.animationIndexMap = new Map,
        this.bufferIndexMap = new Map,
        this.cameraIndexMap = new Map,
        this.skinIndexMap = new Map,
        this.materialIndexMap = new Map,
        this.meshIndexMap = new Map,
        this.nodeIndexMap = new Map,
        this.imageIndexMap = new Map,
        this.textureDefIndexMap = new Map,
        this.textureInfoDefMap = new Map,
        this.samplerDefIndexMap = new Map,
        this.sceneIndexMap = new Map,
        this.imageBufferViews = [],
        this.otherBufferViews = new Map,
        this.otherBufferViewsIndexMap = new Map,
        this.extensionData = {},
        this.bufferURIGenerator = void 0,
        this.imageURIGenerator = void 0,
        this.logger = void 0,
        this._accessorUsageMap = new Map,
        this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]),
        this.accessorParents = new Map,
        this._doc = e,
        this.jsonDoc = t,
        this.options = n;
        const r = e.getRoot(),
            o = r.listBuffers().length,
            i = r.listTextures().length;
        this.bufferURIGenerator = new s_(o > 1, () => n.basename || "buffer"),
        this.imageURIGenerator = new s_(i > 1, t => function(e, t) {
            const n = e.getGraph().listParentEdges(t).find(t => t.getParent() !== e.getRoot());
            return n ? n.getName().replace(/texture$/i, "") : ""
        }(e, t) || n.basename || "texture"),
        this.logger = e.getLogger()
    }
    createTextureInfoDef(e, t)
    {
        const n = {
                magFilter: t.getMagFilter() || void 0,
                minFilter: t.getMinFilter() || void 0,
                wrapS: t.getWrapS(),
                wrapT: t.getWrapT()
            },
            r = JSON.stringify(n);
        this.samplerDefIndexMap.has(r) || (this.samplerDefIndexMap.set(r, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(n));
        const o = {
                source: this.imageIndexMap.get(e),
                sampler: this.samplerDefIndexMap.get(r)
            },
            i = JSON.stringify(o);
        this.textureDefIndexMap.has(i) || (this.textureDefIndexMap.set(i, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(o));
        const a = {
            index: this.textureDefIndexMap.get(i)
        };
        return 0 !== t.getTexCoord() && (a.texCoord = t.getTexCoord()), Object.keys(t.getExtras()).length > 0 && (a.extras = t.getExtras()), this.textureInfoDefMap.set(t, a), a
    }
    createPropertyDef(e)
    {
        const t = {};
        return e.getName() && (t.name = e.getName()), Object.keys(e.getExtras()).length > 0 && (t.extras = e.getExtras()), t
    }
    createAccessorDef(e)
    {
        const t = this.createPropertyDef(e);
        return t.type = e.getType(), t.componentType = e.getComponentType(), t.count = e.getCount(), this._doc.getGraph().listParentEdges(e).some(e => "attributes" === e.getName() && "POSITION" === e.getAttributes().key || "input" === e.getName()) && (t.max = e.getMax([]).map(Math.fround), t.min = e.getMin([]).map(Math.fround)), e.getNormalized() && (t.normalized = e.getNormalized()), t
    }
    createImageData(e, t, n)
    {
        if (this.options.format === $y.GLB)
            this.imageBufferViews.push(t),
            e.bufferView = this.jsonDoc.json.bufferViews.length,
            this.jsonDoc.json.bufferViews.push({
                buffer: 0,
                byteOffset: -1,
                byteLength: t.byteLength
            });
        else {
            const r = Yy.mimeTypeToExtension(n.getMimeType());
            e.uri = this.imageURIGenerator.createURI(n, r),
            this.assignResourceURI(e.uri, t, !1)
        }
    }
    assignResourceURI(e, t, n)
    {
        const r = this.jsonDoc.resources;
        if (!(e in r))
            return void (r[e] = t);
        if (t === r[e])
            return void this.logger.warn(`Duplicate resource URI, "${e}".`);
        const o = `Resource URI "${e}" already assigned to different data.`;
        if (n)
            throw new Error(o);
        this.logger.warn(o)
    }
    getAccessorUsage(e)
    {
        const t = this._accessorUsageMap.get(e);
        if (t)
            return t;
        if (e.getSparse())
            return Gy.SPARSE;
        for (const n of this._doc.getGraph().listParentEdges(e)) {
            const {usage: e} = n.getAttributes();
            if (e)
                return e;
            n.getParent().propertyType !== Fy.ROOT && this.logger.warn(`Missing attribute ".usage" on edge, "${n.getName()}".`)
        }
        return Gy.OTHER
    }
    addAccessorToUsageGroup(e, t)
    {
        const n = this._accessorUsageMap.get(e);
        if (n && n !== t)
            throw new Error(`Accessor with usage "${n}" cannot be reused as "${t}".`);
        return this._accessorUsageMap.set(e, t), this
    }
}
a_.BufferViewTarget = o_,
a_.BufferViewUsage = Gy,
a_.USAGE_TO_TARGET = {
    [Gy.ARRAY_BUFFER]: o_.ARRAY_BUFFER,
    [Gy.ELEMENT_ARRAY_BUFFER]: o_.ELEMENT_ARRAY_BUFFER
};
class s_ {
    constructor(e, t)
    {
        this.multiple = void 0,
        this.basename = void 0,
        this.counter = {},
        this.multiple = e,
        this.basename = t
    }
    createURI(e, t)
    {
        if (e.getURI())
            return e.getURI();
        if (this.multiple) {
            const n = this.basename(e);
            return this.counter[n] = this.counter[n] || 1, `${n}_${this.counter[n]++}.${t}`
        }
        return `${this.basename(e)}.${t}`
    }
}
const {BufferViewUsage: l_} = a_,
    {UNSIGNED_INT: c_, UNSIGNED_SHORT: u_, UNSIGNED_BYTE: d_} = Mv.ComponentType,
    p_ = new Set([Fy.ACCESSOR, Fy.BUFFER, Fy.MATERIAL, Fy.MESH]);
class h_ {
    static write(e, t)
    {
        const n = e.getGraph(),
            r = e.getRoot(),
            o = {
                asset: $v({
                    generator: `glTF-Transform ${Ly}`
                }, r.getAsset()),
                extras: $v({}, r.getExtras())
            },
            i = {
                json: o,
                resources: {}
            },
            a = new a_(e, i, t),
            s = t.logger || fv.DEFAULT_INSTANCE,
            l = new Set(t.extensions.map(e => e.EXTENSION_NAME)),
            c = e.getRoot().listExtensionsUsed().filter(e => l.has(e.extensionName)).sort((e, t) => e.extensionName > t.extensionName ? 1 : -1),
            u = e.getRoot().listExtensionsRequired().filter(e => l.has(e.extensionName)).sort((e, t) => e.extensionName > t.extensionName ? 1 : -1);
        c.length < e.getRoot().listExtensionsUsed().length && s.warn("Some extensions were not registered for I/O, and will not be written.");
        for (const g of c) {
            const e = g.prewriteTypes.filter(e => !p_.has(e));
            e.length && s.warn(`Prewrite hooks for some types (${e.join()}), requested by extension ${g.extensionName}, are unsupported. Please file an issue or a PR.`);
            for (const n of g.writeDependencies)
                g.install(n, t.dependencies[n])
        }
        function d(e, t, n, r) {
            const i = [];
            let s = 0;
            for (const c of e) {
                const e = a.createAccessorDef(c);
                e.bufferView = o.bufferViews.length;
                const t = c.getArray(),
                    n = qy.pad(qy.toView(t));
                e.byteOffset = s,
                s += n.byteLength,
                i.push(n),
                a.accessorIndexMap.set(c, o.accessors.length),
                o.accessors.push(e)
            }
            const l = {
                buffer: t,
                byteOffset: n,
                byteLength: qy.concat(i).byteLength
            };
            return r && (l.target = r), o.bufferViews.push(l), {
                buffers: i,
                byteLength: s
            }
        }
        function p(e, t, n) {
            const r = e[0].getCount();
            let i = 0;
            for (const d of e) {
                const e = a.createAccessorDef(d);
                e.bufferView = o.bufferViews.length,
                e.byteOffset = i;
                const t = d.getElementSize(),
                    n = d.getComponentSize();
                i += qy.padNumber(t * n),
                a.accessorIndexMap.set(d, o.accessors.length),
                o.accessors.push(e)
            }
            const s = r * i,
                l = new ArrayBuffer(s),
                c = new DataView(l);
            for (let o = 0; o < r; o++) {
                let t = 0;
                for (const n of e) {
                    const e = n.getElementSize(),
                        r = n.getComponentSize(),
                        a = n.getComponentType(),
                        s = n.getArray();
                    for (let n = 0; n < e; n++) {
                        const l = o * i + t + n * r,
                            u = s[o * e + n];
                        switch (a) {
                        case Mv.ComponentType.FLOAT:
                            c.setFloat32(l, u, !0);
                            break;
                        case Mv.ComponentType.BYTE:
                            c.setInt8(l, u);
                            break;
                        case Mv.ComponentType.SHORT:
                            c.setInt16(l, u, !0);
                            break;
                        case Mv.ComponentType.UNSIGNED_BYTE:
                            c.setUint8(l, u);
                            break;
                        case Mv.ComponentType.UNSIGNED_SHORT:
                            c.setUint16(l, u, !0);
                            break;
                        case Mv.ComponentType.UNSIGNED_INT:
                            c.setUint32(l, u, !0);
                            break;
                        default:
                            throw new Error("Unexpected component type: " + a)
                        }
                    }
                    t += qy.padNumber(e * r)
                }
            }
            const u = {
                buffer: t,
                byteOffset: n,
                byteLength: s,
                byteStride: i,
                target: a_.BufferViewTarget.ARRAY_BUFFER
            };
            return o.bufferViews.push(u), {
                byteLength: s,
                buffers: [new Uint8Array(l)]
            }
        }
        function h(e, t, n) {
            const r = [];
            let i = 0;
            const l = new Map;
            let c = -1 / 0,
                u = !1;
            for (const s of e) {
                const e = a.createAccessorDef(s);
                o.accessors.push(e),
                a.accessorIndexMap.set(s, o.accessors.length - 1);
                const t = [],
                    n = [],
                    r = [],
                    i = new Array(s.getElementSize()).fill(0);
                for (let o = 0, a = s.getCount(); o < a; o++)
                    if (s.getElement(o, r), !mv.eq(r, i, 0)) {
                        c = Math.max(o, c),
                        t.push(o);
                        for (let e = 0; e < r.length; e++)
                            n.push(r[e])
                    }
                const d = t.length,
                    p = {
                        accessorDef: e,
                        count: d
                    };
                if (l.set(s, p), 0 === d)
                    continue;
                d > s.getCount() / 2 && (u = !0);
                const h = Ky[s.getComponentType()];
                p.indices = t,
                p.values = new h(n)
            }
            if (!Number.isFinite(c))
                return {
                    buffers: r,
                    byteLength: i
                };
            u && s.warn("Some sparse accessors have >50% non-zero elements, which may increase file size.");
            const d = c < 255 ? Uint8Array : c < 65535 ? Uint16Array : Uint32Array,
                p = c < 255 ? d_ : c < 65535 ? u_ : c_,
                h = {
                    buffer: t,
                    byteOffset: n + i,
                    byteLength: 0
                };
            for (const o of e) {
                const e = l.get(o);
                if (0 === e.count)
                    continue;
                e.indicesByteOffset = h.byteLength;
                const t = qy.pad(qy.toView(new d(e.indices)));
                r.push(t),
                i += t.byteLength,
                h.byteLength += t.byteLength
            }
            o.bufferViews.push(h);
            const f = o.bufferViews.length - 1,
                g = {
                    buffer: t,
                    byteOffset: n + i,
                    byteLength: 0
                };
            for (const o of e) {
                const e = l.get(o);
                if (0 === e.count)
                    continue;
                e.valuesByteOffset = g.byteLength;
                const t = qy.pad(qy.toView(e.values));
                r.push(t),
                i += t.byteLength,
                g.byteLength += t.byteLength
            }
            o.bufferViews.push(g);
            const m = o.bufferViews.length - 1;
            for (const o of e) {
                const e = l.get(o);
                0 !== e.count && (e.accessorDef.sparse = {
                    count: e.count,
                    indices: {
                        bufferView: f,
                        byteOffset: e.indicesByteOffset,
                        componentType: p
                    },
                    values: {
                        bufferView: m,
                        byteOffset: e.valuesByteOffset
                    }
                })
            }
            return {
                buffers: r,
                byteLength: i
            }
        }
        if (o.accessors = [], o.bufferViews = [], o.samplers = [], o.textures = [], o.images = r.listTextures().map((e, t) => {
            const n = a.createPropertyDef(e);
            e.getMimeType() && (n.mimeType = e.getMimeType());
            const r = e.getImage();
            return r && a.createImageData(n, r, e), a.imageIndexMap.set(e, t), n
        }), c.filter(e => e.prewriteTypes.includes(Fy.ACCESSOR)).forEach(e => e.prewrite(a, Fy.ACCESSOR)), r.listAccessors().forEach(e => {
            const t = a.accessorUsageGroupedByParent,
                r = a.accessorParents;
            if (a.accessorIndexMap.has(e))
                return;
            const o = a.getAccessorUsage(e);
            if (a.addAccessorToUsageGroup(e, o), t.has(o)) {
                const t = n.listParents(e).find(e => e.propertyType !== Fy.ROOT);
                r.set(e, t)
            }
        }), c.filter(e => e.prewriteTypes.includes(Fy.BUFFER)).forEach(e => e.prewrite(a, Fy.BUFFER)), (r.listAccessors().length > 0 || a.otherBufferViews.size > 0 || r.listTextures().length > 0 && t.format === $y.GLB) && 0 === r.listBuffers().length)
            throw new Error("Buffer required for Document resources, but none was found.");
        o.buffers = [],
        r.listBuffers().forEach((e, n) => {
            const r = a.createPropertyDef(e),
                i = a.accessorUsageGroupedByParent,
                s = e.listParents().filter(e => e instanceof Mv),
                l = new Set(s.map(e => a.accessorParents.get(e))),
                c = new Map(Array.from(l).map((e, t) => [e, t])),
                u = {};
            for (const t of s) {
                var f;
                if (a.accessorIndexMap.has(t))
                    continue;
                const e = a.getAccessorUsage(t);
                let n = e;
                if (i.has(e)) {
                    const e = a.accessorParents.get(t);
                    n += `:${c.get(e)}`
                }
                u[f = n] || (u[f] = {
                    usage: e,
                    accessors: []
                }),
                u[n].accessors.push(t)
            }
            const g = [],
                m = o.buffers.length;
            let b = 0;
            for (const {usage: o, accessors: a} of Object.values(u))
                if (o === l_.ARRAY_BUFFER && t.vertexLayout === zy.INTERLEAVED) {
                    const e = p(a, m, b);
                    b += e.byteLength;
                    for (const t of e.buffers)
                        g.push(t)
                } else if (o === l_.ARRAY_BUFFER)
                    for (const e of a) {
                        const t = p([e], m, b);
                        b += t.byteLength;
                        for (const e of t.buffers)
                            g.push(e)
                    }
                else if (o === l_.SPARSE) {
                    const e = h(a, m, b);
                    b += e.byteLength;
                    for (const t of e.buffers)
                        g.push(t)
                } else if (o === l_.ELEMENT_ARRAY_BUFFER) {
                    const e = d(a, m, b, a_.BufferViewTarget.ELEMENT_ARRAY_BUFFER);
                    b += e.byteLength;
                    for (const t of e.buffers)
                        g.push(t)
                } else {
                    const e = d(a, m, b);
                    b += e.byteLength;
                    for (const t of e.buffers)
                        g.push(t)
                }
            if (a.imageBufferViews.length && 0 === n)
                for (let t = 0; t < a.imageBufferViews.length; t++)
                    if (o.bufferViews[o.images[t].bufferView].byteOffset = b, b += a.imageBufferViews[t].byteLength, g.push(a.imageBufferViews[t]), b % 8) {
                        const e = 8 - b % 8;
                        b += e,
                        g.push(new Uint8Array(e))
                    }
            if (a.otherBufferViews.has(e))
                for (const t of a.otherBufferViews.get(e))
                    o.bufferViews.push({
                        buffer: m,
                        byteOffset: b,
                        byteLength: t.byteLength
                    }),
                    a.otherBufferViewsIndexMap.set(t, o.bufferViews.length - 1),
                    b += t.byteLength,
                    g.push(t);
            if (b) {
                let n;
                t.format === $y.GLB ? n = Ny : (n = a.bufferURIGenerator.createURI(e, "bin"), r.uri = n),
                r.byteLength = b,
                a.assignResourceURI(n, qy.concat(g), !0)
            }
            o.buffers.push(r),
            a.bufferIndexMap.set(e, n)
        }),
        r.listAccessors().find(e => !e.getBuffer()) && s.warn("Skipped writing one or more Accessors: no Buffer assigned."),
        c.filter(e => e.prewriteTypes.includes(Fy.MATERIAL)).forEach(e => e.prewrite(a, Fy.MATERIAL)),
        o.materials = r.listMaterials().map((e, t) => {
            const n = a.createPropertyDef(e);
            if (e.getAlphaMode() !== Qv.AlphaMode.OPAQUE && (n.alphaMode = e.getAlphaMode()), e.getAlphaMode() === Qv.AlphaMode.MASK && (n.alphaCutoff = e.getAlphaCutoff()), e.getDoubleSided() && (n.doubleSided = !0), n.pbrMetallicRoughness = {}, mv.eq(e.getBaseColorFactor(), [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = e.getBaseColorFactor()), mv.eq(e.getEmissiveFactor(), [0, 0, 0]) || (n.emissiveFactor = e.getEmissiveFactor()), 1 !== e.getRoughnessFactor() && (n.pbrMetallicRoughness.roughnessFactor = e.getRoughnessFactor()), 1 !== e.getMetallicFactor() && (n.pbrMetallicRoughness.metallicFactor = e.getMetallicFactor()), e.getBaseColorTexture()) {
                const t = e.getBaseColorTexture(),
                    r = e.getBaseColorTextureInfo();
                n.pbrMetallicRoughness.baseColorTexture = a.createTextureInfoDef(t, r)
            }
            if (e.getEmissiveTexture()) {
                const t = e.getEmissiveTexture(),
                    r = e.getEmissiveTextureInfo();
                n.emissiveTexture = a.createTextureInfoDef(t, r)
            }
            if (e.getNormalTexture()) {
                const t = e.getNormalTexture(),
                    r = e.getNormalTextureInfo(),
                    o = a.createTextureInfoDef(t, r);
                1 !== e.getNormalScale() && (o.scale = e.getNormalScale()),
                n.normalTexture = o
            }
            if (e.getOcclusionTexture()) {
                const t = e.getOcclusionTexture(),
                    r = e.getOcclusionTextureInfo(),
                    o = a.createTextureInfoDef(t, r);
                1 !== e.getOcclusionStrength() && (o.strength = e.getOcclusionStrength()),
                n.occlusionTexture = o
            }
            if (e.getMetallicRoughnessTexture()) {
                const t = e.getMetallicRoughnessTexture(),
                    r = e.getMetallicRoughnessTextureInfo();
                n.pbrMetallicRoughness.metallicRoughnessTexture = a.createTextureInfoDef(t, r)
            }
            return a.materialIndexMap.set(e, t), n
        }),
        c.filter(e => e.prewriteTypes.includes(Fy.MESH)).forEach(e => e.prewrite(a, Fy.MESH)),
        o.meshes = r.listMeshes().map((e, t) => {
            const n = a.createPropertyDef(e);
            let r = null;
            return n.primitives = e.listPrimitives().map(e => {
                const t = {
                    attributes: {}
                };
                t.mode = e.getMode();
                const n = e.getMaterial();
                n && (t.material = a.materialIndexMap.get(n)),
                Object.keys(e.getExtras()).length && (t.extras = e.getExtras());
                const o = e.getIndices();
                o && (t.indices = a.accessorIndexMap.get(o));
                for (const r of e.listSemantics())
                    t.attributes[r] = a.accessorIndexMap.get(e.getAttribute(r));
                for (const r of e.listTargets()) {
                    const e = {};
                    for (const t of r.listSemantics())
                        e[t] = a.accessorIndexMap.get(r.getAttribute(t));
                    t.targets = t.targets || [],
                    t.targets.push(e)
                }
                return e.listTargets().length && !r && (r = e.listTargets().map(e => e.getName())), t
            }), e.getWeights().length && (n.weights = e.getWeights()), r && (n.extras = n.extras || {}, n.extras.targetNames = r), a.meshIndexMap.set(e, t), n
        }),
        o.cameras = r.listCameras().map((e, t) => {
            const n = a.createPropertyDef(e);
            if (n.type = e.getType(), n.type === Pv.Type.PERSPECTIVE) {
                n.perspective = {
                    znear: e.getZNear(),
                    zfar: e.getZFar(),
                    yfov: e.getYFov()
                };
                const t = e.getAspectRatio();
                null !== t && (n.perspective.aspectRatio = t)
            } else
                n.orthographic = {
                    znear: e.getZNear(),
                    zfar: e.getZFar(),
                    xmag: e.getXMag(),
                    ymag: e.getYMag()
                };
            return a.cameraIndexMap.set(e, t), n
        }),
        o.nodes = r.listNodes().map((e, t) => {
            const n = a.createPropertyDef(e);
            return mv.eq(e.getTranslation(), [0, 0, 0]) || (n.translation = e.getTranslation()), mv.eq(e.getRotation(), [0, 0, 0, 1]) || (n.rotation = e.getRotation()), mv.eq(e.getScale(), [1, 1, 1]) || (n.scale = e.getScale()), e.getWeights().length && (n.weights = e.getWeights()), a.nodeIndexMap.set(e, t), n
        }),
        o.skins = r.listSkins().map((e, t) => {
            const n = a.createPropertyDef(e),
                r = e.getInverseBindMatrices();
            r && (n.inverseBindMatrices = a.accessorIndexMap.get(r));
            const o = e.getSkeleton();
            return o && (n.skeleton = a.nodeIndexMap.get(o)), n.joints = e.listJoints().map(e => a.nodeIndexMap.get(e)), a.skinIndexMap.set(e, t), n
        }),
        r.listNodes().forEach((e, t) => {
            const n = o.nodes[t],
                r = e.getMesh();
            r && (n.mesh = a.meshIndexMap.get(r));
            const i = e.getCamera();
            i && (n.camera = a.cameraIndexMap.get(i));
            const s = e.getSkin();
            s && (n.skin = a.skinIndexMap.get(s)),
            e.listChildren().length > 0 && (n.children = e.listChildren().map(e => a.nodeIndexMap.get(e)))
        }),
        o.animations = r.listAnimations().map((e, t) => {
            const n = a.createPropertyDef(e),
                r = new Map;
            return n.samplers = e.listSamplers().map((e, t) => {
                const n = a.createPropertyDef(e);
                return n.input = a.accessorIndexMap.get(e.getInput()), n.output = a.accessorIndexMap.get(e.getOutput()), n.interpolation = e.getInterpolation(), r.set(e, t), n
            }), n.channels = e.listChannels().map(e => {
                const t = a.createPropertyDef(e);
                return t.sampler = r.get(e.getSampler()), t.target = {
                    node: a.nodeIndexMap.get(e.getTargetNode()),
                    path: e.getTargetPath()
                }, t
            }), a.animationIndexMap.set(e, t), n
        }),
        o.scenes = r.listScenes().map((e, t) => {
            const n = a.createPropertyDef(e);
            return n.nodes = e.listChildren().map(e => a.nodeIndexMap.get(e)), a.sceneIndexMap.set(e, t), n
        });
        const f = r.getDefaultScene();
        return f && (o.scene = r.listScenes().indexOf(f)), o.extensionsUsed = c.map(e => e.extensionName), o.extensionsRequired = u.map(e => e.extensionName), c.forEach(e => e.write(a)), function(e) {
            const t = [];
            for (const n in e) {
                const r = e[n];
                (Array.isArray(r) && 0 === r.length || null === r || "" === r || r && "object" == typeof r && 0 === Object.keys(r).length) && t.push(n)
            }
            for (const n of t)
                delete e[n]
        }(o), i
    }
}
var f_,
    g_;
(g_ = f_ || (f_ = {}))[g_.JSON = 1313821514] = "JSON",
g_[g_.BIN = 5130562] = "BIN";
class m_ {
    constructor()
    {
        this._logger = fv.DEFAULT_INSTANCE,
        this._extensions = new Set,
        this._dependencies = {},
        this._vertexLayout = zy.INTERLEAVED,
        this.lastReadBytes = 0,
        this.lastWriteBytes = 0
    }
    setLogger(e)
    {
        return this._logger = e, this
    }
    registerExtensions(e)
    {
        for (const t of e)
            this._extensions.add(t),
            t.register();
        return this
    }
    registerDependencies(e)
    {
        return Object.assign(this._dependencies, e), this
    }
    setVertexLayout(e)
    {
        return this._vertexLayout = e, this
    }
    async read(e)
    {
        return await this.readJSON(await this.readAsJSON(e))
    }
    async readAsJSON(e)
    {
        const t = await this.readURI(e, "view");
        this.lastReadBytes = t.byteLength;
        const n = b_(t) ? this._binaryToJSON(t) : {
            json: JSON.parse(qy.decodeText(t)),
            resources: {}
        };
        return await this._readResourcesExternal(n, this.dirname(e)), this._readResourcesInternal(n), n
    }
    async readJSON(e)
    {
        return e = this._copyJSON(e), this._readResourcesInternal(e), n_.read(e, {
            extensions: Array.from(this._extensions),
            dependencies: this._dependencies,
            logger: this._logger
        })
    }
    async binaryToJSON(e)
    {
        const t = this._binaryToJSON(qy.assertView(e));
        this._readResourcesInternal(t);
        const n = t.json;
        if (n.buffers && n.buffers.some(e => function(e, t) {
            return void 0 !== t.uri && !(t.uri in e.resources)
        }(t, e)))
            throw new Error("Cannot resolve external buffers with binaryToJSON().");
        if (n.images && n.images.some(e => function(e, t) {
            return void 0 !== t.uri && !(t.uri in e.resources) && void 0 === t.bufferView
        }(t, e)))
            throw new Error("Cannot resolve external images with binaryToJSON().");
        return t
    }
    async readBinary(e)
    {
        return this.readJSON(await this.binaryToJSON(qy.assertView(e)))
    }
    async writeJSON(e, t={})
    {
        if (t.format === $y.GLB && e.getRoot().listBuffers().length > 1)
            throw new Error("GLB must have 01 buffers.");
        return h_.write(e, {
            format: t.format || $y.GLTF,
            basename: t.basename || "",
            logger: this._logger,
            vertexLayout: this._vertexLayout,
            dependencies: $v({}, this._dependencies),
            extensions: Array.from(this._extensions)
        })
    }
    async writeBinary(e)
    {
        const {json: t, resources: n} = await this.writeJSON(e, {
                format: $y.GLB
            }),
            r = new Uint32Array([1179937895, 2, 12]),
            o = JSON.stringify(t),
            i = qy.pad(qy.encodeText(o), 32),
            a = qy.toView(new Uint32Array([i.byteLength, 1313821514])),
            s = qy.concat([a, i]);
        r[r.length - 1] += s.byteLength;
        const l = Object.values(n)[0];
        if (!l || !l.byteLength)
            return qy.concat([qy.toView(r), s]);
        const c = qy.pad(l, 0),
            u = qy.toView(new Uint32Array([c.byteLength, 5130562])),
            d = qy.concat([u, c]);
        return r[r.length - 1] += d.byteLength, qy.concat([qy.toView(r), s, d])
    }
    async _readResourcesExternal(e, t)
    {
        var n = this;
        const r = [...e.json.images || [], ...e.json.buffers || []].map(async function(r) {
            const o = r.uri;
            if (!o || o.match(/data:/))
                return Promise.resolve();
            e.resources[o] = await n.readURI(n.resolve(t, o), "view"),
            n.lastReadBytes += e.resources[o].byteLength
        });
        await Promise.all(r)
    }
    _readResourcesInternal(e)
    {
        function t(t) {
            if (t.uri)
                if (t.uri in e.resources)
                    qy.assertView(e.resources[t.uri]);
                else if (t.uri.match(/data:/)) {
                    const n = `__${function() {for (let e = 0; e < 999; e++) {const e = Cv();if (!wv.has(e))return wv.add(e), e}return ""}()}.${Zy.extension(t.uri)}`;
                    e.resources[n] = qy.createBufferFromDataURI(t.uri),
                    t.uri = n
                }
        }
        (e.json.images || []).forEach(e => {
            if (void 0 === e.bufferView && void 0 === e.uri)
                throw new Error("Missing resource URI or buffer view.");
            t(e)
        }),
        (e.json.buffers || []).forEach(t)
    }
    _copyJSON(e)
    {
        const {images: t, buffers: n} = e.json;
        return e = {
            json: $v({}, e.json),
            resources: $v({}, e.resources)
        }, t && (e.json.images = t.map(e => $v({}, e))), n && (e.json.buffers = n.map(e => $v({}, e))), e
    }
    _binaryToJSON(e)
    {
        if (!b_(e))
            throw new Error("Invalid glTF 2.0 binary.");
        const t = new Uint32Array(e.buffer, e.byteOffset + 12, 2);
        if (t[1] !== f_.JSON)
            throw new Error("Missing required GLB JSON chunk.");
        const n = t[0],
            r = qy.decodeText(qy.toView(e, 20, n)),
            o = JSON.parse(r),
            i = 20 + n;
        if (e.byteLength <= i)
            return {
                json: o,
                resources: {}
            };
        const a = new Uint32Array(e.buffer, e.byteOffset + i, 2);
        if (a[1] !== f_.BIN)
            return {
                json: o,
                resources: {}
            };
        const s = a[0],
            l = qy.toView(e, i + 8, s);
        return {
            json: o,
            resources: {
                [Ny]: l
            }
        }
    }
}
function b_(e) {
    if (e.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT)
        return !1;
    const t = new Uint32Array(e.buffer, e.byteOffset, 3);
    return 1179937895 === t[0] && 2 === t[1]
}
class A_ extends m_ {
    constructor(e=lv.DEFAULT_INIT)
    {
        super(),
        this._fetchConfig = void 0,
        this._fetchConfig = e
    }
    async readURI(e, t)
    {
        const n = await fetch(e, this._fetchConfig);
        switch (t) {
        case "view":
            return new Uint8Array(await n.arrayBuffer());
        case "text":
            return n.text()
        }
    }
    resolve(e, t)
    {
        return lv.resolve(e, t)
    }
    dirname(e)
    {
        return lv.dirname(e)
    }
}
class y_ {
    constructor(e, t, n, r)
    {
        this._dataView = void 0,
        this._littleEndian = void 0,
        this._offset = void 0,
        this._dataView = new DataView(e.buffer, e.byteOffset + t, n),
        this._littleEndian = r,
        this._offset = 0
    }
    _nextUint8()
    {
        const e = this._dataView.getUint8(this._offset);
        return this._offset += 1, e
    }
    _nextUint16()
    {
        const e = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2, e
    }
    _nextUint32()
    {
        const e = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _nextUint64()
    {
        const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8, e
    }
    _nextInt32()
    {
        const e = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4, e
    }
    _nextUint8Array(e)
    {
        const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
        return this._offset += e, t
    }
    _skip(e)
    {
        return this._offset += e, this
    }
    _scan(e, t=0)
    {
        const n = this._offset;
        let r = 0;
        for (; this._dataView.getUint8(this._offset) !== t && r < e;)
            r++,
            this._offset++;
        return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
    }
}
const v_ = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function __(e) {
    return (new TextDecoder).decode(e)
}
function x_(e) {
    const t = new Uint8Array(e.buffer, e.byteOffset, v_.length);
    if (t[0] !== v_[0] || t[1] !== v_[1] || t[2] !== v_[2] || t[3] !== v_[3] || t[4] !== v_[4] || t[5] !== v_[5] || t[6] !== v_[6] || t[7] !== v_[7] || t[8] !== v_[8] || t[9] !== v_[9] || t[10] !== v_[10] || t[11] !== v_[11])
        throw new Error("Missing KTX 2.0 identifier.");
    const n = {
            vkFormat: 0,
            typeSize: 1,
            pixelWidth: 0,
            pixelHeight: 0,
            pixelDepth: 0,
            layerCount: 0,
            faceCount: 1,
            levelCount: 0,
            supercompressionScheme: 0,
            levels: [],
            dataFormatDescriptor: [{
                vendorId: 0,
                descriptorType: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: []
            }],
            keyValue: {},
            globalData: null
        },
        r = 17 * Uint32Array.BYTES_PER_ELEMENT,
        o = new y_(e, v_.length, r, !0);
    n.vkFormat = o._nextUint32(),
    n.typeSize = o._nextUint32(),
    n.pixelWidth = o._nextUint32(),
    n.pixelHeight = o._nextUint32(),
    n.pixelDepth = o._nextUint32(),
    n.layerCount = o._nextUint32(),
    n.faceCount = o._nextUint32(),
    n.levelCount = o._nextUint32(),
    n.supercompressionScheme = o._nextUint32();
    const i = o._nextUint32(),
        a = o._nextUint32(),
        s = o._nextUint32(),
        l = o._nextUint32(),
        c = o._nextUint64(),
        u = o._nextUint64(),
        d = 3 * Math.max(n.levelCount, 1) * 8,
        p = new y_(e, v_.length + r, d, !0);
    for (let N = 0, F = Math.max(n.levelCount, 1); N < F; N++)
        n.levels.push({
            levelData: new Uint8Array(e.buffer, e.byteOffset + p._nextUint64(), p._nextUint64()),
            uncompressedByteLength: p._nextUint64()
        });
    const h = new y_(e, i, a, !0);
    h._skip(4);
    const f = h._nextUint16(),
        g = h._nextUint16(),
        m = h._nextUint16(),
        b = h._nextUint16(),
        A = {
            vendorId: f,
            descriptorType: g,
            versionNumber: m,
            colorModel: h._nextUint8(),
            colorPrimaries: h._nextUint8(),
            transferFunction: h._nextUint8(),
            flags: h._nextUint8(),
            texelBlockDimension: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
            bytesPlane: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
            samples: []
        },
        y = (b / 4 - 6) / 4;
    for (let N = 0; N < y; N++) {
        const e = {
            bitOffset: h._nextUint16(),
            bitLength: h._nextUint8(),
            channelType: h._nextUint8(),
            samplePosition: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
            sampleLower: Number.NEGATIVE_INFINITY,
            sampleUpper: Number.POSITIVE_INFINITY
        };
        64 & e.channelType ? (e.sampleLower = h._nextInt32(), e.sampleUpper = h._nextInt32()) : (e.sampleLower = h._nextUint32(), e.sampleUpper = h._nextUint32()),
        A.samples[N] = e
    }
    n.dataFormatDescriptor.length = 0,
    n.dataFormatDescriptor.push(A);
    const v = new y_(e, s, l, !0);
    for (; v._offset < l;) {
        const e = v._nextUint32(),
            t = v._scan(e),
            r = __(t);
        if (n.keyValue[r] = v._nextUint8Array(e - t.byteLength - 1), r.match(/^ktx/i)) {
            const e = __(n.keyValue[r]);
            n.keyValue[r] = e.substring(0, e.lastIndexOf("\0"))
        }
        const o = e % 4 ? 4 - e % 4 : 0;
        v._skip(o)
    }
    if (u <= 0)
        return n;
    const _ = new y_(e, c, u, !0),
        x = _._nextUint16(),
        w = _._nextUint16(),
        C = _._nextUint32(),
        E = _._nextUint32(),
        S = _._nextUint32(),
        I = _._nextUint32(),
        T = [];
    for (let N = 0, F = Math.max(n.levelCount, 1); N < F; N++)
        T.push({
            imageFlags: _._nextUint32(),
            rgbSliceByteOffset: _._nextUint32(),
            rgbSliceByteLength: _._nextUint32(),
            alphaSliceByteOffset: _._nextUint32(),
            alphaSliceByteLength: _._nextUint32()
        });
    const M = c + _._offset,
        R = M + C,
        B = R + E,
        k = B + S,
        D = new Uint8Array(e.buffer, e.byteOffset + M, C),
        P = new Uint8Array(e.buffer, e.byteOffset + R, E),
        O = new Uint8Array(e.buffer, e.byteOffset + B, S),
        L = new Uint8Array(e.buffer, e.byteOffset + k, I);
    return n.globalData = {
        endpointCount: x,
        selectorCount: w,
        imageDescs: T,
        endpointsData: D,
        selectorsData: P,
        tablesData: O,
        extendedData: L
    }, n
}
const w_ = "EXT_mesh_gpu_instancing",
    C_ = "EXT_meshopt_compression",
    E_ = "EXT_texture_webp",
    S_ = "EXT_texture_avif",
    I_ = "KHR_draco_mesh_compression",
    T_ = "KHR_lights_punctual",
    M_ = "KHR_materials_anisotropy",
    R_ = "KHR_materials_clearcoat",
    B_ = "KHR_materials_diffuse_transmission",
    k_ = "KHR_materials_dispersion",
    D_ = "KHR_materials_emissive_strength",
    P_ = "KHR_materials_ior",
    O_ = "KHR_materials_iridescence",
    L_ = "KHR_materials_pbrSpecularGlossiness",
    N_ = "KHR_materials_sheen",
    F_ = "KHR_materials_specular",
    U_ = "KHR_materials_transmission",
    z_ = "KHR_materials_unlit",
    Q_ = "KHR_materials_volume",
    G_ = "KHR_materials_variants",
    j_ = "KHR_mesh_quantization",
    V_ = "KHR_texture_basisu",
    H_ = "KHR_texture_transform",
    $_ = "KHR_xmp_json_ld",
    W_ = "INSTANCE_ATTRIBUTE";
class K_ extends Ov {
    init()
    {
        this.extensionName = w_,
        this.propertyType = "InstancedMesh",
        this.parentTypes = [Fy.NODE]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            attributes: new ky
        })
    }
    getAttribute(e)
    {
        return this.getRefMap("attributes", e)
    }
    setAttribute(e, t)
    {
        return this.setRefMap("attributes", e, t, {
            usage: W_
        })
    }
    listAttributes()
    {
        return this.listRefMapValues("attributes")
    }
    listSemantics()
    {
        return this.listRefMapKeys("attributes")
    }
}
K_.EXTENSION_NAME = w_;
class q_ extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = w_,
        this.provideTypes = [Fy.NODE],
        this.prewriteTypes = [Fy.ACCESSOR]
    }
    createInstancedMesh()
    {
        return new K_(this.document.getGraph())
    }
    read(e)
    {
        return (e.jsonDoc.json.nodes || []).forEach((t, n) => {
            if (!t.extensions || !t.extensions[w_])
                return;
            const r = t.extensions[w_],
                o = this.createInstancedMesh();
            for (const i in r.attributes)
                o.setAttribute(i, e.accessors[r.attributes[i]]);
            e.nodes[n].setExtension(w_, o)
        }), this
    }
    prewrite(e)
    {
        e.accessorUsageGroupedByParent.add(W_);
        for (const t of this.properties)
            for (const n of t.listAttributes())
                e.addAccessorToUsageGroup(n, W_);
        return this
    }
    write(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listNodes().forEach(n => {
            const r = n.getExtension(w_);
            if (r) {
                const o = e.nodeIndexMap.get(n),
                    i = t.json.nodes[o],
                    a = {
                        attributes: {}
                    };
                r.listSemantics().forEach(t => {
                    const n = r.getAttribute(t);
                    a.attributes[t] = e.accessorIndexMap.get(n)
                }),
                i.extensions = i.extensions || {},
                i.extensions[w_] = a
            }
        }), this
    }
}
function X_() {
    return X_ = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, X_.apply(null, arguments)
}
var Y_,
    J_,
    Z_,
    ex,
    tx,
    nx;
q_.EXTENSION_NAME = w_,
(J_ = Y_ || (Y_ = {})).QUANTIZE = "quantize",
J_.FILTER = "filter",
(ex = Z_ || (Z_ = {})).ATTRIBUTES = "ATTRIBUTES",
ex.TRIANGLES = "TRIANGLES",
ex.INDICES = "INDICES",
(nx = tx || (tx = {})).NONE = "NONE",
nx.OCTAHEDRAL = "OCTAHEDRAL",
nx.QUATERNION = "QUATERNION",
nx.EXPONENTIAL = "EXPONENTIAL";
const {BYTE: rx, SHORT: ox, FLOAT: ix} = Mv.ComponentType,
    {encodeNormalizedInt: ax, decodeNormalizedInt: sx} = mv;
function lx(e, t, n, r) {
    const {filter: o, bits: i} = r,
        a = {
            array: e.getArray(),
            byteStride: e.getElementSize() * e.getComponentSize(),
            componentType: e.getComponentType(),
            normalized: e.getNormalized()
        };
    if (n !== Z_.ATTRIBUTES)
        return a;
    if (o !== tx.NONE) {
        let n = e.getNormalized() ? function(e) {
            const t = e.getComponentType(),
                n = e.getArray(),
                r = new Float32Array(n.length);
            for (let o = 0; o < n.length; o++)
                r[o] = sx(n[o], t);
            return r
        }(e) : new Float32Array(a.array);
        switch (o) {
        case tx.EXPONENTIAL:
            a.byteStride = 4 * e.getElementSize(),
            a.componentType = ix,
            a.normalized = !1,
            a.array = t.encodeFilterExp(n, e.getCount(), a.byteStride, i);
            break;
        case tx.OCTAHEDRAL:
            a.byteStride = i > 8 ? 8 : 4,
            a.componentType = i > 8 ? ox : rx,
            a.normalized = !0,
            n = 3 === e.getElementSize() ? function(e) {
                const t = new Float32Array(4 * e.length / 3);
                for (let n = 0, r = e.length / 3; n < r; n++)
                    t[4 * n] = e[3 * n],
                    t[4 * n + 1] = e[3 * n + 1],
                    t[4 * n + 2] = e[3 * n + 2];
                return t
            }(n) : n,
            a.array = t.encodeFilterOct(n, e.getCount(), a.byteStride, i);
            break;
        case tx.QUATERNION:
            a.byteStride = 8,
            a.componentType = ox,
            a.normalized = !0,
            a.array = t.encodeFilterQuat(n, e.getCount(), a.byteStride, i);
            break;
        default:
            throw new Error("Invalid filter.")
        }
        a.min = e.getMin([]),
        a.max = e.getMax([]),
        e.getNormalized() && (a.min = a.min.map(t => sx(t, e.getComponentType())), a.max = a.max.map(t => sx(t, e.getComponentType()))),
        a.normalized && (a.min = a.min.map(e => ax(e, a.componentType)), a.max = a.max.map(e => ax(e, a.componentType)))
    } else
        a.byteStride % 4 && (a.array = function(e, t) {
            const n = qy.padNumber(e.BYTES_PER_ELEMENT * t) / e.BYTES_PER_ELEMENT,
                r = e.length / t,
                o = new e.constructor(r * n);
            for (let i = 0; i * t < e.length; i++)
                for (let r = 0; r < t; r++)
                    o[i * n + r] = e[i * t + r];
            return o
        }(a.array, e.getElementSize()), a.byteStride = a.array.byteLength / e.getCount());
    return a
}
function cx(e, t) {
    return t === a_.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e.listParents().some(e => e instanceof Vv && e.getMode() === Vv.Mode.TRIANGLES) ? Z_.TRIANGLES : Z_.INDICES : Z_.ATTRIBUTES
}
function ux(e, t) {
    const n = t.getGraph().listParentEdges(e).filter(e => !(e.getParent() instanceof Xv));
    for (const r of n) {
        const t = r.getName(),
            n = r.getAttributes().key || "",
            o = r.getParent().propertyType === Fy.PRIMITIVE_TARGET;
        if ("indices" === t)
            return {
                filter: tx.NONE
            };
        if ("attributes" === t) {
            if ("POSITION" === n)
                return {
                    filter: tx.NONE
                };
            if ("TEXCOORD_0" === n)
                return {
                    filter: tx.NONE
                };
            if (n.startsWith("JOINTS_"))
                return {
                    filter: tx.NONE
                };
            if (n.startsWith("WEIGHTS_"))
                return {
                    filter: tx.NONE
                };
            if ("NORMAL" === n || "TANGENT" === n)
                return o ? {
                    filter: tx.NONE
                } : {
                    filter: tx.OCTAHEDRAL,
                    bits: 8
                }
        }
        if ("output" === t) {
            const t = dx(e);
            return "rotation" === t ? {
                filter: tx.QUATERNION,
                bits: 16
            } : "translation" === t || "scale" === t ? {
                filter: tx.EXPONENTIAL,
                bits: 12
            } : {
                filter: tx.NONE
            }
        }
        if ("input" === t)
            return {
                filter: tx.NONE
            };
        if ("inverseBindMatrices" === t)
            return {
                filter: tx.NONE
            }
    }
    return {
        filter: tx.NONE
    }
}
function dx(e) {
    for (const t of e.listParents())
        if (t instanceof kv)
            for (const e of t.listParents())
                if (e instanceof Bv)
                    return e.getTargetPath();
    return null
}
const px = {
    method: Y_.QUANTIZE
};
class hx extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = C_,
        this.prereadTypes = [Fy.BUFFER, Fy.PRIMITIVE],
        this.prewriteTypes = [Fy.BUFFER, Fy.ACCESSOR],
        this.readDependencies = ["meshopt.decoder"],
        this.writeDependencies = ["meshopt.encoder"],
        this._decoder = null,
        this._decoderFallbackBufferMap = new Map,
        this._encoder = null,
        this._encoderOptions = px,
        this._encoderFallbackBuffer = null,
        this._encoderBufferViews = {},
        this._encoderBufferViewData = {},
        this._encoderBufferViewAccessors = {}
    }
    install(e, t)
    {
        return "meshopt.decoder" === e && (this._decoder = t), "meshopt.encoder" === e && (this._encoder = t), this
    }
    setEncoderOptions(e)
    {
        return this._encoderOptions = X_({}, px, e), this
    }
    preread(e, t)
    {
        if (!this._decoder) {
            if (!this.isRequired())
                return this;
            throw new Error(`[${C_}] Please install extension dependency, "meshopt.decoder".`)
        }
        if (!this._decoder.supported) {
            if (!this.isRequired())
                return this;
            throw new Error(`[${C_}]: Missing WASM support.`)
        }
        return t === Fy.BUFFER ? this._prereadBuffers(e) : t === Fy.PRIMITIVE && this._prereadPrimitives(e), this
    }
    _prereadBuffers(e)
    {
        const t = e.jsonDoc;
        (t.json.bufferViews || []).forEach((n, r) => {
            if (!n.extensions || !n.extensions[C_])
                return;
            const o = n.extensions[C_],
                i = o.byteOffset || 0,
                a = o.byteLength || 0,
                s = o.count,
                l = o.byteStride,
                c = new Uint8Array(s * l),
                u = t.json.buffers[o.buffer],
                d = u.uri ? t.resources[u.uri] : t.resources[Ny],
                p = qy.toView(d, i, a);
            this._decoder.decodeGltfBuffer(c, s, l, p, o.mode, o.filter),
            e.bufferViews[r] = c
        })
    }
    _prereadPrimitives(e)
    {
        const t = e.jsonDoc;
        (t.json.bufferViews || []).forEach(n => {
            if (!n.extensions || !n.extensions[C_])
                return;
            const r = n.extensions[C_],
                o = e.buffers[r.buffer],
                i = e.buffers[n.buffer];
            var a;
            (a = t.json.buffers[n.buffer]).extensions && a.extensions[C_] && a.extensions[C_].fallback && this._decoderFallbackBufferMap.set(i, o)
        })
    }
    read(e)
    {
        if (!this.isRequired())
            return this;
        for (const [t, n] of this._decoderFallbackBufferMap) {
            for (const e of t.listParents())
                e instanceof Mv && e.swap(t, n);
            t.dispose()
        }
        return this
    }
    prewrite(e, t)
    {
        return t === Fy.ACCESSOR ? this._prewriteAccessors(e) : t === Fy.BUFFER && this._prewriteBuffers(e), this
    }
    _prewriteAccessors(e)
    {
        const t = e.jsonDoc.json,
            n = this._encoder,
            r = this._encoderOptions,
            o = this.document.getGraph(),
            i = this.document.createBuffer(),
            a = this.document.getRoot().listBuffers().indexOf(i);
        let s = 1;
        const l = new Map,
            c = e => {
                for (const t of o.listParents(e)) {
                    if (t.propertyType === Fy.ROOT)
                        continue;
                    let n = l.get(e);
                    return void 0 === n && l.set(e, n = s++), n
                }
                return -1
            };
        this._encoderFallbackBuffer = i,
        this._encoderBufferViews = {},
        this._encoderBufferViewData = {},
        this._encoderBufferViewAccessors = {};
        for (const u of this.document.getRoot().listAccessors()) {
            if ("weights" === dx(u))
                continue;
            if (u.getSparse())
                continue;
            const o = e.getAccessorUsage(u),
                i = e.accessorUsageGroupedByParent.has(o) ? c(u) : null,
                s = cx(u, o),
                l = r.method === Y_.FILTER ? ux(u, this.document) : {
                    filter: tx.NONE
                },
                d = lx(u, n, s, l),
                {array: p, byteStride: h} = d,
                f = u.getBuffer();
            if (!f)
                throw new Error(`${C_}: Missing buffer for accessor.`);
            const g = this.document.getRoot().listBuffers().indexOf(f),
                m = [o, i, s, l.filter, h, g].join(":");
            let b = this._encoderBufferViews[m],
                A = this._encoderBufferViewData[m],
                y = this._encoderBufferViewAccessors[m];
            b && A || (y = this._encoderBufferViewAccessors[m] = [], A = this._encoderBufferViewData[m] = [], b = this._encoderBufferViews[m] = {
                buffer: a,
                target: a_.USAGE_TO_TARGET[o],
                byteOffset: 0,
                byteLength: 0,
                byteStride: o === a_.BufferViewUsage.ARRAY_BUFFER ? h : void 0,
                extensions: {
                    [C_]: {
                        buffer: g,
                        byteOffset: 0,
                        byteLength: 0,
                        mode: s,
                        filter: l.filter !== tx.NONE ? l.filter : void 0,
                        byteStride: h,
                        count: 0
                    }
                }
            });
            const v = e.createAccessorDef(u);
            v.componentType = d.componentType,
            v.normalized = d.normalized,
            v.byteOffset = b.byteLength,
            v.min && d.min && (v.min = d.min),
            v.max && d.max && (v.max = d.max),
            e.accessorIndexMap.set(u, t.accessors.length),
            t.accessors.push(v),
            y.push(v),
            A.push(new Uint8Array(p.buffer, p.byteOffset, p.byteLength)),
            b.byteLength += p.byteLength,
            b.extensions.EXT_meshopt_compression.count += u.getCount()
        }
    }
    _prewriteBuffers(e)
    {
        const t = this._encoder;
        for (const n in this._encoderBufferViews) {
            const r = this._encoderBufferViews[n],
                o = this._encoderBufferViewData[n],
                i = this.document.getRoot().listBuffers()[r.extensions[C_].buffer],
                a = e.otherBufferViews.get(i) || [],
                {count: s, byteStride: l, mode: c} = r.extensions[C_],
                u = qy.concat(o),
                d = t.encodeGltfBuffer(u, s, l, c),
                p = qy.pad(d);
            r.extensions[C_].byteLength = d.byteLength,
            o.length = 0,
            o.push(p),
            a.push(p),
            e.otherBufferViews.set(i, a)
        }
    }
    write(e)
    {
        let t = 0;
        for (const i in this._encoderBufferViews) {
            const n = this._encoderBufferViews[i],
                r = this._encoderBufferViewData[i][0],
                o = e.otherBufferViewsIndexMap.get(r),
                a = this._encoderBufferViewAccessors[i];
            for (const e of a)
                e.bufferView = o;
            const s = e.jsonDoc.json.bufferViews[o],
                l = s.byteOffset || 0;
            Object.assign(s, n),
            s.byteOffset = t,
            s.extensions[C_].byteOffset = l,
            t += qy.padNumber(n.byteLength)
        }
        const n = this._encoderFallbackBuffer,
            r = e.bufferIndexMap.get(n),
            o = e.jsonDoc.json.buffers[r];
        return o.byteLength = t, o.extensions = {
            [C_]: {
                fallback: !0
            }
        }, n.dispose(), this
    }
}
hx.EXTENSION_NAME = C_,
hx.EncoderMethod = Y_;
class fx {
    match(e)
    {
        return e.length >= 12 && "ftypavif" === qy.decodeText(e.slice(4, 12))
    }
    getSize(e)
    {
        if (!this.match(e))
            return null;
        const t = new DataView(e.buffer, e.byteOffset, e.byteLength);
        let n = mx(t, 0);
        if (!n)
            return null;
        let r = n.end;
        for (; n = mx(t, r);)
            if ("meta" === n.type)
                r = n.start + 4;
            else if ("iprp" === n.type || "ipco" === n.type)
                r = n.start;
            else {
                if ("ispe" === n.type)
                    return [t.getUint32(n.start + 4), t.getUint32(n.start + 8)];
                if ("mdat" === n.type)
                    break;
                r = n.end
            }
        return null
    }
    getChannels(e)
    {
        return 4
    }
}
class gx extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = S_,
        this.prereadTypes = [Fy.TEXTURE]
    }
    static register()
    {
        Yy.registerFormat("image/avif", new fx)
    }
    preread(e)
    {
        return (e.jsonDoc.json.textures || []).forEach(e => {
            e.extensions && e.extensions[S_] && (e.source = e.extensions[S_].source)
        }), this
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listTextures().forEach(n => {
            if ("image/avif" === n.getMimeType()) {
                const r = e.imageIndexMap.get(n);
                (t.json.textures || []).forEach(e => {
                    e.source === r && (e.extensions = e.extensions || {}, e.extensions[S_] = {
                        source: e.source
                    }, delete e.source)
                })
            }
        }), this
    }
}
function mx(e, t) {
    if (e.byteLength < 4 + t)
        return null;
    const n = e.getUint32(t);
    return e.byteLength < n + t || n < 8 ? null : {
        type: qy.decodeText(new Uint8Array(e.buffer, e.byteOffset + t + 4, 4)),
        start: t + 8,
        end: t + n
    }
}
gx.EXTENSION_NAME = S_;
class bx {
    match(e)
    {
        return e.length >= 12 && 87 === e[8] && 69 === e[9] && 66 === e[10] && 80 === e[11]
    }
    getSize(e)
    {
        const t = qy.decodeText(e.slice(0, 4)),
            n = qy.decodeText(e.slice(8, 12));
        if ("RIFF" !== t || "WEBP" !== n)
            return null;
        const r = new DataView(e.buffer, e.byteOffset);
        let o = 12;
        for (; o < r.byteLength;) {
            const e = qy.decodeText(new Uint8Array([r.getUint8(o), r.getUint8(o + 1), r.getUint8(o + 2), r.getUint8(o + 3)])),
                t = r.getUint32(o + 4, !0);
            if ("VP8 " === e)
                return [16383 & r.getInt16(o + 14, !0), 16383 & r.getInt16(o + 16, !0)];
            if ("VP8L" === e) {
                const e = r.getUint8(o + 9),
                    t = r.getUint8(o + 10),
                    n = r.getUint8(o + 11);
                return [1 + ((63 & t) << 8 | e), 1 + ((15 & r.getUint8(o + 12)) << 10 | n << 2 | (192 & t) >> 6)]
            }
            o += 8 + t + t % 2
        }
        return null
    }
    getChannels(e)
    {
        return 4
    }
}
class Ax extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = E_,
        this.prereadTypes = [Fy.TEXTURE]
    }
    static register()
    {
        Yy.registerFormat("image/webp", new bx)
    }
    preread(e)
    {
        return (e.jsonDoc.json.textures || []).forEach(e => {
            e.extensions && e.extensions[E_] && (e.source = e.extensions[E_].source)
        }), this
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listTextures().forEach(n => {
            if ("image/webp" === n.getMimeType()) {
                const r = e.imageIndexMap.get(n);
                (t.json.textures || []).forEach(e => {
                    e.source === r && (e.extensions = e.extensions || {}, e.extensions[E_] = {
                        source: e.source
                    }, delete e.source)
                })
            }
        }), this
    }
}
let yx,
    vx,
    _x,
    xx;
function wx(e, t) {
    const n = new yx.DecoderBuffer;
    try {
        if (n.Init(t, t.length), e.GetEncodedGeometryType(n) !== yx.TRIANGULAR_MESH)
            throw new Error(`[${I_}] Unknown geometry type.`);
        const r = new yx.Mesh;
        if (!e.DecodeBufferToMesh(n, r).ok() || 0 === r.ptr)
            throw new Error(`[${I_}] Decoding failure.`);
        return r
    } finally {
        yx.destroy(n)
    }
}
function Cx(e, t) {
    const n = 3 * t.num_faces();
    let r,
        o;
    if (t.num_points() <= 65534) {
        const i = n * Uint16Array.BYTES_PER_ELEMENT;
        r = yx._malloc(i),
        e.GetTrianglesUInt16Array(t, i, r),
        o = new Uint16Array(yx.HEAPU16.buffer, r, n).slice()
    } else {
        const i = n * Uint32Array.BYTES_PER_ELEMENT;
        r = yx._malloc(i),
        e.GetTrianglesUInt32Array(t, i, r),
        o = new Uint32Array(yx.HEAPU32.buffer, r, n).slice()
    }
    return yx._free(r), o
}
function Ex(e, t, n, r) {
    const o = _x[r.componentType],
        i = vx[r.componentType],
        a = n.num_components(),
        s = t.num_points() * a,
        l = s * i.BYTES_PER_ELEMENT,
        c = yx._malloc(l);
    e.GetAttributeDataArrayForAllPoints(t, n, o, l, c);
    const u = new i(yx.HEAPF32.buffer, c, s).slice();
    return yx._free(c), u
}
var Sx,
    Ix,
    Tx;
Ax.EXTENSION_NAME = E_,
function(e) {
    e[e.EDGEBREAKER = 1] = "EDGEBREAKER",
    e[e.SEQUENTIAL = 0] = "SEQUENTIAL"
}(Sx || (Sx = {})),
(Tx = Ix || (Ix = {})).POSITION = "POSITION",
Tx.NORMAL = "NORMAL",
Tx.COLOR = "COLOR",
Tx.TEX_COORD = "TEX_COORD",
Tx.GENERIC = "GENERIC";
const Mx = {
        [Ix.POSITION]: 14,
        [Ix.NORMAL]: 10,
        [Ix.COLOR]: 8,
        [Ix.TEX_COORD]: 12,
        [Ix.GENERIC]: 12
    },
    Rx = {
        decodeSpeed: 5,
        encodeSpeed: 5,
        method: Sx.EDGEBREAKER,
        quantizationBits: Mx,
        quantizationVolume: "mesh"
    };
function Bx(e, t=Rx) {
    const n = X_({}, Rx, t);
    n.quantizationBits = X_({}, Mx, t.quantizationBits);
    const r = new xx.MeshBuilder,
        o = new xx.Mesh,
        i = new xx.ExpertEncoder(o),
        a = {},
        s = new xx.DracoInt8Array,
        l = e.listTargets().length > 0;
    let c = !1;
    for (const g of e.listSemantics()) {
        const t = e.getAttribute(g);
        if (t.getSparse()) {
            c = !0;
            continue
        }
        const s = kx(g),
            l = Dx(r, t.getComponentType(), o, xx[s], t.getCount(), t.getElementSize(), t.getArray());
        if (-1 === l)
            throw new Error(`Error compressing "${g}" attribute.`);
        if (a[g] = l, "mesh" === n.quantizationVolume || "POSITION" !== g)
            i.SetAttributeQuantization(l, n.quantizationBits[s]);
        else {
            if ("object" != typeof n.quantizationVolume)
                throw new Error("Invalid quantization volume state.");
            {
                const {quantizationVolume: e} = n,
                    r = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], e.max[2] - e.min[2]);
                i.SetAttributeExplicitQuantization(l, n.quantizationBits[s], t.getElementSize(), e.min, r)
            }
        }
    }
    const u = e.getIndices();
    if (!u)
        throw new Px("Primitive must have indices.");
    r.AddFacesToMesh(o, u.getCount() / 3, u.getArray()),
    i.SetSpeedOptions(n.encodeSpeed, n.decodeSpeed),
    i.SetTrackEncodedProperties(!0),
    n.method === Sx.SEQUENTIAL || l || c ? i.SetEncodingMethod(xx.MESH_SEQUENTIAL_ENCODING) : i.SetEncodingMethod(xx.MESH_EDGEBREAKER_ENCODING);
    const d = i.EncodeToDracoBuffer(!(l || c), s);
    if (d <= 0)
        throw new Px("Error applying Draco compression.");
    const p = new Uint8Array(d);
    for (let g = 0; g < d; ++g)
        p[g] = s.GetValue(g);
    const h = i.GetNumberOfEncodedPoints(),
        f = 3 * i.GetNumberOfEncodedFaces();
    return xx.destroy(s), xx.destroy(o), xx.destroy(r), xx.destroy(i), {
        numVertices: h,
        numIndices: f,
        data: p,
        attributeIDs: a
    }
}
function kx(e) {
    return "POSITION" === e ? Ix.POSITION : "NORMAL" === e ? Ix.NORMAL : e.startsWith("COLOR_") ? Ix.COLOR : e.startsWith("TEXCOORD_") ? Ix.TEX_COORD : Ix.GENERIC
}
function Dx(e, t, n, r, o, i, a) {
    switch (t) {
    case Mv.ComponentType.UNSIGNED_BYTE:
        return e.AddUInt8Attribute(n, r, o, i, a);
    case Mv.ComponentType.BYTE:
        return e.AddInt8Attribute(n, r, o, i, a);
    case Mv.ComponentType.UNSIGNED_SHORT:
        return e.AddUInt16Attribute(n, r, o, i, a);
    case Mv.ComponentType.SHORT:
        return e.AddInt16Attribute(n, r, o, i, a);
    case Mv.ComponentType.UNSIGNED_INT:
        return e.AddUInt32Attribute(n, r, o, i, a);
    case Mv.ComponentType.FLOAT:
        return e.AddFloatAttribute(n, r, o, i, a);
    default:
        throw new Error(`Unexpected component type, "${t}".`)
    }
}
class Px extends Error {}
class Ox extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = I_,
        this.prereadTypes = [Fy.PRIMITIVE],
        this.prewriteTypes = [Fy.ACCESSOR],
        this.readDependencies = ["draco3d.decoder"],
        this.writeDependencies = ["draco3d.encoder"],
        this._decoderModule = null,
        this._encoderModule = null,
        this._encoderOptions = {}
    }
    install(e, t)
    {
        var n,
            r;
        return "draco3d.decoder" === e && (this._decoderModule = t, n = this._decoderModule, yx = n, vx = {
            [Mv.ComponentType.FLOAT]: Float32Array,
            [Mv.ComponentType.UNSIGNED_INT]: Uint32Array,
            [Mv.ComponentType.UNSIGNED_SHORT]: Uint16Array,
            [Mv.ComponentType.UNSIGNED_BYTE]: Uint8Array,
            [Mv.ComponentType.SHORT]: Int16Array,
            [Mv.ComponentType.BYTE]: Int8Array
        }, _x = {
            [Mv.ComponentType.FLOAT]: yx.DT_FLOAT32,
            [Mv.ComponentType.UNSIGNED_INT]: yx.DT_UINT32,
            [Mv.ComponentType.UNSIGNED_SHORT]: yx.DT_UINT16,
            [Mv.ComponentType.UNSIGNED_BYTE]: yx.DT_UINT8,
            [Mv.ComponentType.SHORT]: yx.DT_INT16,
            [Mv.ComponentType.BYTE]: yx.DT_INT8
        }), "draco3d.encoder" === e && (this._encoderModule = t, r = this._encoderModule, xx = r), this
    }
    setEncoderOptions(e)
    {
        return this._encoderOptions = e, this
    }
    preread(e)
    {
        if (!this._decoderModule)
            throw new Error(`[${I_}] Please install extension dependency, "draco3d.decoder".`);
        const t = this.document.getLogger(),
            n = e.jsonDoc,
            r = new Map;
        try {
            const o = n.json.meshes || [];
            for (const i of o)
                for (const o of i.primitives) {
                    if (!o.extensions || !o.extensions[I_])
                        continue;
                    const i = o.extensions[I_];
                    let [a, s] = r.get(i.bufferView) || [];
                    if (!s || !a) {
                        const e = n.json.bufferViews[i.bufferView],
                            o = n.json.buffers[e.buffer],
                            l = o.uri ? n.resources[o.uri] : n.resources[Ny],
                            c = e.byteOffset || 0,
                            u = e.byteLength,
                            d = qy.toView(l, c, u);
                        a = new this._decoderModule.Decoder,
                        s = wx(a, d),
                        r.set(i.bufferView, [a, s]),
                        t.debug(`[${I_}] Decompressed ${d.byteLength} bytes.`)
                    }
                    for (const t in i.attributes) {
                        const n = e.jsonDoc.json.accessors[o.attributes[t]],
                            r = a.GetAttributeByUniqueId(s, i.attributes[t]),
                            l = Ex(a, s, r, n);
                        e.accessors[o.attributes[t]].setArray(l)
                    }
                    void 0 !== o.indices && e.accessors[o.indices].setArray(Cx(a, s))
                }
        } finally {
            for (const [e, t] of Array.from(r.values()))
                this._decoderModule.destroy(e),
                this._decoderModule.destroy(t)
        }
        return this
    }
    read(e)
    {
        return this
    }
    prewrite(e, t)
    {
        if (!this._encoderModule)
            throw new Error(`[${I_}] Please install extension dependency, "draco3d.encoder".`);
        const n = this.document.getLogger();
        n.debug(`[${I_}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
        const r = function(e) {
                const t = e.getLogger(),
                    n = new Set,
                    r = new Set;
                let o = 0,
                    i = 0;
                for (const d of e.getRoot().listMeshes())
                    for (const e of d.listPrimitives())
                        e.getIndices() ? e.getMode() !== Vv.Mode.TRIANGLES ? (r.add(e), i++) : n.add(e) : (r.add(e), o++);
                o > 0 && t.warn(`[${I_}] Skipping Draco compression of ${o} non-indexed primitives.`),
                i > 0 && t.warn(`[${I_}] Skipping Draco compression of ${i} non-TRIANGLES primitives.`);
                const a = e.getRoot().listAccessors(),
                    s = new Map;
                for (let d = 0; d < a.length; d++)
                    s.set(a[d], d);
                const l = new Map,
                    c = new Set,
                    u = new Map;
                for (const d of Array.from(n)) {
                    let t = Lx(d, s);
                    if (c.has(t))
                        u.set(d, t);
                    else {
                        if (l.has(d.getIndices())) {
                            const t = d.getIndices(),
                                n = t.clone();
                            s.set(n, e.getRoot().listAccessors().length - 1),
                            d.swap(t, n)
                        }
                        for (const t of d.listAttributes())
                            if (l.has(t)) {
                                const n = t.clone();
                                s.set(n, e.getRoot().listAccessors().length - 1),
                                d.swap(t, n)
                            }
                        t = Lx(d, s),
                        c.add(t),
                        u.set(d, t),
                        l.set(d.getIndices(), t);
                        for (const e of d.listAttributes())
                            l.set(e, t)
                    }
                }
                for (const d of Array.from(l.keys())) {
                    const e = new Set(d.listParents().map(e => e.propertyType));
                    if (2 !== e.size || !e.has(Fy.PRIMITIVE) || !e.has(Fy.ROOT))
                        throw new Error(`[${I_}] Compressed accessors must only be used as indices or vertex attributes.`)
                }
                for (const d of Array.from(n)) {
                    const e = u.get(d),
                        t = d.getIndices();
                    if (l.get(t) !== e || d.listAttributes().some(t => l.get(t) !== e))
                        throw new Error(`[${I_}] Draco primitives must share all, or no, accessors.`)
                }
                for (const d of Array.from(r)) {
                    const e = d.getIndices();
                    if (l.has(e) || d.listAttributes().some(e => l.has(e)))
                        throw new Error(`[${I_}] Accessor cannot be shared by compressed and uncompressed primitives.`)
                }
                return u
            }(this.document),
            o = new Map;
        let i = "mesh";
        "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? n.warn(`[${I_}]: quantizationVolume=scene requires exactly 1 scene.`) : i = ov(this.document.getRoot().listScenes().pop()));
        for (const a of Array.from(r.keys())) {
            const t = r.get(a);
            if (!t)
                throw new Error("Unexpected primitive.");
            if (o.has(t)) {
                o.set(t, o.get(t));
                continue
            }
            const s = a.getIndices(),
                l = e.jsonDoc.json.accessors;
            let c;
            try {
                c = Bx(a, X_({}, this._encoderOptions, {
                    quantizationVolume: i
                }))
            } catch (gL) {
                if (gL instanceof Px) {
                    n.warn(`[${I_}]: ${gL.message} Skipping primitive compression.`);
                    continue
                }
                throw gL
            }
            o.set(t, c);
            const u = e.createAccessorDef(s);
            u.count = c.numIndices,
            e.accessorIndexMap.set(s, l.length),
            l.push(u),
            c.numVertices > 65534 && Mv.getComponentSize(u.componentType) <= 2 ? u.componentType = Mv.ComponentType.UNSIGNED_INT : c.numVertices > 254 && Mv.getComponentSize(u.componentType) <= 1 && (u.componentType = Mv.ComponentType.UNSIGNED_SHORT);
            for (const n of a.listSemantics()) {
                const t = a.getAttribute(n);
                if (void 0 === c.attributeIDs[n])
                    continue;
                const r = e.createAccessorDef(t);
                r.count = c.numVertices,
                e.accessorIndexMap.set(t, l.length),
                l.push(r)
            }
            const d = a.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
            e.otherBufferViews.has(d) || e.otherBufferViews.set(d, []),
            e.otherBufferViews.get(d).push(c.data)
        }
        return n.debug(`[${I_}] Compressed ${r.size} primitives.`), e.extensionData[I_] = {
            primitiveHashMap: r,
            primitiveEncodingMap: o
        }, this
    }
    write(e)
    {
        const t = e.extensionData[I_];
        for (const n of this.document.getRoot().listMeshes()) {
            const r = e.jsonDoc.json.meshes[e.meshIndexMap.get(n)];
            for (let o = 0; o < n.listPrimitives().length; o++) {
                const i = n.listPrimitives()[o],
                    a = r.primitives[o],
                    s = t.primitiveHashMap.get(i);
                if (!s)
                    continue;
                const l = t.primitiveEncodingMap.get(s);
                l && (a.extensions = a.extensions || {}, a.extensions[I_] = {
                    bufferView: e.otherBufferViewsIndexMap.get(l.data),
                    attributes: l.attributeIDs
                })
            }
        }
        if (!t.primitiveHashMap.size) {
            const t = e.jsonDoc.json;
            t.extensionsUsed = (t.extensionsUsed || []).filter(e => e !== I_),
            t.extensionsRequired = (t.extensionsRequired || []).filter(e => e !== I_)
        }
        return this
    }
}
function Lx(e, t) {
    const n = [],
        r = e.getIndices();
    n.push(t.get(r));
    for (const o of e.listAttributes())
        n.push(t.get(o));
    return n.sort().join("|")
}
Ox.EXTENSION_NAME = I_,
Ox.EncoderMethod = Sx;
class Nx extends Ov {
    init()
    {
        this.extensionName = T_,
        this.propertyType = "Light",
        this.parentTypes = [Fy.NODE]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            color: [1, 1, 1],
            intensity: 1,
            type: Nx.Type.POINT,
            range: null,
            innerConeAngle: 0,
            outerConeAngle: Math.PI / 4
        })
    }
    getColor()
    {
        return this.get("color")
    }
    setColor(e)
    {
        return this.set("color", e)
    }
    getIntensity()
    {
        return this.get("intensity")
    }
    setIntensity(e)
    {
        return this.set("intensity", e)
    }
    getType()
    {
        return this.get("type")
    }
    setType(e)
    {
        return this.set("type", e)
    }
    getRange()
    {
        return this.get("range")
    }
    setRange(e)
    {
        return this.set("range", e)
    }
    getInnerConeAngle()
    {
        return this.get("innerConeAngle")
    }
    setInnerConeAngle(e)
    {
        return this.set("innerConeAngle", e)
    }
    getOuterConeAngle()
    {
        return this.get("outerConeAngle")
    }
    setOuterConeAngle(e)
    {
        return this.set("outerConeAngle", e)
    }
}
Nx.EXTENSION_NAME = T_,
Nx.Type = {
    POINT: "point",
    SPOT: "spot",
    DIRECTIONAL: "directional"
};
class Fx extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = T_
    }
    createLight(e="")
    {
        return new Nx(this.document.getGraph(), e)
    }
    read(e)
    {
        const t = e.jsonDoc;
        if (!t.json.extensions || !t.json.extensions[T_])
            return this;
        const n = (t.json.extensions[T_].lights || []).map(e => {
            var t,
                n;
            const r = this.createLight().setName(e.name || "").setType(e.type);
            return void 0 !== e.color && r.setColor(e.color), void 0 !== e.intensity && r.setIntensity(e.intensity), void 0 !== e.range && r.setRange(e.range), void 0 !== (null == (t = e.spot) ? void 0 : t.innerConeAngle) && r.setInnerConeAngle(e.spot.innerConeAngle), void 0 !== (null == (n = e.spot) ? void 0 : n.outerConeAngle) && r.setOuterConeAngle(e.spot.outerConeAngle), r
        });
        return t.json.nodes.forEach((t, r) => {
            if (!t.extensions || !t.extensions[T_])
                return;
            const o = t.extensions[T_];
            e.nodes[r].setExtension(T_, n[o.light])
        }), this
    }
    write(e)
    {
        const t = e.jsonDoc;
        if (0 === this.properties.size)
            return this;
        const n = [],
            r = new Map;
        for (const o of this.properties) {
            const e = o,
                t = {
                    type: e.getType()
                };
            mv.eq(e.getColor(), [1, 1, 1]) || (t.color = e.getColor()),
            1 !== e.getIntensity() && (t.intensity = e.getIntensity()),
            null != e.getRange() && (t.range = e.getRange()),
            e.getName() && (t.name = e.getName()),
            e.getType() === Nx.Type.SPOT && (t.spot = {
                innerConeAngle: e.getInnerConeAngle(),
                outerConeAngle: e.getOuterConeAngle()
            }),
            n.push(t),
            r.set(e, n.length - 1)
        }
        return this.document.getRoot().listNodes().forEach(n => {
            const o = n.getExtension(T_);
            if (o) {
                const i = e.nodeIndexMap.get(n),
                    a = t.json.nodes[i];
                a.extensions = a.extensions || {},
                a.extensions[T_] = {
                    light: r.get(o)
                }
            }
        }), t.json.extensions = t.json.extensions || {}, t.json.extensions[T_] = {
            lights: n
        }, this
    }
}
Fx.EXTENSION_NAME = T_;
const {R: Ux, G: zx, B: Qx} = Vy;
class Gx extends Ov {
    init()
    {
        this.extensionName = M_,
        this.propertyType = "Anisotropy",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            anisotropyStrength: 0,
            anisotropyRotation: 0,
            anisotropyTexture: null,
            anisotropyTextureInfo: new Lv(this.graph, "anisotropyTextureInfo")
        })
    }
    getAnisotropyStrength()
    {
        return this.get("anisotropyStrength")
    }
    setAnisotropyStrength(e)
    {
        return this.set("anisotropyStrength", e)
    }
    getAnisotropyRotation()
    {
        return this.get("anisotropyRotation")
    }
    setAnisotropyRotation(e)
    {
        return this.set("anisotropyRotation", e)
    }
    getAnisotropyTexture()
    {
        return this.getRef("anisotropyTexture")
    }
    getAnisotropyTextureInfo()
    {
        return this.getRef("anisotropyTexture") ? this.getRef("anisotropyTextureInfo") : null
    }
    setAnisotropyTexture(e)
    {
        return this.setRef("anisotropyTexture", e, {
            channels: Ux | zx | Qx
        })
    }
}
Gx.EXTENSION_NAME = M_;
class jx extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = M_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createAnisotropy()
    {
        return new Gx(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[M_]) {
                const o = this.createAnisotropy();
                e.materials[n].setExtension(M_, o);
                const i = t.extensions[M_];
                if (void 0 !== i.anisotropyStrength && o.setAnisotropyStrength(i.anisotropyStrength), void 0 !== i.anisotropyRotation && o.setAnisotropyRotation(i.anisotropyRotation), void 0 !== i.anisotropyTexture) {
                    const t = i.anisotropyTexture,
                        n = e.textures[r[t.index].source];
                    o.setAnisotropyTexture(n),
                    e.setTextureInfo(o.getAnisotropyTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(M_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[M_] = {};
                if (r.getAnisotropyStrength() > 0 && (a.anisotropyStrength = r.getAnisotropyStrength()), 0 !== r.getAnisotropyRotation() && (a.anisotropyRotation = r.getAnisotropyRotation()), r.getAnisotropyTexture()) {
                    const t = r.getAnisotropyTexture(),
                        n = r.getAnisotropyTextureInfo();
                    a.anisotropyTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
jx.EXTENSION_NAME = M_;
const {R: Vx, G: Hx, B: $x} = Vy;
class Wx extends Ov {
    init()
    {
        this.extensionName = R_,
        this.propertyType = "Clearcoat",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            clearcoatFactor: 0,
            clearcoatTexture: null,
            clearcoatTextureInfo: new Lv(this.graph, "clearcoatTextureInfo"),
            clearcoatRoughnessFactor: 0,
            clearcoatRoughnessTexture: null,
            clearcoatRoughnessTextureInfo: new Lv(this.graph, "clearcoatRoughnessTextureInfo"),
            clearcoatNormalScale: 1,
            clearcoatNormalTexture: null,
            clearcoatNormalTextureInfo: new Lv(this.graph, "clearcoatNormalTextureInfo")
        })
    }
    getClearcoatFactor()
    {
        return this.get("clearcoatFactor")
    }
    setClearcoatFactor(e)
    {
        return this.set("clearcoatFactor", e)
    }
    getClearcoatTexture()
    {
        return this.getRef("clearcoatTexture")
    }
    getClearcoatTextureInfo()
    {
        return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null
    }
    setClearcoatTexture(e)
    {
        return this.setRef("clearcoatTexture", e, {
            channels: Vx
        })
    }
    getClearcoatRoughnessFactor()
    {
        return this.get("clearcoatRoughnessFactor")
    }
    setClearcoatRoughnessFactor(e)
    {
        return this.set("clearcoatRoughnessFactor", e)
    }
    getClearcoatRoughnessTexture()
    {
        return this.getRef("clearcoatRoughnessTexture")
    }
    getClearcoatRoughnessTextureInfo()
    {
        return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null
    }
    setClearcoatRoughnessTexture(e)
    {
        return this.setRef("clearcoatRoughnessTexture", e, {
            channels: Hx
        })
    }
    getClearcoatNormalScale()
    {
        return this.get("clearcoatNormalScale")
    }
    setClearcoatNormalScale(e)
    {
        return this.set("clearcoatNormalScale", e)
    }
    getClearcoatNormalTexture()
    {
        return this.getRef("clearcoatNormalTexture")
    }
    getClearcoatNormalTextureInfo()
    {
        return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null
    }
    setClearcoatNormalTexture(e)
    {
        return this.setRef("clearcoatNormalTexture", e, {
            channels: Vx | Hx | $x
        })
    }
}
Wx.EXTENSION_NAME = R_;
class Kx extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = R_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createClearcoat()
    {
        return new Wx(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[R_]) {
                const o = this.createClearcoat();
                e.materials[n].setExtension(R_, o);
                const i = t.extensions[R_];
                if (void 0 !== i.clearcoatFactor && o.setClearcoatFactor(i.clearcoatFactor), void 0 !== i.clearcoatRoughnessFactor && o.setClearcoatRoughnessFactor(i.clearcoatRoughnessFactor), void 0 !== i.clearcoatTexture) {
                    const t = i.clearcoatTexture,
                        n = e.textures[r[t.index].source];
                    o.setClearcoatTexture(n),
                    e.setTextureInfo(o.getClearcoatTextureInfo(), t)
                }
                if (void 0 !== i.clearcoatRoughnessTexture) {
                    const t = i.clearcoatRoughnessTexture,
                        n = e.textures[r[t.index].source];
                    o.setClearcoatRoughnessTexture(n),
                    e.setTextureInfo(o.getClearcoatRoughnessTextureInfo(), t)
                }
                if (void 0 !== i.clearcoatNormalTexture) {
                    const t = i.clearcoatNormalTexture,
                        n = e.textures[r[t.index].source];
                    o.setClearcoatNormalTexture(n),
                    e.setTextureInfo(o.getClearcoatNormalTextureInfo(), t),
                    void 0 !== t.scale && o.setClearcoatNormalScale(t.scale)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(R_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[R_] = {
                    clearcoatFactor: r.getClearcoatFactor(),
                    clearcoatRoughnessFactor: r.getClearcoatRoughnessFactor()
                };
                if (r.getClearcoatTexture()) {
                    const t = r.getClearcoatTexture(),
                        n = r.getClearcoatTextureInfo();
                    a.clearcoatTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getClearcoatRoughnessTexture()) {
                    const t = r.getClearcoatRoughnessTexture(),
                        n = r.getClearcoatRoughnessTextureInfo();
                    a.clearcoatRoughnessTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getClearcoatNormalTexture()) {
                    const t = r.getClearcoatNormalTexture(),
                        n = r.getClearcoatNormalTextureInfo();
                    a.clearcoatNormalTexture = e.createTextureInfoDef(t, n),
                    1 !== r.getClearcoatNormalScale() && (a.clearcoatNormalTexture.scale = r.getClearcoatNormalScale())
                }
            }
        }), this
    }
}
Kx.EXTENSION_NAME = R_;
const {R: qx, G: Xx, B: Yx, A: Jx} = Vy;
class Zx extends Ov {
    init()
    {
        this.extensionName = B_,
        this.propertyType = "DiffuseTransmission",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            diffuseTransmissionFactor: 0,
            diffuseTransmissionTexture: null,
            diffuseTransmissionTextureInfo: new Lv(this.graph, "diffuseTransmissionTextureInfo"),
            diffuseTransmissionColorFactor: [1, 1, 1],
            diffuseTransmissionColorTexture: null,
            diffuseTransmissionColorTextureInfo: new Lv(this.graph, "diffuseTransmissionColorTextureInfo")
        })
    }
    getDiffuseTransmissionFactor()
    {
        return this.get("diffuseTransmissionFactor")
    }
    setDiffuseTransmissionFactor(e)
    {
        return this.set("diffuseTransmissionFactor", e)
    }
    getDiffuseTransmissionTexture()
    {
        return this.getRef("diffuseTransmissionTexture")
    }
    getDiffuseTransmissionTextureInfo()
    {
        return this.getRef("diffuseTransmissionTexture") ? this.getRef("diffuseTransmissionTextureInfo") : null
    }
    setDiffuseTransmissionTexture(e)
    {
        return this.setRef("diffuseTransmissionTexture", e, {
            channels: Jx
        })
    }
    getDiffuseTransmissionColorFactor()
    {
        return this.get("diffuseTransmissionColorFactor")
    }
    setDiffuseTransmissionColorFactor(e)
    {
        return this.set("diffuseTransmissionColorFactor", e)
    }
    getDiffuseTransmissionColorTexture()
    {
        return this.getRef("diffuseTransmissionColorTexture")
    }
    getDiffuseTransmissionColorTextureInfo()
    {
        return this.getRef("diffuseTransmissionColorTexture") ? this.getRef("diffuseTransmissionColorTextureInfo") : null
    }
    setDiffuseTransmissionColorTexture(e)
    {
        return this.setRef("diffuseTransmissionColorTexture", e, {
            channels: qx | Xx | Yx
        })
    }
}
Zx.EXTENSION_NAME = B_;
class ew extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = B_
    }
    createDiffuseTransmission()
    {
        return new Zx(this.document.getGraph())
    }
    read(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[B_]) {
                const o = this.createDiffuseTransmission();
                e.materials[n].setExtension(B_, o);
                const i = t.extensions[B_];
                if (void 0 !== i.diffuseTransmissionFactor && o.setDiffuseTransmissionFactor(i.diffuseTransmissionFactor), void 0 !== i.diffuseTransmissionColorFactor && o.setDiffuseTransmissionColorFactor(i.diffuseTransmissionColorFactor), void 0 !== i.diffuseTransmissionTexture) {
                    const t = i.diffuseTransmissionTexture,
                        n = e.textures[r[t.index].source];
                    o.setDiffuseTransmissionTexture(n),
                    e.setTextureInfo(o.getDiffuseTransmissionTextureInfo(), t)
                }
                if (void 0 !== i.diffuseTransmissionColorTexture) {
                    const t = i.diffuseTransmissionColorTexture,
                        n = e.textures[r[t.index].source];
                    o.setDiffuseTransmissionColorTexture(n),
                    e.setTextureInfo(o.getDiffuseTransmissionColorTextureInfo(), t)
                }
            }
        }), this
    }
    write(e)
    {
        const t = e.jsonDoc;
        for (const n of this.document.getRoot().listMaterials()) {
            const r = n.getExtension(B_);
            if (!r)
                continue;
            const o = e.materialIndexMap.get(n),
                i = t.json.materials[o];
            i.extensions = i.extensions || {};
            const a = i.extensions[B_] = {
                diffuseTransmissionFactor: r.getDiffuseTransmissionFactor(),
                diffuseTransmissionColorFactor: r.getDiffuseTransmissionColorFactor()
            };
            if (r.getDiffuseTransmissionTexture()) {
                const t = r.getDiffuseTransmissionTexture(),
                    n = r.getDiffuseTransmissionTextureInfo();
                a.diffuseTransmissionTexture = e.createTextureInfoDef(t, n)
            }
            if (r.getDiffuseTransmissionColorTexture()) {
                const t = r.getDiffuseTransmissionColorTexture(),
                    n = r.getDiffuseTransmissionColorTextureInfo();
                a.diffuseTransmissionColorTexture = e.createTextureInfoDef(t, n)
            }
        }
        return this
    }
}
ew.EXTENSION_NAME = B_;
class tw extends Ov {
    init()
    {
        this.extensionName = k_,
        this.propertyType = "Dispersion",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            dispersion: 0
        })
    }
    getDispersion()
    {
        return this.get("dispersion")
    }
    setDispersion(e)
    {
        return this.set("dispersion", e)
    }
}
tw.EXTENSION_NAME = k_;
class nw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = k_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createDispersion()
    {
        return new tw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        return (e.jsonDoc.json.materials || []).forEach((t, n) => {
            if (t.extensions && t.extensions[k_]) {
                const r = this.createDispersion();
                e.materials[n].setExtension(k_, r);
                const o = t.extensions[k_];
                void 0 !== o.dispersion && r.setDispersion(o.dispersion)
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(k_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {},
                i.extensions[k_] = {
                    dispersion: r.getDispersion()
                }
            }
        }), this
    }
}
nw.EXTENSION_NAME = k_;
class rw extends Ov {
    init()
    {
        this.extensionName = D_,
        this.propertyType = "EmissiveStrength",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            emissiveStrength: 1
        })
    }
    getEmissiveStrength()
    {
        return this.get("emissiveStrength")
    }
    setEmissiveStrength(e)
    {
        return this.set("emissiveStrength", e)
    }
}
rw.EXTENSION_NAME = D_;
class ow extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = D_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createEmissiveStrength()
    {
        return new rw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        return (e.jsonDoc.json.materials || []).forEach((t, n) => {
            if (t.extensions && t.extensions[D_]) {
                const r = this.createEmissiveStrength();
                e.materials[n].setExtension(D_, r);
                const o = t.extensions[D_];
                void 0 !== o.emissiveStrength && r.setEmissiveStrength(o.emissiveStrength)
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(D_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {},
                i.extensions[D_] = {
                    emissiveStrength: r.getEmissiveStrength()
                }
            }
        }), this
    }
}
ow.EXTENSION_NAME = D_;
class iw extends Ov {
    init()
    {
        this.extensionName = P_,
        this.propertyType = "IOR",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            ior: 1.5
        })
    }
    getIOR()
    {
        return this.get("ior")
    }
    setIOR(e)
    {
        return this.set("ior", e)
    }
}
iw.EXTENSION_NAME = P_;
class aw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = P_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createIOR()
    {
        return new iw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        return (e.jsonDoc.json.materials || []).forEach((t, n) => {
            if (t.extensions && t.extensions[P_]) {
                const r = this.createIOR();
                e.materials[n].setExtension(P_, r);
                const o = t.extensions[P_];
                void 0 !== o.ior && r.setIOR(o.ior)
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(P_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {},
                i.extensions[P_] = {
                    ior: r.getIOR()
                }
            }
        }), this
    }
}
aw.EXTENSION_NAME = P_;
const {R: sw, G: lw} = Vy;
class cw extends Ov {
    init()
    {
        this.extensionName = O_,
        this.propertyType = "Iridescence",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            iridescenceFactor: 0,
            iridescenceTexture: null,
            iridescenceTextureInfo: new Lv(this.graph, "iridescenceTextureInfo"),
            iridescenceIOR: 1.3,
            iridescenceThicknessMinimum: 100,
            iridescenceThicknessMaximum: 400,
            iridescenceThicknessTexture: null,
            iridescenceThicknessTextureInfo: new Lv(this.graph, "iridescenceThicknessTextureInfo")
        })
    }
    getIridescenceFactor()
    {
        return this.get("iridescenceFactor")
    }
    setIridescenceFactor(e)
    {
        return this.set("iridescenceFactor", e)
    }
    getIridescenceTexture()
    {
        return this.getRef("iridescenceTexture")
    }
    getIridescenceTextureInfo()
    {
        return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null
    }
    setIridescenceTexture(e)
    {
        return this.setRef("iridescenceTexture", e, {
            channels: sw
        })
    }
    getIridescenceIOR()
    {
        return this.get("iridescenceIOR")
    }
    setIridescenceIOR(e)
    {
        return this.set("iridescenceIOR", e)
    }
    getIridescenceThicknessMinimum()
    {
        return this.get("iridescenceThicknessMinimum")
    }
    setIridescenceThicknessMinimum(e)
    {
        return this.set("iridescenceThicknessMinimum", e)
    }
    getIridescenceThicknessMaximum()
    {
        return this.get("iridescenceThicknessMaximum")
    }
    setIridescenceThicknessMaximum(e)
    {
        return this.set("iridescenceThicknessMaximum", e)
    }
    getIridescenceThicknessTexture()
    {
        return this.getRef("iridescenceThicknessTexture")
    }
    getIridescenceThicknessTextureInfo()
    {
        return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null
    }
    setIridescenceThicknessTexture(e)
    {
        return this.setRef("iridescenceThicknessTexture", e, {
            channels: lw
        })
    }
}
cw.EXTENSION_NAME = O_;
class uw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = O_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createIridescence()
    {
        return new cw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[O_]) {
                const o = this.createIridescence();
                e.materials[n].setExtension(O_, o);
                const i = t.extensions[O_];
                if (void 0 !== i.iridescenceFactor && o.setIridescenceFactor(i.iridescenceFactor), void 0 !== i.iridescenceIor && o.setIridescenceIOR(i.iridescenceIor), void 0 !== i.iridescenceThicknessMinimum && o.setIridescenceThicknessMinimum(i.iridescenceThicknessMinimum), void 0 !== i.iridescenceThicknessMaximum && o.setIridescenceThicknessMaximum(i.iridescenceThicknessMaximum), void 0 !== i.iridescenceTexture) {
                    const t = i.iridescenceTexture,
                        n = e.textures[r[t.index].source];
                    o.setIridescenceTexture(n),
                    e.setTextureInfo(o.getIridescenceTextureInfo(), t)
                }
                if (void 0 !== i.iridescenceThicknessTexture) {
                    const t = i.iridescenceThicknessTexture,
                        n = e.textures[r[t.index].source];
                    o.setIridescenceThicknessTexture(n),
                    e.setTextureInfo(o.getIridescenceThicknessTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(O_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[O_] = {};
                if (r.getIridescenceFactor() > 0 && (a.iridescenceFactor = r.getIridescenceFactor()), 1.3 !== r.getIridescenceIOR() && (a.iridescenceIor = r.getIridescenceIOR()), 100 !== r.getIridescenceThicknessMinimum() && (a.iridescenceThicknessMinimum = r.getIridescenceThicknessMinimum()), 400 !== r.getIridescenceThicknessMaximum() && (a.iridescenceThicknessMaximum = r.getIridescenceThicknessMaximum()), r.getIridescenceTexture()) {
                    const t = r.getIridescenceTexture(),
                        n = r.getIridescenceTextureInfo();
                    a.iridescenceTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getIridescenceThicknessTexture()) {
                    const t = r.getIridescenceThicknessTexture(),
                        n = r.getIridescenceThicknessTextureInfo();
                    a.iridescenceThicknessTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
uw.EXTENSION_NAME = O_;
const {R: dw, G: pw, B: hw, A: fw} = Vy;
class gw extends Ov {
    init()
    {
        this.extensionName = L_,
        this.propertyType = "PBRSpecularGlossiness",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            diffuseFactor: [1, 1, 1, 1],
            diffuseTexture: null,
            diffuseTextureInfo: new Lv(this.graph, "diffuseTextureInfo"),
            specularFactor: [1, 1, 1],
            glossinessFactor: 1,
            specularGlossinessTexture: null,
            specularGlossinessTextureInfo: new Lv(this.graph, "specularGlossinessTextureInfo")
        })
    }
    getDiffuseFactor()
    {
        return this.get("diffuseFactor")
    }
    setDiffuseFactor(e)
    {
        return this.set("diffuseFactor", e)
    }
    getDiffuseTexture()
    {
        return this.getRef("diffuseTexture")
    }
    getDiffuseTextureInfo()
    {
        return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null
    }
    setDiffuseTexture(e)
    {
        return this.setRef("diffuseTexture", e, {
            channels: dw | pw | hw | fw,
            isColor: !0
        })
    }
    getSpecularFactor()
    {
        return this.get("specularFactor")
    }
    setSpecularFactor(e)
    {
        return this.set("specularFactor", e)
    }
    getGlossinessFactor()
    {
        return this.get("glossinessFactor")
    }
    setGlossinessFactor(e)
    {
        return this.set("glossinessFactor", e)
    }
    getSpecularGlossinessTexture()
    {
        return this.getRef("specularGlossinessTexture")
    }
    getSpecularGlossinessTextureInfo()
    {
        return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null
    }
    setSpecularGlossinessTexture(e)
    {
        return this.setRef("specularGlossinessTexture", e, {
            channels: dw | pw | hw | fw
        })
    }
}
gw.EXTENSION_NAME = L_;
class mw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = L_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createPBRSpecularGlossiness()
    {
        return new gw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[L_]) {
                const o = this.createPBRSpecularGlossiness();
                e.materials[n].setExtension(L_, o);
                const i = t.extensions[L_];
                if (void 0 !== i.diffuseFactor && o.setDiffuseFactor(i.diffuseFactor), void 0 !== i.specularFactor && o.setSpecularFactor(i.specularFactor), void 0 !== i.glossinessFactor && o.setGlossinessFactor(i.glossinessFactor), void 0 !== i.diffuseTexture) {
                    const t = i.diffuseTexture,
                        n = e.textures[r[t.index].source];
                    o.setDiffuseTexture(n),
                    e.setTextureInfo(o.getDiffuseTextureInfo(), t)
                }
                if (void 0 !== i.specularGlossinessTexture) {
                    const t = i.specularGlossinessTexture,
                        n = e.textures[r[t.index].source];
                    o.setSpecularGlossinessTexture(n),
                    e.setTextureInfo(o.getSpecularGlossinessTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(L_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[L_] = {
                    diffuseFactor: r.getDiffuseFactor(),
                    specularFactor: r.getSpecularFactor(),
                    glossinessFactor: r.getGlossinessFactor()
                };
                if (r.getDiffuseTexture()) {
                    const t = r.getDiffuseTexture(),
                        n = r.getDiffuseTextureInfo();
                    a.diffuseTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getSpecularGlossinessTexture()) {
                    const t = r.getSpecularGlossinessTexture(),
                        n = r.getSpecularGlossinessTextureInfo();
                    a.specularGlossinessTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
mw.EXTENSION_NAME = L_;
const {R: bw, G: Aw, B: yw, A: vw} = Vy;
class _w extends Ov {
    init()
    {
        this.extensionName = N_,
        this.propertyType = "Sheen",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            sheenColorFactor: [0, 0, 0],
            sheenColorTexture: null,
            sheenColorTextureInfo: new Lv(this.graph, "sheenColorTextureInfo"),
            sheenRoughnessFactor: 0,
            sheenRoughnessTexture: null,
            sheenRoughnessTextureInfo: new Lv(this.graph, "sheenRoughnessTextureInfo")
        })
    }
    getSheenColorFactor()
    {
        return this.get("sheenColorFactor")
    }
    setSheenColorFactor(e)
    {
        return this.set("sheenColorFactor", e)
    }
    getSheenColorTexture()
    {
        return this.getRef("sheenColorTexture")
    }
    getSheenColorTextureInfo()
    {
        return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null
    }
    setSheenColorTexture(e)
    {
        return this.setRef("sheenColorTexture", e, {
            channels: bw | Aw | yw,
            isColor: !0
        })
    }
    getSheenRoughnessFactor()
    {
        return this.get("sheenRoughnessFactor")
    }
    setSheenRoughnessFactor(e)
    {
        return this.set("sheenRoughnessFactor", e)
    }
    getSheenRoughnessTexture()
    {
        return this.getRef("sheenRoughnessTexture")
    }
    getSheenRoughnessTextureInfo()
    {
        return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null
    }
    setSheenRoughnessTexture(e)
    {
        return this.setRef("sheenRoughnessTexture", e, {
            channels: vw
        })
    }
}
_w.EXTENSION_NAME = N_;
class xw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = N_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createSheen()
    {
        return new _w(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[N_]) {
                const o = this.createSheen();
                e.materials[n].setExtension(N_, o);
                const i = t.extensions[N_];
                if (void 0 !== i.sheenColorFactor && o.setSheenColorFactor(i.sheenColorFactor), void 0 !== i.sheenRoughnessFactor && o.setSheenRoughnessFactor(i.sheenRoughnessFactor), void 0 !== i.sheenColorTexture) {
                    const t = i.sheenColorTexture,
                        n = e.textures[r[t.index].source];
                    o.setSheenColorTexture(n),
                    e.setTextureInfo(o.getSheenColorTextureInfo(), t)
                }
                if (void 0 !== i.sheenRoughnessTexture) {
                    const t = i.sheenRoughnessTexture,
                        n = e.textures[r[t.index].source];
                    o.setSheenRoughnessTexture(n),
                    e.setTextureInfo(o.getSheenRoughnessTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(N_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[N_] = {
                    sheenColorFactor: r.getSheenColorFactor(),
                    sheenRoughnessFactor: r.getSheenRoughnessFactor()
                };
                if (r.getSheenColorTexture()) {
                    const t = r.getSheenColorTexture(),
                        n = r.getSheenColorTextureInfo();
                    a.sheenColorTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getSheenRoughnessTexture()) {
                    const t = r.getSheenRoughnessTexture(),
                        n = r.getSheenRoughnessTextureInfo();
                    a.sheenRoughnessTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
xw.EXTENSION_NAME = N_;
const {R: ww, G: Cw, B: Ew, A: Sw} = Vy;
class Iw extends Ov {
    init()
    {
        this.extensionName = F_,
        this.propertyType = "Specular",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            specularFactor: 1,
            specularTexture: null,
            specularTextureInfo: new Lv(this.graph, "specularTextureInfo"),
            specularColorFactor: [1, 1, 1],
            specularColorTexture: null,
            specularColorTextureInfo: new Lv(this.graph, "specularColorTextureInfo")
        })
    }
    getSpecularFactor()
    {
        return this.get("specularFactor")
    }
    setSpecularFactor(e)
    {
        return this.set("specularFactor", e)
    }
    getSpecularColorFactor()
    {
        return this.get("specularColorFactor")
    }
    setSpecularColorFactor(e)
    {
        return this.set("specularColorFactor", e)
    }
    getSpecularTexture()
    {
        return this.getRef("specularTexture")
    }
    getSpecularTextureInfo()
    {
        return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null
    }
    setSpecularTexture(e)
    {
        return this.setRef("specularTexture", e, {
            channels: Sw
        })
    }
    getSpecularColorTexture()
    {
        return this.getRef("specularColorTexture")
    }
    getSpecularColorTextureInfo()
    {
        return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null
    }
    setSpecularColorTexture(e)
    {
        return this.setRef("specularColorTexture", e, {
            channels: ww | Cw | Ew,
            isColor: !0
        })
    }
}
Iw.EXTENSION_NAME = F_;
class Tw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = F_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createSpecular()
    {
        return new Iw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[F_]) {
                const o = this.createSpecular();
                e.materials[n].setExtension(F_, o);
                const i = t.extensions[F_];
                if (void 0 !== i.specularFactor && o.setSpecularFactor(i.specularFactor), void 0 !== i.specularColorFactor && o.setSpecularColorFactor(i.specularColorFactor), void 0 !== i.specularTexture) {
                    const t = i.specularTexture,
                        n = e.textures[r[t.index].source];
                    o.setSpecularTexture(n),
                    e.setTextureInfo(o.getSpecularTextureInfo(), t)
                }
                if (void 0 !== i.specularColorTexture) {
                    const t = i.specularColorTexture,
                        n = e.textures[r[t.index].source];
                    o.setSpecularColorTexture(n),
                    e.setTextureInfo(o.getSpecularColorTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(F_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[F_] = {};
                if (1 !== r.getSpecularFactor() && (a.specularFactor = r.getSpecularFactor()), mv.eq(r.getSpecularColorFactor(), [1, 1, 1]) || (a.specularColorFactor = r.getSpecularColorFactor()), r.getSpecularTexture()) {
                    const t = r.getSpecularTexture(),
                        n = r.getSpecularTextureInfo();
                    a.specularTexture = e.createTextureInfoDef(t, n)
                }
                if (r.getSpecularColorTexture()) {
                    const t = r.getSpecularColorTexture(),
                        n = r.getSpecularColorTextureInfo();
                    a.specularColorTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
Tw.EXTENSION_NAME = F_;
const {R: Mw} = Vy;
class Rw extends Ov {
    init()
    {
        this.extensionName = U_,
        this.propertyType = "Transmission",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            transmissionFactor: 0,
            transmissionTexture: null,
            transmissionTextureInfo: new Lv(this.graph, "transmissionTextureInfo")
        })
    }
    getTransmissionFactor()
    {
        return this.get("transmissionFactor")
    }
    setTransmissionFactor(e)
    {
        return this.set("transmissionFactor", e)
    }
    getTransmissionTexture()
    {
        return this.getRef("transmissionTexture")
    }
    getTransmissionTextureInfo()
    {
        return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null
    }
    setTransmissionTexture(e)
    {
        return this.setRef("transmissionTexture", e, {
            channels: Mw
        })
    }
}
Rw.EXTENSION_NAME = U_;
class Bw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = U_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createTransmission()
    {
        return new Rw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[U_]) {
                const o = this.createTransmission();
                e.materials[n].setExtension(U_, o);
                const i = t.extensions[U_];
                if (void 0 !== i.transmissionFactor && o.setTransmissionFactor(i.transmissionFactor), void 0 !== i.transmissionTexture) {
                    const t = i.transmissionTexture,
                        n = e.textures[r[t.index].source];
                    o.setTransmissionTexture(n),
                    e.setTextureInfo(o.getTransmissionTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(U_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[U_] = {
                    transmissionFactor: r.getTransmissionFactor()
                };
                if (r.getTransmissionTexture()) {
                    const t = r.getTransmissionTexture(),
                        n = r.getTransmissionTextureInfo();
                    a.transmissionTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
Bw.EXTENSION_NAME = U_;
class kw extends Ov {
    init()
    {
        this.extensionName = z_,
        this.propertyType = "Unlit",
        this.parentTypes = [Fy.MATERIAL]
    }
}
kw.EXTENSION_NAME = z_;
class Dw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = z_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createUnlit()
    {
        return new kw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        return (e.jsonDoc.json.materials || []).forEach((t, n) => {
            t.extensions && t.extensions[z_] && e.materials[n].setExtension(z_, this.createUnlit())
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            if (n.getExtension(z_)) {
                const r = e.materialIndexMap.get(n),
                    o = t.json.materials[r];
                o.extensions = o.extensions || {},
                o.extensions[z_] = {}
            }
        }), this
    }
}
Dw.EXTENSION_NAME = z_;
class Pw extends Ov {
    init()
    {
        this.extensionName = G_,
        this.propertyType = "Mapping",
        this.parentTypes = ["MappingList"]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            material: null,
            variants: new By
        })
    }
    getMaterial()
    {
        return this.getRef("material")
    }
    setMaterial(e)
    {
        return this.setRef("material", e)
    }
    addVariant(e)
    {
        return this.addRef("variants", e)
    }
    removeVariant(e)
    {
        return this.removeRef("variants", e)
    }
    listVariants()
    {
        return this.listRefs("variants")
    }
}
Pw.EXTENSION_NAME = G_;
class Ow extends Ov {
    init()
    {
        this.extensionName = G_,
        this.propertyType = "MappingList",
        this.parentTypes = [Fy.PRIMITIVE]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            mappings: new By
        })
    }
    addMapping(e)
    {
        return this.addRef("mappings", e)
    }
    removeMapping(e)
    {
        return this.removeRef("mappings", e)
    }
    listMappings()
    {
        return this.listRefs("mappings")
    }
}
Ow.EXTENSION_NAME = G_;
class Lw extends Ov {
    init()
    {
        this.extensionName = G_,
        this.propertyType = "Variant",
        this.parentTypes = ["MappingList"]
    }
}
Lw.EXTENSION_NAME = G_;
class Nw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = G_
    }
    createMappingList()
    {
        return new Ow(this.document.getGraph())
    }
    createVariant(e="")
    {
        return new Lw(this.document.getGraph(), e)
    }
    createMapping()
    {
        return new Pw(this.document.getGraph())
    }
    listVariants()
    {
        return Array.from(this.properties).filter(e => e instanceof Lw)
    }
    read(e)
    {
        const t = e.jsonDoc;
        if (!t.json.extensions || !t.json.extensions[G_])
            return this;
        const n = (t.json.extensions[G_].variants || []).map(e => this.createVariant().setName(e.name || ""));
        return (t.json.meshes || []).forEach((t, r) => {
            const o = e.meshes[r];
            (t.primitives || []).forEach((t, r) => {
                if (!t.extensions || !t.extensions[G_])
                    return;
                const i = this.createMappingList(),
                    a = t.extensions[G_];
                for (const o of a.mappings) {
                    const t = this.createMapping();
                    void 0 !== o.material && t.setMaterial(e.materials[o.material]);
                    for (const e of o.variants || [])
                        t.addVariant(n[e]);
                    i.addMapping(t)
                }
                o.listPrimitives()[r].setExtension(G_, i)
            })
        }), this
    }
    write(e)
    {
        const t = e.jsonDoc,
            n = this.listVariants();
        if (!n.length)
            return this;
        const r = [],
            o = new Map;
        for (const i of n)
            o.set(i, r.length),
            r.push(e.createPropertyDef(i));
        for (const i of this.document.getRoot().listMeshes()) {
            const t = e.meshIndexMap.get(i);
            i.listPrimitives().forEach((n, r) => {
                const i = n.getExtension(G_);
                if (!i)
                    return;
                const a = e.jsonDoc.json.meshes[t].primitives[r],
                    s = i.listMappings().map(t => {
                        const n = e.createPropertyDef(t),
                            r = t.getMaterial();
                        return r && (n.material = e.materialIndexMap.get(r)), n.variants = t.listVariants().map(e => o.get(e)), n
                    });
                a.extensions = a.extensions || {},
                a.extensions[G_] = {
                    mappings: s
                }
            })
        }
        return t.json.extensions = t.json.extensions || {}, t.json.extensions[G_] = {
            variants: r
        }, this
    }
}
Nw.EXTENSION_NAME = G_;
const {G: Fw} = Vy;
class Uw extends Ov {
    init()
    {
        this.extensionName = Q_,
        this.propertyType = "Volume",
        this.parentTypes = [Fy.MATERIAL]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            thicknessFactor: 0,
            thicknessTexture: null,
            thicknessTextureInfo: new Lv(this.graph, "thicknessTexture"),
            attenuationDistance: 1 / 0,
            attenuationColor: [1, 1, 1]
        })
    }
    getThicknessFactor()
    {
        return this.get("thicknessFactor")
    }
    setThicknessFactor(e)
    {
        return this.set("thicknessFactor", e)
    }
    getThicknessTexture()
    {
        return this.getRef("thicknessTexture")
    }
    getThicknessTextureInfo()
    {
        return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null
    }
    setThicknessTexture(e)
    {
        return this.setRef("thicknessTexture", e, {
            channels: Fw
        })
    }
    getAttenuationDistance()
    {
        return this.get("attenuationDistance")
    }
    setAttenuationDistance(e)
    {
        return this.set("attenuationDistance", e)
    }
    getAttenuationColor()
    {
        return this.get("attenuationColor")
    }
    setAttenuationColor(e)
    {
        return this.set("attenuationColor", e)
    }
}
Uw.EXTENSION_NAME = Q_;
class zw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = Q_,
        this.prereadTypes = [Fy.MESH],
        this.prewriteTypes = [Fy.MESH]
    }
    createVolume()
    {
        return new Uw(this.document.getGraph())
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
    preread(e)
    {
        const t = e.jsonDoc,
            n = t.json.materials || [],
            r = t.json.textures || [];
        return n.forEach((t, n) => {
            if (t.extensions && t.extensions[Q_]) {
                const o = this.createVolume();
                e.materials[n].setExtension(Q_, o);
                const i = t.extensions[Q_];
                if (void 0 !== i.thicknessFactor && o.setThicknessFactor(i.thicknessFactor), void 0 !== i.attenuationDistance && o.setAttenuationDistance(i.attenuationDistance), void 0 !== i.attenuationColor && o.setAttenuationColor(i.attenuationColor), void 0 !== i.thicknessTexture) {
                    const t = i.thicknessTexture,
                        n = e.textures[r[t.index].source];
                    o.setThicknessTexture(n),
                    e.setTextureInfo(o.getThicknessTextureInfo(), t)
                }
            }
        }), this
    }
    prewrite(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(n => {
            const r = n.getExtension(Q_);
            if (r) {
                const o = e.materialIndexMap.get(n),
                    i = t.json.materials[o];
                i.extensions = i.extensions || {};
                const a = i.extensions[Q_] = {};
                if (r.getThicknessFactor() > 0 && (a.thicknessFactor = r.getThicknessFactor()), Number.isFinite(r.getAttenuationDistance()) && (a.attenuationDistance = r.getAttenuationDistance()), mv.eq(r.getAttenuationColor(), [1, 1, 1]) || (a.attenuationColor = r.getAttenuationColor()), r.getThicknessTexture()) {
                    const t = r.getThicknessTexture(),
                        n = r.getThicknessTextureInfo();
                    a.thicknessTexture = e.createTextureInfoDef(t, n)
                }
            }
        }), this
    }
}
zw.EXTENSION_NAME = Q_;
class Qw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = j_
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        return this
    }
}
Qw.EXTENSION_NAME = j_;
class Gw {
    match(e)
    {
        return 171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 50 === e[5] && 48 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11]
    }
    getSize(e)
    {
        const t = x_(e);
        return [t.pixelWidth, t.pixelHeight]
    }
    getChannels(e)
    {
        const t = x_(e).dataFormatDescriptor[0];
        if (163 === t.colorModel)
            return 2 !== t.samples.length || 15 & ~t.samples[1].channelType ? 3 : 4;
        if (166 === t.colorModel)
            return 3 == (15 & t.samples[0].channelType) ? 4 : 3;
        throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`)
    }
    getVRAMByteLength(e)
    {
        const t = x_(e),
            n = this.getChannels(e) > 3;
        let r = 0;
        for (let o = 0; o < t.levels.length; o++) {
            const e = t.levels[o];
            e.uncompressedByteLength ? r += e.uncompressedByteLength : r += Math.max(1, Math.floor(t.pixelWidth / Math.pow(2, o))) / 4 * (Math.max(1, Math.floor(t.pixelHeight / Math.pow(2, o))) / 4) * (n ? 16 : 8)
        }
        return r
    }
}
class jw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = V_,
        this.prereadTypes = [Fy.TEXTURE]
    }
    static register()
    {
        Yy.registerFormat("image/ktx2", new Gw)
    }
    preread(e)
    {
        return e.jsonDoc.json.textures.forEach(e => {
            if (e.extensions && e.extensions[V_]) {
                const t = e.extensions[V_];
                e.source = t.source
            }
        }), this
    }
    read(e)
    {
        return this
    }
    write(e)
    {
        const t = e.jsonDoc;
        return this.document.getRoot().listTextures().forEach(n => {
            if ("image/ktx2" === n.getMimeType()) {
                const r = e.imageIndexMap.get(n);
                t.json.textures.forEach(e => {
                    e.source === r && (e.extensions = e.extensions || {}, e.extensions[V_] = {
                        source: e.source
                    }, delete e.source)
                })
            }
        }), this
    }
}
jw.EXTENSION_NAME = V_;
class Vw extends Ov {
    init()
    {
        this.extensionName = H_,
        this.propertyType = "Transform",
        this.parentTypes = [Fy.TEXTURE_INFO]
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            offset: [0, 0],
            rotation: 0,
            scale: [1, 1],
            texCoord: null
        })
    }
    getOffset()
    {
        return this.get("offset")
    }
    setOffset(e)
    {
        return this.set("offset", e)
    }
    getRotation()
    {
        return this.get("rotation")
    }
    setRotation(e)
    {
        return this.set("rotation", e)
    }
    getScale()
    {
        return this.get("scale")
    }
    setScale(e)
    {
        return this.set("scale", e)
    }
    getTexCoord()
    {
        return this.get("texCoord")
    }
    setTexCoord(e)
    {
        return this.set("texCoord", e)
    }
}
Vw.EXTENSION_NAME = H_;
class Hw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = H_
    }
    createTransform()
    {
        return new Vw(this.document.getGraph())
    }
    read(e)
    {
        for (const [t, n] of Array.from(e.textureInfos.entries())) {
            if (!n.extensions || !n.extensions[H_])
                continue;
            const e = this.createTransform(),
                r = n.extensions[H_];
            void 0 !== r.offset && e.setOffset(r.offset),
            void 0 !== r.rotation && e.setRotation(r.rotation),
            void 0 !== r.scale && e.setScale(r.scale),
            void 0 !== r.texCoord && e.setTexCoord(r.texCoord),
            t.setExtension(H_, e)
        }
        return this
    }
    write(e)
    {
        const t = Array.from(e.textureInfoDefMap.entries());
        for (const [n, r] of t) {
            const e = n.getExtension(H_);
            if (!e)
                continue;
            r.extensions = r.extensions || {};
            const t = {},
                o = mv.eq;
            o(e.getOffset(), [0, 0]) || (t.offset = e.getOffset()),
            0 !== e.getRotation() && (t.rotation = e.getRotation()),
            o(e.getScale(), [1, 1]) || (t.scale = e.getScale()),
            null != e.getTexCoord() && (t.texCoord = e.getTexCoord()),
            r.extensions[H_] = t
        }
        return this
    }
}
Hw.EXTENSION_NAME = H_;
const $w = [Fy.ROOT, Fy.SCENE, Fy.NODE, Fy.MESH, Fy.MATERIAL, Fy.TEXTURE, Fy.ANIMATION];
class Ww extends Ov {
    init()
    {
        this.extensionName = $_,
        this.propertyType = "Packet",
        this.parentTypes = $w
    }
    getDefaults()
    {
        return Object.assign(super.getDefaults(), {
            context: {},
            properties: {}
        })
    }
    getContext()
    {
        return this.get("context")
    }
    setContext(e)
    {
        return this.set("context", X_({}, e))
    }
    listProperties()
    {
        return Object.keys(this.get("properties"))
    }
    getProperty(e)
    {
        const t = this.get("properties");
        return e in t ? t[e] : null
    }
    setProperty(e, t)
    {
        this._assertContext(e);
        const n = X_({}, this.get("properties"));
        return t ? n[e] = t : delete n[e], this.set("properties", n)
    }
    toJSONLD()
    {
        return X_({
            "@context": Kw(this.get("context"))
        }, Kw(this.get("properties")))
    }
    fromJSONLD(e)
    {
        const t = (e = Kw(e))["@context"];
        return t && this.set("context", t), delete e["@context"], this.set("properties", e)
    }
    _assertContext(e)
    {
        if (!(e.split(":")[0] in this.get("context")))
            throw new Error(`${$_}: Missing context for term, "${e}".`)
    }
}
function Kw(e) {
    return JSON.parse(JSON.stringify(e))
}
Ww.EXTENSION_NAME = $_;
class qw extends Jv {
    constructor(...e)
    {
        super(...e),
        this.extensionName = $_
    }
    createPacket()
    {
        return new Ww(this.document.getGraph())
    }
    listPackets()
    {
        return Array.from(this.properties)
    }
    read(e)
    {
        var t;
        const n = null == (t = e.jsonDoc.json.extensions) ? void 0 : t[$_];
        if (!n || !n.packets)
            return this;
        const r = e.jsonDoc.json,
            o = this.document.getRoot(),
            i = n.packets.map(e => this.createPacket().fromJSONLD(e)),
            a = [[r.asset], r.scenes, r.nodes, r.meshes, r.materials, r.images, r.animations],
            s = [[o], o.listScenes(), o.listNodes(), o.listMeshes(), o.listMaterials(), o.listTextures(), o.listAnimations()];
        for (let l = 0; l < a.length; l++) {
            const e = a[l] || [];
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (n.extensions && n.extensions[$_]) {
                    const e = n.extensions[$_];
                    s[l][t].setExtension($_, i[e.packet])
                }
            }
        }
        return this
    }
    write(e)
    {
        const {json: t} = e.jsonDoc,
            n = [];
        for (const r of this.properties) {
            n.push(r.toJSONLD());
            for (const o of r.listParents()) {
                let r;
                switch (o.propertyType) {
                case Fy.ROOT:
                    r = t.asset;
                    break;
                case Fy.SCENE:
                    r = t.scenes[e.sceneIndexMap.get(o)];
                    break;
                case Fy.NODE:
                    r = t.nodes[e.nodeIndexMap.get(o)];
                    break;
                case Fy.MESH:
                    r = t.meshes[e.meshIndexMap.get(o)];
                    break;
                case Fy.MATERIAL:
                    r = t.materials[e.materialIndexMap.get(o)];
                    break;
                case Fy.TEXTURE:
                    r = t.images[e.imageIndexMap.get(o)];
                    break;
                case Fy.ANIMATION:
                    r = t.animations[e.animationIndexMap.get(o)];
                    break;
                default:
                    r = null,
                    this.document.getLogger().warn(`[${$_}]: Unsupported parent property, "${o.propertyType}"`)
                }
                r && (r.extensions = r.extensions || {}, r.extensions[$_] = {
                    packet: n.length - 1
                })
            }
        }
        return n.length > 0 && (t.extensions = t.extensions || {}, t.extensions[$_] = {
            packets: n
        }), this
    }
}
qw.EXTENSION_NAME = $_;
const Xw = [q_, hx, gx, Ax, Ox, Fx, jx, Kx, ew, nw, ow, aw, uw, mw, Tw, xw, Bw, Dw, Nw, zw, Qw, jw, Hw, qw];
function Yw() {
    return Yw = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t];
            for (var r in n)
                ({}).hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }, Yw.apply(null, arguments)
}
const {POINTS: Jw, LINES: Zw, LINE_STRIP: eC, LINE_LOOP: tC, TRIANGLES: nC, TRIANGLE_STRIP: rC, TRIANGLE_FAN: oC} = Vv.Mode;
var iC,
    aC,
    sC = "undefined" != typeof Float32Array ? Float32Array : Array;
function lC(e, t) {
    return function(e, t) {
        const n = [],
            r = [],
            o = [];
        e.traverse(e => {
            const t = e.getMesh(),
                i = e.getExtension("EXT_mesh_gpu_instancing");
            i && t ? (o.push(t), n.push([i.listAttributes()[0].getCount(), t])) : t && (o.push(t), r.push(t))
        });
        const i = o.flatMap(e => e.listPrimitives()).map(e => e.getAttribute("POSITION")),
            a = Array.from(new Set(i)),
            s = Array.from(new Set(o)),
            l = Array.from(new Set(s.flatMap(e => e.listPrimitives())));
        switch (t) {
        case iC.RENDER:
        case iC.RENDER_CACHED:
            return uC(r.map(e => cC(e, t))) + uC(n.map(([e, n]) => e * cC(n, t)));
        case iC.UPLOAD_NAIVE:
            return uC(s.map(e => cC(e, t)));
        case iC.UPLOAD:
            return uC(a.map(e => e.getCount()));
        case iC.DISTINCT:
        case iC.DISTINCT_POSITION:
            return pC(t);
        case iC.UNUSED:
            return dC(l);
        default:
            return hC(t)
        }
    }(e, t)
}
function cC(e, t) {
    const n = e.listPrimitives(),
        r = Array.from(new Set(n)),
        o = Array.from(new Set(r.map(e => e.getAttribute("POSITION"))));
    switch (t) {
    case iC.RENDER:
    case iC.RENDER_CACHED:
    case iC.UPLOAD_NAIVE:
        return uC(n.map(e => function(e, t) {
            const n = e.getAttribute("POSITION"),
                r = e.getIndices();
            switch (t) {
            case iC.RENDER:
                return r ? r.getCount() : n.getCount();
            case iC.RENDER_CACHED:
                return r ? new Set(r.getArray()).size : n.getCount();
            case iC.UPLOAD_NAIVE:
            case iC.UPLOAD:
                return n.getCount();
            case iC.DISTINCT:
            case iC.DISTINCT_POSITION:
                return pC(t);
            case iC.UNUSED:
                return r ? n.getCount() - new Set(r.getArray()).size : 0;
            default:
                return hC(t)
            }
        }(e, t)));
    case iC.UPLOAD:
        return uC(o.map(e => e.getCount()));
    case iC.DISTINCT:
    case iC.DISTINCT_POSITION:
        return pC(t);
    case iC.UNUSED:
        return dC(r);
    default:
        return hC(t)
    }
}
function uC(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++)
        t += e[n];
    return t
}
function dC(e) {
    const t = new Map;
    for (const r of e) {
        const e = r.getAttribute("POSITION"),
            n = r.getIndices(),
            o = t.get(e) || new Set;
        o.add(n),
        t.set(e, o)
    }
    let n = 0;
    for (const [r, o] of t) {
        if (o.has(null))
            continue;
        const e = new Uint8Array(r.getCount());
        for (const t of o) {
            const n = t.getArray();
            for (let t = 0, r = n.length; t < r; t++)
                e[n[t]] = 1
        }
        for (let t = 0, o = r.getCount(); t < o; t++)
            0 === e[t] && n++
    }
    return n
}
function pC(e) {
    throw new Error(`Not implemented: ${e}`)
}
function hC(e) {
    throw new Error(`Unexpected value: ${e}`)
}
Math.hypot || (Math.hypot = function() {
    for (var e = 0, t = arguments.length; t--;)
        e += arguments[t] * arguments[t];
    return Math.sqrt(e)
}),
(aC = iC || (iC = {})).RENDER = "render",
aC.RENDER_CACHED = "render-cached",
aC.UPLOAD = "upload",
aC.UPLOAD_NAIVE = "upload-naive",
aC.DISTINCT = "distinct",
aC.DISTINCT_POSITION = "distinct-position",
aC.UNUSED = "unused",
function() {
    var e = new sC(3);
    sC != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0)
}();
const {FLOAT: fC} = Mv.ComponentType,
    {LINES: gC, LINE_STRIP: mC, LINE_LOOP: bC, TRIANGLES: AC, TRIANGLE_STRIP: yC, TRIANGLE_FAN: vC} = Vv.Mode;
Fy.ACCESSOR,
Fy.MESH,
Fy.TEXTURE,
Fy.MATERIAL,
Fy.SKIN;
const {TEXTURE_INFO: _C, ROOT: xC} = Fy;
function wC(e) {
    return {
        properties: e.getRoot().listScenes().map(e => {
            const t = e.listChildren()[0],
                n = ov(e);
            return {
                name: e.getName(),
                rootName: t ? t.getName() : "",
                bboxMin: RC(n.min),
                bboxMax: RC(n.max),
                renderVertexCount: lC(e, iC.RENDER),
                uploadVertexCount: lC(e, iC.UPLOAD),
                uploadNaiveVertexCount: lC(e, iC.UPLOAD_NAIVE)
            }
        })
    }
}
function CC(e) {
    return {
        properties: e.getRoot().listMeshes().map(e => {
            const t = e.listParents().filter(e => e.propertyType !== Fy.ROOT).length;
            let n = 0;
            const r = new Set,
                o = new Set,
                i = new Set;
            e.listPrimitives().forEach(e => {
                for (const n of e.listSemantics()) {
                    const t = e.getAttribute(n);
                    r.add(n + ":" + BC(t)),
                    i.add(t)
                }
                for (const n of e.listTargets())
                    n.listAttributes().forEach(e => i.add(e));
                const t = e.getIndices();
                t && (o.add(BC(t)), i.add(t)),
                n += function(e) {
                    const t = e.getIndices(),
                        n = e.getAttribute("POSITION");
                    switch (e.getMode()) {
                    case Vv.Mode.POINTS:
                        return t ? t.getCount() : n.getCount();
                    case Vv.Mode.LINES:
                        return t ? t.getCount() / 2 : n.getCount() / 2;
                    case Vv.Mode.LINE_LOOP:
                        return t ? t.getCount() : n.getCount();
                    case Vv.Mode.LINE_STRIP:
                        return t ? t.getCount() - 1 : n.getCount() - 1;
                    case Vv.Mode.TRIANGLES:
                        return t ? t.getCount() / 3 : n.getCount() / 3;
                    case Vv.Mode.TRIANGLE_STRIP:
                    case Vv.Mode.TRIANGLE_FAN:
                        return t ? t.getCount() - 2 : n.getCount() - 2;
                    default:
                        throw new Error("Unexpected mode: " + e.getMode())
                    }
                }(e)
            });
            let a = 0;
            Array.from(i).forEach(e => a += e.getArray().byteLength);
            const s = e.listPrimitives().map(e => TC[e.getMode()]);
            return {
                name: e.getName(),
                mode: Array.from(new Set(s)),
                meshPrimitives: e.listPrimitives().length,
                glPrimitives: n,
                vertices: cC(e, iC.UPLOAD),
                indices: Array.from(o).sort(),
                attributes: Array.from(r).sort(),
                instances: t,
                size: a
            }
        })
    }
}
function EC(e) {
    return {
        properties: e.getRoot().listMaterials().map(t => {
            const n = t.listParents().filter(e => e.propertyType !== Fy.ROOT).length,
                r = new Set(t.listExtensions()),
                o = e.getGraph().listEdges().filter(e => {
                    const n = e.getChild(),
                        o = e.getParent();
                    return n instanceof qv && o === t || !!(n instanceof qv && o instanceof Ov && r.has(o))
                }).map(e => e.getName());
            return {
                name: t.getName(),
                instances: n,
                textures: o,
                alphaMode: t.getAlphaMode(),
                doubleSided: t.getDoubleSided()
            }
        })
    }
}
function SC(e) {
    return {
        properties: e.getRoot().listTextures().map(t => {
            const n = t.listParents().filter(e => e.propertyType !== Fy.ROOT).length,
                r = e.getGraph().listParentEdges(t).filter(e => e.getParent().propertyType !== Fy.ROOT).map(e => e.getName()),
                o = Yy.getSize(t.getImage(), t.getMimeType());
            let i = "";
            if ("image/ktx2" === t.getMimeType()) {
                const e = x_(t.getImage()).dataFormatDescriptor[0];
                163 === e.colorModel ? i = "ETC1S" : 166 === e.colorModel && (i = "UASTC")
            }
            return {
                name: t.getName(),
                uri: t.getURI(),
                slots: Array.from(new Set(r)),
                instances: n,
                mimeType: t.getMimeType(),
                compression: i,
                resolution: o ? o.join("x") : "",
                size: t.getImage().byteLength,
                gpuSize: Yy.getVRAMByteLength(t.getImage(), t.getMimeType())
            }
        })
    }
}
function IC(e) {
    return {
        properties: e.getRoot().listAnimations().map(e => {
            let t = 1 / 0,
                n = -1 / 0;
            e.listSamplers().forEach(e => {
                const r = e.getInput();
                r && (t = Math.min(t, r.getMin([])[0]), n = Math.max(n, r.getMax([])[0]))
            });
            let r = 0,
                o = 0;
            const i = new Set;
            return e.listSamplers().forEach(e => {
                const t = e.getInput(),
                    n = e.getOutput();
                t && (o += t.getCount(), i.add(t), n && i.add(n))
            }), Array.from(i).forEach(e => {
                r += e.getArray().byteLength
            }), {
                name: e.getName(),
                channels: e.listChannels().length,
                samplers: e.listSamplers().length,
                duration: Math.round(1e3 * (n - t)) / 1e3,
                keyframes: o,
                size: r
            }
        })
    }
}
!function() {
    var e = new sC(4);
    sC != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0)
}(),
Fy.NODE,
Fy.SKIN,
Fy.MESH,
Fy.CAMERA,
Fy.PRIMITIVE,
Fy.PRIMITIVE_TARGET,
Fy.ANIMATION,
Fy.MATERIAL,
Fy.TEXTURE,
Fy.ACCESSOR,
Fy.BUFFER;
const TC = ["POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN"],
    MC = {
        Float32Array: "f32",
        Uint32Array: "u32",
        Uint16Array: "u16",
        Uint8Array: "u8",
        Int32Array: "i32",
        Int16Array: "i16",
        Int8Array: "i8"
    };
function RC(e) {
    for (let t = 0; t < e.length; t++)
        e[t].toFixed && (e[t] = Number(e[t].toFixed(5)));
    return e
}
function BC(e) {
    const t = e.getArray();
    return (MC[t.constructor.name] || "?") + (e.getNormalized() ? "_norm" : "")
}
const {LINE_STRIP: kC, LINE_LOOP: DC, TRIANGLE_STRIP: PC, TRIANGLE_FAN: OC} = Vv.Mode,
    {ROOT: LC, NODE: NC, MESH: FC, PRIMITIVE: UC, ACCESSOR: zC} = Fy,
    {TRANSLATION: QC, ROTATION: GC, SCALE: jC, WEIGHTS: VC} = Bv.TargetPath;
var HC,
    $C;
Yw({
    level: "high"
}, {
    pattern: /.*/,
    quantizationVolume: "mesh",
    quantizePosition: 14,
    quantizeNormal: 10,
    quantizeTexcoord: 12,
    quantizeColor: 8,
    quantizeWeight: 8,
    quantizeGeneric: 12,
    normalizeWeights: !0,
    cleanup: !0
}),
($C = HC || (HC = {}))[$C.STEP = 0] = "STEP",
$C[$C.LERP = 1] = "LERP",
$C[$C.SLERP = 2] = "SLERP",
Promise.resolve();
const {POINTS: WC, LINES: KC, LINE_STRIP: qC, LINE_LOOP: XC, TRIANGLES: YC, TRIANGLE_STRIP: JC, TRIANGLE_FAN: ZC} = Vv.Mode;
var eE,
    tE;
(tE = eE || (eE = {})).LANCZOS3 = "lanczos3",
tE.LANCZOS2 = "lanczos2",
eE.LANCZOS3;
class nE {
    worker;
    idsCounter = 0;
    pendingRequests = {};
    constructor()
    {
        this.worker = new Worker(new URL("/assets/ktx-worker-DdS_K55O.js", import.meta.url), {
            type: "module"
        }),
        this.worker.onmessage = e => {
            this.onMessage(e)
        }
    }
    async init()
    {
        const e = this.idsCounter++;
        return new Promise(t => {
            this.worker.postMessage({
                type: "init",
                id: e
            }),
            this.pendingRequests[e] = () => {
                t()
            }
        })
    }
    async applyChanges(e, t)
    {
        const n = this.idsCounter++;
        return new Promise(r => {
            this.worker.postMessage({
                type: "applyChanges",
                id: n,
                data: {
                    settings: e,
                    gltfData: t
                }
            }, [t]),
            this.pendingRequests[n] = e => {
                r(e.buffer)
            }
        })
    }
    onMessage(e)
    {
        const {id: t, data: n} = e.data,
            r = this.pendingRequests[t];
        r && (r(n), delete this.pendingRequests[t])
    }
}
class rE {
    io;
    renderer;
    scene;
    camera;
    controls;
    clock = new bh;
    loadedScene = new od;
    loadedSceneGLB = null;
    loadedModifiedScene = new od;
    analysisResults;
    workerAPI;
    shadowPlane;
    dracoLoader;
    ktx2Loader;
    constructor(e)
    {
        this.renderer = new cm({
            antialias: !1,
            canvas: e
        }),
        this.renderer.shadowMap.enabled = !0,
        this.renderer.shadowMap.type = 2,
        this.scene = new sd,
        this.scene.background = new su(2236962),
        this.scene.add(new Jp(16777215, 4473924, 1)),
        this.scene.add(this.loadedScene),
        this.scene.add(this.loadedModifiedScene);
        const t = new mp(20, 20),
            n = new bp({
                opacity: .3
            });
        this.shadowPlane = new Qu(t, n),
        this.shadowPlane.rotation.x = -Math.PI / 2,
        this.shadowPlane.receiveShadow = !0,
        this.scene.add(this.shadowPlane),
        this.loadedModifiedScene.visible = !1;
        const r = new ph(16777215, 2);
        r.position.set(2, 10, -1.5),
        r.target.position.set(0, 0, 0),
        r.castShadow = !0,
        r.shadow.camera.near = .1,
        r.shadow.camera.far = 50,
        r.shadow.camera.left = -10,
        r.shadow.camera.right = 10,
        r.shadow.camera.top = 10,
        r.shadow.camera.bottom = -10,
        r.shadow.mapSize.width = 2048,
        r.shadow.mapSize.height = 2048,
        r.shadow.normalBias = .05,
        this.scene.add(r),
        this.scene.add(r.target),
        this.camera = new Zu(75, 1, .1, 1e3),
        this.camera.position.set(7.997131554411993, 4.219569131269548, 6.489250935244249),
        this.controls = new vm(this.camera, this.renderer.domElement),
        this.controls.target.set(0, 0, 0),
        this.controls.enableDamping = !0,
        this.controls.maxDistance = 20,
        this.controls.minDistance = 5,
        this.controls.update(),
        window.addEventListener("resize", () => this.onResize()),
        this.onResize(),
        this.RAF(),
        this.io = new A_,
        this.io.registerExtensions(Xw),
        this.analysisResults = {
            original: {
                target: "Original",
                vertices: 0,
                primitives: 0,
                vertexDataSize: 0,
                textureDataSize: 0,
                fileSize: 0,
                memorySize: 0
            },
            compressed: {
                target: "Compressed",
                vertices: 0,
                primitives: 0,
                vertexDataSize: 0,
                textureDataSize: 0,
                fileSize: 0,
                memorySize: 0
            },
            compressedBytes: new Uint8Array
        },
        this.workerAPI = new nE,
        this.dracoLoader = new oA,
        this.dracoLoader.setDecoderPath("./libs/draco/"),
        this.ktx2Loader = new ny,
        this.ktx2Loader.setTranscoderPath("./libs/basis/"),
        this.ktx2Loader.detectSupport(this.renderer)
    }
    async init()
    {
        const e = [Ey.createDecoderModule({
                locateFile: e => `/libs/draco/${e}`
            }), Ey.createEncoderModule({
                locateFile: e => `/libs/draco/${e}`
            }), this.workerAPI.init(), this.loadHDR("/resources/skybox/background_1k.hdr")],
            [t, n] = await Promise.all(e);
        this.io.registerDependencies({
            "draco3d.decoder": t,
            "draco3d.encoder": n
        })
    }
    onResize()
    {
        const e = window.innerWidth,
            t = window.innerHeight;
        this.camera.aspect = e / t,
        this.camera.updateProjectionMatrix(),
        this.renderer.setSize(e, t, !1)
    }
    async loadSceneFromFiles(e)
    {
        const t = {};
        for (const s of e) {
            const e = URL.createObjectURL(s);
            t[s.name] = e
        }
        const n = new Qp;
        n.setURLModifier(e => {
            const n = (e => {
                const t = (e = e.replace(/^\.\/+/, "")).split("/");
                return t[t.length - 1] || e
            })(e);
            return t[n] ?? e
        });
        const r = new Pm(n);
        r.setDRACOLoader(this.dracoLoader),
        r.setKTX2Loader(this.ktx2Loader);
        const o = e.find(e => {
                const t = e.name.toLowerCase();
                return t.endsWith(".gltf") || t.endsWith(".glb")
            }).name,
            i = t[o],
            a = await r.loadAsync(i);
        for (const s of Object.values(t))
            URL.revokeObjectURL(s);
        return a
    }
    filterFiles(e)
    {
        const t = e.filter(e => {
            const t = e.name.toLowerCase();
            return t.endsWith(".gltf") || t.endsWith(".glb")
        });
        if (t.length > 0) {
            const n = t[0];
            return e.filter(e => e === n || !e.name.toLowerCase().endsWith(".gltf") && !e.name.toLowerCase().endsWith(".glb"))
        }
        return null
    }
    async loadModels(e)
    {
        const t = this.filterFiles(e);
        if (!t)
            throw new Error("No GLTF or GLB file found in the provided files.");
        const n = await this.loadSceneFromFiles(t);
        this.loadedScene.add(n.scene),
        this.loadedSceneGLB = n,
        this.loadedScene.traverse(e => {
            e instanceof Qu && (e.castShadow = !0, e.receiveShadow = !0)
        });
        const r = (new Gl).setFromObject(n.scene),
            o = 15 / (2 * r.getBoundingSphere(new ac).radius);
        this.loadedScene.scale.setScalar(o),
        this.loadedModifiedScene.scale.setScalar(o);
        const i = r.getCenter(new hl);
        this.loadedScene.position.set(this.loadedScene.position.x - i.x * o, this.loadedScene.position.y - i.y * o, this.loadedScene.position.z - i.z * o),
        this.loadedModifiedScene.position.set(this.loadedModifiedScene.position.x - i.x * o, this.loadedModifiedScene.position.y - i.y * o, this.loadedModifiedScene.position.z - i.z * o);
        const a = r.max.y - r.min.y;
        this.shadowPlane.position.set(0, -a * o * .5, 0);
        const s = await this.exportLoadedScene();
        if (!s)
            throw new Error("Failed to export loaded scene for analysis");
        const l = await this.io.readBinary(new Uint8Array(s));
        this.analysisResults.original = await this.performAnalysisDocument(l, n),
        this.analysisResults.original.target = "Original",
        this.analysisResults.original.fileSize = t.reduce((e, t) => e + t.size, 0)
    }
    async performAnalysisDocument(e, t)
    {
        const n = {
            scenes: wC(r = e),
            meshes: CC(r),
            materials: EC(r),
            textures: SC(r),
            animations: IC(r)
        };
        var r;
        return await this.performAnalysis(n, t)
    }
    getBPP(e)
    {
        switch (e) {
        case Va:
        case qa:
        case Xa:
            return 1;
        case Ya:
        case Ja:
            return 2;
        case Ha:
        case 1032:
            return 3;
        case $a:
        case Za:
        case Wa:
        case Ka:
            return 4;
        case es:
        case ts:
            return .5;
        case ns:
        case rs:
            return 1;
        case os:
        case as:
            return .5;
        case is:
        case ss:
            return .25;
        case ls:
        case cs:
            return .5;
        case us:
        case ds:
            return 1;
        case ps:
            return .8;
        case hs:
            return .64;
        case fs:
            return .5333333333333333;
        case gs:
            return .4444444444444444;
        case ms:
            return .4;
        case bs:
            return .3333333333333333;
        case As:
            return .25;
        case ys:
            return .32;
        case vs:
            return .26666666666666666;
        case _s:
            return .2;
        case xs:
            return .16;
        case ws:
            return .13333333333333333;
        case Cs:
            return .1111111111111111;
        case Es:
        case Ss:
        case Is:
            return 1;
        case Ts:
        case Ms:
            return .5;
        case Rs:
        case Bs:
            return 1;
        default:
            return 4
        }
    }
    async performAnalysis(e, t)
    {
        const n = {
            target: "",
            vertices: 0,
            primitives: 0,
            vertexDataSize: 0,
            textureDataSize: 0,
            fileSize: 0,
            memorySize: 0
        };
        for (let o of e.meshes.properties)
            n.vertices += o.vertices,
            n.primitives += o.glPrimitives,
            n.vertexDataSize += o.size,
            n.memorySize += o.size;
        const r = {};
        t.scene.traverse(e => {
            if (e instanceof Qu) {
                const t = e.material;
                if (Array.isArray(t))
                    for (const e of t)
                        for (const t of Object.keys(e)) {
                            const n = e[t];
                            n && n.isTexture && (r[n.uuid] = n)
                        }
                else
                    for (const e of Object.keys(t)) {
                        const n = t[e];
                        n && n.isTexture && (r[n.uuid] = n)
                    }
            }
        });
        for (let o = 0; o < Object.values(r).length; o++) {
            const e = Object.values(r)[o],
                t = e.mipmaps && e.mipmaps.length > 0 || e.generateMipmaps,
                i = e.image,
                a = i.width * i.height * this.getBPP(e.format) * (t ? 4 / 3 : 1);
            n.textureDataSize += a,
            n.memorySize += a
        }
        return n
    }
    async loadHDR(e)
    {
        const t = new sy,
            n = await t.loadAsync(e);
        n.mapping = xa,
        this.scene.backgroundBlurriness = .7,
        this.scene.backgroundIntensity = .5,
        this.scene.environmentIntensity = .75,
        this.scene.background = n,
        this.scene.environment = n
    }
    step(e, t)
    {
        this.controls.update()
    }
    render()
    {
        this.renderer.render(this.scene, this.camera)
    }
    RAF()
    {
        requestAnimationFrame(() => {
            this.step(this.clock.getDelta(), this.clock.getElapsedTime()),
            this.render(),
            this.RAF()
        })
    }
    setVisibleScene(e)
    {
        "original" === e ? (this.loadedModifiedScene.visible = !1, this.loadedScene.visible = !0) : (this.loadedModifiedScene.visible = !0, this.loadedScene.visible = !1)
    }
    async exportLoadedScene()
    {
        const e = new Tb;
        e.setTextureUtils(py);
        const t = {
                binary: !0,
                animations: this.loadedSceneGLB?.animations || []
            },
            n = await e.parseAsync(this.loadedScene.children[0], t);
        return n instanceof ArrayBuffer == 0 ? null : n
    }
    async applyChanges(e)
    {
        if (!this.loadedScene)
            return;
        const t = await this.exportLoadedScene();
        if (!t)
            return;
        const n = await this.workerAPI.applyChanges(e, t),
            r = new Uint8Array(n),
            o = new Pm;
        o.setDRACOLoader(this.dracoLoader),
        o.setKTX2Loader(this.ktx2Loader);
        const i = await o.parseAsync(r.buffer, "");
        this.loadedModifiedScene.traverse(e => {
            if (e instanceof Qu) {
                for (let t in e.material)
                    if (e.material[t] instanceof Ll) {
                        const n = e.material[t];
                        n.source.data instanceof ImageBitmap && n.source.data.close(),
                        n.dispose()
                    }
                e.geometry.dispose(),
                e.material.dispose()
            }
        }),
        this.loadedModifiedScene.clear(),
        this.loadedModifiedScene.add(i.scene),
        i.scene.traverse(e => {
            e instanceof Qu && (e.castShadow = !0, e.receiveShadow = !0)
        });
        const a = await this.io.readBinary(new Uint8Array(r));
        return this.analysisResults.compressed = await this.performAnalysisDocument(a, i), this.analysisResults.compressed.target = "Compressed", this.analysisResults.compressed.fileSize = r.byteLength, this.analysisResults.compressedBytes = r, this.analysisResults
    }
}
aE = aE || new Map;
const oE = function(e, t) {
        var n = aE.get(e);
        n ? n.push(t) : aE.set(e, [t])
    },
    iE = function(e, t) {
        var n = aE.get(e);
        n && n.slice().map(function(e) {
            e(t)
        }),
        (n = aE.get("*")) && n.slice().map(function(n) {
            n(e, t)
        })
    };
var aE;
const sE = (e, t) => {
        const n = e.__vccOpts || e;
        for (const [r, o] of t)
            n[r] = o;
        return n
    },
    lE = sE(yn({
        __name: "threejs-viewer",
        setup(e) {
            const t = ft(null);
            let n = null;
            return oE("loadModel", async ({files: e}) => {
                if (n)
                    try {
                        await n.loadModels(e),
                        iE("loaded", {
                            error: null
                        })
                    } catch (t) {
                        iE("loaded", {
                            error: t.message
                        })
                    }
            }), oE("applyChanges", async ({settings: e}) => {
                n && n.applyChanges(e).then(e => {
                    e && iE("compressionCompleted", {
                        result: e
                    })
                })
            }), oE("selectionChanged", e => {
                n && n.setVisibleScene(e.name)
            }), Dn(async () => {
                t.value && (n = new rE(t.value), await n.init())
            }), (e, n) => (uo(), go("div", Mo(e.$attrs, {
                class: "flex flex-1"
            }), [_o("canvas", {
                ref_key: "canvasRef",
                ref: t,
                class: "flex-1 parent"
            }, null, 512), Eo("", !0)], 16))
        }
    }), [["__scopeId", "data-v-21dad4de"]]);
function cE(e, t) {
    return !!e && (e.classList ? e.classList.contains(t) : new RegExp("(^| )" + t + "( |$)", "gi").test(e.className))
}
function uE(e, t) {
    if (e && t) {
        let n = t => {
            cE(e, t) || (e.classList ? e.classList.add(t) : e.className += " " + t)
        };
        [t].flat().filter(Boolean).forEach(e => e.split(" ").forEach(n))
    }
}
function dE(e, t) {
    if (e && t) {
        let n = t => {
            e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " ")
        };
        [t].flat().filter(Boolean).forEach(e => e.split(" ").forEach(n))
    }
}
function pE(e) {
    for (let n of null == document ? void 0 : document.styleSheets)
        try {
            for (let t of null == n ? void 0 : n.cssRules)
                for (let n of null == t ? void 0 : t.style)
                    if (e.test(n))
                        return {
                            name: n,
                            value: t.style.getPropertyValue(n).trim()
                        }
        } catch (t) {}
    return null
}
function hE(e) {
    let t = {
        width: 0,
        height: 0
    };
    if (e) {
        let [n, r] = [e.style.visibility, e.style.display],
            o = e.getBoundingClientRect();
        e.style.visibility = "hidden",
        e.style.display = "block",
        t.width = o.width || e.offsetWidth,
        t.height = o.height || e.offsetHeight,
        e.style.display = r,
        e.style.visibility = n
    }
    return t
}
function fE() {
    let e = window,
        t = document,
        n = t.documentElement,
        r = t.getElementsByTagName("body")[0];
    return {
        width: e.innerWidth || n.clientWidth || r.clientWidth,
        height: e.innerHeight || n.clientHeight || r.clientHeight
    }
}
function gE(e) {
    return e ? Math.abs(e.scrollLeft) : 0
}
function mE() {
    let e = document.documentElement;
    return (window.pageXOffset || gE(e)) - (e.clientLeft || 0)
}
function bE() {
    let e = document.documentElement;
    return (window.pageYOffset || e.scrollTop) - (e.clientTop || 0)
}
function AE(e) {
    return !!e && "rtl" === getComputedStyle(e).direction
}
function yE(e, t, n=!0) {
    var r,
        o,
        i,
        a;
    if (e) {
        let s,
            l,
            c = e.offsetParent ? {
                width: e.offsetWidth,
                height: e.offsetHeight
            } : hE(e),
            u = c.height,
            d = c.width,
            p = t.offsetHeight,
            h = t.offsetWidth,
            f = t.getBoundingClientRect(),
            g = bE(),
            m = mE(),
            b = fE(),
            A = "top";
        f.top + p + u > b.height ? (s = f.top + g - u, A = "bottom", s < 0 && (s = g)) : s = p + f.top + g,
        l = f.left + d > b.width ? Math.max(0, f.left + m + h - d) : f.left + m,
        AE(e) ? e.style.insetInlineEnd = l + "px" : e.style.insetInlineStart = l + "px",
        e.style.top = s + "px",
        e.style.transformOrigin = A,
        n && (e.style.marginTop = "bottom" === A ? `calc(${null != (o = null == (r = pE(/-anchor-gutter$/)) ? void 0 : r.value) ? o : "2px"} * -1)` : null != (a = null == (i = pE(/-anchor-gutter$/)) ? void 0 : i.value) ? a : "")
    }
}
function vE(e, t) {
    e && ("string" == typeof t ? e.style.cssText = t : Object.entries(t || {}).forEach(([t, n]) => e.style[t] = n))
}
function _E(e, t) {
    return e instanceof HTMLElement ? e.offsetWidth : 0
}
function xE(e) {
    if (e) {
        let t = e.parentNode;
        return t && t instanceof ShadowRoot && t.host && (t = t.host), t
    }
    return null
}
function wE(e) {
    return !(null == e || !e.nodeName || !xE(e))
}
function CE(e) {
    return "undefined" != typeof Element ? e instanceof Element : null !== e && "object" == typeof e && 1 === e.nodeType && "string" == typeof e.nodeName
}
function EE() {
    if (window.getSelection) {
        let e = window.getSelection() || {};
        e.empty ? e.empty() : e.removeAllRanges && e.rangeCount > 0 && e.getRangeAt(0).getClientRects().length > 0 && e.removeAllRanges()
    }
}
function SE(e, t={}) {
    if (CE(e)) {
        let n = (t, r) => {
            var o,
                i;
            let a = null != (o = null == e ? void 0 : e.$attrs) && o[t] ? [null == (i = null == e ? void 0 : e.$attrs) ? void 0 : i[t]] : [];
            return [r].flat().reduce((e, r) => {
                if (null != r) {
                    let o = typeof r;
                    if ("string" === o || "number" === o)
                        e.push(r);
                    else if ("object" === o) {
                        let o = Array.isArray(r) ? n(t, r) : Object.entries(r).map(([e, n]) => "style" !== t || !n && 0 !== n ? n ? e : void 0 : `${e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${n}`);
                        e = o.length ? e.concat(o.filter(e => !!e)) : e
                    }
                }
                return e
            }, a)
        };
        Object.entries(t).forEach(([t, r]) => {
            if (null != r) {
                let o = t.match(/^on(.+)/);
                o ? e.addEventListener(o[1].toLowerCase(), r) : "p-bind" === t || "pBind" === t ? SE(e, r) : (r = "class" === t ? [...new Set(n("class", r))].join(" ").trim() : "style" === t ? n("style", r).join(";").trim() : r, (e.$attrs = e.$attrs || {}) && (e.$attrs[t] = r), e.setAttribute(t, r))
            }
        })
    }
}
function IE(e, t={}, ...n) {
    if (e) {
        let r = document.createElement(e);
        return SE(r, t), r.append(...n), r
    }
}
function TE(e, t) {
    return CE(e) ? Array.from(e.querySelectorAll(t)) : []
}
function ME(e, t) {
    return CE(e) ? e.matches(t) ? e : e.querySelector(t) : null
}
function RE(e, t) {
    e && document.activeElement !== e && e.focus(t)
}
function BE(e, t) {
    if (CE(e)) {
        let n = e.getAttribute(t);
        return isNaN(n) ? "true" === n || "false" === n ? "true" === n : n : +n
    }
}
function kE(e, t="") {
    let n = TE(e, `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [href]:not([tabindex = "-1"]):not([style*="display:none"]):not([hidden])${t},\n            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t}`),
        r = [];
    for (let o of n)
        "none" != getComputedStyle(o).display && "hidden" != getComputedStyle(o).visibility && r.push(o);
    return r
}
function DE(e, t) {
    let n = kE(e, t);
    return n.length > 0 ? n[0] : null
}
function PE(e) {
    if (e) {
        let t = e.offsetHeight,
            n = getComputedStyle(e);
        return t -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom) + parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth), t
    }
    return 0
}
function OE(e) {
    var t;
    if (e) {
        let n = null == (t = xE(e)) ? void 0 : t.childNodes,
            r = 0;
        if (n)
            for (let t = 0; t < n.length; t++) {
                if (n[t] === e)
                    return r;
                1 === n[t].nodeType && r++
            }
    }
    return -1
}
function LE(e, t) {
    let n = kE(e, t);
    return n.length > 0 ? n[n.length - 1] : null
}
function NE(e, t) {
    let n = e.nextElementSibling;
    for (; n;) {
        if (n.matches(t))
            return n;
        n = n.nextElementSibling
    }
    return null
}
function FE(e) {
    if (e) {
        let t = e.getBoundingClientRect();
        return {
            top: t.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
            left: t.left + (window.pageXOffset || gE(document.documentElement) || gE(document.body) || 0)
        }
    }
    return {
        top: "auto",
        left: "auto"
    }
}
function UE(e, t) {
    return e ? e.offsetHeight : 0
}
function zE(e, t=[]) {
    let n = xE(e);
    return null === n ? t : zE(n, t.concat([n]))
}
function QE(e, t) {
    let n = e.previousElementSibling;
    for (; n;) {
        if (n.matches(t))
            return n;
        n = n.previousElementSibling
    }
    return null
}
function GE(e) {
    let t = [];
    if (e) {
        let n = zE(e),
            r = /(auto|scroll)/,
            o = e => {
                try {
                    let t = window.getComputedStyle(e, null);
                    return r.test(t.getPropertyValue("overflow")) || r.test(t.getPropertyValue("overflowX")) || r.test(t.getPropertyValue("overflowY"))
                } catch (t) {
                    return !1
                }
            };
        for (let e of n) {
            let n = 1 === e.nodeType && e.dataset.scrollselectors;
            if (n) {
                let r = n.split(",");
                for (let n of r) {
                    let r = ME(e, n);
                    r && o(r) && t.push(r)
                }
            }
            9 !== e.nodeType && o(e) && t.push(e)
        }
    }
    return t
}
function jE() {
    return window.getSelection ? window.getSelection().toString() : document.getSelection ? document.getSelection().toString() : void 0
}
function VE(e) {
    if (e) {
        let t = e.offsetWidth,
            n = getComputedStyle(e);
        return t -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight) + parseFloat(n.borderLeftWidth) + parseFloat(n.borderRightWidth), t
    }
    return 0
}
function HE(e, t, n) {
    let r = e[t];
    "function" == typeof r && r.apply(e, [])
}
function $E(e) {
    if (e) {
        let t = e.nodeName,
            n = e.parentElement && e.parentElement.nodeName;
        return "INPUT" === t || "TEXTAREA" === t || "BUTTON" === t || "A" === t || "INPUT" === n || "TEXTAREA" === n || "BUTTON" === n || "A" === n || !!e.closest(".p-button, .p-checkbox, .p-radiobutton")
    }
    return !1
}
function WE() {
    return !("undefined" == typeof window || !window.document || !window.document.createElement)
}
function KE(e, t="") {
    return !!CE(e) && e.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t},\n            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${t}`)
}
function qE(e) {
    return !(!e || null == e.offsetParent)
}
function XE() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0
}
function YE(e, t="", n) {
    CE(e) && null != n && e.setAttribute(t, n)
}
var JE = Object.defineProperty,
    ZE = Object.getOwnPropertySymbols,
    eS = Object.prototype.hasOwnProperty,
    tS = Object.prototype.propertyIsEnumerable,
    nS = (e, t, n) => t in e ? JE(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n;
function rS(e) {
    return null == e || "" === e || Array.isArray(e) && 0 === e.length || !(e instanceof Date) && "object" == typeof e && 0 === Object.keys(e).length
}
function oS(e, t, n=new WeakSet) {
    if (e === t)
        return !0;
    if (!e || !t || "object" != typeof e || "object" != typeof t || n.has(e) || n.has(t))
        return !1;
    n.add(e).add(t);
    let r,
        o,
        i,
        a = Array.isArray(e),
        s = Array.isArray(t);
    if (a && s) {
        if (o = e.length, o != t.length)
            return !1;
        for (r = o; 0 !== r--;)
            if (!oS(e[r], t[r], n))
                return !1;
        return !0
    }
    if (a != s)
        return !1;
    let l = e instanceof Date,
        c = t instanceof Date;
    if (l != c)
        return !1;
    if (l && c)
        return e.getTime() == t.getTime();
    let u = e instanceof RegExp,
        d = t instanceof RegExp;
    if (u != d)
        return !1;
    if (u && d)
        return e.toString() == t.toString();
    let p = Object.keys(e);
    if (o = p.length, o !== Object.keys(t).length)
        return !1;
    for (r = o; 0 !== r--;)
        if (!Object.prototype.hasOwnProperty.call(t, p[r]))
            return !1;
    for (r = o; 0 !== r--;)
        if (i = p[r], !oS(e[i], t[i], n))
            return !1;
    return !0
}
function iS(e, t) {
    return oS(e, t)
}
function aS(e) {
    return "function" == typeof e && "call" in e && "apply" in e
}
function sS(e) {
    return !rS(e)
}
function lS(e, t) {
    if (!e || !t)
        return null;
    try {
        let n = e[t];
        if (sS(n))
            return n
    } catch (aE) {}
    if (Object.keys(e).length) {
        if (aS(t))
            return t(e);
        if (-1 === t.indexOf("."))
            return e[t];
        {
            let n = t.split("."),
                r = e;
            for (let e = 0, t = n.length; e < t; ++e) {
                if (null == r)
                    return null;
                r = r[n[e]]
            }
            return r
        }
    }
    return null
}
function cS(e, t, n) {
    return n ? lS(e, n) === lS(t, n) : iS(e, t)
}
function uS(e, t=!0) {
    return e instanceof Object && e.constructor === Object && (t || 0 !== Object.keys(e).length)
}
function dS(e={}, t={}) {
    let n = ((e, t) => {
        for (var n in t || (t = {}))
            eS.call(t, n) && nS(e, n, t[n]);
        if (ZE)
            for (var n of ZE(t))
                tS.call(t, n) && nS(e, n, t[n]);
        return e
    })({}, e);
    return Object.keys(t).forEach(r => {
        let o = r;
        uS(t[o]) && o in e && uS(e[o]) ? n[o] = dS(e[o], t[o]) : n[o] = t[o]
    }), n
}
function pS(...e) {
    return e.reduce((e, t, n) => 0 === n ? t : dS(e, t), {})
}
function hS(e, t) {
    let n = -1;
    if (t)
        for (let r = 0; r < t.length; r++)
            if (t[r] === e) {
                n = r;
                break
            }
    return n
}
function fS(e, t) {
    let n = -1;
    if (sS(e))
        try {
            n = e.findLastIndex(t)
        } catch (r) {
            n = e.lastIndexOf([...e].reverse().find(t))
        }
    return n
}
function gS(e, ...t) {
    return aS(e) ? e(...t) : e
}
function mS(e, t=!0) {
    return "string" == typeof e && (t || "" !== e)
}
function bS(e) {
    return mS(e) ? e.replace(/(-|_)/g, "").toLowerCase() : e
}
function AS(e, t="", n={}) {
    let r = bS(t).split("."),
        o = r.shift();
    return o ? uS(e) ? AS(gS(e[Object.keys(e).find(e => bS(e) === o) || ""], n), r.join("."), n) : void 0 : gS(e, n)
}
function yS(e, t=!0) {
    return Array.isArray(e) && (t || 0 !== e.length)
}
function vS() {
    return new Intl.Collator(void 0, {
        numeric: !0
    }).compare
}
function _S(e, t) {
    if (t) {
        let n = t.test(e);
        return t.lastIndex = 0, n
    }
    return !1
}
function xS(e) {
    return e && e.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":").trim()
}
function wS(e) {
    if (e && /[\xC0-\xFF\u0100-\u017E]/.test(e)) {
        let t = {
            A: /[\xC0-\xC5\u0100\u0102\u0104]/g,
            AE: /[\xC6]/g,
            C: /[\xC7\u0106\u0108\u010A\u010C]/g,
            D: /[\xD0\u010E\u0110]/g,
            E: /[\xC8-\xCB\u0112\u0114\u0116\u0118\u011A]/g,
            G: /[\u011C\u011E\u0120\u0122]/g,
            H: /[\u0124\u0126]/g,
            I: /[\xCC-\xCF\u0128\u012A\u012C\u012E\u0130]/g,
            IJ: /[\u0132]/g,
            J: /[\u0134]/g,
            K: /[\u0136]/g,
            L: /[\u0139\u013B\u013D\u013F\u0141]/g,
            N: /[\xD1\u0143\u0145\u0147\u014A]/g,
            O: /[\xD2-\xD6\xD8\u014C\u014E\u0150]/g,
            OE: /[\u0152]/g,
            R: /[\u0154\u0156\u0158]/g,
            S: /[\u015A\u015C\u015E\u0160]/g,
            T: /[\u0162\u0164\u0166]/g,
            U: /[\xD9-\xDC\u0168\u016A\u016C\u016E\u0170\u0172]/g,
            W: /[\u0174]/g,
            Y: /[\xDD\u0176\u0178]/g,
            Z: /[\u0179\u017B\u017D]/g,
            a: /[\xE0-\xE5\u0101\u0103\u0105]/g,
            ae: /[\xE6]/g,
            c: /[\xE7\u0107\u0109\u010B\u010D]/g,
            d: /[\u010F\u0111]/g,
            e: /[\xE8-\xEB\u0113\u0115\u0117\u0119\u011B]/g,
            g: /[\u011D\u011F\u0121\u0123]/g,
            i: /[\xEC-\xEF\u0129\u012B\u012D\u012F\u0131]/g,
            ij: /[\u0133]/g,
            j: /[\u0135]/g,
            k: /[\u0137,\u0138]/g,
            l: /[\u013A\u013C\u013E\u0140\u0142]/g,
            n: /[\xF1\u0144\u0146\u0148\u014B]/g,
            p: /[\xFE]/g,
            o: /[\xF2-\xF6\xF8\u014D\u014F\u0151]/g,
            oe: /[\u0153]/g,
            r: /[\u0155\u0157\u0159]/g,
            s: /[\u015B\u015D\u015F\u0161]/g,
            t: /[\u0163\u0165\u0167]/g,
            u: /[\xF9-\xFC\u0169\u016B\u016D\u016F\u0171\u0173]/g,
            w: /[\u0175]/g,
            y: /[\xFD\xFF\u0177]/g,
            z: /[\u017A\u017C\u017E]/g
        };
        for (let n in t)
            e = e.replace(t[n], n)
    }
    return e
}
function CS(e, t, n) {
    e && t !== n && (n >= e.length && (n %= e.length, t %= e.length), e.splice(n, 0, e.splice(t, 1)[0]))
}
function ES(e, t, n=1, r, o=1) {
    let i = function(e, t, n, r=1) {
            let o = -1,
                i = rS(e),
                a = rS(t);
            return o = i && a ? 0 : i ? r : a ? -r : "string" == typeof e && "string" == typeof t ? n(e, t) : e < t ? -1 : e > t ? 1 : 0, o
        }(e, t, r, n),
        a = n;
    return (rS(e) || rS(t)) && (a = 1 === o ? n : o), a * i
}
function SS(e) {
    return mS(e) ? e.replace(/(_)/g, "-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : e
}
var IS = {};
function TS(e="pui_id_") {
    return Object.hasOwn(IS, e) || (IS[e] = 0), IS[e]++, `${e}${IS[e]}`
}
var MS = function() {
    let e = [],
        t = (t, n, r=0) => [...e].reverse().find(e => !0) || {
            key: t,
            value: r
        },
        n = e => e && parseInt(e.style.zIndex, 10) || 0;
    return {
        get: n,
        set: (n, r, o) => {
            r && (r.style.zIndex = String(((n, r, o=999) => {
                let i = t(n, 0, o),
                    a = i.value + (i.key === n ? 0 : o) + 1;
                return e.push({
                    key: n,
                    value: a
                }), a
            })(n, 0, o)))
        },
        clear: t => {
            t && ((t => {
                e = e.filter(e => e.value !== t)
            })(n(t)), t.style.zIndex = "")
        },
        getCurrent: e => (e => t(e).value)(e)
    }
}();
function RS(...e) {
    if (e) {
        let t = [];
        for (let n = 0; n < e.length; n++) {
            let r = e[n];
            if (!r)
                continue;
            let o = typeof r;
            if ("string" === o || "number" === o)
                t.push(r);
            else if ("object" === o) {
                let e = Array.isArray(r) ? [RS(...r)] : Object.entries(r).map(([e, t]) => t ? e : void 0);
                t = e.length ? t.concat(e.filter(e => !!e)) : t
            }
        }
        return t.join(" ").trim()
    }
}
function BS() {
    let e = new Map;
    return {
        on(t, n) {
            let r = e.get(t);
            return r ? r.push(n) : r = [n], e.set(t, r), this
        },
        off(t, n) {
            let r = e.get(t);
            return r && r.splice(r.indexOf(n) >>> 0, 1), this
        },
        emit(t, n) {
            let r = e.get(t);
            r && r.forEach(e => {
                e(n)
            })
        },
        clear() {
            e.clear()
        }
    }
}
function kS(e) {
    return (kS = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function DS(e) {
    var t = function(e) {
        if ("object" != kS(e) || !e)
            return e;
        var t = e[Symbol.toPrimitive];
        if (void 0 !== t) {
            var n = t.call(e, "string");
            if ("object" != kS(n))
                return n;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(e)
    }(e);
    return "symbol" == kS(t) ? t : t + ""
}
var PS = function() {
    return e = function e(t) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {};
        !function(e, t) {
            if (!(e instanceof t))
                throw new TypeError("Cannot call a class as a function")
        }(this, e),
        this.element = t,
        this.listener = n
    }, (t = [{
        key: "bindScrollListener",
        value: function() {
            this.scrollableParents = GE(this.element);
            for (var e = 0; e < this.scrollableParents.length; e++)
                this.scrollableParents[e].addEventListener("scroll", this.listener)
        }
    }, {
        key: "unbindScrollListener",
        value: function() {
            if (this.scrollableParents)
                for (var e = 0; e < this.scrollableParents.length; e++)
                    this.scrollableParents[e].removeEventListener("scroll", this.listener)
        }
    }, {
        key: "destroy",
        value: function() {
            this.unbindScrollListener(),
            this.element = null,
            this.listener = null,
            this.scrollableParents = null
        }
    }]) && function(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value" in r && (r.writable = !0),
            Object.defineProperty(e, DS(r.key), r)
        }
    }(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
    var e,
        t
}();
function OS(e) {
    return (OS = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function LS(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function NS(e, t, n) {
    return (t = FS(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
function FS(e) {
    var t = function(e) {
        if ("object" != OS(e) || !e)
            return e;
        var t = e[Symbol.toPrimitive];
        if (void 0 !== t) {
            var n = t.call(e, "string");
            if ("object" != OS(n))
                return n;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        }
        return String(e)
    }(e);
    return "symbol" == OS(t) ? t : t + ""
}
var US = function() {
    return e = function e(t) {
        var n = t.init,
            r = t.type;
        !function(e, t) {
            if (!(e instanceof t))
                throw new TypeError("Cannot call a class as a function")
        }(this, e),
        NS(this, "helpers", void 0),
        NS(this, "type", void 0),
        this.helpers = new Set(n),
        this.type = r
    }, t = [{
        key: "add",
        value: function(e) {
            this.helpers.add(e)
        }
    }, {
        key: "update",
        value: function() {}
    }, {
        key: "delete",
        value: function(e) {
            this.helpers.delete(e)
        }
    }, {
        key: "clear",
        value: function() {
            this.helpers.clear()
        }
    }, {
        key: "get",
        value: function(e, t) {
            var n,
                r = this._get(e, t),
                o = r ? this._recursive(function(e) {
                    if (Array.isArray(e))
                        return LS(e)
                }(n = this.helpers) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                        return Array.from(e)
                }(n) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e)
                            return LS(e, t);
                        var n = {}.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? LS(e, t) : void 0
                    }
                }(n) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }(), r) : null;
            return sS(o) ? o : null
        }
    }, {
        key: "_isMatched",
        value: function(e, t) {
            var n,
                r = null == e ? void 0 : e.parent;
            return (null == r || null === (n = r.vnode) || void 0 === n ? void 0 : n.key) === t || r && this._isMatched(r, t) || !1
        }
    }, {
        key: "_get",
        value: function(e, t) {
            var n,
                r;
            return (null === (n = t || (null == e ? void 0 : e.$slots)) || void 0 === n || null === (r = n.default) || void 0 === r ? void 0 : r.call(n)) || null
        }
    }, {
        key: "_recursive",
        value: function() {
            var e = this,
                t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                n = [];
            return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []).forEach(function(r) {
                r.children instanceof Array ? n = n.concat(e._recursive(t, r.children)) : r.type.name === e.type ? n.push(r) : sS(r.key) && (n = n.concat(t.filter(function(t) {
                    return e._isMatched(t, r.key)
                }).map(function(e) {
                    return e.vnode
                })))
            }), n
        }
    }], t && function(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1,
            r.configurable = !0,
            "value" in r && (r.writable = !0),
            Object.defineProperty(e, FS(r.key), r)
        }
    }(e.prototype, t), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e;
    var e,
        t
}();
function zS(e, t) {
    if (e) {
        var n = e.props;
        if (n) {
            var r = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                o = Object.prototype.hasOwnProperty.call(n, r) ? r : t;
            return e.type.extends.props[t].type === Boolean && "" === n[o] || n[o]
        }
    }
    return null
}
var QS = Object.defineProperty,
    GS = Object.defineProperties,
    jS = Object.getOwnPropertyDescriptors,
    VS = Object.getOwnPropertySymbols,
    HS = Object.prototype.hasOwnProperty,
    $S = Object.prototype.propertyIsEnumerable,
    WS = (e, t, n) => t in e ? QS(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    KS = (e, t) => {
        for (var n in t || (t = {}))
            HS.call(t, n) && WS(e, n, t[n]);
        if (VS)
            for (var n of VS(t))
                $S.call(t, n) && WS(e, n, t[n]);
        return e
    },
    qS = (e, t) => GS(e, jS(t)),
    XS = (e, t) => {
        var n = {};
        for (var r in e)
            HS.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (null != e && VS)
            for (var r of VS(e))
                t.indexOf(r) < 0 && $S.call(e, r) && (n[r] = e[r]);
        return n
    },
    YS = BS(),
    JS = /{([^}]*)}/g,
    ZS = /(\d+\s+[\+\-\*\/]\s+\d+)/g,
    eI = /var\([^)]+\)/g;
function tI(e) {
    return mS(e) ? e.replace(/[A-Z]/g, (e, t) => 0 === t ? e : "." + e.toLowerCase()).toLowerCase() : e
}
function nI(e) {
    return uS(e) && e.hasOwnProperty("$value") && e.hasOwnProperty("$type") ? e.$value : e
}
function rI(e="", t="") {
    return function(e) {
        return e.replaceAll(/ /g, "").replace(/[^\w]/g, "-")
    }(`${mS(e, !1) && mS(t, !1) ? `${e}-` : e}${t}`)
}
function oI(e="", t="") {
    return `--${rI(e, t)}`
}
function iI(e, t="", n="", r=[], o) {
    if (mS(e)) {
        let t = e.trim();
        if (function(e="") {
            return ((e.match(/{/g) || []).length + (e.match(/}/g) || []).length) % 2 != 0
        }(t))
            return;
        if (_S(t, JS)) {
            let e = t.replaceAll(JS, e => {
                let t = e.replace(/{|}/g, "").split(".").filter(e => !r.some(t => _S(e, t)));
                return `var(${oI(n, SS(t.join("-")))}${sS(o) ? `, ${o}` : ""})`
            });
            return _S(e.replace(eI, "0"), ZS) ? `calc(${e})` : e
        }
        return t
    }
    if (function(e) {
        return sS(e) && !isNaN(e)
    }(e))
        return e
}
function aI(e, t, n) {
    mS(t, !1) && e.push(`${t}:${n};`)
}
function sI(e, t) {
    return e ? `${e}{${t}}` : ""
}
function lI(e, t) {
    if (-1 === e.indexOf("dt("))
        return e;
    function n(e, t) {
        let n = [],
            o = 0,
            i = "",
            a = null,
            s = 0;
        for (; o <= e.length;) {
            let l = e[o];
            if (('"' === l || "'" === l || "`" === l) && "\\" !== e[o - 1] && (a = a === l ? null : l), !a && ("(" === l && s++, ")" === l && s--, ("," === l || o === e.length) && 0 === s)) {
                let e = i.trim();
                e.startsWith("dt(") ? n.push(lI(e, t)) : n.push(r(e)),
                i = "",
                o++;
                continue
            }
            void 0 !== l && (i += l),
            o++
        }
        return n
    }
    function r(e) {
        let t = e[0];
        if (('"' === t || "'" === t || "`" === t) && e[e.length - 1] === t)
            return e.slice(1, -1);
        let n = Number(e);
        return isNaN(n) ? e : n
    }
    let o = [],
        i = [];
    for (let a = 0; a < e.length; a++)
        if ("d" === e[a] && "dt(" === e.slice(a, a + 3))
            i.push(a),
            a += 2;
        else if (")" === e[a] && i.length > 0) {
            let e = i.pop();
            0 === i.length && o.push([e, a])
        }
    if (!o.length)
        return e;
    for (let a = o.length - 1; a >= 0; a--) {
        let [r, i] = o[a],
            s = t(...n(e.slice(r + 3, i), t));
        e = e.slice(0, r) + s + e.slice(i + 1)
    }
    return e
}
var cI = e => {
        var t;
        let n = fI.getTheme(),
            r = dI(n, e, void 0, "variable");
        return {
            name: null == (t = null == r ? void 0 : r.match(/--[\w-]+/g)) ? void 0 : t[0],
            variable: r,
            value: dI(n, e, void 0, "value")
        }
    },
    uI = (...e) => dI(fI.getTheme(), ...e),
    dI = (e={}, t, n, r) => {
        if (t) {
            let {variable: o, options: i} = fI.defaults || {},
                {prefix: a, transform: s} = (null == e ? void 0 : e.options) || i || {},
                l = _S(t, JS) ? t : `{${t}}`;
            return "value" === r || rS(r) && "strict" === s ? fI.getTokenValue(t) : iI(l, void 0, a, [o.excludedKeyRegex], n)
        }
        return ""
    };
function pI(e, ...t) {
    if (e instanceof Array) {
        let n = e.reduce((e, n, r) => {
            var o;
            return e + n + (null != (o = gS(t[r], {
                dt: uI
            })) ? o : "")
        }, "");
        return lI(n, uI)
    }
    return gS(e, {
        dt: uI
    })
}
var hI = {
        regex: {
            rules: {
                class: {
                    pattern: /^\.([a-zA-Z][\w-]*)$/,
                    resolve(e) {
                        return {
                            type: "class",
                            selector: e,
                            matched: this.pattern.test(e.trim())
                        }
                    }
                },
                attr: {
                    pattern: /^\[(.*)\]$/,
                    resolve(e) {
                        return {
                            type: "attr",
                            selector: `:root${e},:host${e}`,
                            matched: this.pattern.test(e.trim())
                        }
                    }
                },
                media: {
                    pattern: /^@media (.*)$/,
                    resolve(e) {
                        return {
                            type: "media",
                            selector: e,
                            matched: this.pattern.test(e.trim())
                        }
                    }
                },
                system: {
                    pattern: /^system$/,
                    resolve(e) {
                        return {
                            type: "system",
                            selector: "@media (prefers-color-scheme: dark)",
                            matched: this.pattern.test(e.trim())
                        }
                    }
                },
                custom: {
                    resolve: e => ({
                        type: "custom",
                        selector: e,
                        matched: !0
                    })
                }
            },
            resolve(e) {
                let t = Object.keys(this.rules).filter(e => "custom" !== e).map(e => this.rules[e]);
                return [e].flat().map(e => {
                    var n;
                    return null != (n = t.map(t => t.resolve(e)).find(e => e.matched)) ? n : this.rules.custom.resolve(e)
                })
            }
        },
        _toVariables: (e, t) => function(e, t={}) {
            let n = fI.defaults.variable,
                {prefix: r=n.prefix, selector: o=n.selector, excludedKeyRegex: i=n.excludedKeyRegex} = t,
                a = [],
                s = [],
                l = [{
                    node: e,
                    path: r
                }];
            for (; l.length;) {
                let {node: e, path: t} = l.pop();
                for (let n in e) {
                    let o = nI(e[n]),
                        c = _S(n, i) ? rI(t) : rI(t, SS(n));
                    if (uS(o))
                        l.push({
                            node: o,
                            path: c
                        });
                    else {
                        aI(s, oI(c), iI(o, c, r, [i]));
                        let e = c;
                        r && e.startsWith(r + "-") && (e = e.slice(r.length + 1)),
                        a.push(e.replace(/-/g, "."))
                    }
                }
            }
            let c = s.join("");
            return {
                value: s,
                tokens: a,
                declarations: c,
                css: sI(o, c)
            }
        }(e, {
            prefix: null == t ? void 0 : t.prefix
        }),
        getCommon({name: e="", theme: t={}, params: n, set: r, defaults: o}) {
            var i,
                a,
                s,
                l,
                c,
                u,
                d;
            let p,
                h,
                f,
                g,
                m,
                b,
                A,
                {preset: y, options: v} = t;
            if (sS(y) && "strict" !== v.transform) {
                let {primitive: t, semantic: n, extend: _} = y,
                    x = n || {},
                    {colorScheme: w} = x,
                    C = XS(x, ["colorScheme"]),
                    E = _ || {},
                    {colorScheme: S} = E,
                    I = XS(E, ["colorScheme"]),
                    T = w || {},
                    {dark: M} = T,
                    R = XS(T, ["dark"]),
                    B = S || {},
                    {dark: k} = B,
                    D = XS(B, ["dark"]),
                    P = sS(t) ? this._toVariables({
                        primitive: t
                    }, v) : {},
                    O = sS(C) ? this._toVariables({
                        semantic: C
                    }, v) : {},
                    L = sS(R) ? this._toVariables({
                        light: R
                    }, v) : {},
                    N = sS(M) ? this._toVariables({
                        dark: M
                    }, v) : {},
                    F = sS(I) ? this._toVariables({
                        semantic: I
                    }, v) : {},
                    U = sS(D) ? this._toVariables({
                        light: D
                    }, v) : {},
                    z = sS(k) ? this._toVariables({
                        dark: k
                    }, v) : {},
                    [Q, G] = [null != (i = P.declarations) ? i : "", P.tokens],
                    [j, V] = [null != (a = O.declarations) ? a : "", O.tokens || []],
                    [H, $] = [null != (s = L.declarations) ? s : "", L.tokens || []],
                    [W, K] = [null != (l = N.declarations) ? l : "", N.tokens || []],
                    [q, X] = [null != (c = F.declarations) ? c : "", F.tokens || []],
                    [Y, J] = [null != (u = U.declarations) ? u : "", U.tokens || []],
                    [Z, ee] = [null != (d = z.declarations) ? d : "", z.tokens || []];
                p = this.transformCSS(e, Q, "light", "variable", v, r, o),
                h = G,
                f = `${this.transformCSS(e, `${j}${H}`, "light", "variable", v, r, o)}${this.transformCSS(e, `${W}`, "dark", "variable", v, r, o)}`,
                g = [...new Set([...V, ...$, ...K])],
                m = `${this.transformCSS(e, `${q}${Y}color-scheme:light`, "light", "variable", v, r, o)}${this.transformCSS(e, `${Z}color-scheme:dark`, "dark", "variable", v, r, o)}`,
                b = [...new Set([...X, ...J, ...ee])],
                A = gS(y.css, {
                    dt: uI
                })
            }
            return {
                primitive: {
                    css: p,
                    tokens: h
                },
                semantic: {
                    css: f,
                    tokens: g
                },
                global: {
                    css: m,
                    tokens: b
                },
                style: A
            }
        },
        getPreset({name: e="", preset: t={}, options: n, params: r, set: o, defaults: i, selector: a}) {
            var s,
                l,
                c;
            let u,
                d,
                p;
            if (sS(t) && "strict" !== n.transform) {
                let r = e.replace("-directive", ""),
                    h = t,
                    {colorScheme: f, extend: g, css: m} = h,
                    b = XS(h, ["colorScheme", "extend", "css"]),
                    A = g || {},
                    {colorScheme: y} = A,
                    v = XS(A, ["colorScheme"]),
                    _ = f || {},
                    {dark: x} = _,
                    w = XS(_, ["dark"]),
                    C = y || {},
                    {dark: E} = C,
                    S = XS(C, ["dark"]),
                    I = sS(b) ? this._toVariables({
                        [r]: KS(KS({}, b), v)
                    }, n) : {},
                    T = sS(w) ? this._toVariables({
                        [r]: KS(KS({}, w), S)
                    }, n) : {},
                    M = sS(x) ? this._toVariables({
                        [r]: KS(KS({}, x), E)
                    }, n) : {},
                    [R, B] = [null != (s = I.declarations) ? s : "", I.tokens || []],
                    [k, D] = [null != (l = T.declarations) ? l : "", T.tokens || []],
                    [P, O] = [null != (c = M.declarations) ? c : "", M.tokens || []];
                u = `${this.transformCSS(r, `${R}${k}`, "light", "variable", n, o, i, a)}${this.transformCSS(r, P, "dark", "variable", n, o, i, a)}`,
                d = [...new Set([...B, ...D, ...O])],
                p = gS(m, {
                    dt: uI
                })
            }
            return {
                css: u,
                tokens: d,
                style: p
            }
        },
        getPresetC({name: e="", theme: t={}, params: n, set: r, defaults: o}) {
            var i;
            let {preset: a, options: s} = t,
                l = null == (i = null == a ? void 0 : a.components) ? void 0 : i[e];
            return this.getPreset({
                name: e,
                preset: l,
                options: s,
                params: n,
                set: r,
                defaults: o
            })
        },
        getPresetD({name: e="", theme: t={}, params: n, set: r, defaults: o}) {
            var i,
                a;
            let s = e.replace("-directive", ""),
                {preset: l, options: c} = t,
                u = (null == (i = null == l ? void 0 : l.components) ? void 0 : i[s]) || (null == (a = null == l ? void 0 : l.directives) ? void 0 : a[s]);
            return this.getPreset({
                name: s,
                preset: u,
                options: c,
                params: n,
                set: r,
                defaults: o
            })
        },
        applyDarkColorScheme: e => !("none" === e.darkModeSelector || !1 === e.darkModeSelector),
        getColorSchemeOption(e, t) {
            var n;
            return this.applyDarkColorScheme(e) ? this.regex.resolve(!0 === e.darkModeSelector ? t.options.darkModeSelector : null != (n = e.darkModeSelector) ? n : t.options.darkModeSelector) : []
        },
        getLayerOrder(e, t={}, n, r) {
            let {cssLayer: o} = t;
            return o ? `@layer ${gS(o.order || o.name || "primeui", n)}` : ""
        },
        getCommonStyleSheet({name: e="", theme: t={}, params: n, props: r={}, set: o, defaults: i}) {
            let a = this.getCommon({
                    name: e,
                    theme: t,
                    params: n,
                    set: o,
                    defaults: i
                }),
                s = Object.entries(r).reduce((e, [t, n]) => e.push(`${t}="${n}"`) && e, []).join(" ");
            return Object.entries(a || {}).reduce((e, [t, n]) => {
                if (uS(n) && Object.hasOwn(n, "css")) {
                    let r = xS(n.css),
                        o = `${t}-variables`;
                    e.push(`<style type="text/css" data-primevue-style-id="${o}" ${s}>${r}</style>`)
                }
                return e
            }, []).join("")
        },
        getStyleSheet({name: e="", theme: t={}, params: n, props: r={}, set: o, defaults: i}) {
            var a;
            let s = {
                    name: e,
                    theme: t,
                    params: n,
                    set: o,
                    defaults: i
                },
                l = null == (a = e.includes("-directive") ? this.getPresetD(s) : this.getPresetC(s)) ? void 0 : a.css,
                c = Object.entries(r).reduce((e, [t, n]) => e.push(`${t}="${n}"`) && e, []).join(" ");
            return l ? `<style type="text/css" data-primevue-style-id="${e}-variables" ${c}>${xS(l)}</style>` : ""
        },
        createTokens(e={}, t, n="", r="", o={}) {
            let i = function(e, t={}, n=[]) {
                    if (n.includes(this.path))
                        return {
                            colorScheme: e,
                            path: this.path,
                            paths: t,
                            value: void 0
                        };
                    n.push(this.path),
                    t.name = this.path,
                    t.binding || (t.binding = {});
                    let r = this.value;
                    if ("string" == typeof this.value && JS.test(this.value)) {
                        let o = this.value.trim().replace(JS, r => {
                            var o;
                            let i = r.slice(1, -1),
                                a = this.tokens[i];
                            if (!a)
                                return "__UNRESOLVED__";
                            let s = a.computed(e, t, n);
                            return Array.isArray(s) && 2 === s.length ? `light-dark(${s[0].value},${s[1].value})` : null != (o = null == s ? void 0 : s.value) ? o : "__UNRESOLVED__"
                        });
                        r = ZS.test(o.replace(eI, "0")) ? `calc(${o})` : o
                    }
                    return rS(t.binding) && delete t.binding, n.pop(), {
                        colorScheme: e,
                        path: this.path,
                        paths: t,
                        value: r.includes("__UNRESOLVED__") ? void 0 : r
                    }
                },
                a = (e, n, r) => {
                    Object.entries(e).forEach(([e, s]) => {
                        let l = _S(e, t.variable.excludedKeyRegex) ? n : n ? `${n}.${tI(e)}` : tI(e),
                            c = r ? `${r}.${e}` : e;
                        uS(s) ? a(s, l, c) : (o[l] || (o[l] = {
                            paths: [],
                            computed: (e, t={}, n=[]) => {
                                if (1 === o[l].paths.length)
                                    return o[l].paths[0].computed(o[l].paths[0].scheme, t.binding, n);
                                if (e && "none" !== e)
                                    for (let r = 0; r < o[l].paths.length; r++) {
                                        let i = o[l].paths[r];
                                        if (i.scheme === e)
                                            return i.computed(e, t.binding, n)
                                    }
                                return o[l].paths.map(e => e.computed(e.scheme, t[e.scheme], n))
                            }
                        }), o[l].paths.push({
                            path: c,
                            value: s,
                            scheme: c.includes("colorScheme.light") ? "light" : c.includes("colorScheme.dark") ? "dark" : "none",
                            computed: i,
                            tokens: o
                        }))
                    })
                };
            return a(e, n, r), o
        },
        getTokenValue(e, t, n) {
            var r;
            let o = t.split(".").filter(e => !_S(e.toLowerCase(), n.variable.excludedKeyRegex)).join("."),
                i = t.includes("colorScheme.light") ? "light" : t.includes("colorScheme.dark") ? "dark" : void 0,
                a = [null == (r = e[o]) ? void 0 : r.computed(i)].flat().filter(e => e);
            return 1 === a.length ? a[0].value : a.reduce((e={}, t) => {
                let n = t,
                    {colorScheme: r} = n,
                    o = XS(n, ["colorScheme"]);
                return e[r] = o, e
            }, void 0)
        },
        getSelectorRule: (e, t, n, r) => "class" === n || "attr" === n ? sI(sS(t) ? `${e}${t},${e} ${t}` : e, r) : sI(e, sI(null != t ? t : ":root,:host", r)),
        transformCSS(e, t, n, r, o={}, i, a, s) {
            if (sS(t)) {
                let {cssLayer: l} = o;
                if ("style" !== r) {
                    let e = this.getColorSchemeOption(o, a);
                    t = "dark" === n ? e.reduce((e, {type: n, selector: r}) => (sS(r) && (e += r.includes("[CSS]") ? r.replace("[CSS]", t) : this.getSelectorRule(r, s, n, t)), e), "") : sI(null != s ? s : ":root,:host", t)
                }
                if (l) {
                    let n = {
                        name: "primeui"
                    };
                    uS(l) && (n.name = gS(l.name, {
                        name: e,
                        type: r
                    })),
                    sS(n.name) && (t = sI(`@layer ${n.name}`, t), null == i || i.layerNames(n.name))
                }
                return t
            }
            return ""
        }
    },
    fI = {
        defaults: {
            variable: {
                prefix: "p",
                selector: ":root,:host",
                excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi
            },
            options: {
                prefix: "p",
                darkModeSelector: "system",
                cssLayer: !1
            }
        },
        _theme: void 0,
        _layerNames: new Set,
        _loadedStyleNames: new Set,
        _loadingStyles: new Set,
        _tokens: {},
        update(e={}) {
            let {theme: t} = e;
            t && (this._theme = qS(KS({}, t), {
                options: KS(KS({}, this.defaults.options), t.options)
            }), this._tokens = hI.createTokens(this.preset, this.defaults), this.clearLoadedStyleNames())
        },
        get theme() {
            return this._theme
        },
        get preset() {
            var e;
            return (null == (e = this.theme) ? void 0 : e.preset) || {}
        },
        get options() {
            var e;
            return (null == (e = this.theme) ? void 0 : e.options) || {}
        },
        get tokens() {
            return this._tokens
        },
        getTheme() {
            return this.theme
        },
        setTheme(e) {
            this.update({
                theme: e
            }),
            YS.emit("theme:change", e)
        },
        getPreset() {
            return this.preset
        },
        setPreset(e) {
            this._theme = qS(KS({}, this.theme), {
                preset: e
            }),
            this._tokens = hI.createTokens(e, this.defaults),
            this.clearLoadedStyleNames(),
            YS.emit("preset:change", e),
            YS.emit("theme:change", this.theme)
        },
        getOptions() {
            return this.options
        },
        setOptions(e) {
            this._theme = qS(KS({}, this.theme), {
                options: e
            }),
            this.clearLoadedStyleNames(),
            YS.emit("options:change", e),
            YS.emit("theme:change", this.theme)
        },
        getLayerNames() {
            return [...this._layerNames]
        },
        setLayerNames(e) {
            this._layerNames.add(e)
        },
        getLoadedStyleNames() {
            return this._loadedStyleNames
        },
        isStyleNameLoaded(e) {
            return this._loadedStyleNames.has(e)
        },
        setLoadedStyleName(e) {
            this._loadedStyleNames.add(e)
        },
        deleteLoadedStyleName(e) {
            this._loadedStyleNames.delete(e)
        },
        clearLoadedStyleNames() {
            this._loadedStyleNames.clear()
        },
        getTokenValue(e) {
            return hI.getTokenValue(this.tokens, e, this.defaults)
        },
        getCommon(e="", t) {
            return hI.getCommon({
                name: e,
                theme: this.theme,
                params: t,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            })
        },
        getComponent(e="", t) {
            let n = {
                name: e,
                theme: this.theme,
                params: t,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            };
            return hI.getPresetC(n)
        },
        getDirective(e="", t) {
            let n = {
                name: e,
                theme: this.theme,
                params: t,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            };
            return hI.getPresetD(n)
        },
        getCustomPreset(e="", t, n, r) {
            let o = {
                name: e,
                preset: t,
                options: this.options,
                selector: n,
                params: r,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            };
            return hI.getPreset(o)
        },
        getLayerOrderCSS(e="") {
            return hI.getLayerOrder(e, this.options, {
                names: this.getLayerNames()
            }, this.defaults)
        },
        transformCSS(e="", t, n="style", r) {
            return hI.transformCSS(e, t, r, n, this.options, {
                layerNames: this.setLayerNames.bind(this)
            }, this.defaults)
        },
        getCommonStyleSheet(e="", t, n={}) {
            return hI.getCommonStyleSheet({
                name: e,
                theme: this.theme,
                params: t,
                props: n,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            })
        },
        getStyleSheet(e, t, n={}) {
            return hI.getStyleSheet({
                name: e,
                theme: this.theme,
                params: t,
                props: n,
                defaults: this.defaults,
                set: {
                    layerNames: this.setLayerNames.bind(this)
                }
            })
        },
        onStyleMounted(e) {
            this._loadingStyles.add(e)
        },
        onStyleUpdated(e) {
            this._loadingStyles.add(e)
        },
        onStyleLoaded(e, {name: t}) {
            this._loadingStyles.size && (this._loadingStyles.delete(t), YS.emit(`theme:${t}:load`, e), !this._loadingStyles.size && YS.emit("theme:load"))
        }
    },
    gI = {
        _loadedStyleNames: new Set,
        getLoadedStyleNames: function() {
            return this._loadedStyleNames
        },
        isStyleNameLoaded: function(e) {
            return this._loadedStyleNames.has(e)
        },
        setLoadedStyleName: function(e) {
            this._loadedStyleNames.add(e)
        },
        deleteLoadedStyleName: function(e) {
            this._loadedStyleNames.delete(e)
        },
        clearLoadedStyleNames: function() {
            this._loadedStyleNames.clear()
        }
    };
function mI(e) {
    return (mI = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function bI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function AI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? bI(Object(n), !0).forEach(function(t) {
            yI(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bI(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function yI(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != mI(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != mI(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == mI(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var vI,
    _I,
    xI,
    wI,
    CI = 0;
function EI(e) {
    return (EI = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function SI(e, t) {
    return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r,
                    o,
                    i,
                    a,
                    s = [],
                    l = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t)
                        ;
                    else
                        for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                            ;
                } catch (u) {
                    c = !0,
                    o = u
                } finally {
                    try {
                        if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                            return
                    } finally {
                        if (c)
                            throw o
                    }
                }
                return s
            }
        }(e, t) || function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return II(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? II(e, t) : void 0
            }
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function II(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function TI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function MI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? TI(Object(n), !0).forEach(function(t) {
            RI(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TI(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function RI(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != EI(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != EI(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == EI(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
function BI(e, t) {
    return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
        raw: {
            value: Object.freeze(t)
        }
    }))
}
var kI = {
        name: "base",
        css: function(e) {
            var t = e.dt;
            return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    opacity: 0;\n    overflow: hidden;\n    padding: 0;\n    pointer-events: none;\n    position: absolute;\n    white-space: nowrap;\n    width: 1px;\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(t("scrollbar.width"), ";\n}\n")
        },
        style: "\n    *,\n    ::before,\n    ::after {\n        box-sizing: border-box;\n    }\n\n    /* Non vue overlay animations */\n    .p-connected-overlay {\n        opacity: 0;\n        transform: scaleY(0.8);\n        transition:\n            transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n            opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n    }\n\n    .p-connected-overlay-visible {\n        opacity: 1;\n        transform: scaleY(1);\n    }\n\n    .p-connected-overlay-hidden {\n        opacity: 0;\n        transform: scaleY(1);\n        transition: opacity 0.1s linear;\n    }\n\n    /* Vue based overlay animations */\n    .p-connected-overlay-enter-from {\n        opacity: 0;\n        transform: scaleY(0.8);\n    }\n\n    .p-connected-overlay-leave-to {\n        opacity: 0;\n    }\n\n    .p-connected-overlay-enter-active {\n        transition:\n            transform 0.12s cubic-bezier(0, 0, 0.2, 1),\n            opacity 0.12s cubic-bezier(0, 0, 0.2, 1);\n    }\n\n    .p-connected-overlay-leave-active {\n        transition: opacity 0.1s linear;\n    }\n\n    /* Toggleable Content */\n    .p-toggleable-content-enter-from,\n    .p-toggleable-content-leave-to {\n        max-height: 0;\n    }\n\n    .p-toggleable-content-enter-to,\n    .p-toggleable-content-leave-from {\n        max-height: 1000px;\n    }\n\n    .p-toggleable-content-leave-active {\n        overflow: hidden;\n        transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);\n    }\n\n    .p-toggleable-content-enter-active {\n        overflow: hidden;\n        transition: max-height 1s ease-in-out;\n    }\n\n    .p-disabled,\n    .p-disabled * {\n        cursor: default;\n        pointer-events: none;\n        user-select: none;\n    }\n\n    .p-disabled,\n    .p-component:disabled {\n        opacity: dt('disabled.opacity');\n    }\n\n    .pi {\n        font-size: dt('icon.size');\n    }\n\n    .p-icon {\n        width: dt('icon.size');\n        height: dt('icon.size');\n    }\n\n    .p-overlay-mask {\n        background: dt('mask.background');\n        color: dt('mask.color');\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    .p-overlay-mask-enter {\n        animation: p-overlay-mask-enter-animation dt('mask.transition.duration') forwards;\n    }\n\n    .p-overlay-mask-leave {\n        animation: p-overlay-mask-leave-animation dt('mask.transition.duration') forwards;\n    }\n\n    @keyframes p-overlay-mask-enter-animation {\n        from {\n            background: transparent;\n        }\n        to {\n            background: dt('mask.background');\n        }\n    }\n    @keyframes p-overlay-mask-leave-animation {\n        from {\n            background: dt('mask.background');\n        }\n        to {\n            background: transparent;\n        }\n    }\n",
        classes: {},
        inlineStyles: {},
        load: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(e) {
                    return e
                })(pI(vI || (vI = BI(["", ""])), e));
            return sS(n) ? function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = ft(!1),
                    r = ft(e),
                    o = ft(null),
                    i = WE() ? window.document : void 0,
                    a = t.document,
                    s = void 0 === a ? i : a,
                    l = t.immediate,
                    c = void 0 === l || l,
                    u = t.manual,
                    d = void 0 !== u && u,
                    p = t.name,
                    h = void 0 === p ? "style_".concat(++CI) : p,
                    f = t.id,
                    g = void 0 === f ? void 0 : f,
                    m = t.media,
                    b = void 0 === m ? void 0 : m,
                    A = t.nonce,
                    y = void 0 === A ? void 0 : A,
                    v = t.first,
                    _ = void 0 !== v && v,
                    x = t.onMounted,
                    w = void 0 === x ? void 0 : x,
                    C = t.onUpdated,
                    E = void 0 === C ? void 0 : C,
                    S = t.onLoad,
                    I = void 0 === S ? void 0 : S,
                    T = t.props,
                    M = void 0 === T ? {} : T,
                    R = function() {},
                    B = function(t) {
                        var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (s) {
                            var a = AI(AI({}, M), i),
                                l = a.name || h,
                                c = a.id || g,
                                u = a.nonce || y;
                            o.value = s.querySelector('style[data-primevue-style-id="'.concat(l, '"]')) || s.getElementById(c) || s.createElement("style"),
                            o.value.isConnected || (r.value = t || e, SE(o.value, {
                                type: "text/css",
                                id: c,
                                media: b,
                                nonce: u
                            }), _ ? s.head.prepend(o.value) : s.head.appendChild(o.value), YE(o.value, "data-primevue-style-id", l), SE(o.value, a), o.value.onload = function(e) {
                                return null == I ? void 0 : I(e, {
                                    name: l
                                })
                            }, null == w || w(l)),
                            n.value || (R = Vr(r, function(e) {
                                o.value.textContent = e,
                                null == E || E(l)
                            }, {
                                immediate: !0
                            }), n.value = !0)
                        }
                    };
                return c && !d && function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    Po() && Po().components ? Dn(e) : t ? e() : Pt(e)
                }(B), {
                    id: g,
                    name: h,
                    el: o,
                    css: r,
                    unload: function() {
                        s && n.value && (R(), wE(o.value) && s.head.removeChild(o.value), n.value = !1, o.value = null)
                    },
                    load: B,
                    isLoaded: ot(n)
                }
            }(xS(n), MI({
                name: this.name
            }, t)) : {}
        },
        loadCSS: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return this.load(this.css, e)
        },
        loadStyle: function() {
            var e = this,
                t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            return this.load(this.style, t, function() {
                var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                return fI.transformCSS(t.name || e.name, "".concat(r).concat(pI(_I || (_I = BI(["", ""])), n)))
            })
        },
        getCommonTheme: function(e) {
            return fI.getCommon(this.name, e)
        },
        getComponentTheme: function(e) {
            return fI.getComponent(this.name, e)
        },
        getDirectiveTheme: function(e) {
            return fI.getDirective(this.name, e)
        },
        getPresetTheme: function(e, t, n) {
            return fI.getCustomPreset(this.name, e, t, n)
        },
        getLayerOrderThemeCSS: function() {
            return fI.getLayerOrderCSS(this.name)
        },
        getStyleSheet: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (this.css) {
                var n = gS(this.css, {
                        dt: uI
                    }) || "",
                    r = xS(pI(xI || (xI = BI(["", "", ""])), n, e)),
                    o = Object.entries(t).reduce(function(e, t) {
                        var n = SI(t, 2),
                            r = n[0],
                            o = n[1];
                        return e.push("".concat(r, '="').concat(o, '"')) && e
                    }, []).join(" ");
                return sS(r) ? '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(o, ">").concat(r, "</style>") : ""
            }
            return ""
        },
        getCommonThemeStyleSheet: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return fI.getCommonStyleSheet(this.name, e, t)
        },
        getThemeStyleSheet: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = [fI.getStyleSheet(this.name, e, t)];
            if (this.style) {
                var r = "base" === this.name ? "global-style" : "".concat(this.name, "-style"),
                    o = pI(wI || (wI = BI(["", ""])), gS(this.style, {
                        dt: uI
                    })),
                    i = xS(fI.transformCSS(r, o)),
                    a = Object.entries(t).reduce(function(e, t) {
                        var n = SI(t, 2),
                            r = n[0],
                            o = n[1];
                        return e.push("".concat(r, '="').concat(o, '"')) && e
                    }, []).join(" ");
                sS(i) && n.push('<style type="text/css" data-primevue-style-id="'.concat(r, '" ').concat(a, ">").concat(i, "</style>"))
            }
            return n.join("")
        },
        extend: function(e) {
            return MI(MI({}, this), {}, {
                css: void 0,
                style: void 0
            }, e)
        }
    },
    DI = BS();
function PI(e) {
    return (PI = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function OI(e, t) {
    return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r,
                    o,
                    i,
                    a,
                    s = [],
                    l = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t)
                        ;
                    else
                        for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                            ;
                } catch (u) {
                    c = !0,
                    o = u
                } finally {
                    try {
                        if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                            return
                    } finally {
                        if (c)
                            throw o
                    }
                }
                return s
            }
        }(e, t) || function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return LI(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? LI(e, t) : void 0
            }
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function LI(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function NI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function FI(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? NI(Object(n), !0).forEach(function(t) {
            UI(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NI(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function UI(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != PI(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != PI(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == PI(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var zI = {
        _getMeta: function() {
            return [uS(arguments.length <= 0 ? void 0 : arguments[0]) || arguments.length <= 0 ? void 0 : arguments[0], gS(uS(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])]
        },
        _getConfig: function(e, t) {
            var n,
                r,
                o;
            return null === (n = (null == e || null === (r = e.instance) || void 0 === r ? void 0 : r.$primevue) || (null == t || null === (o = t.ctx) || void 0 === o || null === (o = o.appContext) || void 0 === o || null === (o = o.config) || void 0 === o || null === (o = o.globalProperties) || void 0 === o ? void 0 : o.$primevue)) || void 0 === n ? void 0 : n.config
        },
        _getOptionValue: AS,
        _getPTValue: function() {
            var e,
                t,
                n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                s = function() {
                    var e = zI._getOptionValue.apply(zI, arguments);
                    return mS(e) || yS(e) ? {
                        class: e
                    } : e
                },
                l = (null === (e = n.binding) || void 0 === e || null === (e = e.value) || void 0 === e ? void 0 : e.ptOptions) || (null === (t = n.$primevueConfig) || void 0 === t ? void 0 : t.ptOptions) || {},
                c = l.mergeSections,
                u = void 0 === c || c,
                d = l.mergeProps,
                p = void 0 !== d && d,
                h = a ? zI._useDefaultPT(n, n.defaultPT(), s, o, i) : void 0,
                f = zI._usePT(n, zI._getPT(r, n.$name), s, o, FI(FI({}, i), {}, {
                    global: h || {}
                })),
                g = zI._getPTDatasets(n, o);
            return u || !u && f ? p ? zI._mergeProps(n, p, h, f, g) : FI(FI(FI({}, h), f), g) : FI(FI({}, f), g)
        },
        _getPTDatasets: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                n = "data-pc-";
            return FI(FI({}, "root" === t && UI({}, "".concat(n, "name"), bS(e.$name))), {}, UI({}, "".concat(n, "section"), bS(t)))
        },
        _getPT: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = function(e) {
                    var r,
                        o = n ? n(e) : e,
                        i = bS(t);
                    return null !== (r = null == o ? void 0 : o[i]) && void 0 !== r ? r : o
                };
            return e && Object.hasOwn(e, "_usept") ? {
                _usept: e._usept,
                originalValue: r(e.originalValue),
                value: r(e.value)
            } : r(e)
        },
        _usePT: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                t = arguments.length > 1 ? arguments[1] : void 0,
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0,
                o = arguments.length > 4 ? arguments[4] : void 0,
                i = function(e) {
                    return n(e, r, o)
                };
            if (t && Object.hasOwn(t, "_usept")) {
                var a,
                    s = t._usept || (null === (a = e.$primevueConfig) || void 0 === a ? void 0 : a.ptOptions) || {},
                    l = s.mergeSections,
                    c = void 0 === l || l,
                    u = s.mergeProps,
                    d = void 0 !== u && u,
                    p = i(t.originalValue),
                    h = i(t.value);
                if (void 0 === p && void 0 === h)
                    return;
                return mS(h) ? h : mS(p) ? p : c || !c && h ? d ? zI._mergeProps(e, d, p, h) : FI(FI({}, p), h) : h
            }
            return i(t)
        },
        _useDefaultPT: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0,
                o = arguments.length > 4 ? arguments[4] : void 0;
            return zI._usePT(e, t, n, r, o)
        },
        _loadStyles: function() {
            var e,
                t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                n = arguments.length > 1 ? arguments[1] : void 0,
                r = arguments.length > 2 ? arguments[2] : void 0,
                o = zI._getConfig(n, r),
                i = {
                    nonce: null == o || null === (e = o.csp) || void 0 === e ? void 0 : e.nonce
                };
            zI._loadCoreStyles(t, i),
            zI._loadThemeStyles(t, i),
            zI._loadScopedThemeStyles(t, i),
            zI._removeThemeListeners(t),
            t.$loadStyles = function() {
                return zI._loadThemeStyles(t, i)
            },
            zI._themeChangeListener(t.$loadStyles)
        },
        _loadCoreStyles: function() {
            var e,
                t,
                n,
                r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                o = arguments.length > 1 ? arguments[1] : void 0;
            !gI.isStyleNameLoaded(null === (e = r.$style) || void 0 === e ? void 0 : e.name) && null !== (t = r.$style) && void 0 !== t && t.name && (kI.loadCSS(o), null === (n = r.$style) || void 0 === n || n.loadCSS(o), gI.setLoadedStyleName(r.$style.name))
        },
        _loadThemeStyles: function() {
            var e,
                t,
                n,
                r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                o = arguments.length > 1 ? arguments[1] : void 0;
            if (!(null != r && r.isUnstyled() || "none" === (null == r || null === (e = r.theme) || void 0 === e ? void 0 : e.call(r)))) {
                if (!fI.isStyleNameLoaded("common")) {
                    var i,
                        a,
                        s = (null === (i = r.$style) || void 0 === i || null === (a = i.getCommonTheme) || void 0 === a ? void 0 : a.call(i)) || {},
                        l = s.primitive,
                        c = s.semantic,
                        u = s.global,
                        d = s.style;
                    kI.load(null == l ? void 0 : l.css, FI({
                        name: "primitive-variables"
                    }, o)),
                    kI.load(null == c ? void 0 : c.css, FI({
                        name: "semantic-variables"
                    }, o)),
                    kI.load(null == u ? void 0 : u.css, FI({
                        name: "global-variables"
                    }, o)),
                    kI.loadStyle(FI({
                        name: "global-style"
                    }, o), d),
                    fI.setLoadedStyleName("common")
                }
                if (!fI.isStyleNameLoaded(null === (t = r.$style) || void 0 === t ? void 0 : t.name) && null !== (n = r.$style) && void 0 !== n && n.name) {
                    var p,
                        h,
                        f,
                        g,
                        m = (null === (p = r.$style) || void 0 === p || null === (h = p.getDirectiveTheme) || void 0 === h ? void 0 : h.call(p)) || {},
                        b = m.css,
                        A = m.style;
                    null === (f = r.$style) || void 0 === f || f.load(b, FI({
                        name: "".concat(r.$style.name, "-variables")
                    }, o)),
                    null === (g = r.$style) || void 0 === g || g.loadStyle(FI({
                        name: "".concat(r.$style.name, "-style")
                    }, o), A),
                    fI.setLoadedStyleName(r.$style.name)
                }
                if (!fI.isStyleNameLoaded("layer-order")) {
                    var y,
                        v,
                        _ = null === (y = r.$style) || void 0 === y || null === (v = y.getLayerOrderThemeCSS) || void 0 === v ? void 0 : v.call(y);
                    kI.load(_, FI({
                        name: "layer-order",
                        first: !0
                    }, o)),
                    fI.setLoadedStyleName("layer-order")
                }
            }
        },
        _loadScopedThemeStyles: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                t = arguments.length > 1 ? arguments[1] : void 0,
                n = e.preset();
            if (n && e.$attrSelector) {
                var r,
                    o,
                    i,
                    a = ((null === (r = e.$style) || void 0 === r || null === (o = r.getPresetTheme) || void 0 === o ? void 0 : o.call(r, n, "[".concat(e.$attrSelector, "]"))) || {}).css,
                    s = null === (i = e.$style) || void 0 === i ? void 0 : i.load(a, FI({
                        name: "".concat(e.$attrSelector, "-").concat(e.$style.name)
                    }, t));
                e.scopedStyleEl = s.el
            }
        },
        _themeChangeListener: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function() {};
            gI.clearLoadedStyleNames(),
            YS.on("theme:change", e)
        },
        _removeThemeListeners: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            YS.off("theme:change", e.$loadStyles),
            e.$loadStyles = void 0
        },
        _hook: function(e, t, n, r, o, i) {
            var a,
                s,
                l,
                c = "on".concat(mS(l = t, !1) ? l[0].toUpperCase() + l.slice(1) : l),
                u = zI._getConfig(r, o),
                d = null == n ? void 0 : n.$instance,
                p = zI._usePT(d, zI._getPT(null == r || null === (a = r.value) || void 0 === a ? void 0 : a.pt, e), zI._getOptionValue, "hooks.".concat(c)),
                h = zI._useDefaultPT(d, null == u || null === (s = u.pt) || void 0 === s || null === (s = s.directives) || void 0 === s ? void 0 : s[e], zI._getOptionValue, "hooks.".concat(c)),
                f = {
                    el: n,
                    binding: r,
                    vnode: o,
                    prevVnode: i
                };
            null == p || p(d, f),
            null == h || h(d, f)
        },
        _mergeProps: function() {
            for (var e = arguments.length > 1 ? arguments[1] : void 0, t = arguments.length, n = new Array(t > 2 ? t - 2 : 0), r = 2; r < t; r++)
                n[r - 2] = arguments[r];
            return aS(e) ? e.apply(void 0, n) : Mo.apply(void 0, n)
        },
        _extend: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = function(n, r, o, i, a) {
                    var s,
                        l,
                        c,
                        u;
                    r._$instances = r._$instances || {};
                    var d = zI._getConfig(o, i),
                        p = r._$instances[e] || {},
                        h = rS(p) ? FI(FI({}, t), null == t ? void 0 : t.methods) : {};
                    r._$instances[e] = FI(FI({}, p), {}, {
                        $name: e,
                        $host: r,
                        $binding: o,
                        $modifiers: null == o ? void 0 : o.modifiers,
                        $value: null == o ? void 0 : o.value,
                        $el: p.$el || r || void 0,
                        $style: FI({
                            classes: void 0,
                            inlineStyles: void 0,
                            load: function() {},
                            loadCSS: function() {},
                            loadStyle: function() {}
                        }, null == t ? void 0 : t.style),
                        $primevueConfig: d,
                        $attrSelector: null === (s = r.$pd) || void 0 === s || null === (s = s[e]) || void 0 === s ? void 0 : s.attrSelector,
                        defaultPT: function() {
                            return zI._getPT(null == d ? void 0 : d.pt, void 0, function(t) {
                                var n;
                                return null == t || null === (n = t.directives) || void 0 === n ? void 0 : n[e]
                            })
                        },
                        isUnstyled: function() {
                            var t,
                                n;
                            return void 0 !== (null === (t = r._$instances[e]) || void 0 === t || null === (t = t.$binding) || void 0 === t || null === (t = t.value) || void 0 === t ? void 0 : t.unstyled) ? null === (n = r._$instances[e]) || void 0 === n || null === (n = n.$binding) || void 0 === n || null === (n = n.value) || void 0 === n ? void 0 : n.unstyled : null == d ? void 0 : d.unstyled
                        },
                        theme: function() {
                            var t;
                            return null === (t = r._$instances[e]) || void 0 === t || null === (t = t.$primevueConfig) || void 0 === t ? void 0 : t.theme
                        },
                        preset: function() {
                            var t;
                            return null === (t = r._$instances[e]) || void 0 === t || null === (t = t.$binding) || void 0 === t || null === (t = t.value) || void 0 === t ? void 0 : t.dt
                        },
                        ptm: function() {
                            var t,
                                n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                                o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return zI._getPTValue(r._$instances[e], null === (t = r._$instances[e]) || void 0 === t || null === (t = t.$binding) || void 0 === t || null === (t = t.value) || void 0 === t ? void 0 : t.pt, n, FI({}, o))
                        },
                        ptmo: function() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                                o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                            return zI._getPTValue(r._$instances[e], t, n, o, !1)
                        },
                        cx: function() {
                            var t,
                                n,
                                o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                                i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return null !== (t = r._$instances[e]) && void 0 !== t && t.isUnstyled() ? void 0 : zI._getOptionValue(null === (n = r._$instances[e]) || void 0 === n || null === (n = n.$style) || void 0 === n ? void 0 : n.classes, o, FI({}, i))
                        },
                        sx: function() {
                            var t,
                                n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                                o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                            return arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? void 0 : zI._getOptionValue(null === (t = r._$instances[e]) || void 0 === t || null === (t = t.$style) || void 0 === t ? void 0 : t.inlineStyles, n, FI({}, o))
                        }
                    }, h),
                    r.$instance = r._$instances[e],
                    null === (l = (c = r.$instance)[n]) || void 0 === l || l.call(c, r, o, i, a),
                    r["$".concat(e)] = r.$instance,
                    zI._hook(e, n, r, o, i, a),
                    r.$pd || (r.$pd = {}),
                    r.$pd[e] = FI(FI({}, null === (u = r.$pd) || void 0 === u ? void 0 : u[e]), {}, {
                        name: e,
                        instance: r._$instances[e]
                    })
                };
            return {
                created: function(t, r, o, i) {
                    t.$pd || (t.$pd = {}),
                    t.$pd[e] = {
                        name: e,
                        attrSelector: TS("pd")
                    },
                    n("created", t, r, o, i)
                },
                beforeMount: function(t, r, o, i) {
                    var a;
                    zI._loadStyles(null === (a = t.$pd[e]) || void 0 === a ? void 0 : a.instance, r, o),
                    n("beforeMount", t, r, o, i),
                    function(t) {
                        var n,
                            r,
                            o,
                            i = t._$instances[e],
                            a = null == i ? void 0 : i.watch,
                            s = function(e) {
                                var t,
                                    n = e.newValue,
                                    r = e.oldValue;
                                return null == a || null === (t = a.config) || void 0 === t ? void 0 : t.call(i, n, r)
                            },
                            l = function(e) {
                                var t,
                                    n = e.newValue,
                                    r = e.oldValue;
                                return null == a || null === (t = a["config.ripple"]) || void 0 === t ? void 0 : t.call(i, n, r)
                            };
                        i.$watchersCallback = {
                            config: s,
                            "config.ripple": l
                        },
                        null == a || null === (n = a.config) || void 0 === n || n.call(i, null == i ? void 0 : i.$primevueConfig),
                        DI.on("config:change", s),
                        null == a || null === (r = a["config.ripple"]) || void 0 === r || r.call(i, null == i || null === (o = i.$primevueConfig) || void 0 === o ? void 0 : o.ripple),
                        DI.on("config:ripple:change", l)
                    }(t)
                },
                mounted: function(t, r, o, i) {
                    var a;
                    zI._loadStyles(null === (a = t.$pd[e]) || void 0 === a ? void 0 : a.instance, r, o),
                    n("mounted", t, r, o, i)
                },
                beforeUpdate: function(e, t, r, o) {
                    n("beforeUpdate", e, t, r, o)
                },
                updated: function(t, r, o, i) {
                    var a;
                    zI._loadStyles(null === (a = t.$pd[e]) || void 0 === a ? void 0 : a.instance, r, o),
                    n("updated", t, r, o, i)
                },
                beforeUnmount: function(t, r, o, i) {
                    var a;
                    !function(t) {
                        var n = t._$instances[e].$watchersCallback;
                        n && (DI.off("config:change", n.config), DI.off("config:ripple:change", n["config.ripple"]), t._$instances[e].$watchersCallback = void 0)
                    }(t),
                    zI._removeThemeListeners(null === (a = t.$pd[e]) || void 0 === a ? void 0 : a.instance),
                    n("beforeUnmount", t, r, o, i)
                },
                unmounted: function(t, r, o, i) {
                    var a;
                    null === (a = t.$pd[e]) || void 0 === a || null === (a = a.instance) || void 0 === a || null === (a = a.scopedStyleEl) || void 0 === a || null === (a = a.value) || void 0 === a || a.remove(),
                    n("unmounted", t, r, o, i)
                }
            }
        },
        extend: function() {
            var e = OI(zI._getMeta.apply(zI, arguments), 2),
                t = e[0],
                n = e[1];
            return FI({
                extend: function() {
                    var e = OI(zI._getMeta.apply(zI, arguments), 2),
                        t = e[0],
                        r = e[1];
                    return zI.extend(t, FI(FI(FI({}, n), null == n ? void 0 : n.methods), r))
                }
            }, zI._extend(t, n))
        }
    },
    QI = kI.extend({
        name: "tooltip-directive",
        style: "\n    .p-tooltip {\n        position: absolute;\n        display: none;\n        max-width: dt('tooltip.max.width');\n    }\n\n    .p-tooltip-right,\n    .p-tooltip-left {\n        padding: 0 dt('tooltip.gutter');\n    }\n\n    .p-tooltip-top,\n    .p-tooltip-bottom {\n        padding: dt('tooltip.gutter') 0;\n    }\n\n    .p-tooltip-text {\n        white-space: pre-line;\n        word-break: break-word;\n        background: dt('tooltip.background');\n        color: dt('tooltip.color');\n        padding: dt('tooltip.padding');\n        box-shadow: dt('tooltip.shadow');\n        border-radius: dt('tooltip.border.radius');\n    }\n\n    .p-tooltip-arrow {\n        position: absolute;\n        width: 0;\n        height: 0;\n        border-color: transparent;\n        border-style: solid;\n    }\n\n    .p-tooltip-right .p-tooltip-arrow {\n        margin-top: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter') 0;\n        border-right-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-left .p-tooltip-arrow {\n        margin-top: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') 0 dt('tooltip.gutter') dt('tooltip.gutter');\n        border-left-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-top .p-tooltip-arrow {\n        margin-left: calc(-1 * dt('tooltip.gutter'));\n        border-width: dt('tooltip.gutter') dt('tooltip.gutter') 0 dt('tooltip.gutter');\n        border-top-color: dt('tooltip.background');\n        border-bottom-color: dt('tooltip.background');\n    }\n\n    .p-tooltip-bottom .p-tooltip-arrow {\n        margin-left: calc(-1 * dt('tooltip.gutter'));\n        border-width: 0 dt('tooltip.gutter') dt('tooltip.gutter') dt('tooltip.gutter');\n        border-top-color: dt('tooltip.background');\n        border-bottom-color: dt('tooltip.background');\n    }\n",
        classes: {
            root: "p-tooltip p-component",
            arrow: "p-tooltip-arrow",
            text: "p-tooltip-text"
        }
    });
function GI(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function jI(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != VI(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != VI(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == VI(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
function VI(e) {
    return (VI = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
var HI = zI.extend({
    style: QI
}).extend("tooltip", {
    beforeMount: function(e, t) {
        var n,
            r = this.getTarget(e);
        if (r.$_ptooltipModifiers = this.getModifiers(t), t.value) {
            if ("string" == typeof t.value)
                r.$_ptooltipValue = t.value,
                r.$_ptooltipDisabled = !1,
                r.$_ptooltipEscape = !0,
                r.$_ptooltipClass = null,
                r.$_ptooltipFitContent = !0,
                r.$_ptooltipIdAttr = TS("pv_id") + "_tooltip",
                r.$_ptooltipShowDelay = 0,
                r.$_ptooltipHideDelay = 0,
                r.$_ptooltipAutoHide = !0;
            else if ("object" === VI(t.value) && t.value) {
                if (rS(t.value.value) || "" === t.value.value.trim())
                    return;
                r.$_ptooltipValue = t.value.value,
                r.$_ptooltipDisabled = !!t.value.disabled === t.value.disabled && t.value.disabled,
                r.$_ptooltipEscape = !!t.value.escape !== t.value.escape || t.value.escape,
                r.$_ptooltipClass = t.value.class || "",
                r.$_ptooltipFitContent = !!t.value.fitContent !== t.value.fitContent || t.value.fitContent,
                r.$_ptooltipIdAttr = t.value.id || TS("pv_id") + "_tooltip",
                r.$_ptooltipShowDelay = t.value.showDelay || 0,
                r.$_ptooltipHideDelay = t.value.hideDelay || 0,
                r.$_ptooltipAutoHide = !!t.value.autoHide !== t.value.autoHide || t.value.autoHide
            }
            r.$_ptooltipZIndex = null === (n = t.instance.$primevue) || void 0 === n || null === (n = n.config) || void 0 === n || null === (n = n.zIndex) || void 0 === n ? void 0 : n.tooltip,
            this.bindEvents(r, t),
            e.setAttribute("data-pd-tooltip", !0)
        }
    },
    updated: function(e, t) {
        var n = this.getTarget(e);
        if (n.$_ptooltipModifiers = this.getModifiers(t), this.unbindEvents(n), t.value)
            if ("string" == typeof t.value)
                n.$_ptooltipValue = t.value,
                n.$_ptooltipDisabled = !1,
                n.$_ptooltipEscape = !0,
                n.$_ptooltipClass = null,
                n.$_ptooltipIdAttr = n.$_ptooltipIdAttr || TS("pv_id") + "_tooltip",
                n.$_ptooltipShowDelay = 0,
                n.$_ptooltipHideDelay = 0,
                n.$_ptooltipAutoHide = !0,
                this.bindEvents(n, t);
            else if ("object" === VI(t.value) && t.value) {
                if (rS(t.value.value) || "" === t.value.value.trim())
                    return void this.unbindEvents(n, t);
                n.$_ptooltipValue = t.value.value,
                n.$_ptooltipDisabled = !!t.value.disabled === t.value.disabled && t.value.disabled,
                n.$_ptooltipEscape = !!t.value.escape !== t.value.escape || t.value.escape,
                n.$_ptooltipClass = t.value.class || "",
                n.$_ptooltipFitContent = !!t.value.fitContent !== t.value.fitContent || t.value.fitContent,
                n.$_ptooltipIdAttr = t.value.id || n.$_ptooltipIdAttr || TS("pv_id") + "_tooltip",
                n.$_ptooltipShowDelay = t.value.showDelay || 0,
                n.$_ptooltipHideDelay = t.value.hideDelay || 0,
                n.$_ptooltipAutoHide = !!t.value.autoHide !== t.value.autoHide || t.value.autoHide,
                this.bindEvents(n, t)
            }
    },
    unmounted: function(e, t) {
        var n = this.getTarget(e);
        this.hide(e, 0),
        this.remove(n),
        this.unbindEvents(n, t),
        n.$_ptooltipScrollHandler && (n.$_ptooltipScrollHandler.destroy(), n.$_ptooltipScrollHandler = null)
    },
    timer: void 0,
    methods: {
        bindEvents: function(e, t) {
            var n = this;
            e.$_ptooltipModifiers.focus ? (e.$_ptooltipFocusEvent = function(e) {
                return n.onFocus(e, t)
            }, e.$_ptooltipBlurEvent = this.onBlur.bind(this), e.addEventListener("focus", e.$_ptooltipFocusEvent), e.addEventListener("blur", e.$_ptooltipBlurEvent)) : (e.$_ptooltipMouseEnterEvent = function(e) {
                return n.onMouseEnter(e, t)
            }, e.$_ptooltipMouseLeaveEvent = this.onMouseLeave.bind(this), e.$_ptooltipClickEvent = this.onClick.bind(this), e.addEventListener("mouseenter", e.$_ptooltipMouseEnterEvent), e.addEventListener("mouseleave", e.$_ptooltipMouseLeaveEvent), e.addEventListener("click", e.$_ptooltipClickEvent)),
            e.$_ptooltipKeydownEvent = this.onKeydown.bind(this),
            e.addEventListener("keydown", e.$_ptooltipKeydownEvent),
            e.$_pWindowResizeEvent = this.onWindowResize.bind(this, e)
        },
        unbindEvents: function(e) {
            e.$_ptooltipModifiers.focus ? (e.removeEventListener("focus", e.$_ptooltipFocusEvent), e.$_ptooltipFocusEvent = null, e.removeEventListener("blur", e.$_ptooltipBlurEvent), e.$_ptooltipBlurEvent = null) : (e.removeEventListener("mouseenter", e.$_ptooltipMouseEnterEvent), e.$_ptooltipMouseEnterEvent = null, e.removeEventListener("mouseleave", e.$_ptooltipMouseLeaveEvent), e.$_ptooltipMouseLeaveEvent = null, e.removeEventListener("click", e.$_ptooltipClickEvent), e.$_ptooltipClickEvent = null),
            e.removeEventListener("keydown", e.$_ptooltipKeydownEvent),
            window.removeEventListener("resize", e.$_pWindowResizeEvent),
            e.$_ptooltipId && this.remove(e)
        },
        bindScrollListener: function(e) {
            var t = this;
            e.$_ptooltipScrollHandler || (e.$_ptooltipScrollHandler = new PS(e, function() {
                t.hide(e)
            })),
            e.$_ptooltipScrollHandler.bindScrollListener()
        },
        unbindScrollListener: function(e) {
            e.$_ptooltipScrollHandler && e.$_ptooltipScrollHandler.unbindScrollListener()
        },
        onMouseEnter: function(e, t) {
            var n = e.currentTarget,
                r = n.$_ptooltipShowDelay;
            this.show(n, t, r)
        },
        onMouseLeave: function(e) {
            var t = e.currentTarget,
                n = t.$_ptooltipHideDelay;
            (t.$_ptooltipAutoHide || "tooltip" !== BE(e.target, "data-pc-name") && "arrow" !== BE(e.target, "data-pc-section") && "text" !== BE(e.target, "data-pc-section") && "tooltip" !== BE(e.relatedTarget, "data-pc-name") && "arrow" !== BE(e.relatedTarget, "data-pc-section") && "text" !== BE(e.relatedTarget, "data-pc-section")) && this.hide(t, n)
        },
        onFocus: function(e, t) {
            var n = e.currentTarget,
                r = n.$_ptooltipShowDelay;
            this.show(n, t, r)
        },
        onBlur: function(e) {
            var t = e.currentTarget,
                n = t.$_ptooltipHideDelay;
            this.hide(t, n)
        },
        onClick: function(e) {
            var t = e.currentTarget,
                n = t.$_ptooltipHideDelay;
            this.hide(t, n)
        },
        onKeydown: function(e) {
            var t = e.currentTarget.$_ptooltipHideDelay;
            "Escape" === e.code && this.hide(e.currentTarget, t)
        },
        onWindowResize: function(e) {
            XE() || this.hide(e),
            window.removeEventListener("resize", e.$_pWindowResizeEvent)
        },
        tooltipActions: function(e, t) {
            if (!e.$_ptooltipDisabled && wE(e) && e.$_ptooltipPendingShow) {
                e.$_ptooltipPendingShow = !1;
                var n = this.create(e, t);
                this.align(e),
                !this.isUnstyled() && function(e) {
                    if (e) {
                        e.style.opacity = "0";
                        let t = +new Date,
                            n = "0",
                            r = function() {
                                n = "" + (+e.style.opacity + ((new Date).getTime() - t) / 250),
                                e.style.opacity = n,
                                t = +new Date,
                                +n < 1 && ("requestAnimationFrame" in window ? requestAnimationFrame(r) : setTimeout(r, 16))
                            };
                        r()
                    }
                }(n);
                var r = this;
                window.addEventListener("resize", e.$_pWindowResizeEvent),
                n.addEventListener("mouseleave", function t() {
                    r.hide(e),
                    n.removeEventListener("mouseleave", t),
                    e.removeEventListener("mouseenter", e.$_ptooltipMouseEnterEvent),
                    setTimeout(function() {
                        return e.addEventListener("mouseenter", e.$_ptooltipMouseEnterEvent)
                    }, 50)
                }),
                this.bindScrollListener(e),
                MS.set("tooltip", n, e.$_ptooltipZIndex)
            }
        },
        show: function(e, t, n) {
            var r = this;
            void 0 !== n ? (this.timer = setTimeout(function() {
                return r.tooltipActions(e, t)
            }, n), e.$_ptooltipPendingShow = !0) : (this.tooltipActions(e, t), e.$_ptooltipPendingShow = !1)
        },
        tooltipRemoval: function(e) {
            this.remove(e),
            this.unbindScrollListener(e),
            window.removeEventListener("resize", e.$_pWindowResizeEvent)
        },
        hide: function(e, t) {
            var n = this;
            clearTimeout(this.timer),
            e.$_ptooltipPendingShow = !1,
            void 0 !== t ? setTimeout(function() {
                return n.tooltipRemoval(e)
            }, t) : this.tooltipRemoval(e)
        },
        getTooltipElement: function(e) {
            return document.getElementById(e.$_ptooltipId)
        },
        getArrowElement: function(e) {
            return ME(this.getTooltipElement(e), '[data-pc-section="arrow"]')
        },
        create: function(e) {
            var t = e.$_ptooltipModifiers,
                n = IE("div", {
                    class: !this.isUnstyled() && this.cx("arrow"),
                    "p-bind": this.ptm("arrow", {
                        context: t
                    })
                }),
                r = IE("div", {
                    class: !this.isUnstyled() && this.cx("text"),
                    "p-bind": this.ptm("text", {
                        context: t
                    })
                });
            e.$_ptooltipEscape ? (r.innerHTML = "", r.appendChild(document.createTextNode(e.$_ptooltipValue))) : r.innerHTML = e.$_ptooltipValue;
            var o = IE("div", jI(jI({
                id: e.$_ptooltipIdAttr,
                role: "tooltip",
                style: {
                    display: "inline-block",
                    width: e.$_ptooltipFitContent ? "fit-content" : void 0,
                    pointerEvents: !this.isUnstyled() && e.$_ptooltipAutoHide && "none"
                },
                class: [!this.isUnstyled() && this.cx("root"), e.$_ptooltipClass]
            }, this.$attrSelector, ""), "p-bind", this.ptm("root", {
                context: t
            })), n, r);
            return document.body.appendChild(o), e.$_ptooltipId = o.id, this.$el = o, o
        },
        remove: function(e) {
            if (e) {
                var t = this.getTooltipElement(e);
                t && t.parentElement && (MS.clear(t), document.body.removeChild(t)),
                e.$_ptooltipId = null
            }
        },
        align: function(e) {
            var t = e.$_ptooltipModifiers;
            t.top ? (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignTop(e))) : t.left ? (this.alignLeft(e), this.isOutOfBounds(e) && (this.alignRight(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignLeft(e))))) : t.bottom ? (this.alignBottom(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && this.alignBottom(e))) : (this.alignRight(e), this.isOutOfBounds(e) && (this.alignLeft(e), this.isOutOfBounds(e) && (this.alignTop(e), this.isOutOfBounds(e) && (this.alignBottom(e), this.isOutOfBounds(e) && this.alignRight(e)))))
        },
        getHostOffset: function(e) {
            var t = e.getBoundingClientRect();
            return {
                left: t.left + mE(),
                top: t.top + bE()
            }
        },
        alignRight: function(e) {
            this.preAlign(e, "right");
            var t = this.getTooltipElement(e),
                n = this.getArrowElement(e),
                r = this.getHostOffset(e),
                o = r.left + _E(e),
                i = r.top + (UE(e) - UE(t)) / 2;
            t.style.left = o + "px",
            t.style.top = i + "px",
            n.style.top = "50%",
            n.style.right = null,
            n.style.bottom = null,
            n.style.left = "0"
        },
        alignLeft: function(e) {
            this.preAlign(e, "left");
            var t = this.getTooltipElement(e),
                n = this.getArrowElement(e),
                r = this.getHostOffset(e),
                o = r.left - _E(t),
                i = r.top + (UE(e) - UE(t)) / 2;
            t.style.left = o + "px",
            t.style.top = i + "px",
            n.style.top = "50%",
            n.style.right = "0",
            n.style.bottom = null,
            n.style.left = null
        },
        alignTop: function(e) {
            this.preAlign(e, "top");
            var t = this.getTooltipElement(e),
                n = this.getArrowElement(e),
                r = _E(t),
                o = _E(e),
                i = fE().width,
                a = this.getHostOffset(e),
                s = a.left + (o - r) / 2,
                l = a.top - UE(t);
            s < 0 ? s = 0 : s + r > i && (s = Math.floor(a.left + o - r)),
            t.style.left = s + "px",
            t.style.top = l + "px";
            var c = a.left - this.getHostOffset(t).left + o / 2;
            n.style.top = null,
            n.style.right = null,
            n.style.bottom = "0",
            n.style.left = c + "px"
        },
        alignBottom: function(e) {
            this.preAlign(e, "bottom");
            var t = this.getTooltipElement(e),
                n = this.getArrowElement(e),
                r = _E(t),
                o = _E(e),
                i = fE().width,
                a = this.getHostOffset(e),
                s = a.left + (o - r) / 2,
                l = a.top + UE(e);
            s < 0 ? s = 0 : s + r > i && (s = Math.floor(a.left + o - r)),
            t.style.left = s + "px",
            t.style.top = l + "px";
            var c = a.left - this.getHostOffset(t).left + o / 2;
            n.style.top = "0",
            n.style.right = null,
            n.style.bottom = null,
            n.style.left = c + "px"
        },
        preAlign: function(e, t) {
            var n = this.getTooltipElement(e);
            n.style.left = "-999px",
            n.style.top = "-999px",
            dE(n, "p-tooltip-".concat(n.$_ptooltipPosition)),
            !this.isUnstyled() && uE(n, "p-tooltip-".concat(t)),
            n.$_ptooltipPosition = t,
            n.setAttribute("data-p-position", t)
        },
        isOutOfBounds: function(e) {
            var t = this.getTooltipElement(e),
                n = t.getBoundingClientRect(),
                r = n.top,
                o = n.left,
                i = _E(t),
                a = UE(t),
                s = fE();
            return o + i > s.width || o < 0 || r < 0 || r + a > s.height
        },
        getTarget: function(e) {
            var t;
            return cE(e, "p-inputwrapper") && null !== (t = ME(e, "input")) && void 0 !== t ? t : e
        },
        getModifiers: function(e) {
            return e.modifiers && Object.keys(e.modifiers).length ? e.modifiers : e.arg && "object" === VI(e.arg) ? Object.entries(e.arg).reduce(function(e, t) {
                var n,
                    r,
                    o = (r = 2, function(e) {
                        if (Array.isArray(e))
                            return e
                    }(n = t) || function(e, t) {
                        var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != n) {
                            var r,
                                o,
                                i,
                                a,
                                s = [],
                                l = !0,
                                c = !1;
                            try {
                                if (i = (n = n.call(e)).next, 0 === t)
                                    ;
                                else
                                    for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                                        ;
                            } catch (u) {
                                c = !0,
                                o = u
                            } finally {
                                try {
                                    if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                                        return
                                } finally {
                                    if (c)
                                        throw o
                                }
                            }
                            return s
                        }
                    }(n, r) || function(e, t) {
                        if (e) {
                            if ("string" == typeof e)
                                return GI(e, t);
                            var n = {}.toString.call(e).slice(8, -1);
                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? GI(e, t) : void 0
                        }
                    }(n, r) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()),
                    i = o[0],
                    a = o[1];
                return "event" !== i && "position" !== i || (e[a] = !0), e
            }, {}) : {}
        }
    }
});
var $I = kI.extend({
    name: "common"
});
function WI(e) {
    return (WI = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function KI(e, t) {
    return JI(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r,
                    o,
                    i,
                    a,
                    s = [],
                    l = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t) {
                        if (Object(n) !== n)
                            return;
                        l = !1
                    } else
                        for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                            ;
                } catch (u) {
                    c = !0,
                    o = u
                } finally {
                    try {
                        if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                            return
                    } finally {
                        if (c)
                            throw o
                    }
                }
                return s
            }
        }(e, t) || XI(e, t) || qI()
}
function qI() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}
function XI(e, t) {
    if (e) {
        if ("string" == typeof e)
            return YI(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? YI(e, t) : void 0
    }
}
function YI(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function JI(e) {
    if (Array.isArray(e))
        return e
}
function ZI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function eT(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? ZI(Object(n), !0).forEach(function(t) {
            tT(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZI(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function tT(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != WI(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != WI(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == WI(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var nT = {
        name: "BaseComponent",
        props: {
            pt: {
                type: Object,
                default: void 0
            },
            ptOptions: {
                type: Object,
                default: void 0
            },
            unstyled: {
                type: Boolean,
                default: void 0
            },
            dt: {
                type: Object,
                default: void 0
            }
        },
        inject: {
            $parentInstance: {
                default: void 0
            }
        },
        watch: {
            isUnstyled: {
                immediate: !0,
                handler: function(e) {
                    YS.off("theme:change", this._loadCoreStyles),
                    e || (this._loadCoreStyles(), this._themeChangeListener(this._loadCoreStyles))
                }
            },
            dt: {
                immediate: !0,
                handler: function(e, t) {
                    var n = this;
                    YS.off("theme:change", this._themeScopedListener),
                    e ? (this._loadScopedThemeStyles(e), this._themeScopedListener = function() {
                        return n._loadScopedThemeStyles(e)
                    }, this._themeChangeListener(this._themeScopedListener)) : this._unloadScopedThemeStyles()
                }
            }
        },
        scopedStyleEl: void 0,
        rootEl: void 0,
        uid: void 0,
        $attrSelector: void 0,
        beforeCreate: function() {
            var e,
                t,
                n,
                r,
                o,
                i,
                a,
                s,
                l,
                c,
                u,
                d = null === (e = this.pt) || void 0 === e ? void 0 : e._usept,
                p = d ? null === (t = this.pt) || void 0 === t || null === (t = t.originalValue) || void 0 === t ? void 0 : t[this.$.type.name] : void 0;
            null === (r = (d ? null === (n = this.pt) || void 0 === n || null === (n = n.value) || void 0 === n ? void 0 : n[this.$.type.name] : this.pt) || p) || void 0 === r || null === (r = r.hooks) || void 0 === r || null === (o = r.onBeforeCreate) || void 0 === o || o.call(r);
            var h = null === (i = this.$primevueConfig) || void 0 === i || null === (i = i.pt) || void 0 === i ? void 0 : i._usept,
                f = h ? null === (a = this.$primevue) || void 0 === a || null === (a = a.config) || void 0 === a || null === (a = a.pt) || void 0 === a ? void 0 : a.originalValue : void 0;
            null === (c = (h ? null === (s = this.$primevue) || void 0 === s || null === (s = s.config) || void 0 === s || null === (s = s.pt) || void 0 === s ? void 0 : s.value : null === (l = this.$primevue) || void 0 === l || null === (l = l.config) || void 0 === l ? void 0 : l.pt) || f) || void 0 === c || null === (c = c[this.$.type.name]) || void 0 === c || null === (c = c.hooks) || void 0 === c || null === (u = c.onBeforeCreate) || void 0 === u || u.call(c),
            this.$attrSelector = function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "pc",
                    t = function() {
                        const e = Po();
                        return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : ""
                    }();
                return "".concat(e).concat(t.replace("v-", "").replaceAll("-", "_"))
            }(),
            this.uid = this.$attrs.id || this.$attrSelector.replace("pc", "pv_id_")
        },
        created: function() {
            this._hook("onCreated")
        },
        beforeMount: function() {
            var e;
            this.rootEl = ME(CE(this.$el) ? this.$el : null === (e = this.$el) || void 0 === e ? void 0 : e.parentElement, "[".concat(this.$attrSelector, "]")),
            this.rootEl && (this.rootEl.$pc = eT({
                name: this.$.type.name,
                attrSelector: this.$attrSelector
            }, this.$params)),
            this._loadStyles(),
            this._hook("onBeforeMount")
        },
        mounted: function() {
            this._hook("onMounted")
        },
        beforeUpdate: function() {
            this._hook("onBeforeUpdate")
        },
        updated: function() {
            this._hook("onUpdated")
        },
        beforeUnmount: function() {
            this._hook("onBeforeUnmount")
        },
        unmounted: function() {
            this._removeThemeListeners(),
            this._unloadScopedThemeStyles(),
            this._hook("onUnmounted")
        },
        methods: {
            _hook: function(e) {
                if (!this.$options.hostName) {
                    var t = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(e)),
                        n = this._useDefaultPT(this._getOptionValue, "hooks.".concat(e));
                    null == t || t(),
                    null == n || n()
                }
            },
            _mergeProps: function(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                    n[r - 1] = arguments[r];
                return aS(e) ? e.apply(void 0, n) : Mo.apply(void 0, n)
            },
            _load: function() {
                gI.isStyleNameLoaded("base") || (kI.loadCSS(this.$styleOptions), this._loadGlobalStyles(), gI.setLoadedStyleName("base")),
                this._loadThemeStyles()
            },
            _loadStyles: function() {
                this._load(),
                this._themeChangeListener(this._load)
            },
            _loadCoreStyles: function() {
                var e,
                    t;
                !gI.isStyleNameLoaded(null === (e = this.$style) || void 0 === e ? void 0 : e.name) && null !== (t = this.$style) && void 0 !== t && t.name && ($I.loadCSS(this.$styleOptions), this.$options.style && this.$style.loadCSS(this.$styleOptions), gI.setLoadedStyleName(this.$style.name))
            },
            _loadGlobalStyles: function() {
                var e = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
                sS(e) && kI.load(e, eT({
                    name: "global"
                }, this.$styleOptions))
            },
            _loadThemeStyles: function() {
                var e,
                    t;
                if (!this.isUnstyled && "none" !== this.$theme) {
                    if (!fI.isStyleNameLoaded("common")) {
                        var n,
                            r,
                            o = (null === (n = this.$style) || void 0 === n || null === (r = n.getCommonTheme) || void 0 === r ? void 0 : r.call(n)) || {},
                            i = o.primitive,
                            a = o.semantic,
                            s = o.global,
                            l = o.style;
                        kI.load(null == i ? void 0 : i.css, eT({
                            name: "primitive-variables"
                        }, this.$styleOptions)),
                        kI.load(null == a ? void 0 : a.css, eT({
                            name: "semantic-variables"
                        }, this.$styleOptions)),
                        kI.load(null == s ? void 0 : s.css, eT({
                            name: "global-variables"
                        }, this.$styleOptions)),
                        kI.loadStyle(eT({
                            name: "global-style"
                        }, this.$styleOptions), l),
                        fI.setLoadedStyleName("common")
                    }
                    if (!fI.isStyleNameLoaded(null === (e = this.$style) || void 0 === e ? void 0 : e.name) && null !== (t = this.$style) && void 0 !== t && t.name) {
                        var c,
                            u,
                            d,
                            p,
                            h = (null === (c = this.$style) || void 0 === c || null === (u = c.getComponentTheme) || void 0 === u ? void 0 : u.call(c)) || {},
                            f = h.css,
                            g = h.style;
                        null === (d = this.$style) || void 0 === d || d.load(f, eT({
                            name: "".concat(this.$style.name, "-variables")
                        }, this.$styleOptions)),
                        null === (p = this.$style) || void 0 === p || p.loadStyle(eT({
                            name: "".concat(this.$style.name, "-style")
                        }, this.$styleOptions), g),
                        fI.setLoadedStyleName(this.$style.name)
                    }
                    if (!fI.isStyleNameLoaded("layer-order")) {
                        var m,
                            b,
                            A = null === (m = this.$style) || void 0 === m || null === (b = m.getLayerOrderThemeCSS) || void 0 === b ? void 0 : b.call(m);
                        kI.load(A, eT({
                            name: "layer-order",
                            first: !0
                        }, this.$styleOptions)),
                        fI.setLoadedStyleName("layer-order")
                    }
                }
            },
            _loadScopedThemeStyles: function(e) {
                var t,
                    n,
                    r,
                    o = ((null === (t = this.$style) || void 0 === t || null === (n = t.getPresetTheme) || void 0 === n ? void 0 : n.call(t, e, "[".concat(this.$attrSelector, "]"))) || {}).css,
                    i = null === (r = this.$style) || void 0 === r ? void 0 : r.load(o, eT({
                        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
                    }, this.$styleOptions));
                this.scopedStyleEl = i.el
            },
            _unloadScopedThemeStyles: function() {
                var e;
                null === (e = this.scopedStyleEl) || void 0 === e || null === (e = e.value) || void 0 === e || e.remove()
            },
            _themeChangeListener: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function() {};
                gI.clearLoadedStyleNames(),
                YS.on("theme:change", e)
            },
            _removeThemeListeners: function() {
                YS.off("theme:change", this._loadCoreStyles),
                YS.off("theme:change", this._load),
                YS.off("theme:change", this._themeScopedListener)
            },
            _getHostInstance: function(e) {
                return e ? this.$options.hostName ? e.$.type.name === this.$options.hostName ? e : this._getHostInstance(e.$parentInstance) : e.$parentInstance : void 0
            },
            _getPropValue: function(e) {
                var t;
                return this[e] || (null === (t = this._getHostInstance(this)) || void 0 === t ? void 0 : t[e])
            },
            _getOptionValue: function(e) {
                return AS(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {})
            },
            _getPTValue: function() {
                var e,
                    t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    i = /./g.test(n) && !!r[n.split(".")[0]],
                    a = this._getPropValue("ptOptions") || (null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.ptOptions) || {},
                    s = a.mergeSections,
                    l = void 0 === s || s,
                    c = a.mergeProps,
                    u = void 0 !== c && c,
                    d = o ? i ? this._useGlobalPT(this._getPTClassValue, n, r) : this._useDefaultPT(this._getPTClassValue, n, r) : void 0,
                    p = i ? void 0 : this._getPTSelf(t, this._getPTClassValue, n, eT(eT({}, r), {}, {
                        global: d || {}
                    })),
                    h = this._getPTDatasets(n);
                return l || !l && p ? u ? this._mergeProps(u, d, p, h) : eT(eT(eT({}, d), p), h) : eT(eT({}, p), h)
            },
            _getPTSelf: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                    n[r - 1] = arguments[r];
                return Mo(this._usePT.apply(this, [this._getPT(e, this.$name)].concat(n)), this._usePT.apply(this, [this.$_attrsPT].concat(n)))
            },
            _getPTDatasets: function() {
                var e,
                    t,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    r = "data-pc-",
                    o = "root" === n && sS(null === (e = this.pt) || void 0 === e ? void 0 : e["data-pc-section"]);
                return "transition" !== n && eT(eT({}, "root" === n && eT(eT(tT({}, "".concat(r, "name"), bS(o ? null === (t = this.pt) || void 0 === t ? void 0 : t["data-pc-section"] : this.$.type.name)), o && tT({}, "".concat(r, "extend"), bS(this.$.type.name))), {}, tT({}, "".concat(this.$attrSelector), ""))), {}, tT({}, "".concat(r, "section"), bS(n)))
            },
            _getPTClassValue: function() {
                var e = this._getOptionValue.apply(this, arguments);
                return mS(e) || yS(e) ? {
                    class: e
                } : e
            },
            _getPT: function(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    r = arguments.length > 2 ? arguments[2] : void 0,
                    o = function(e) {
                        var o,
                            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            a = r ? r(e) : e,
                            s = bS(n),
                            l = bS(t.$name);
                        return null !== (o = i ? s !== l ? null == a ? void 0 : a[s] : void 0 : null == a ? void 0 : a[s]) && void 0 !== o ? o : a
                    };
                return null != e && e.hasOwnProperty("_usept") ? {
                    _usept: e._usept,
                    originalValue: o(e.originalValue),
                    value: o(e.value)
                } : o(e, !0)
            },
            _usePT: function(e, t, n, r) {
                var o = function(e) {
                    return t(e, n, r)
                };
                if (null != e && e.hasOwnProperty("_usept")) {
                    var i,
                        a = e._usept || (null === (i = this.$primevueConfig) || void 0 === i ? void 0 : i.ptOptions) || {},
                        s = a.mergeSections,
                        l = void 0 === s || s,
                        c = a.mergeProps,
                        u = void 0 !== c && c,
                        d = o(e.originalValue),
                        p = o(e.value);
                    if (void 0 === d && void 0 === p)
                        return;
                    return mS(p) ? p : mS(d) ? d : l || !l && p ? u ? this._mergeProps(u, d, p) : eT(eT({}, d), p) : p
                }
                return o(e)
            },
            _useGlobalPT: function(e, t, n) {
                return this._usePT(this.globalPT, e, t, n)
            },
            _useDefaultPT: function(e, t, n) {
                return this._usePT(this.defaultPT, e, t, n)
            },
            ptm: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return this._getPTValue(this.pt, e, eT(eT({}, this.$params), t))
            },
            ptmi: function() {
                var e,
                    t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    r = Mo(this.$_attrsWithoutPT, this.ptm(t, n));
                return (null == r ? void 0 : r.hasOwnProperty("id")) && (null !== (e = r.id) && void 0 !== e || (r.id = this.$id)), r
            },
            ptmo: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return this._getPTValue(e, t, eT({
                    instance: this
                }, n), !1)
            },
            cx: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return this.isUnstyled ? void 0 : this._getOptionValue(this.$style.classes, e, eT(eT({}, this.$params), t))
            },
            sx: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) {
                    var n = this._getOptionValue(this.$style.inlineStyles, e, eT(eT({}, this.$params), t));
                    return [this._getOptionValue($I.inlineStyles, e, eT(eT({}, this.$params), t)), n]
                }
            }
        },
        computed: {
            globalPT: function() {
                var e,
                    t = this;
                return this._getPT(null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.pt, void 0, function(e) {
                    return gS(e, {
                        instance: t
                    })
                })
            },
            defaultPT: function() {
                var e,
                    t = this;
                return this._getPT(null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.pt, void 0, function(e) {
                    return t._getOptionValue(e, t.$name, eT({}, t.$params)) || gS(e, eT({}, t.$params))
                })
            },
            isUnstyled: function() {
                var e;
                return void 0 !== this.unstyled ? this.unstyled : null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.unstyled
            },
            $id: function() {
                return this.$attrs.id || this.uid
            },
            $inProps: function() {
                var e,
                    t = Object.keys((null === (e = this.$.vnode) || void 0 === e ? void 0 : e.props) || {});
                return Object.fromEntries(Object.entries(this.$props).filter(function(e) {
                    var n = KI(e, 1)[0];
                    return null == t ? void 0 : t.includes(n)
                }))
            },
            $theme: function() {
                var e;
                return null === (e = this.$primevueConfig) || void 0 === e ? void 0 : e.theme
            },
            $style: function() {
                return eT(eT({
                    classes: void 0,
                    inlineStyles: void 0,
                    load: function() {},
                    loadCSS: function() {},
                    loadStyle: function() {}
                }, (this._getHostInstance(this) || {}).$style), this.$options.style)
            },
            $styleOptions: function() {
                var e;
                return {
                    nonce: null === (e = this.$primevueConfig) || void 0 === e || null === (e = e.csp) || void 0 === e ? void 0 : e.nonce
                }
            },
            $primevueConfig: function() {
                var e;
                return null === (e = this.$primevue) || void 0 === e ? void 0 : e.config
            },
            $name: function() {
                return this.$options.hostName || this.$.type.name
            },
            $params: function() {
                var e = this._getHostInstance(this) || this.$parent;
                return {
                    instance: this,
                    props: this.$props,
                    state: this.$data,
                    attrs: this.$attrs,
                    parent: {
                        instance: e,
                        props: null == e ? void 0 : e.$props,
                        state: null == e ? void 0 : e.$data,
                        attrs: null == e ? void 0 : e.$attrs
                    }
                }
            },
            $_attrsPT: function() {
                return Object.entries(this.$attrs || {}).filter(function(e) {
                    var t = KI(e, 1)[0];
                    return null == t ? void 0 : t.startsWith("pt:")
                }).reduce(function(e, t) {
                    var n,
                        r = KI(t, 2),
                        o = r[0],
                        i = r[1],
                        a = (n = o.split(":"), JI(n) || function(e) {
                            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                                return Array.from(e)
                        }(n) || XI(n) || qI()).slice(1);
                    return null == a || a.reduce(function(e, t, n, r) {
                        return !e[t] && (e[t] = n === r.length - 1 ? i : {}), e[t]
                    }, e), e
                }, {})
            },
            $_attrsWithoutPT: function() {
                return Object.entries(this.$attrs || {}).filter(function(e) {
                    var t = KI(e, 1)[0];
                    return !(null != t && t.startsWith("pt:"))
                }).reduce(function(e, t) {
                    var n = KI(t, 2),
                        r = n[0],
                        o = n[1];
                    return e[r] = o, e
                }, {})
            }
        }
    },
    rT = {
        name: "BaseEditableHolder",
        extends: nT,
        emits: ["update:modelValue", "value-change"],
        props: {
            modelValue: {
                type: null,
                default: void 0
            },
            defaultValue: {
                type: null,
                default: void 0
            },
            name: {
                type: String,
                default: void 0
            },
            invalid: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            formControl: {
                type: Object,
                default: void 0
            }
        },
        inject: {
            $parentInstance: {
                default: void 0
            },
            $pcForm: {
                default: void 0
            },
            $pcFormField: {
                default: void 0
            }
        },
        data: function() {
            return {
                d_value: void 0 !== this.defaultValue ? this.defaultValue : this.modelValue
            }
        },
        watch: {
            modelValue: {
                deep: !0,
                handler: function(e) {
                    this.d_value = e
                }
            },
            defaultValue: function(e) {
                this.d_value = e
            },
            $formName: {
                immediate: !0,
                handler: function(e) {
                    var t,
                        n;
                    this.formField = (null === (t = this.$pcForm) || void 0 === t || null === (n = t.register) || void 0 === n ? void 0 : n.call(t, e, this.$formControl)) || {}
                }
            },
            $formControl: {
                immediate: !0,
                handler: function(e) {
                    var t,
                        n;
                    this.formField = (null === (t = this.$pcForm) || void 0 === t || null === (n = t.register) || void 0 === n ? void 0 : n.call(t, this.$formName, e)) || {}
                }
            },
            $formDefaultValue: {
                immediate: !0,
                handler: function(e) {
                    this.d_value !== e && (this.d_value = e)
                }
            },
            $formValue: {
                immediate: !1,
                handler: function(e) {
                    var t;
                    null !== (t = this.$pcForm) && void 0 !== t && t.getFieldState(this.$formName) && e !== this.d_value && (this.d_value = e)
                }
            }
        },
        formField: {},
        methods: {
            writeValue: function(e, t) {
                var n,
                    r;
                this.controlled && (this.d_value = e, this.$emit("update:modelValue", e)),
                this.$emit("value-change", e),
                null === (n = (r = this.formField).onChange) || void 0 === n || n.call(r, {
                    originalEvent: t,
                    value: e
                })
            },
            findNonEmpty: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                return t.find(sS)
            }
        },
        computed: {
            $filled: function() {
                return sS(this.d_value)
            },
            $invalid: function() {
                var e,
                    t;
                return !this.$formNovalidate && this.findNonEmpty(this.invalid, null === (e = this.$pcFormField) || void 0 === e || null === (e = e.$field) || void 0 === e ? void 0 : e.invalid, null === (t = this.$pcForm) || void 0 === t || null === (t = t.getFieldState(this.$formName)) || void 0 === t ? void 0 : t.invalid)
            },
            $formName: function() {
                var e;
                return this.$formNovalidate ? void 0 : this.name || (null === (e = this.$formControl) || void 0 === e ? void 0 : e.name)
            },
            $formControl: function() {
                var e;
                return this.formControl || (null === (e = this.$pcFormField) || void 0 === e ? void 0 : e.formControl)
            },
            $formNovalidate: function() {
                var e;
                return null === (e = this.$formControl) || void 0 === e ? void 0 : e.novalidate
            },
            $formDefaultValue: function() {
                var e,
                    t;
                return this.findNonEmpty(this.d_value, null === (e = this.$pcFormField) || void 0 === e ? void 0 : e.initialValue, null === (t = this.$pcForm) || void 0 === t || null === (t = t.initialValues) || void 0 === t ? void 0 : t[this.$formName])
            },
            $formValue: function() {
                var e,
                    t;
                return this.findNonEmpty(null === (e = this.$pcFormField) || void 0 === e || null === (e = e.$field) || void 0 === e ? void 0 : e.value, null === (t = this.$pcForm) || void 0 === t || null === (t = t.getFieldState(this.$formName)) || void 0 === t ? void 0 : t.value)
            },
            controlled: function() {
                return this.$inProps.hasOwnProperty("modelValue") || !this.$inProps.hasOwnProperty("modelValue") && !this.$inProps.hasOwnProperty("defaultValue")
            },
            filled: function() {
                return this.$filled
            }
        }
    },
    oT = kI.extend({
        name: "slider",
        style: "\n    .p-slider {\n        display: block;\n        position: relative;\n        background: dt('slider.track.background');\n        border-radius: dt('slider.track.border.radius');\n    }\n\n    .p-slider-handle {\n        cursor: grab;\n        touch-action: none;\n        user-select: none;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: dt('slider.handle.height');\n        width: dt('slider.handle.width');\n        background: dt('slider.handle.background');\n        border-radius: dt('slider.handle.border.radius');\n        transition:\n            background dt('slider.transition.duration'),\n            color dt('slider.transition.duration'),\n            border-color dt('slider.transition.duration'),\n            box-shadow dt('slider.transition.duration'),\n            outline-color dt('slider.transition.duration');\n        outline-color: transparent;\n    }\n\n    .p-slider-handle::before {\n        content: '';\n        width: dt('slider.handle.content.width');\n        height: dt('slider.handle.content.height');\n        display: block;\n        background: dt('slider.handle.content.background');\n        border-radius: dt('slider.handle.content.border.radius');\n        box-shadow: dt('slider.handle.content.shadow');\n        transition: background dt('slider.transition.duration');\n    }\n\n    .p-slider:not(.p-disabled) .p-slider-handle:hover {\n        background: dt('slider.handle.hover.background');\n    }\n\n    .p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n        background: dt('slider.handle.content.hover.background');\n    }\n\n    .p-slider-handle:focus-visible {\n        box-shadow: dt('slider.handle.focus.ring.shadow');\n        outline: dt('slider.handle.focus.ring.width') dt('slider.handle.focus.ring.style') dt('slider.handle.focus.ring.color');\n        outline-offset: dt('slider.handle.focus.ring.offset');\n    }\n\n    .p-slider-range {\n        display: block;\n        background: dt('slider.range.background');\n        border-radius: dt('slider.track.border.radius');\n    }\n\n    .p-slider.p-slider-horizontal {\n        height: dt('slider.track.size');\n    }\n\n    .p-slider-horizontal .p-slider-range {\n        inset-block-start: 0;\n        inset-inline-start: 0;\n        height: 100%;\n    }\n\n    .p-slider-horizontal .p-slider-handle {\n        inset-block-start: 50%;\n        margin-block-start: calc(-1 * calc(dt('slider.handle.height') / 2));\n        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));\n    }\n\n    .p-slider-vertical {\n        min-height: 100px;\n        width: dt('slider.track.size');\n    }\n\n    .p-slider-vertical .p-slider-handle {\n        inset-inline-start: 50%;\n        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));\n        margin-block-end: calc(-1 * calc(dt('slider.handle.height') / 2));\n    }\n\n    .p-slider-vertical .p-slider-range {\n        inset-block-end: 0;\n        inset-inline-start: 0;\n        width: 100%;\n    }\n",
        classes: {
            root: function(e) {
                var t = e.instance,
                    n = e.props;
                return ["p-slider p-component", {
                    "p-disabled": n.disabled,
                    "p-invalid": t.$invalid,
                    "p-slider-horizontal": "horizontal" === n.orientation,
                    "p-slider-vertical": "vertical" === n.orientation
                }]
            },
            range: "p-slider-range",
            handle: "p-slider-handle"
        },
        inlineStyles: {
            handle: {
                position: "absolute"
            },
            range: {
                position: "absolute"
            }
        }
    });
function iT(e) {
    return (iT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function aT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var sT = {
        name: "Slider",
        extends: {
            name: "BaseSlider",
            extends: rT,
            props: {
                min: {
                    type: Number,
                    default: 0
                },
                max: {
                    type: Number,
                    default: 100
                },
                orientation: {
                    type: String,
                    default: "horizontal"
                },
                step: {
                    type: Number,
                    default: null
                },
                range: {
                    type: Boolean,
                    default: !1
                },
                tabindex: {
                    type: Number,
                    default: 0
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                ariaLabel: {
                    type: String,
                    default: null
                }
            },
            style: oT,
            provide: function() {
                return {
                    $pcSlider: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change", "slideend"],
        dragging: !1,
        handleIndex: null,
        initX: null,
        initY: null,
        barWidth: null,
        barHeight: null,
        dragListener: null,
        dragEndListener: null,
        beforeUnmount: function() {
            this.unbindDragListeners()
        },
        methods: {
            updateDomData: function() {
                var e = this.$el.getBoundingClientRect();
                this.initX = e.left + mE(),
                this.initY = e.top + bE(),
                this.barWidth = this.$el.offsetWidth,
                this.barHeight = this.$el.offsetHeight
            },
            setValue: function(e) {
                var t,
                    n = e.touches ? e.touches[0].pageX : e.pageX,
                    r = e.touches ? e.touches[0].pageY : e.pageY;
                t = "horizontal" === this.orientation ? AE(this.$el) ? 100 * (this.initX + this.barWidth - n) / this.barWidth : 100 * (n - this.initX) / this.barWidth : 100 * (this.initY + this.barHeight - r) / this.barHeight;
                var o = (this.max - this.min) * (t / 100) + this.min;
                if (this.step) {
                    var i = this.range ? this.value[this.handleIndex] : this.value,
                        a = o - i;
                    a < 0 ? o = i + Math.ceil(o / this.step - i / this.step) * this.step : a > 0 && (o = i + Math.floor(o / this.step - i / this.step) * this.step)
                } else
                    o = Math.floor(o);
                this.updateModel(e, o)
            },
            updateModel: function(e, t) {
                var n,
                    r,
                    o = Math.round(100 * t) / 100;
                this.range ? (n = this.value ? function(e) {
                    if (Array.isArray(e))
                        return aT(e)
                }(r = this.value) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                        return Array.from(e)
                }(r) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e)
                            return aT(e, t);
                        var n = {}.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? aT(e, t) : void 0
                    }
                }(r) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }() : [], 0 == this.handleIndex ? (o < this.min ? o = this.min : o >= this.max && (o = this.max), n[0] = o) : (o > this.max ? o = this.max : o <= this.min && (o = this.min), n[1] = o)) : (o < this.min ? o = this.min : o > this.max && (o = this.max), n = o),
                this.writeValue(n, e),
                this.$emit("change", n)
            },
            onDragStart: function(e, t) {
                this.disabled || (this.$el.setAttribute("data-p-sliding", !0), this.dragging = !0, this.updateDomData(), this.range && this.value[0] === this.max ? this.handleIndex = 0 : this.handleIndex = t, e.currentTarget.focus())
            },
            onDrag: function(e) {
                this.dragging && this.setValue(e)
            },
            onDragEnd: function(e) {
                this.dragging && (this.dragging = !1, this.$el.setAttribute("data-p-sliding", !1), this.$emit("slideend", {
                    originalEvent: e,
                    value: this.value
                }))
            },
            onBarClick: function(e) {
                this.disabled || "handle" !== BE(e.target, "data-pc-section") && (this.updateDomData(), this.setValue(e))
            },
            onMouseDown: function(e, t) {
                this.bindDragListeners(),
                this.onDragStart(e, t)
            },
            onKeyDown: function(e, t) {
                switch (this.handleIndex = t, e.code) {
                case "ArrowDown":
                case "ArrowLeft":
                    this.decrementValue(e, t),
                    e.preventDefault();
                    break;
                case "ArrowUp":
                case "ArrowRight":
                    this.incrementValue(e, t),
                    e.preventDefault();
                    break;
                case "PageDown":
                    this.decrementValue(e, t, !0),
                    e.preventDefault();
                    break;
                case "PageUp":
                    this.incrementValue(e, t, !0),
                    e.preventDefault();
                    break;
                case "Home":
                    this.updateModel(e, this.min),
                    e.preventDefault();
                    break;
                case "End":
                    this.updateModel(e, this.max),
                    e.preventDefault()
                }
            },
            onBlur: function(e, t) {
                var n,
                    r;
                null === (n = (r = this.formField).onBlur) || void 0 === n || n.call(r, e)
            },
            decrementValue: function(e, t) {
                var n,
                    r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                n = this.range ? this.step ? this.value[t] - this.step : this.value[t] - 1 : this.step ? this.value - this.step : !this.step && r ? this.value - 10 : this.value - 1,
                this.updateModel(e, n),
                e.preventDefault()
            },
            incrementValue: function(e, t) {
                var n,
                    r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                n = this.range ? this.step ? this.value[t] + this.step : this.value[t] + 1 : this.step ? this.value + this.step : !this.step && r ? this.value + 10 : this.value + 1,
                this.updateModel(e, n),
                e.preventDefault()
            },
            bindDragListeners: function() {
                this.dragListener || (this.dragListener = this.onDrag.bind(this), document.addEventListener("mousemove", this.dragListener)),
                this.dragEndListener || (this.dragEndListener = this.onDragEnd.bind(this), document.addEventListener("mouseup", this.dragEndListener))
            },
            unbindDragListeners: function() {
                this.dragListener && (document.removeEventListener("mousemove", this.dragListener), this.dragListener = null),
                this.dragEndListener && (document.removeEventListener("mouseup", this.dragEndListener), this.dragEndListener = null)
            },
            rangeStyle: function() {
                if (this.range) {
                    var e = this.rangeEndPosition > this.rangeStartPosition ? this.rangeEndPosition - this.rangeStartPosition : this.rangeStartPosition - this.rangeEndPosition,
                        t = this.rangeEndPosition > this.rangeStartPosition ? this.rangeStartPosition : this.rangeEndPosition;
                    return this.horizontal ? {
                        "inset-inline-start": t + "%",
                        width: e + "%"
                    } : {
                        bottom: t + "%",
                        height: e + "%"
                    }
                }
                return this.horizontal ? {
                    width: this.handlePosition + "%"
                } : {
                    height: this.handlePosition + "%"
                }
            },
            handleStyle: function() {
                return this.horizontal ? {
                    "inset-inline-start": this.handlePosition + "%"
                } : {
                    bottom: this.handlePosition + "%"
                }
            },
            rangeStartHandleStyle: function() {
                return this.horizontal ? {
                    "inset-inline-start": this.rangeStartPosition + "%"
                } : {
                    bottom: this.rangeStartPosition + "%"
                }
            },
            rangeEndHandleStyle: function() {
                return this.horizontal ? {
                    "inset-inline-start": this.rangeEndPosition + "%"
                } : {
                    bottom: this.rangeEndPosition + "%"
                }
            }
        },
        computed: {
            value: function() {
                var e,
                    t,
                    n,
                    r,
                    o;
                return this.range ? [null !== (t = null === (n = this.d_value) || void 0 === n ? void 0 : n[0]) && void 0 !== t ? t : this.min, null !== (r = null === (o = this.d_value) || void 0 === o ? void 0 : o[1]) && void 0 !== r ? r : this.max] : null !== (e = this.d_value) && void 0 !== e ? e : this.min
            },
            horizontal: function() {
                return "horizontal" === this.orientation
            },
            vertical: function() {
                return "vertical" === this.orientation
            },
            handlePosition: function() {
                return this.value < this.min ? 0 : this.value > this.max ? 100 : 100 * (this.value - this.min) / (this.max - this.min)
            },
            rangeStartPosition: function() {
                return this.value && void 0 !== this.value[0] ? this.value[0] < this.min ? 0 : 100 * (this.value[0] - this.min) / (this.max - this.min) : 0
            },
            rangeEndPosition: function() {
                return this.value && 2 === this.value.length && void 0 !== this.value[1] ? this.value[1] > this.max ? 100 : 100 * (this.value[1] - this.min) / (this.max - this.min) : 100
            },
            dataP: function() {
                return RS((e = {}, t = this.orientation, n = this.orientation, (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != iT(e) || !e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t);
                            if ("object" != iT(r))
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(e)
                    }(e, "string");
                    return "symbol" == iT(t) ? t : t + ""
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e));
                var e,
                    t,
                    n
            }
        }
    },
    lT = ["data-p"],
    cT = ["data-p"],
    uT = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"],
    dT = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"],
    pT = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "aria-labelledby", "aria-label", "aria-orientation", "data-p"];
sT.render = function(e, t, n, r, o, i) {
    return uo(), go("div", Mo({
        class: e.cx("root"),
        onClick: t[18] || (t[18] = function() {
            return i.onBarClick && i.onBarClick.apply(i, arguments)
        })
    }, e.ptmi("root"), {
        "data-p-sliding": !1,
        "data-p": i.dataP
    }), [_o("span", Mo({
        class: e.cx("range"),
        style: [e.sx("range"), i.rangeStyle()]
    }, e.ptm("range"), {
        "data-p": i.dataP
    }), null, 16, cT), e.range ? Eo("", !0) : (uo(), go("span", Mo({
        key: 0,
        class: e.cx("handle"),
        style: [e.sx("handle"), i.handleStyle()],
        onTouchstartPassive: t[0] || (t[0] = function(e) {
            return i.onDragStart(e)
        }),
        onTouchmovePassive: t[1] || (t[1] = function(e) {
            return i.onDrag(e)
        }),
        onTouchend: t[2] || (t[2] = function(e) {
            return i.onDragEnd(e)
        }),
        onMousedown: t[3] || (t[3] = function(e) {
            return i.onMouseDown(e)
        }),
        onKeydown: t[4] || (t[4] = function(e) {
            return i.onKeyDown(e)
        }),
        onBlur: t[5] || (t[5] = function(e) {
            return i.onBlur(e)
        }),
        tabindex: e.tabindex,
        role: "slider",
        "aria-valuemin": e.min,
        "aria-valuenow": e.d_value,
        "aria-valuemax": e.max,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        "aria-orientation": e.orientation
    }, e.ptm("handle"), {
        "data-p": i.dataP
    }), null, 16, uT)), e.range ? (uo(), go("span", Mo({
        key: 1,
        class: e.cx("handle"),
        style: [e.sx("handle"), i.rangeStartHandleStyle()],
        onTouchstartPassive: t[6] || (t[6] = function(e) {
            return i.onDragStart(e, 0)
        }),
        onTouchmovePassive: t[7] || (t[7] = function(e) {
            return i.onDrag(e)
        }),
        onTouchend: t[8] || (t[8] = function(e) {
            return i.onDragEnd(e)
        }),
        onMousedown: t[9] || (t[9] = function(e) {
            return i.onMouseDown(e, 0)
        }),
        onKeydown: t[10] || (t[10] = function(e) {
            return i.onKeyDown(e, 0)
        }),
        onBlur: t[11] || (t[11] = function(e) {
            return i.onBlur(e, 0)
        }),
        tabindex: e.tabindex,
        role: "slider",
        "aria-valuemin": e.min,
        "aria-valuenow": e.d_value ? e.d_value[0] : null,
        "aria-valuemax": e.max,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        "aria-orientation": e.orientation
    }, e.ptm("startHandler"), {
        "data-p": i.dataP
    }), null, 16, dT)) : Eo("", !0), e.range ? (uo(), go("span", Mo({
        key: 2,
        class: e.cx("handle"),
        style: [e.sx("handle"), i.rangeEndHandleStyle()],
        onTouchstartPassive: t[12] || (t[12] = function(e) {
            return i.onDragStart(e, 1)
        }),
        onTouchmovePassive: t[13] || (t[13] = function(e) {
            return i.onDrag(e)
        }),
        onTouchend: t[14] || (t[14] = function(e) {
            return i.onDragEnd(e)
        }),
        onMousedown: t[15] || (t[15] = function(e) {
            return i.onMouseDown(e, 1)
        }),
        onKeydown: t[16] || (t[16] = function(e) {
            return i.onKeyDown(e, 1)
        }),
        onBlur: t[17] || (t[17] = function(e) {
            return i.onBlur(e, 1)
        }),
        tabindex: e.tabindex,
        role: "slider",
        "aria-valuemin": e.min,
        "aria-valuenow": e.d_value ? e.d_value[1] : null,
        "aria-valuemax": e.max,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        "aria-orientation": e.orientation
    }, e.ptm("endHandler"), {
        "data-p": i.dataP
    }), null, 16, pT)) : Eo("", !0)], 16, lT)
};
var hT = kI.extend({
    name: "baseicon",
    css: "\n.p-icon {\n    display: inline-block;\n    vertical-align: baseline;\n    flex-shrink: 0;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n"
});
function fT(e) {
    return (fT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function gT(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function mT(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? gT(Object(n), !0).forEach(function(t) {
            bT(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gT(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function bT(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != fT(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != fT(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == fT(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var AT = {
        name: "BaseIcon",
        extends: nT,
        props: {
            label: {
                type: String,
                default: void 0
            },
            spin: {
                type: Boolean,
                default: !1
            }
        },
        style: hT,
        provide: function() {
            return {
                $pcIcon: this,
                $parentInstance: this
            }
        },
        methods: {
            pti: function() {
                var e = rS(this.label);
                return mT(mT({}, !this.isUnstyled && {
                    class: ["p-icon", {
                        "p-icon-spin": this.spin
                    }]
                }), {}, {
                    role: e ? void 0 : "img",
                    "aria-label": e ? void 0 : this.label,
                    "aria-hidden": e
                })
            }
        }
    },
    yT = {
        name: "TimesIcon",
        extends: AT
    };
function vT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
yT.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return vT(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return vT(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? vT(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var _T = kI.extend({
    name: "ripple-directive",
    style: "\n    .p-ink {\n        display: block;\n        position: absolute;\n        background: dt('ripple.background');\n        border-radius: 100%;\n        transform: scale(0);\n        pointer-events: none;\n    }\n\n    .p-ink-active {\n        animation: ripple 0.4s linear;\n    }\n\n    @keyframes ripple {\n        100% {\n            opacity: 0;\n            transform: scale(2.5);\n        }\n    }\n",
    classes: {
        root: "p-ink"
    }
});
function xT(e) {
    return (xT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function wT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function CT(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != xT(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != xT(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == xT(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var ET = zI.extend({
        style: _T
    }).extend("ripple", {
        watch: {
            "config.ripple": function(e) {
                e ? (this.createRipple(this.$host), this.bindEvents(this.$host), this.$host.setAttribute("data-pd-ripple", !0), this.$host.style.overflow = "hidden", this.$host.style.position = "relative") : (this.remove(this.$host), this.$host.removeAttribute("data-pd-ripple"))
            }
        },
        unmounted: function(e) {
            this.remove(e)
        },
        timeout: void 0,
        methods: {
            bindEvents: function(e) {
                e.addEventListener("mousedown", this.onMouseDown.bind(this))
            },
            unbindEvents: function(e) {
                e.removeEventListener("mousedown", this.onMouseDown.bind(this))
            },
            createRipple: function(e) {
                var t = this.getInk(e);
                t || (t = IE("span", CT(CT({
                    role: "presentation",
                    "aria-hidden": !0,
                    "data-p-ink": !0,
                    "data-p-ink-active": !1,
                    class: !this.isUnstyled() && this.cx("root"),
                    onAnimationEnd: this.onAnimationEnd.bind(this)
                }, this.$attrSelector, ""), "p-bind", this.ptm("root"))), e.appendChild(t), this.$el = t)
            },
            remove: function(e) {
                var t = this.getInk(e);
                t && (this.$host.style.overflow = "", this.$host.style.position = "", this.unbindEvents(e), t.removeEventListener("animationend", this.onAnimationEnd), t.remove())
            },
            onMouseDown: function(e) {
                var t = this,
                    n = e.currentTarget,
                    r = this.getInk(n);
                if (r && "none" !== getComputedStyle(r, null).display) {
                    if (!this.isUnstyled() && dE(r, "p-ink-active"), r.setAttribute("data-p-ink-active", "false"), !PE(r) && !VE(r)) {
                        var o = Math.max(_E(n), UE(n));
                        r.style.height = o + "px",
                        r.style.width = o + "px"
                    }
                    var i = FE(n),
                        a = e.pageX - i.left + document.body.scrollTop - VE(r) / 2,
                        s = e.pageY - i.top + document.body.scrollLeft - PE(r) / 2;
                    r.style.top = s + "px",
                    r.style.left = a + "px",
                    !this.isUnstyled() && uE(r, "p-ink-active"),
                    r.setAttribute("data-p-ink-active", "true"),
                    this.timeout = setTimeout(function() {
                        r && (!t.isUnstyled() && dE(r, "p-ink-active"), r.setAttribute("data-p-ink-active", "false"))
                    }, 401)
                }
            },
            onAnimationEnd: function(e) {
                this.timeout && clearTimeout(this.timeout),
                !this.isUnstyled() && dE(e.currentTarget, "p-ink-active"),
                e.currentTarget.setAttribute("data-p-ink-active", "false")
            },
            getInk: function(e) {
                return e && e.children ? (t = e.children, function(e) {
                    if (Array.isArray(e))
                        return wT(e)
                }(t) || function(e) {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                        return Array.from(e)
                }(t) || function(e, t) {
                    if (e) {
                        if ("string" == typeof e)
                            return wT(e, t);
                        var n = {}.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? wT(e, t) : void 0
                    }
                }(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()).find(function(e) {
                    return "ripple" === BE(e, "data-pc-name")
                }) : void 0;
                var t
            }
        }
    }),
    ST = kI.extend({
        name: "message",
        style: "\n    .p-message {\n        border-radius: dt('message.border.radius');\n        outline-width: dt('message.border.width');\n        outline-style: solid;\n    }\n\n    .p-message-content {\n        display: flex;\n        align-items: center;\n        padding: dt('message.content.padding');\n        gap: dt('message.content.gap');\n        height: 100%;\n    }\n\n    .p-message-icon {\n        flex-shrink: 0;\n    }\n\n    .p-message-close-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        margin-inline-start: auto;\n        overflow: hidden;\n        position: relative;\n        width: dt('message.close.button.width');\n        height: dt('message.close.button.height');\n        border-radius: dt('message.close.button.border.radius');\n        background: transparent;\n        transition:\n            background dt('message.transition.duration'),\n            color dt('message.transition.duration'),\n            outline-color dt('message.transition.duration'),\n            box-shadow dt('message.transition.duration'),\n            opacity 0.3s;\n        outline-color: transparent;\n        color: inherit;\n        padding: 0;\n        border: none;\n        cursor: pointer;\n        user-select: none;\n    }\n\n    .p-message-close-icon {\n        font-size: dt('message.close.icon.size');\n        width: dt('message.close.icon.size');\n        height: dt('message.close.icon.size');\n    }\n\n    .p-message-close-button:focus-visible {\n        outline-width: dt('message.close.button.focus.ring.width');\n        outline-style: dt('message.close.button.focus.ring.style');\n        outline-offset: dt('message.close.button.focus.ring.offset');\n    }\n\n    .p-message-info {\n        background: dt('message.info.background');\n        outline-color: dt('message.info.border.color');\n        color: dt('message.info.color');\n        box-shadow: dt('message.info.shadow');\n    }\n\n    .p-message-info .p-message-close-button:focus-visible {\n        outline-color: dt('message.info.close.button.focus.ring.color');\n        box-shadow: dt('message.info.close.button.focus.ring.shadow');\n    }\n\n    .p-message-info .p-message-close-button:hover {\n        background: dt('message.info.close.button.hover.background');\n    }\n\n    .p-message-info.p-message-outlined {\n        color: dt('message.info.outlined.color');\n        outline-color: dt('message.info.outlined.border.color');\n    }\n\n    .p-message-info.p-message-simple {\n        color: dt('message.info.simple.color');\n    }\n\n    .p-message-success {\n        background: dt('message.success.background');\n        outline-color: dt('message.success.border.color');\n        color: dt('message.success.color');\n        box-shadow: dt('message.success.shadow');\n    }\n\n    .p-message-success .p-message-close-button:focus-visible {\n        outline-color: dt('message.success.close.button.focus.ring.color');\n        box-shadow: dt('message.success.close.button.focus.ring.shadow');\n    }\n\n    .p-message-success .p-message-close-button:hover {\n        background: dt('message.success.close.button.hover.background');\n    }\n\n    .p-message-success.p-message-outlined {\n        color: dt('message.success.outlined.color');\n        outline-color: dt('message.success.outlined.border.color');\n    }\n\n    .p-message-success.p-message-simple {\n        color: dt('message.success.simple.color');\n    }\n\n    .p-message-warn {\n        background: dt('message.warn.background');\n        outline-color: dt('message.warn.border.color');\n        color: dt('message.warn.color');\n        box-shadow: dt('message.warn.shadow');\n    }\n\n    .p-message-warn .p-message-close-button:focus-visible {\n        outline-color: dt('message.warn.close.button.focus.ring.color');\n        box-shadow: dt('message.warn.close.button.focus.ring.shadow');\n    }\n\n    .p-message-warn .p-message-close-button:hover {\n        background: dt('message.warn.close.button.hover.background');\n    }\n\n    .p-message-warn.p-message-outlined {\n        color: dt('message.warn.outlined.color');\n        outline-color: dt('message.warn.outlined.border.color');\n    }\n\n    .p-message-warn.p-message-simple {\n        color: dt('message.warn.simple.color');\n    }\n\n    .p-message-error {\n        background: dt('message.error.background');\n        outline-color: dt('message.error.border.color');\n        color: dt('message.error.color');\n        box-shadow: dt('message.error.shadow');\n    }\n\n    .p-message-error .p-message-close-button:focus-visible {\n        outline-color: dt('message.error.close.button.focus.ring.color');\n        box-shadow: dt('message.error.close.button.focus.ring.shadow');\n    }\n\n    .p-message-error .p-message-close-button:hover {\n        background: dt('message.error.close.button.hover.background');\n    }\n\n    .p-message-error.p-message-outlined {\n        color: dt('message.error.outlined.color');\n        outline-color: dt('message.error.outlined.border.color');\n    }\n\n    .p-message-error.p-message-simple {\n        color: dt('message.error.simple.color');\n    }\n\n    .p-message-secondary {\n        background: dt('message.secondary.background');\n        outline-color: dt('message.secondary.border.color');\n        color: dt('message.secondary.color');\n        box-shadow: dt('message.secondary.shadow');\n    }\n\n    .p-message-secondary .p-message-close-button:focus-visible {\n        outline-color: dt('message.secondary.close.button.focus.ring.color');\n        box-shadow: dt('message.secondary.close.button.focus.ring.shadow');\n    }\n\n    .p-message-secondary .p-message-close-button:hover {\n        background: dt('message.secondary.close.button.hover.background');\n    }\n\n    .p-message-secondary.p-message-outlined {\n        color: dt('message.secondary.outlined.color');\n        outline-color: dt('message.secondary.outlined.border.color');\n    }\n\n    .p-message-secondary.p-message-simple {\n        color: dt('message.secondary.simple.color');\n    }\n\n    .p-message-contrast {\n        background: dt('message.contrast.background');\n        outline-color: dt('message.contrast.border.color');\n        color: dt('message.contrast.color');\n        box-shadow: dt('message.contrast.shadow');\n    }\n\n    .p-message-contrast .p-message-close-button:focus-visible {\n        outline-color: dt('message.contrast.close.button.focus.ring.color');\n        box-shadow: dt('message.contrast.close.button.focus.ring.shadow');\n    }\n\n    .p-message-contrast .p-message-close-button:hover {\n        background: dt('message.contrast.close.button.hover.background');\n    }\n\n    .p-message-contrast.p-message-outlined {\n        color: dt('message.contrast.outlined.color');\n        outline-color: dt('message.contrast.outlined.border.color');\n    }\n\n    .p-message-contrast.p-message-simple {\n        color: dt('message.contrast.simple.color');\n    }\n\n    .p-message-text {\n        font-size: dt('message.text.font.size');\n        font-weight: dt('message.text.font.weight');\n    }\n\n    .p-message-icon {\n        font-size: dt('message.icon.size');\n        width: dt('message.icon.size');\n        height: dt('message.icon.size');\n    }\n\n    .p-message-enter-from {\n        opacity: 0;\n    }\n\n    .p-message-enter-active {\n        transition: opacity 0.3s;\n    }\n\n    .p-message.p-message-leave-from {\n        max-height: 1000px;\n    }\n\n    .p-message.p-message-leave-to {\n        max-height: 0;\n        opacity: 0;\n        margin: 0;\n    }\n\n    .p-message-leave-active {\n        overflow: hidden;\n        transition:\n            max-height 0.45s cubic-bezier(0, 1, 0, 1),\n            opacity 0.3s,\n            margin 0.3s;\n    }\n\n    .p-message-leave-active .p-message-close-button {\n        opacity: 0;\n    }\n\n    .p-message-sm .p-message-content {\n        padding: dt('message.content.sm.padding');\n    }\n\n    .p-message-sm .p-message-text {\n        font-size: dt('message.text.sm.font.size');\n    }\n\n    .p-message-sm .p-message-icon {\n        font-size: dt('message.icon.sm.size');\n        width: dt('message.icon.sm.size');\n        height: dt('message.icon.sm.size');\n    }\n\n    .p-message-sm .p-message-close-icon {\n        font-size: dt('message.close.icon.sm.size');\n        width: dt('message.close.icon.sm.size');\n        height: dt('message.close.icon.sm.size');\n    }\n\n    .p-message-lg .p-message-content {\n        padding: dt('message.content.lg.padding');\n    }\n\n    .p-message-lg .p-message-text {\n        font-size: dt('message.text.lg.font.size');\n    }\n\n    .p-message-lg .p-message-icon {\n        font-size: dt('message.icon.lg.size');\n        width: dt('message.icon.lg.size');\n        height: dt('message.icon.lg.size');\n    }\n\n    .p-message-lg .p-message-close-icon {\n        font-size: dt('message.close.icon.lg.size');\n        width: dt('message.close.icon.lg.size');\n        height: dt('message.close.icon.lg.size');\n    }\n\n    .p-message-outlined {\n        background: transparent;\n        outline-width: dt('message.outlined.border.width');\n    }\n\n    .p-message-simple {\n        background: transparent;\n        outline-color: transparent;\n        box-shadow: none;\n    }\n\n    .p-message-simple .p-message-content {\n        padding: dt('message.simple.content.padding');\n    }\n\n    .p-message-outlined .p-message-close-button:hover,\n    .p-message-simple .p-message-close-button:hover {\n        background: transparent;\n    }\n",
        classes: {
            root: function(e) {
                var t = e.props;
                return ["p-message p-component p-message-" + t.severity, {
                    "p-message-outlined": "outlined" === t.variant,
                    "p-message-simple": "simple" === t.variant,
                    "p-message-sm": "small" === t.size,
                    "p-message-lg": "large" === t.size
                }]
            },
            content: "p-message-content",
            icon: "p-message-icon",
            text: "p-message-text",
            closeButton: "p-message-close-button",
            closeIcon: "p-message-close-icon"
        }
    });
function IT(e) {
    return (IT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function TT(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != IT(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != IT(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == IT(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var MT = {
    name: "Message",
    extends: {
        name: "BaseMessage",
        extends: nT,
        props: {
            severity: {
                type: String,
                default: "info"
            },
            closable: {
                type: Boolean,
                default: !1
            },
            life: {
                type: Number,
                default: null
            },
            icon: {
                type: String,
                default: void 0
            },
            closeIcon: {
                type: String,
                default: void 0
            },
            closeButtonProps: {
                type: null,
                default: null
            },
            size: {
                type: String,
                default: null
            },
            variant: {
                type: String,
                default: null
            }
        },
        style: ST,
        provide: function() {
            return {
                $pcMessage: this,
                $parentInstance: this
            }
        }
    },
    inheritAttrs: !1,
    emits: ["close", "life-end"],
    timeout: null,
    data: function() {
        return {
            visible: !0
        }
    },
    mounted: function() {
        var e = this;
        this.life && setTimeout(function() {
            e.visible = !1,
            e.$emit("life-end")
        }, this.life)
    },
    methods: {
        close: function(e) {
            this.visible = !1,
            this.$emit("close", e)
        }
    },
    computed: {
        closeAriaLabel: function() {
            return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0
        },
        dataP: function() {
            return RS(TT(TT({
                outlined: "outlined" === this.variant,
                simple: "simple" === this.variant
            }, this.severity, this.severity), this.size, this.size))
        }
    },
    directives: {
        ripple: ET
    },
    components: {
        TimesIcon: yT
    }
};
function RT(e) {
    return (RT = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function BT(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function kT(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? BT(Object(n), !0).forEach(function(t) {
            DT(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BT(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function DT(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != RT(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != RT(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == RT(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var PT = ["data-p"],
    OT = ["data-p"],
    LT = ["data-p"],
    NT = ["aria-label", "data-p"],
    FT = ["data-p"];
MT.render = function(e, t, n, r, o, i) {
    var a = jn("TimesIcon"),
        s = $n("ripple");
    return uo(), mo(ii, Mo({
        name: "p-message",
        appear: ""
    }, e.ptmi("transition")), {
        default: Vt(function() {
            return [Ht(_o("div", Mo({
                class: e.cx("root"),
                role: "alert",
                "aria-live": "assertive",
                "aria-atomic": "true",
                "data-p": i.dataP
            }, e.ptm("root")), [e.$slots.container ? Yn(e.$slots, "container", {
                key: 0,
                closeCallback: i.close
            }) : (uo(), go("div", Mo({
                key: 1,
                class: e.cx("content"),
                "data-p": i.dataP
            }, e.ptm("content")), [Yn(e.$slots, "icon", {
                class: G(e.cx("icon"))
            }, function() {
                return [(uo(), mo(Hn(e.icon ? "span" : null), Mo({
                    class: [e.cx("icon"), e.icon],
                    "data-p": i.dataP
                }, e.ptm("icon")), null, 16, ["class", "data-p"]))]
            }), e.$slots.default ? (uo(), go("div", Mo({
                key: 0,
                class: e.cx("text"),
                "data-p": i.dataP
            }, e.ptm("text")), [Yn(e.$slots, "default")], 16, LT)) : Eo("", !0), e.closable ? Ht((uo(), go("button", Mo({
                key: 1,
                class: e.cx("closeButton"),
                "aria-label": i.closeAriaLabel,
                type: "button",
                onClick: t[0] || (t[0] = function(e) {
                    return i.close(e)
                }),
                "data-p": i.dataP
            }, kT(kT({}, e.closeButtonProps), e.ptm("closeButton"))), [Yn(e.$slots, "closeicon", {}, function() {
                return [e.closeIcon ? (uo(), go("i", Mo({
                    key: 0,
                    class: [e.cx("closeIcon"), e.closeIcon],
                    "data-p": i.dataP
                }, e.ptm("closeIcon")), null, 16, FT)) : (uo(), mo(a, Mo({
                    key: 1,
                    class: [e.cx("closeIcon"), e.closeIcon],
                    "data-p": i.dataP
                }, e.ptm("closeIcon")), null, 16, ["class", "data-p"]))]
            })], 16, NT)), [[s]]) : Eo("", !0)], 16, OT))], 16, PT), [[yi, o.visible]])]
        }),
        _: 3
    }, 16)
};
var UT = "startsWith",
    zT = "contains",
    QT = "equals",
    GT = "notEquals";
function jT(e, t) {
    var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
        if (Array.isArray(e) || (n = function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return VT(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? VT(e, t) : void 0
            }
        }(e)) || t) {
            n && (e = n);
            var r = 0,
                o = function() {};
            return {
                s: o,
                n: function() {
                    return r >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[r++]
                    }
                },
                e: function(e) {
                    throw e
                },
                f: o
            }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
    var i,
        a = !0,
        s = !1;
    return {
        s: function() {
            n = n.call(e)
        },
        n: function() {
            var e = n.next();
            return a = e.done, e
        },
        e: function(e) {
            s = !0,
            i = e
        },
        f: function() {
            try {
                a || null == n.return || n.return()
            } finally {
                if (s)
                    throw i
            }
        }
    }
}
function VT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var HT = {
        filter: function(e, t, n, r, o) {
            var i = [];
            if (!e)
                return i;
            var a,
                s = jT(e);
            try {
                for (s.s(); !(a = s.n()).done;) {
                    var l = a.value;
                    if ("string" == typeof l) {
                        if (this.filters[r](l, n, o)) {
                            i.push(l);
                            continue
                        }
                    } else {
                        var c,
                            u = jT(t);
                        try {
                            for (u.s(); !(c = u.n()).done;) {
                                var d = lS(l, c.value);
                                if (this.filters[r](d, n, o)) {
                                    i.push(l);
                                    break
                                }
                            }
                        } catch (p) {
                            u.e(p)
                        } finally {
                            u.f()
                        }
                    }
                }
            } catch (p) {
                s.e(p)
            } finally {
                s.f()
            }
            return i
        },
        filters: {
            startsWith: function(e, t, n) {
                if (null == t || "" === t)
                    return !0;
                if (null == e)
                    return !1;
                var r = wS(t.toString()).toLocaleLowerCase(n);
                return wS(e.toString()).toLocaleLowerCase(n).slice(0, r.length) === r
            },
            contains: function(e, t, n) {
                if (null == t || "" === t)
                    return !0;
                if (null == e)
                    return !1;
                var r = wS(t.toString()).toLocaleLowerCase(n);
                return -1 !== wS(e.toString()).toLocaleLowerCase(n).indexOf(r)
            },
            notContains: function(e, t, n) {
                if (null == t || "" === t)
                    return !0;
                if (null == e)
                    return !1;
                var r = wS(t.toString()).toLocaleLowerCase(n);
                return -1 === wS(e.toString()).toLocaleLowerCase(n).indexOf(r)
            },
            endsWith: function(e, t, n) {
                if (null == t || "" === t)
                    return !0;
                if (null == e)
                    return !1;
                var r = wS(t.toString()).toLocaleLowerCase(n),
                    o = wS(e.toString()).toLocaleLowerCase(n);
                return -1 !== o.indexOf(r, o.length - r.length)
            },
            equals: function(e, t, n) {
                return null == t || "" === t || null != e && (e.getTime && t.getTime ? e.getTime() === t.getTime() : wS(e.toString()).toLocaleLowerCase(n) == wS(t.toString()).toLocaleLowerCase(n))
            },
            notEquals: function(e, t, n) {
                return null != t && "" !== t && (null == e || (e.getTime && t.getTime ? e.getTime() !== t.getTime() : wS(e.toString()).toLocaleLowerCase(n) != wS(t.toString()).toLocaleLowerCase(n)))
            },
            in: function(e, t) {
                if (null == t || 0 === t.length)
                    return !0;
                for (var n = 0; n < t.length; n++)
                    if (cS(e, t[n]))
                        return !0;
                return !1
            },
            between: function(e, t) {
                return null == t || null == t[0] || null == t[1] || null != e && (e.getTime ? t[0].getTime() <= e.getTime() && e.getTime() <= t[1].getTime() : t[0] <= e && e <= t[1])
            },
            lt: function(e, t) {
                return null == t || null != e && (e.getTime && t.getTime ? e.getTime() < t.getTime() : e < t)
            },
            lte: function(e, t) {
                return null == t || null != e && (e.getTime && t.getTime ? e.getTime() <= t.getTime() : e <= t)
            },
            gt: function(e, t) {
                return null == t || null != e && (e.getTime && t.getTime ? e.getTime() > t.getTime() : e > t)
            },
            gte: function(e, t) {
                return null == t || null != e && (e.getTime && t.getTime ? e.getTime() >= t.getTime() : e >= t)
            },
            dateIs: function(e, t) {
                return null == t || null != e && e.toDateString() === t.toDateString()
            },
            dateIsNot: function(e, t) {
                return null == t || null != e && e.toDateString() !== t.toDateString()
            },
            dateBefore: function(e, t) {
                return null == t || null != e && e.getTime() < t.getTime()
            },
            dateAfter: function(e, t) {
                return null == t || null != e && e.getTime() > t.getTime()
            }
        },
        register: function(e, t) {
            this.filters[e] = t
        }
    },
    $T = {
        name: "BlankIcon",
        extends: AT
    };
function WT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
$T.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return WT(e)
    }(a = t[0] || (t[0] = [_o("rect", {
        width: "1",
        height: "1",
        fill: "currentColor",
        "fill-opacity": "0"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return WT(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? WT(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var KT = {
    name: "CheckIcon",
    extends: AT
};
function qT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
KT.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return qT(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M4.86199 11.5948C4.78717 11.5923 4.71366 11.5745 4.64596 11.5426C4.57826 11.5107 4.51779 11.4652 4.46827 11.4091L0.753985 7.69483C0.683167 7.64891 0.623706 7.58751 0.580092 7.51525C0.536478 7.44299 0.509851 7.36177 0.502221 7.27771C0.49459 7.19366 0.506156 7.10897 0.536046 7.03004C0.565935 6.95111 0.613367 6.88 0.674759 6.82208C0.736151 6.76416 0.8099 6.72095 0.890436 6.69571C0.970973 6.67046 1.05619 6.66385 1.13966 6.67635C1.22313 6.68886 1.30266 6.72017 1.37226 6.76792C1.44186 6.81567 1.4997 6.8786 1.54141 6.95197L4.86199 10.2503L12.6397 2.49483C12.7444 2.42694 12.8689 2.39617 12.9932 2.40745C13.1174 2.41873 13.2343 2.47141 13.3251 2.55705C13.4159 2.64268 13.4753 2.75632 13.4938 2.87973C13.5123 3.00315 13.4888 3.1292 13.4271 3.23768L5.2557 11.4091C5.20618 11.4652 5.14571 11.5107 5.07801 11.5426C5.01031 11.5745 4.9368 11.5923 4.86199 11.5948Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return qT(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? qT(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var XT = {
    name: "ChevronDownIcon",
    extends: AT
};
function YT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
XT.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return YT(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M7.01744 10.398C6.91269 10.3985 6.8089 10.378 6.71215 10.3379C6.61541 10.2977 6.52766 10.2386 6.45405 10.1641L1.13907 4.84913C1.03306 4.69404 0.985221 4.5065 1.00399 4.31958C1.02276 4.13266 1.10693 3.95838 1.24166 3.82747C1.37639 3.69655 1.55301 3.61742 1.74039 3.60402C1.92777 3.59062 2.11386 3.64382 2.26584 3.75424L7.01744 8.47394L11.769 3.75424C11.9189 3.65709 12.097 3.61306 12.2748 3.62921C12.4527 3.64535 12.6199 3.72073 12.7498 3.84328C12.8797 3.96582 12.9647 4.12842 12.9912 4.30502C13.0177 4.48162 12.9841 4.662 12.8958 4.81724L7.58083 10.1322C7.50996 10.2125 7.42344 10.2775 7.32656 10.3232C7.22968 10.3689 7.12449 10.3944 7.01744 10.398Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return YT(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? YT(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var JT = {
    name: "SearchIcon",
    extends: AT
};
function ZT(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
JT.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return ZT(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M2.67602 11.0265C3.6661 11.688 4.83011 12.0411 6.02086 12.0411C6.81149 12.0411 7.59438 11.8854 8.32483 11.5828C8.87005 11.357 9.37808 11.0526 9.83317 10.6803L12.9769 13.8241C13.0323 13.8801 13.0983 13.9245 13.171 13.9548C13.2438 13.985 13.3219 14.0003 13.4007 14C13.4795 14.0003 13.5575 13.985 13.6303 13.9548C13.7031 13.9245 13.7691 13.8801 13.8244 13.8241C13.9367 13.7116 13.9998 13.5592 13.9998 13.4003C13.9998 13.2414 13.9367 13.089 13.8244 12.9765L10.6807 9.8328C11.053 9.37773 11.3573 8.86972 11.5831 8.32452C11.8857 7.59408 12.0414 6.81119 12.0414 6.02056C12.0414 4.8298 11.6883 3.66579 11.0268 2.67572C10.3652 1.68564 9.42494 0.913972 8.32483 0.45829C7.22472 0.00260857 6.01418 -0.116618 4.84631 0.115686C3.67844 0.34799 2.60568 0.921393 1.76369 1.76338C0.921698 2.60537 0.348296 3.67813 0.115991 4.84601C-0.116313 6.01388 0.00291375 7.22441 0.458595 8.32452C0.914277 9.42464 1.68595 10.3649 2.67602 11.0265ZM3.35565 2.0158C4.14456 1.48867 5.07206 1.20731 6.02086 1.20731C7.29317 1.20731 8.51338 1.71274 9.41304 2.6124C10.3127 3.51206 10.8181 4.73226 10.8181 6.00457C10.8181 6.95337 10.5368 7.88088 10.0096 8.66978C9.48251 9.45868 8.73328 10.0736 7.85669 10.4367C6.98011 10.7997 6.01554 10.8947 5.08496 10.7096C4.15439 10.5245 3.2996 10.0676 2.62869 9.39674C1.95778 8.72583 1.50089 7.87104 1.31579 6.94046C1.13068 6.00989 1.22568 5.04532 1.58878 4.16874C1.95187 3.29215 2.56675 2.54292 3.35565 2.0158Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return ZT(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ZT(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var eM = {
    name: "SpinnerIcon",
    extends: AT
};
function tM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
eM.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return tM(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return tM(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? tM(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var nM = {
        name: "IconField",
        extends: {
            name: "BaseIconField",
            extends: nT,
            style: kI.extend({
                name: "iconfield",
                style: "\n    .p-iconfield {\n        position: relative;\n        display: block;\n    }\n\n    .p-inputicon {\n        position: absolute;\n        top: 50%;\n        margin-top: calc(-1 * (dt('icon.size') / 2));\n        color: dt('iconfield.icon.color');\n        line-height: 1;\n        z-index: 1;\n    }\n\n    .p-iconfield .p-inputicon:first-child {\n        inset-inline-start: dt('form.field.padding.x');\n    }\n\n    .p-iconfield .p-inputicon:last-child {\n        inset-inline-end: dt('form.field.padding.x');\n    }\n\n    .p-iconfield .p-inputtext:not(:first-child),\n    .p-iconfield .p-inputwrapper:not(:first-child) .p-inputtext {\n        padding-inline-start: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-iconfield .p-inputtext:not(:last-child) {\n        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-iconfield:has(.p-inputfield-sm) .p-inputicon {\n        font-size: dt('form.field.sm.font.size');\n        width: dt('form.field.sm.font.size');\n        height: dt('form.field.sm.font.size');\n        margin-top: calc(-1 * (dt('form.field.sm.font.size') / 2));\n    }\n\n    .p-iconfield:has(.p-inputfield-lg) .p-inputicon {\n        font-size: dt('form.field.lg.font.size');\n        width: dt('form.field.lg.font.size');\n        height: dt('form.field.lg.font.size');\n        margin-top: calc(-1 * (dt('form.field.lg.font.size') / 2));\n    }\n",
                classes: {
                    root: "p-iconfield"
                }
            }),
            provide: function() {
                return {
                    $pcIconField: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        render: function(e, t, n, r, o, i) {
            return uo(), go("div", Mo({
                class: e.cx("root")
            }, e.ptmi("root")), [Yn(e.$slots, "default")], 16)
        }
    },
    rM = {
        name: "InputIcon",
        extends: {
            name: "BaseInputIcon",
            extends: nT,
            style: kI.extend({
                name: "inputicon",
                classes: {
                    root: "p-inputicon"
                }
            }),
            props: {
                class: null
            },
            provide: function() {
                return {
                    $pcInputIcon: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        computed: {
            containerClass: function() {
                return [this.cx("root"), this.class]
            }
        },
        render: function(e, t, n, r, o, i) {
            return uo(), go("span", Mo({
                class: i.containerClass
            }, e.ptmi("root"), {
                "aria-hidden": "true"
            }), [Yn(e.$slots, "default")], 16)
        }
    },
    oM = {
        name: "BaseInput",
        extends: rT,
        props: {
            size: {
                type: String,
                default: null
            },
            fluid: {
                type: Boolean,
                default: null
            },
            variant: {
                type: String,
                default: null
            }
        },
        inject: {
            $parentInstance: {
                default: void 0
            },
            $pcFluid: {
                default: void 0
            }
        },
        computed: {
            $variant: function() {
                var e;
                return null !== (e = this.variant) && void 0 !== e ? e : this.$primevue.config.inputStyle || this.$primevue.config.inputVariant
            },
            $fluid: function() {
                var e;
                return null !== (e = this.fluid) && void 0 !== e ? e : !!this.$pcFluid
            },
            hasFluid: function() {
                return this.$fluid
            }
        }
    };
function iM(e) {
    return (iM = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
var aM = {
        name: "InputText",
        extends: {
            name: "BaseInputText",
            extends: oM,
            style: kI.extend({
                name: "inputtext",
                style: "\n    .p-inputtext {\n        font-family: inherit;\n        font-feature-settings: inherit;\n        font-size: 1rem;\n        color: dt('inputtext.color');\n        background: dt('inputtext.background');\n        padding-block: dt('inputtext.padding.y');\n        padding-inline: dt('inputtext.padding.x');\n        border: 1px solid dt('inputtext.border.color');\n        transition:\n            background dt('inputtext.transition.duration'),\n            color dt('inputtext.transition.duration'),\n            border-color dt('inputtext.transition.duration'),\n            outline-color dt('inputtext.transition.duration'),\n            box-shadow dt('inputtext.transition.duration');\n        appearance: none;\n        border-radius: dt('inputtext.border.radius');\n        outline-color: transparent;\n        box-shadow: dt('inputtext.shadow');\n    }\n\n    .p-inputtext:enabled:hover {\n        border-color: dt('inputtext.hover.border.color');\n    }\n\n    .p-inputtext:enabled:focus {\n        border-color: dt('inputtext.focus.border.color');\n        box-shadow: dt('inputtext.focus.ring.shadow');\n        outline: dt('inputtext.focus.ring.width') dt('inputtext.focus.ring.style') dt('inputtext.focus.ring.color');\n        outline-offset: dt('inputtext.focus.ring.offset');\n    }\n\n    .p-inputtext.p-invalid {\n        border-color: dt('inputtext.invalid.border.color');\n    }\n\n    .p-inputtext.p-variant-filled {\n        background: dt('inputtext.filled.background');\n    }\n\n    .p-inputtext.p-variant-filled:enabled:hover {\n        background: dt('inputtext.filled.hover.background');\n    }\n\n    .p-inputtext.p-variant-filled:enabled:focus {\n        background: dt('inputtext.filled.focus.background');\n    }\n\n    .p-inputtext:disabled {\n        opacity: 1;\n        background: dt('inputtext.disabled.background');\n        color: dt('inputtext.disabled.color');\n    }\n\n    .p-inputtext::placeholder {\n        color: dt('inputtext.placeholder.color');\n    }\n\n    .p-inputtext.p-invalid::placeholder {\n        color: dt('inputtext.invalid.placeholder.color');\n    }\n\n    .p-inputtext-sm {\n        font-size: dt('inputtext.sm.font.size');\n        padding-block: dt('inputtext.sm.padding.y');\n        padding-inline: dt('inputtext.sm.padding.x');\n    }\n\n    .p-inputtext-lg {\n        font-size: dt('inputtext.lg.font.size');\n        padding-block: dt('inputtext.lg.padding.y');\n        padding-inline: dt('inputtext.lg.padding.x');\n    }\n\n    .p-inputtext-fluid {\n        width: 100%;\n    }\n",
                classes: {
                    root: function(e) {
                        var t = e.instance,
                            n = e.props;
                        return ["p-inputtext p-component", {
                            "p-filled": t.$filled,
                            "p-inputtext-sm p-inputfield-sm": "small" === n.size,
                            "p-inputtext-lg p-inputfield-lg": "large" === n.size,
                            "p-invalid": t.$invalid,
                            "p-variant-filled": "filled" === t.$variant,
                            "p-inputtext-fluid": t.$fluid
                        }]
                    }
                }
            }),
            provide: function() {
                return {
                    $pcInputText: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        methods: {
            onInput: function(e) {
                this.writeValue(e.target.value, e)
            }
        },
        computed: {
            attrs: function() {
                return Mo(this.ptmi("root", {
                    context: {
                        filled: this.$filled,
                        disabled: this.disabled
                    }
                }), this.formField)
            },
            dataP: function() {
                return RS((e = {
                    invalid: this.$invalid,
                    fluid: this.$fluid,
                    filled: "filled" === this.$variant
                }, t = this.size, n = this.size, (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != iM(e) || !e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t);
                            if ("object" != iM(r))
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(e)
                    }(e, "string");
                    return "symbol" == iM(t) ? t : t + ""
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e));
                var e,
                    t,
                    n
            }
        }
    },
    sM = ["value", "name", "disabled", "aria-invalid", "data-p"];
aM.render = function(e, t, n, r, o, i) {
    return uo(), go("input", Mo({
        type: "text",
        class: e.cx("root"),
        value: e.d_value,
        name: e.name,
        disabled: e.disabled,
        "aria-invalid": e.$invalid || void 0,
        "data-p": i.dataP,
        onInput: t[0] || (t[0] = function() {
            return i.onInput && i.onInput.apply(i, arguments)
        })
    }, i.attrs), null, 16, sM)
};
var lM = BS(),
    cM = {
        name: "Portal",
        props: {
            appendTo: {
                type: [String, Object],
                default: "body"
            },
            disabled: {
                type: Boolean,
                default: !1
            }
        },
        data: function() {
            return {
                mounted: !1
            }
        },
        mounted: function() {
            this.mounted = WE()
        },
        computed: {
            inline: function() {
                return this.disabled || "self" === this.appendTo
            }
        },
        render: function(e, t, n, r, o, i) {
            return i.inline ? Yn(e.$slots, "default", {
                key: 0
            }) : o.mounted ? (uo(), mo(nn, {
                key: 1,
                to: n.appendTo
            }, [Yn(e.$slots, "default")], 8, ["to"])) : Eo("", !0)
        }
    },
    uM = kI.extend({
        name: "virtualscroller",
        css: "\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n\n.p-virtualscroller .p-virtualscroller-loading {\n    transform: none !important;\n    min-height: 0;\n    position: sticky;\n    inset-block-start: 0;\n    inset-inline-start: 0;\n}\n",
        style: "\n    .p-virtualscroller-loader {\n        background: dt('virtualscroller.loader.mask.background');\n        color: dt('virtualscroller.loader.mask.color');\n    }\n\n    .p-virtualscroller-loading-icon {\n        font-size: dt('virtualscroller.loader.icon.size');\n        width: dt('virtualscroller.loader.icon.size');\n        height: dt('virtualscroller.loader.icon.size');\n    }\n"
    });
function dM(e) {
    return (dM = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function pM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function hM(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? pM(Object(n), !0).forEach(function(t) {
            fM(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pM(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function fM(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != dM(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != dM(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == dM(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var gM = {
        name: "VirtualScroller",
        extends: {
            name: "BaseVirtualScroller",
            extends: nT,
            props: {
                id: {
                    type: String,
                    default: null
                },
                style: null,
                class: null,
                items: {
                    type: Array,
                    default: null
                },
                itemSize: {
                    type: [Number, Array],
                    default: 0
                },
                scrollHeight: null,
                scrollWidth: null,
                orientation: {
                    type: String,
                    default: "vertical"
                },
                numToleratedItems: {
                    type: Number,
                    default: null
                },
                delay: {
                    type: Number,
                    default: 0
                },
                resizeDelay: {
                    type: Number,
                    default: 10
                },
                lazy: {
                    type: Boolean,
                    default: !1
                },
                disabled: {
                    type: Boolean,
                    default: !1
                },
                loaderDisabled: {
                    type: Boolean,
                    default: !1
                },
                columns: {
                    type: Array,
                    default: null
                },
                loading: {
                    type: Boolean,
                    default: !1
                },
                showSpacer: {
                    type: Boolean,
                    default: !0
                },
                showLoader: {
                    type: Boolean,
                    default: !1
                },
                tabindex: {
                    type: Number,
                    default: 0
                },
                inline: {
                    type: Boolean,
                    default: !1
                },
                step: {
                    type: Number,
                    default: 0
                },
                appendOnly: {
                    type: Boolean,
                    default: !1
                },
                autoSize: {
                    type: Boolean,
                    default: !1
                }
            },
            style: uM,
            provide: function() {
                return {
                    $pcVirtualScroller: this,
                    $parentInstance: this
                }
            },
            beforeMount: function() {
                var e;
                uM.loadCSS({
                    nonce: null === (e = this.$primevueConfig) || void 0 === e || null === (e = e.csp) || void 0 === e ? void 0 : e.nonce
                })
            }
        },
        inheritAttrs: !1,
        emits: ["update:numToleratedItems", "scroll", "scroll-index-change", "lazy-load"],
        data: function() {
            var e = this.isBoth();
            return {
                first: e ? {
                    rows: 0,
                    cols: 0
                } : 0,
                last: e ? {
                    rows: 0,
                    cols: 0
                } : 0,
                page: e ? {
                    rows: 0,
                    cols: 0
                } : 0,
                numItemsInViewport: e ? {
                    rows: 0,
                    cols: 0
                } : 0,
                lastScrollPos: e ? {
                    top: 0,
                    left: 0
                } : 0,
                d_numToleratedItems: this.numToleratedItems,
                d_loading: this.loading,
                loaderArr: [],
                spacerStyle: {},
                contentStyle: {}
            }
        },
        element: null,
        content: null,
        lastScrollPos: null,
        scrollTimeout: null,
        resizeTimeout: null,
        defaultWidth: 0,
        defaultHeight: 0,
        defaultContentWidth: 0,
        defaultContentHeight: 0,
        isRangeChanged: !1,
        lazyLoadState: {},
        resizeListener: null,
        resizeObserver: null,
        initialized: !1,
        watch: {
            numToleratedItems: function(e) {
                this.d_numToleratedItems = e
            },
            loading: function(e, t) {
                this.lazy && e !== t && e !== this.d_loading && (this.d_loading = e)
            },
            items: {
                handler: function(e, t) {
                    t && t.length === (e || []).length || (this.init(), this.calculateAutoSize())
                },
                deep: !0
            },
            itemSize: function() {
                this.init(),
                this.calculateAutoSize()
            },
            orientation: function() {
                this.lastScrollPos = this.isBoth() ? {
                    top: 0,
                    left: 0
                } : 0
            },
            scrollHeight: function() {
                this.init(),
                this.calculateAutoSize()
            },
            scrollWidth: function() {
                this.init(),
                this.calculateAutoSize()
            }
        },
        mounted: function() {
            this.viewInit(),
            this.lastScrollPos = this.isBoth() ? {
                top: 0,
                left: 0
            } : 0,
            this.lazyLoadState = this.lazyLoadState || {}
        },
        updated: function() {
            !this.initialized && this.viewInit()
        },
        unmounted: function() {
            this.unbindResizeListener(),
            this.initialized = !1
        },
        methods: {
            viewInit: function() {
                qE(this.element) && (this.setContentEl(this.content), this.init(), this.calculateAutoSize(), this.defaultWidth = VE(this.element), this.defaultHeight = PE(this.element), this.defaultContentWidth = VE(this.content), this.defaultContentHeight = PE(this.content), this.initialized = !0),
                this.element && this.bindResizeListener()
            },
            init: function() {
                this.disabled || (this.setSize(), this.calculateOptions(), this.setSpacerSize())
            },
            isVertical: function() {
                return "vertical" === this.orientation
            },
            isHorizontal: function() {
                return "horizontal" === this.orientation
            },
            isBoth: function() {
                return "both" === this.orientation
            },
            scrollTo: function(e) {
                this.element && this.element.scrollTo(e)
            },
            scrollToIndex: function(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "auto",
                    r = this.isBoth(),
                    o = this.isHorizontal();
                if (r ? e.every(function(e) {
                    return e > -1
                }) : e > -1) {
                    var i = this.first,
                        a = this.element,
                        s = a.scrollTop,
                        l = void 0 === s ? 0 : s,
                        c = a.scrollLeft,
                        u = void 0 === c ? 0 : c,
                        d = this.calculateNumItems().numToleratedItems,
                        p = this.getContentPosition(),
                        h = this.itemSize,
                        f = function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                            return e <= (arguments.length > 1 ? arguments[1] : void 0) ? 0 : e
                        },
                        g = function(e, t, n) {
                            return e * t + n
                        },
                        m = function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return t.scrollTo({
                                left: e,
                                top: r,
                                behavior: n
                            })
                        },
                        b = r ? {
                            rows: 0,
                            cols: 0
                        } : 0,
                        A = !1,
                        y = !1;
                    r ? (m(g((b = {
                        rows: f(e[0], d[0]),
                        cols: f(e[1], d[1])
                    }).cols, h[1], p.left), g(b.rows, h[0], p.top)), y = this.lastScrollPos.top !== l || this.lastScrollPos.left !== u, A = b.rows !== i.rows || b.cols !== i.cols) : (b = f(e, d), o ? m(g(b, h, p.left), l) : m(u, g(b, h, p.top)), y = this.lastScrollPos !== (o ? u : l), A = b !== i),
                    this.isRangeChanged = A,
                    y && (this.first = b)
                }
            },
            scrollInView: function(e, t) {
                var n = this,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "auto";
                if (t) {
                    var o = this.isBoth(),
                        i = this.isHorizontal();
                    if (o ? e.every(function(e) {
                        return e > -1
                    }) : e > -1) {
                        var a = this.getRenderedRange(),
                            s = a.first,
                            l = a.viewport,
                            c = function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                                return n.scrollTo({
                                    left: e,
                                    top: t,
                                    behavior: r
                                })
                            },
                            u = "to-end" === t;
                        if ("to-start" === t) {
                            if (o)
                                l.first.rows - s.rows > e[0] ? c(l.first.cols * this.itemSize[1], (l.first.rows - 1) * this.itemSize[0]) : l.first.cols - s.cols > e[1] && c((l.first.cols - 1) * this.itemSize[1], l.first.rows * this.itemSize[0]);
                            else if (l.first - s > e) {
                                var d = (l.first - 1) * this.itemSize;
                                i ? c(d, 0) : c(0, d)
                            }
                        } else if (u)
                            if (o)
                                l.last.rows - s.rows <= e[0] + 1 ? c(l.first.cols * this.itemSize[1], (l.first.rows + 1) * this.itemSize[0]) : l.last.cols - s.cols <= e[1] + 1 && c((l.first.cols + 1) * this.itemSize[1], l.first.rows * this.itemSize[0]);
                            else if (l.last - s <= e + 1) {
                                var p = (l.first + 1) * this.itemSize;
                                i ? c(p, 0) : c(0, p)
                            }
                    }
                } else
                    this.scrollToIndex(e, r)
            },
            getRenderedRange: function() {
                var e = function(e, t) {
                        return Math.floor(e / (t || e))
                    },
                    t = this.first,
                    n = 0;
                if (this.element) {
                    var r = this.isBoth(),
                        o = this.isHorizontal(),
                        i = this.element,
                        a = i.scrollTop,
                        s = i.scrollLeft;
                    n = r ? {
                        rows: (t = {
                            rows: e(a, this.itemSize[0]),
                            cols: e(s, this.itemSize[1])
                        }).rows + this.numItemsInViewport.rows,
                        cols: t.cols + this.numItemsInViewport.cols
                    } : (t = e(o ? s : a, this.itemSize)) + this.numItemsInViewport
                }
                return {
                    first: this.first,
                    last: this.last,
                    viewport: {
                        first: t,
                        last: n
                    }
                }
            },
            calculateNumItems: function() {
                var e = this.isBoth(),
                    t = this.isHorizontal(),
                    n = this.itemSize,
                    r = this.getContentPosition(),
                    o = this.element ? this.element.offsetWidth - r.left : 0,
                    i = this.element ? this.element.offsetHeight - r.top : 0,
                    a = function(e, t) {
                        return Math.ceil(e / (t || e))
                    },
                    s = function(e) {
                        return Math.ceil(e / 2)
                    },
                    l = e ? {
                        rows: a(i, n[0]),
                        cols: a(o, n[1])
                    } : a(t ? o : i, n);
                return {
                    numItemsInViewport: l,
                    numToleratedItems: this.d_numToleratedItems || (e ? [s(l.rows), s(l.cols)] : s(l))
                }
            },
            calculateOptions: function() {
                var e = this,
                    t = this.isBoth(),
                    n = this.first,
                    r = this.calculateNumItems(),
                    o = r.numItemsInViewport,
                    i = r.numToleratedItems,
                    a = function(t, n, r) {
                        var o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                        return e.getLast(t + n + (t < r ? 2 : 3) * r, o)
                    },
                    s = t ? {
                        rows: a(n.rows, o.rows, i[0]),
                        cols: a(n.cols, o.cols, i[1], !0)
                    } : a(n, o, i);
                this.last = s,
                this.numItemsInViewport = o,
                this.d_numToleratedItems = i,
                this.$emit("update:numToleratedItems", this.d_numToleratedItems),
                this.showLoader && (this.loaderArr = t ? Array.from({
                    length: o.rows
                }).map(function() {
                    return Array.from({
                        length: o.cols
                    })
                }) : Array.from({
                    length: o
                })),
                this.lazy && Promise.resolve().then(function() {
                    var r;
                    e.lazyLoadState = {
                        first: e.step ? t ? {
                            rows: 0,
                            cols: n.cols
                        } : 0 : n,
                        last: Math.min(e.step ? e.step : s, (null === (r = e.items) || void 0 === r ? void 0 : r.length) || 0)
                    },
                    e.$emit("lazy-load", e.lazyLoadState)
                })
            },
            calculateAutoSize: function() {
                var e = this;
                this.autoSize && !this.d_loading && Promise.resolve().then(function() {
                    if (e.content) {
                        var t = e.isBoth(),
                            n = e.isHorizontal(),
                            r = e.isVertical();
                        e.content.style.minHeight = e.content.style.minWidth = "auto",
                        e.content.style.position = "relative",
                        e.element.style.contain = "none";
                        var o = [VE(e.element), PE(e.element)],
                            i = o[0],
                            a = o[1];
                        (t || n) && (e.element.style.width = i < e.defaultWidth ? i + "px" : e.scrollWidth || e.defaultWidth + "px"),
                        (t || r) && (e.element.style.height = a < e.defaultHeight ? a + "px" : e.scrollHeight || e.defaultHeight + "px"),
                        e.content.style.minHeight = e.content.style.minWidth = "",
                        e.content.style.position = "",
                        e.element.style.contain = ""
                    }
                })
            },
            getLast: function() {
                var e,
                    t,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    r = arguments.length > 1 ? arguments[1] : void 0;
                return this.items ? Math.min(r ? (null === (e = this.columns || this.items[0]) || void 0 === e ? void 0 : e.length) || 0 : (null === (t = this.items) || void 0 === t ? void 0 : t.length) || 0, n) : 0
            },
            getContentPosition: function() {
                if (this.content) {
                    var e = getComputedStyle(this.content),
                        t = parseFloat(e.paddingLeft) + Math.max(parseFloat(e.left) || 0, 0),
                        n = parseFloat(e.paddingRight) + Math.max(parseFloat(e.right) || 0, 0),
                        r = parseFloat(e.paddingTop) + Math.max(parseFloat(e.top) || 0, 0),
                        o = parseFloat(e.paddingBottom) + Math.max(parseFloat(e.bottom) || 0, 0);
                    return {
                        left: t,
                        right: n,
                        top: r,
                        bottom: o,
                        x: t + n,
                        y: r + o
                    }
                }
                return {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    x: 0,
                    y: 0
                }
            },
            setSize: function() {
                var e = this;
                if (this.element) {
                    var t = this.isBoth(),
                        n = this.isHorizontal(),
                        r = this.element.parentElement,
                        o = this.scrollWidth || "".concat(this.element.offsetWidth || r.offsetWidth, "px"),
                        i = this.scrollHeight || "".concat(this.element.offsetHeight || r.offsetHeight, "px"),
                        a = function(t, n) {
                            return e.element.style[t] = n
                        };
                    t || n ? (a("height", i), a("width", o)) : a("height", i)
                }
            },
            setSpacerSize: function() {
                var e = this,
                    t = this.items;
                if (t) {
                    var n = this.isBoth(),
                        r = this.isHorizontal(),
                        o = this.getContentPosition(),
                        i = function(t, n, r) {
                            var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                            return e.spacerStyle = hM(hM({}, e.spacerStyle), fM({}, "".concat(t), (n || []).length * r + o + "px"))
                        };
                    n ? (i("height", t, this.itemSize[0], o.y), i("width", this.columns || t[1], this.itemSize[1], o.x)) : r ? i("width", this.columns || t, this.itemSize, o.x) : i("height", t, this.itemSize, o.y)
                }
            },
            setContentPosition: function(e) {
                var t = this;
                if (this.content && !this.appendOnly) {
                    var n = this.isBoth(),
                        r = this.isHorizontal(),
                        o = e ? e.first : this.first,
                        i = function(e, t) {
                            return e * t
                        },
                        a = function() {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return t.contentStyle = hM(hM({}, t.contentStyle), {
                                transform: "translate3d(".concat(e, "px, ").concat(n, "px, 0)")
                            })
                        };
                    if (n)
                        a(i(o.cols, this.itemSize[1]), i(o.rows, this.itemSize[0]));
                    else {
                        var s = i(o, this.itemSize);
                        r ? a(s, 0) : a(0, s)
                    }
                }
            },
            onScrollPositionChange: function(e) {
                var t = this,
                    n = e.target,
                    r = this.isBoth(),
                    o = this.isHorizontal(),
                    i = this.getContentPosition(),
                    a = function(e, t) {
                        return e ? e > t ? e - t : e : 0
                    },
                    s = function(e, t) {
                        return Math.floor(e / (t || e))
                    },
                    l = function(e, t, n, r, o, i) {
                        return e <= o ? o : i ? n - r - o : t + o - 1
                    },
                    c = function(e, n, r, o, i, a, s, l) {
                        if (e <= a)
                            return 0;
                        var c = Math.max(0, s ? e < n ? r : e - a : e > n ? r : e - 2 * a),
                            u = t.getLast(c, l);
                        return c > u ? u - i : c
                    },
                    u = function(e, n, r, o, i, a) {
                        var s = n + o + 2 * i;
                        return e >= i && (s += i + 1), t.getLast(s, a)
                    },
                    d = a(n.scrollTop, i.top),
                    p = a(n.scrollLeft, i.left),
                    h = r ? {
                        rows: 0,
                        cols: 0
                    } : 0,
                    f = this.last,
                    g = !1,
                    m = this.lastScrollPos;
                if (r) {
                    var b = this.lastScrollPos.top <= d,
                        A = this.lastScrollPos.left <= p;
                    if (!this.appendOnly || this.appendOnly && (b || A)) {
                        var y = {
                                rows: s(d, this.itemSize[0]),
                                cols: s(p, this.itemSize[1])
                            },
                            v = {
                                rows: l(y.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], b),
                                cols: l(y.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], A)
                            };
                        h = {
                            rows: c(y.rows, v.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], b),
                            cols: c(y.cols, v.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], A, !0)
                        },
                        f = {
                            rows: u(y.rows, h.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),
                            cols: u(y.cols, h.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], !0)
                        },
                        g = h.rows !== this.first.rows || f.rows !== this.last.rows || h.cols !== this.first.cols || f.cols !== this.last.cols || this.isRangeChanged,
                        m = {
                            top: d,
                            left: p
                        }
                    }
                } else {
                    var _ = o ? p : d,
                        x = this.lastScrollPos <= _;
                    if (!this.appendOnly || this.appendOnly && x) {
                        var w = s(_, this.itemSize);
                        f = u(w, h = c(w, l(w, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, x), this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, x), this.last, this.numItemsInViewport, this.d_numToleratedItems),
                        g = h !== this.first || f !== this.last || this.isRangeChanged,
                        m = _
                    }
                }
                return {
                    first: h,
                    last: f,
                    isRangeChanged: g,
                    scrollPos: m
                }
            },
            onScrollChange: function(e) {
                var t = this.onScrollPositionChange(e),
                    n = t.first,
                    r = t.last,
                    o = t.isRangeChanged,
                    i = t.scrollPos;
                if (o) {
                    var a = {
                        first: n,
                        last: r
                    };
                    if (this.setContentPosition(a), this.first = n, this.last = r, this.lastScrollPos = i, this.$emit("scroll-index-change", a), this.lazy && this.isPageChanged(n)) {
                        var s,
                            l,
                            c = {
                                first: this.step ? Math.min(this.getPageByFirst(n) * this.step, ((null === (s = this.items) || void 0 === s ? void 0 : s.length) || 0) - this.step) : n,
                                last: Math.min(this.step ? (this.getPageByFirst(n) + 1) * this.step : r, (null === (l = this.items) || void 0 === l ? void 0 : l.length) || 0)
                            };
                        (this.lazyLoadState.first !== c.first || this.lazyLoadState.last !== c.last) && this.$emit("lazy-load", c),
                        this.lazyLoadState = c
                    }
                }
            },
            onScroll: function(e) {
                var t = this;
                this.$emit("scroll", e),
                this.delay ? (this.scrollTimeout && clearTimeout(this.scrollTimeout), this.isPageChanged() && (!this.d_loading && this.showLoader && (this.onScrollPositionChange(e).isRangeChanged || this.step && this.isPageChanged()) && (this.d_loading = !0), this.scrollTimeout = setTimeout(function() {
                    t.onScrollChange(e),
                    !t.d_loading || !t.showLoader || t.lazy && void 0 !== t.loading || (t.d_loading = !1, t.page = t.getPageByFirst())
                }, this.delay))) : this.onScrollChange(e)
            },
            onResize: function() {
                var e = this;
                this.resizeTimeout && clearTimeout(this.resizeTimeout),
                this.resizeTimeout = setTimeout(function() {
                    if (qE(e.element)) {
                        var t = e.isBoth(),
                            n = e.isVertical(),
                            r = e.isHorizontal(),
                            o = [VE(e.element), PE(e.element)],
                            i = o[0],
                            a = o[1],
                            s = i !== e.defaultWidth,
                            l = a !== e.defaultHeight;
                        (t ? s || l : r ? s : n && l) && (e.d_numToleratedItems = e.numToleratedItems, e.defaultWidth = i, e.defaultHeight = a, e.defaultContentWidth = VE(e.content), e.defaultContentHeight = PE(e.content), e.init())
                    }
                }, this.resizeDelay)
            },
            bindResizeListener: function() {
                var e = this;
                this.resizeListener || (this.resizeListener = this.onResize.bind(this), window.addEventListener("resize", this.resizeListener), window.addEventListener("orientationchange", this.resizeListener), this.resizeObserver = new ResizeObserver(function() {
                    e.onResize()
                }), this.resizeObserver.observe(this.element))
            },
            unbindResizeListener: function() {
                this.resizeListener && (window.removeEventListener("resize", this.resizeListener), window.removeEventListener("orientationchange", this.resizeListener), this.resizeListener = null),
                this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null)
            },
            getOptions: function(e) {
                var t = (this.items || []).length,
                    n = this.isBoth() ? this.first.rows + e : this.first + e;
                return {
                    index: n,
                    count: t,
                    first: 0 === n,
                    last: n === t - 1,
                    even: n % 2 == 0,
                    odd: n % 2 != 0
                }
            },
            getLoaderOptions: function(e, t) {
                var n = this.loaderArr.length;
                return hM({
                    index: e,
                    count: n,
                    first: 0 === e,
                    last: e === n - 1,
                    even: e % 2 == 0,
                    odd: e % 2 != 0
                }, t)
            },
            getPageByFirst: function(e) {
                return Math.floor(((null != e ? e : this.first) + 4 * this.d_numToleratedItems) / (this.step || 1))
            },
            isPageChanged: function(e) {
                return !(this.step && !this.lazy) || this.page !== this.getPageByFirst(null != e ? e : this.first)
            },
            setContentEl: function(e) {
                this.content = e || this.content || ME(this.element, '[data-pc-section="content"]')
            },
            elementRef: function(e) {
                this.element = e
            },
            contentRef: function(e) {
                this.content = e
            }
        },
        computed: {
            containerClass: function() {
                return ["p-virtualscroller", this.class, {
                    "p-virtualscroller-inline": this.inline,
                    "p-virtualscroller-both p-both-scroll": this.isBoth(),
                    "p-virtualscroller-horizontal p-horizontal-scroll": this.isHorizontal()
                }]
            },
            contentClass: function() {
                return ["p-virtualscroller-content", {
                    "p-virtualscroller-loading": this.d_loading
                }]
            },
            loaderClass: function() {
                return ["p-virtualscroller-loader", {
                    "p-virtualscroller-loader-mask": !this.$slots.loader
                }]
            },
            loadedItems: function() {
                var e = this;
                return this.items && !this.d_loading ? this.isBoth() ? this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map(function(t) {
                    return e.columns ? t : t.slice(e.appendOnly ? 0 : e.first.cols, e.last.cols)
                }) : this.isHorizontal() && this.columns ? this.items : this.items.slice(this.appendOnly ? 0 : this.first, this.last) : []
            },
            loadedRows: function() {
                return this.d_loading ? this.loaderDisabled ? this.loaderArr : [] : this.loadedItems
            },
            loadedColumns: function() {
                if (this.columns) {
                    var e = this.isBoth(),
                        t = this.isHorizontal();
                    if (e || t)
                        return this.d_loading && this.loaderDisabled ? e ? this.loaderArr[0] : this.loaderArr : this.columns.slice(e ? this.first.cols : this.first, e ? this.last.cols : this.last)
                }
                return this.columns
            }
        },
        components: {
            SpinnerIcon: eM
        }
    },
    mM = ["tabindex"];
gM.render = function(e, t, n, r, o, i) {
    var a = jn("SpinnerIcon");
    return e.disabled ? (uo(), go(oo, {
        key: 1
    }, [Yn(e.$slots, "default"), Yn(e.$slots, "content", {
        items: e.items,
        rows: e.items,
        columns: i.loadedColumns
    })], 64)) : (uo(), go("div", Mo({
        key: 0,
        ref: i.elementRef,
        class: i.containerClass,
        tabindex: e.tabindex,
        style: e.style,
        onScroll: t[0] || (t[0] = function() {
            return i.onScroll && i.onScroll.apply(i, arguments)
        })
    }, e.ptmi("root")), [Yn(e.$slots, "content", {
        styleClass: i.contentClass,
        items: i.loadedItems,
        getItemOptions: i.getOptions,
        loading: o.d_loading,
        getLoaderOptions: i.getLoaderOptions,
        itemSize: e.itemSize,
        rows: i.loadedRows,
        columns: i.loadedColumns,
        contentRef: i.contentRef,
        spacerStyle: o.spacerStyle,
        contentStyle: o.contentStyle,
        vertical: i.isVertical(),
        horizontal: i.isHorizontal(),
        both: i.isBoth()
    }, function() {
        return [_o("div", Mo({
            ref: i.contentRef,
            class: i.contentClass,
            style: o.contentStyle
        }, e.ptm("content")), [(uo(!0), go(oo, null, qn(i.loadedItems, function(t, n) {
            return Yn(e.$slots, "item", {
                key: n,
                item: t,
                options: i.getOptions(n)
            })
        }), 128))], 16)]
    }), e.showSpacer ? (uo(), go("div", Mo({
        key: 0,
        class: "p-virtualscroller-spacer",
        style: o.spacerStyle
    }, e.ptm("spacer")), null, 16)) : Eo("", !0), !e.loaderDisabled && e.showLoader && o.d_loading ? (uo(), go("div", Mo({
        key: 1,
        class: i.loaderClass
    }, e.ptm("loader")), [e.$slots && e.$slots.loader ? (uo(!0), go(oo, {
        key: 0
    }, qn(o.loaderArr, function(t, n) {
        return Yn(e.$slots, "loader", {
            key: n,
            options: i.getLoaderOptions(n, i.isBoth() && {
                numCols: e.d_numItemsInViewport.cols
            })
        })
    }), 128)) : Eo("", !0), Yn(e.$slots, "loadingicon", {}, function() {
        return [xo(a, Mo({
            spin: "",
            class: "p-virtualscroller-loading-icon"
        }, e.ptm("loadingIcon")), null, 16)]
    })], 16)) : Eo("", !0)], 16, mM))
};
var bM = kI.extend({
    name: "select",
    style: "\n    .p-select {\n        display: inline-flex;\n        cursor: pointer;\n        position: relative;\n        user-select: none;\n        background: dt('select.background');\n        border: 1px solid dt('select.border.color');\n        transition:\n            background dt('select.transition.duration'),\n            color dt('select.transition.duration'),\n            border-color dt('select.transition.duration'),\n            outline-color dt('select.transition.duration'),\n            box-shadow dt('select.transition.duration');\n        border-radius: dt('select.border.radius');\n        outline-color: transparent;\n        box-shadow: dt('select.shadow');\n    }\n\n    .p-select:not(.p-disabled):hover {\n        border-color: dt('select.hover.border.color');\n    }\n\n    .p-select:not(.p-disabled).p-focus {\n        border-color: dt('select.focus.border.color');\n        box-shadow: dt('select.focus.ring.shadow');\n        outline: dt('select.focus.ring.width') dt('select.focus.ring.style') dt('select.focus.ring.color');\n        outline-offset: dt('select.focus.ring.offset');\n    }\n\n    .p-select.p-variant-filled {\n        background: dt('select.filled.background');\n    }\n\n    .p-select.p-variant-filled:not(.p-disabled):hover {\n        background: dt('select.filled.hover.background');\n    }\n\n    .p-select.p-variant-filled:not(.p-disabled).p-focus {\n        background: dt('select.filled.focus.background');\n    }\n\n    .p-select.p-invalid {\n        border-color: dt('select.invalid.border.color');\n    }\n\n    .p-select.p-disabled {\n        opacity: 1;\n        background: dt('select.disabled.background');\n    }\n\n    .p-select-clear-icon {\n        align-self: center;\n        color: dt('select.clear.icon.color');\n        inset-inline-end: dt('select.dropdown.width');\n    }\n\n    .p-select-dropdown {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        background: transparent;\n        color: dt('select.dropdown.color');\n        width: dt('select.dropdown.width');\n        border-start-end-radius: dt('select.border.radius');\n        border-end-end-radius: dt('select.border.radius');\n    }\n\n    .p-select-label {\n        display: block;\n        white-space: nowrap;\n        overflow: hidden;\n        flex: 1 1 auto;\n        width: 1%;\n        padding: dt('select.padding.y') dt('select.padding.x');\n        text-overflow: ellipsis;\n        cursor: pointer;\n        color: dt('select.color');\n        background: transparent;\n        border: 0 none;\n        outline: 0 none;\n        font-size: 1rem;\n    }\n\n    .p-select-label.p-placeholder {\n        color: dt('select.placeholder.color');\n    }\n\n    .p-select.p-invalid .p-select-label.p-placeholder {\n        color: dt('select.invalid.placeholder.color');\n    }\n\n    .p-select.p-disabled .p-select-label {\n        color: dt('select.disabled.color');\n    }\n\n    .p-select-label-empty {\n        overflow: hidden;\n        opacity: 0;\n    }\n\n    input.p-select-label {\n        cursor: default;\n    }\n\n    .p-select-overlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background: dt('select.overlay.background');\n        color: dt('select.overlay.color');\n        border: 1px solid dt('select.overlay.border.color');\n        border-radius: dt('select.overlay.border.radius');\n        box-shadow: dt('select.overlay.shadow');\n        min-width: 100%;\n    }\n\n    .p-select-header {\n        padding: dt('select.list.header.padding');\n    }\n\n    .p-select-filter {\n        width: 100%;\n    }\n\n    .p-select-list-container {\n        overflow: auto;\n    }\n\n    .p-select-option-group {\n        cursor: auto;\n        margin: 0;\n        padding: dt('select.option.group.padding');\n        background: dt('select.option.group.background');\n        color: dt('select.option.group.color');\n        font-weight: dt('select.option.group.font.weight');\n    }\n\n    .p-select-list {\n        margin: 0;\n        padding: 0;\n        list-style-type: none;\n        padding: dt('select.list.padding');\n        gap: dt('select.list.gap');\n        display: flex;\n        flex-direction: column;\n    }\n\n    .p-select-option {\n        cursor: pointer;\n        font-weight: normal;\n        white-space: nowrap;\n        position: relative;\n        overflow: hidden;\n        display: flex;\n        align-items: center;\n        padding: dt('select.option.padding');\n        border: 0 none;\n        color: dt('select.option.color');\n        background: transparent;\n        transition:\n            background dt('select.transition.duration'),\n            color dt('select.transition.duration'),\n            border-color dt('select.transition.duration'),\n            box-shadow dt('select.transition.duration'),\n            outline-color dt('select.transition.duration');\n        border-radius: dt('select.option.border.radius');\n    }\n\n    .p-select-option:not(.p-select-option-selected):not(.p-disabled).p-focus {\n        background: dt('select.option.focus.background');\n        color: dt('select.option.focus.color');\n    }\n\n    .p-select-option.p-select-option-selected {\n        background: dt('select.option.selected.background');\n        color: dt('select.option.selected.color');\n    }\n\n    .p-select-option.p-select-option-selected.p-focus {\n        background: dt('select.option.selected.focus.background');\n        color: dt('select.option.selected.focus.color');\n    }\n\n    .p-select-option-blank-icon {\n        flex-shrink: 0;\n    }\n\n    .p-select-option-check-icon {\n        position: relative;\n        flex-shrink: 0;\n        margin-inline-start: dt('select.checkmark.gutter.start');\n        margin-inline-end: dt('select.checkmark.gutter.end');\n        color: dt('select.checkmark.color');\n    }\n\n    .p-select-empty-message {\n        padding: dt('select.empty.message.padding');\n    }\n\n    .p-select-fluid {\n        display: flex;\n        width: 100%;\n    }\n\n    .p-select-sm .p-select-label {\n        font-size: dt('select.sm.font.size');\n        padding-block: dt('select.sm.padding.y');\n        padding-inline: dt('select.sm.padding.x');\n    }\n\n    .p-select-sm .p-select-dropdown .p-icon {\n        font-size: dt('select.sm.font.size');\n        width: dt('select.sm.font.size');\n        height: dt('select.sm.font.size');\n    }\n\n    .p-select-lg .p-select-label {\n        font-size: dt('select.lg.font.size');\n        padding-block: dt('select.lg.padding.y');\n        padding-inline: dt('select.lg.padding.x');\n    }\n\n    .p-select-lg .p-select-dropdown .p-icon {\n        font-size: dt('select.lg.font.size');\n        width: dt('select.lg.font.size');\n        height: dt('select.lg.font.size');\n    }\n\n    .p-floatlabel-in .p-select-filter {\n        padding-block-start: dt('select.padding.y');\n        padding-block-end: dt('select.padding.y');\n    }\n",
    classes: {
        root: function(e) {
            var t = e.instance,
                n = e.props,
                r = e.state;
            return ["p-select p-component p-inputwrapper", {
                "p-disabled": n.disabled,
                "p-invalid": t.$invalid,
                "p-variant-filled": "filled" === t.$variant,
                "p-focus": r.focused,
                "p-inputwrapper-filled": t.$filled,
                "p-inputwrapper-focus": r.focused || r.overlayVisible,
                "p-select-open": r.overlayVisible,
                "p-select-fluid": t.$fluid,
                "p-select-sm p-inputfield-sm": "small" === n.size,
                "p-select-lg p-inputfield-lg": "large" === n.size
            }]
        },
        label: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-select-label", {
                "p-placeholder": !n.editable && t.label === n.placeholder,
                "p-select-label-empty": !(n.editable || t.$slots.value || "p-emptylabel" !== t.label && 0 !== t.label.length)
            }]
        },
        clearIcon: "p-select-clear-icon",
        dropdown: "p-select-dropdown",
        loadingicon: "p-select-loading-icon",
        dropdownIcon: "p-select-dropdown-icon",
        overlay: "p-select-overlay p-component",
        header: "p-select-header",
        pcFilter: "p-select-filter",
        listContainer: "p-select-list-container",
        list: "p-select-list",
        optionGroup: "p-select-option-group",
        optionGroupLabel: "p-select-option-group-label",
        option: function(e) {
            var t = e.instance,
                n = e.props,
                r = e.state,
                o = e.option,
                i = e.focusedOption;
            return ["p-select-option", {
                "p-select-option-selected": t.isSelected(o) && n.highlightOnSelect,
                "p-focus": r.focusedOptionIndex === i,
                "p-disabled": t.isOptionDisabled(o)
            }]
        },
        optionLabel: "p-select-option-label",
        optionCheckIcon: "p-select-option-check-icon",
        optionBlankIcon: "p-select-option-blank-icon",
        emptyMessage: "p-select-empty-message"
    }
});
function AM(e) {
    return (AM = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function yM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function vM(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function _M(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? vM(Object(n), !0).forEach(function(t) {
            xM(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vM(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function xM(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != AM(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != AM(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == AM(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var wM = {
        name: "Select",
        extends: {
            name: "BaseSelect",
            extends: oM,
            props: {
                options: Array,
                optionLabel: [String, Function],
                optionValue: [String, Function],
                optionDisabled: [String, Function],
                optionGroupLabel: [String, Function],
                optionGroupChildren: [String, Function],
                scrollHeight: {
                    type: String,
                    default: "14rem"
                },
                filter: Boolean,
                filterPlaceholder: String,
                filterLocale: String,
                filterMatchMode: {
                    type: String,
                    default: "contains"
                },
                filterFields: {
                    type: Array,
                    default: null
                },
                editable: Boolean,
                placeholder: {
                    type: String,
                    default: null
                },
                dataKey: null,
                showClear: {
                    type: Boolean,
                    default: !1
                },
                inputId: {
                    type: String,
                    default: null
                },
                inputClass: {
                    type: [String, Object],
                    default: null
                },
                inputStyle: {
                    type: Object,
                    default: null
                },
                labelId: {
                    type: String,
                    default: null
                },
                labelClass: {
                    type: [String, Object],
                    default: null
                },
                labelStyle: {
                    type: Object,
                    default: null
                },
                panelClass: {
                    type: [String, Object],
                    default: null
                },
                overlayStyle: {
                    type: Object,
                    default: null
                },
                overlayClass: {
                    type: [String, Object],
                    default: null
                },
                panelStyle: {
                    type: Object,
                    default: null
                },
                appendTo: {
                    type: [String, Object],
                    default: "body"
                },
                loading: {
                    type: Boolean,
                    default: !1
                },
                clearIcon: {
                    type: String,
                    default: void 0
                },
                dropdownIcon: {
                    type: String,
                    default: void 0
                },
                filterIcon: {
                    type: String,
                    default: void 0
                },
                loadingIcon: {
                    type: String,
                    default: void 0
                },
                resetFilterOnHide: {
                    type: Boolean,
                    default: !1
                },
                resetFilterOnClear: {
                    type: Boolean,
                    default: !1
                },
                virtualScrollerOptions: {
                    type: Object,
                    default: null
                },
                autoOptionFocus: {
                    type: Boolean,
                    default: !1
                },
                autoFilterFocus: {
                    type: Boolean,
                    default: !1
                },
                selectOnFocus: {
                    type: Boolean,
                    default: !1
                },
                focusOnHover: {
                    type: Boolean,
                    default: !0
                },
                highlightOnSelect: {
                    type: Boolean,
                    default: !0
                },
                checkmark: {
                    type: Boolean,
                    default: !1
                },
                filterMessage: {
                    type: String,
                    default: null
                },
                selectionMessage: {
                    type: String,
                    default: null
                },
                emptySelectionMessage: {
                    type: String,
                    default: null
                },
                emptyFilterMessage: {
                    type: String,
                    default: null
                },
                emptyMessage: {
                    type: String,
                    default: null
                },
                tabindex: {
                    type: Number,
                    default: 0
                },
                ariaLabel: {
                    type: String,
                    default: null
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                }
            },
            style: bM,
            provide: function() {
                return {
                    $pcSelect: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change", "focus", "blur", "before-show", "before-hide", "show", "hide", "filter"],
        outsideClickListener: null,
        scrollHandler: null,
        resizeListener: null,
        labelClickListener: null,
        matchMediaOrientationListener: null,
        overlay: null,
        list: null,
        virtualScroller: null,
        searchTimeout: null,
        searchValue: null,
        isModelValueChanged: !1,
        data: function() {
            return {
                clicked: !1,
                focused: !1,
                focusedOptionIndex: -1,
                filterValue: null,
                overlayVisible: !1,
                queryOrientation: null
            }
        },
        watch: {
            modelValue: function() {
                this.isModelValueChanged = !0
            },
            options: function() {
                this.autoUpdateModel()
            }
        },
        mounted: function() {
            this.autoUpdateModel(),
            this.bindLabelClickListener(),
            this.bindMatchMediaOrientationListener()
        },
        updated: function() {
            this.overlayVisible && this.isModelValueChanged && this.scrollInView(this.findSelectedOptionIndex()),
            this.isModelValueChanged = !1
        },
        beforeUnmount: function() {
            this.unbindOutsideClickListener(),
            this.unbindResizeListener(),
            this.unbindLabelClickListener(),
            this.unbindMatchMediaOrientationListener(),
            this.scrollHandler && (this.scrollHandler.destroy(), this.scrollHandler = null),
            this.overlay && (MS.clear(this.overlay), this.overlay = null)
        },
        methods: {
            getOptionIndex: function(e, t) {
                return this.virtualScrollerDisabled ? e : t && t(e).index
            },
            getOptionLabel: function(e) {
                return this.optionLabel ? lS(e, this.optionLabel) : e
            },
            getOptionValue: function(e) {
                return this.optionValue ? lS(e, this.optionValue) : e
            },
            getOptionRenderKey: function(e, t) {
                return (this.dataKey ? lS(e, this.dataKey) : this.getOptionLabel(e)) + "_" + t
            },
            getPTItemOptions: function(e, t, n, r) {
                return this.ptm(r, {
                    context: {
                        option: e,
                        index: n,
                        selected: this.isSelected(e),
                        focused: this.focusedOptionIndex === this.getOptionIndex(n, t),
                        disabled: this.isOptionDisabled(e)
                    }
                })
            },
            isOptionDisabled: function(e) {
                return !!this.optionDisabled && lS(e, this.optionDisabled)
            },
            isOptionGroup: function(e) {
                return this.optionGroupLabel && e.optionGroup && e.group
            },
            getOptionGroupLabel: function(e) {
                return lS(e, this.optionGroupLabel)
            },
            getOptionGroupChildren: function(e) {
                return lS(e, this.optionGroupChildren)
            },
            getAriaPosInset: function(e) {
                var t = this;
                return (this.optionGroupLabel ? e - this.visibleOptions.slice(0, e).filter(function(e) {
                    return t.isOptionGroup(e)
                }).length : e) + 1
            },
            show: function(e) {
                this.$emit("before-show"),
                this.overlayVisible = !0,
                this.focusedOptionIndex = -1 !== this.focusedOptionIndex ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex(),
                e && RE(this.$refs.focusInput)
            },
            hide: function(e) {
                var t = this;
                setTimeout(function() {
                    t.$emit("before-hide"),
                    t.overlayVisible = !1,
                    t.clicked = !1,
                    t.focusedOptionIndex = -1,
                    t.searchValue = "",
                    t.resetFilterOnHide && (t.filterValue = null),
                    e && RE(t.$refs.focusInput)
                }, 0)
            },
            onFocus: function(e) {
                this.disabled || (this.focused = !0, this.overlayVisible && (this.focusedOptionIndex = -1 !== this.focusedOptionIndex ? this.focusedOptionIndex : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.editable ? -1 : this.findSelectedOptionIndex(), this.scrollInView(this.focusedOptionIndex)), this.$emit("focus", e))
            },
            onBlur: function(e) {
                var t = this;
                setTimeout(function() {
                    var n,
                        r;
                    t.focused = !1,
                    t.focusedOptionIndex = -1,
                    t.searchValue = "",
                    t.$emit("blur", e),
                    null === (n = (r = t.formField).onBlur) || void 0 === n || n.call(r, e)
                }, 100)
            },
            onKeyDown: function(e) {
                if (this.disabled)
                    e.preventDefault();
                else {
                    if (/(android)/i.test(navigator.userAgent))
                        switch (e.code) {
                        case "Backspace":
                            this.onBackspaceKey(e, this.editable);
                            break;
                        case "Enter":
                        case "NumpadDecimal":
                            this.onEnterKey(e);
                            break;
                        default:
                            return void e.preventDefault()
                        }
                    var t = e.metaKey || e.ctrlKey;
                    switch (e.code) {
                    case "ArrowDown":
                        this.onArrowDownKey(e);
                        break;
                    case "ArrowUp":
                        this.onArrowUpKey(e, this.editable);
                        break;
                    case "ArrowLeft":
                    case "ArrowRight":
                        this.onArrowLeftKey(e, this.editable);
                        break;
                    case "Home":
                        this.onHomeKey(e, this.editable);
                        break;
                    case "End":
                        this.onEndKey(e, this.editable);
                        break;
                    case "PageDown":
                        this.onPageDownKey(e);
                        break;
                    case "PageUp":
                        this.onPageUpKey(e);
                        break;
                    case "Space":
                        this.onSpaceKey(e, this.editable);
                        break;
                    case "Enter":
                    case "NumpadEnter":
                        this.onEnterKey(e);
                        break;
                    case "Escape":
                        this.onEscapeKey(e);
                        break;
                    case "Tab":
                        this.onTabKey(e);
                        break;
                    case "Backspace":
                        this.onBackspaceKey(e, this.editable);
                        break;
                    case "ShiftLeft":
                    case "ShiftRight":
                        break;
                    default:
                        !t && function(e="") {
                            return sS(e) && 1 === e.length && !!e.match(/\S| /)
                        }(e.key) && (!this.overlayVisible && this.show(), !this.editable && this.searchOptions(e, e.key), this.filter && (this.filterValue = e.key))
                    }
                    this.clicked = !1
                }
            },
            onEditableInput: function(e) {
                var t = e.target.value;
                this.searchValue = "",
                !this.searchOptions(e, t) && (this.focusedOptionIndex = -1),
                this.updateModel(e, t),
                !this.overlayVisible && sS(t) && this.show()
            },
            onContainerClick: function(e) {
                this.disabled || this.loading || "INPUT" === e.target.tagName || "clearicon" === e.target.getAttribute("data-pc-section") || e.target.closest('[data-pc-section="clearicon"]') || (this.overlay && this.overlay.contains(e.target) || (this.overlayVisible ? this.hide(!0) : this.show(!0)), this.clicked = !0)
            },
            onClearClick: function(e) {
                this.updateModel(e, null),
                this.resetFilterOnClear && (this.filterValue = null)
            },
            onFirstHiddenFocus: function(e) {
                RE(e.relatedTarget === this.$refs.focusInput ? DE(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput)
            },
            onLastHiddenFocus: function(e) {
                RE(e.relatedTarget === this.$refs.focusInput ? LE(this.overlay, ':not([data-p-hidden-focusable="true"])') : this.$refs.focusInput)
            },
            onOptionSelect: function(e, t) {
                var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    r = this.getOptionValue(t);
                this.updateModel(e, r),
                n && this.hide(!0)
            },
            onOptionMouseMove: function(e, t) {
                this.focusOnHover && this.changeFocusedOptionIndex(e, t)
            },
            onFilterChange: function(e) {
                var t = e.target.value;
                this.filterValue = t,
                this.focusedOptionIndex = -1,
                this.$emit("filter", {
                    originalEvent: e,
                    value: t
                }),
                !this.virtualScrollerDisabled && this.virtualScroller.scrollToIndex(0)
            },
            onFilterKeyDown: function(e) {
                if (!e.isComposing)
                    switch (e.code) {
                    case "ArrowDown":
                        this.onArrowDownKey(e);
                        break;
                    case "ArrowUp":
                        this.onArrowUpKey(e, !0);
                        break;
                    case "ArrowLeft":
                    case "ArrowRight":
                        this.onArrowLeftKey(e, !0);
                        break;
                    case "Home":
                        this.onHomeKey(e, !0);
                        break;
                    case "End":
                        this.onEndKey(e, !0);
                        break;
                    case "Enter":
                    case "NumpadEnter":
                        this.onEnterKey(e);
                        break;
                    case "Escape":
                        this.onEscapeKey(e);
                        break;
                    case "Tab":
                        this.onTabKey(e)
                    }
            },
            onFilterBlur: function() {
                this.focusedOptionIndex = -1
            },
            onFilterUpdated: function() {
                this.overlayVisible && this.alignOverlay()
            },
            onOverlayClick: function(e) {
                lM.emit("overlay-click", {
                    originalEvent: e,
                    target: this.$el
                })
            },
            onOverlayKeyDown: function(e) {
                "Escape" === e.code && this.onEscapeKey(e)
            },
            onArrowDownKey: function(e) {
                if (this.overlayVisible) {
                    var t = -1 !== this.focusedOptionIndex ? this.findNextOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findFirstOptionIndex() : this.findFirstFocusedOptionIndex();
                    this.changeFocusedOptionIndex(e, t)
                } else
                    this.show(),
                    this.editable && this.changeFocusedOptionIndex(e, this.findSelectedOptionIndex());
                e.preventDefault()
            },
            onArrowUpKey: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (e.altKey && !t)
                    -1 !== this.focusedOptionIndex && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]),
                    this.overlayVisible && this.hide(),
                    e.preventDefault();
                else {
                    var n = -1 !== this.focusedOptionIndex ? this.findPrevOptionIndex(this.focusedOptionIndex) : this.clicked ? this.findLastOptionIndex() : this.findLastFocusedOptionIndex();
                    this.changeFocusedOptionIndex(e, n),
                    !this.overlayVisible && this.show(),
                    e.preventDefault()
                }
            },
            onArrowLeftKey: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && (this.focusedOptionIndex = -1)
            },
            onHomeKey: function(e) {
                if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
                    var t = e.currentTarget;
                    e.shiftKey ? t.setSelectionRange(0, e.target.selectionStart) : (t.setSelectionRange(0, 0), this.focusedOptionIndex = -1)
                } else
                    this.changeFocusedOptionIndex(e, this.findFirstOptionIndex()),
                    !this.overlayVisible && this.show();
                e.preventDefault()
            },
            onEndKey: function(e) {
                if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) {
                    var t = e.currentTarget;
                    if (e.shiftKey)
                        t.setSelectionRange(e.target.selectionStart, t.value.length);
                    else {
                        var n = t.value.length;
                        t.setSelectionRange(n, n),
                        this.focusedOptionIndex = -1
                    }
                } else
                    this.changeFocusedOptionIndex(e, this.findLastOptionIndex()),
                    !this.overlayVisible && this.show();
                e.preventDefault()
            },
            onPageUpKey: function(e) {
                this.scrollInView(0),
                e.preventDefault()
            },
            onPageDownKey: function(e) {
                this.scrollInView(this.visibleOptions.length - 1),
                e.preventDefault()
            },
            onEnterKey: function(e) {
                this.overlayVisible ? (-1 !== this.focusedOptionIndex && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]), this.hide(!0)) : (this.focusedOptionIndex = -1, this.onArrowDownKey(e)),
                e.preventDefault()
            },
            onSpaceKey: function(e) {
                !(arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) && this.onEnterKey(e)
            },
            onEscapeKey: function(e) {
                this.overlayVisible && this.hide(!0),
                e.preventDefault(),
                e.stopPropagation()
            },
            onTabKey: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1] || (this.overlayVisible && this.hasFocusableElements() ? (RE(this.$refs.firstHiddenFocusableElementOnOverlay), e.preventDefault()) : (-1 !== this.focusedOptionIndex && this.onOptionSelect(e, this.visibleOptions[this.focusedOptionIndex]), this.overlayVisible && this.hide(this.filter)))
            },
            onBackspaceKey: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && !this.overlayVisible && this.show()
            },
            onOverlayEnter: function(e) {
                var t = this;
                MS.set("overlay", e, this.$primevue.config.zIndex.overlay),
                vE(e, {
                    position: "absolute",
                    top: "0"
                }),
                this.alignOverlay(),
                this.scrollInView(),
                this.$attrSelector && e.setAttribute(this.$attrSelector, ""),
                setTimeout(function() {
                    t.autoFilterFocus && t.filter && RE(t.$refs.filterInput.$el),
                    t.autoUpdateModel()
                }, 1)
            },
            onOverlayAfterEnter: function() {
                this.bindOutsideClickListener(),
                this.bindScrollListener(),
                this.bindResizeListener(),
                this.$emit("show")
            },
            onOverlayLeave: function() {
                var e = this;
                this.unbindOutsideClickListener(),
                this.unbindScrollListener(),
                this.unbindResizeListener(),
                this.autoFilterFocus && this.filter && !this.editable && this.$nextTick(function() {
                    e.$refs.filterInput && RE(e.$refs.filterInput.$el)
                }),
                this.$emit("hide"),
                this.overlay = null
            },
            onOverlayAfterLeave: function(e) {
                MS.clear(e)
            },
            alignOverlay: function() {
                "self" === this.appendTo ? function(e, t, n=!0, r) {
                    var o;
                    if (e) {
                        let i,
                            a,
                            s = e.offsetParent ? {
                                width: e.offsetWidth,
                                height: e.offsetHeight
                            } : hE(e),
                            l = t.offsetHeight,
                            c = t.getBoundingClientRect(),
                            u = fE(),
                            d = null != r ? r : "top";
                        if (!r && c.top + l + s.height > u.height ? (i = -1 * s.height, d = "bottom", c.top + i < 0 && (i = -1 * c.top)) : i = l, a = s.width > u.width ? -1 * c.left : c.left + s.width > u.width ? -1 * (c.left + s.width - u.width) : 0, e.style.top = i + "px", e.style.insetInlineStart = a + "px", e.style.transformOrigin = d, n) {
                            let t = null == (o = pE(/-anchor-gutter$/)) ? void 0 : o.value;
                            e.style.marginTop = "bottom" === d ? `calc(${null != t ? t : "2px"} * -1)` : null != t ? t : ""
                        }
                    }
                }(this.overlay, this.$el) : this.overlay && (this.overlay.style.minWidth = _E(this.$el) + "px", yE(this.overlay, this.$el))
            },
            bindOutsideClickListener: function() {
                var e = this;
                this.outsideClickListener || (this.outsideClickListener = function(t) {
                    var n = t.composedPath();
                    e.overlayVisible && e.overlay && !n.includes(e.$el) && !n.includes(e.overlay) && e.hide()
                }, document.addEventListener("click", this.outsideClickListener, !0))
            },
            unbindOutsideClickListener: function() {
                this.outsideClickListener && (document.removeEventListener("click", this.outsideClickListener, !0), this.outsideClickListener = null)
            },
            bindScrollListener: function() {
                var e = this;
                this.scrollHandler || (this.scrollHandler = new PS(this.$refs.container, function() {
                    e.overlayVisible && e.hide()
                })),
                this.scrollHandler.bindScrollListener()
            },
            unbindScrollListener: function() {
                this.scrollHandler && this.scrollHandler.unbindScrollListener()
            },
            bindResizeListener: function() {
                var e = this;
                this.resizeListener || (this.resizeListener = function() {
                    e.overlayVisible && !XE() && e.hide()
                }, window.addEventListener("resize", this.resizeListener))
            },
            unbindResizeListener: function() {
                this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null)
            },
            bindLabelClickListener: function() {
                var e = this;
                if (!this.editable && !this.labelClickListener) {
                    var t = document.querySelector('label[for="'.concat(this.labelId, '"]'));
                    t && qE(t) && (this.labelClickListener = function() {
                        RE(e.$refs.focusInput)
                    }, t.addEventListener("click", this.labelClickListener))
                }
            },
            unbindLabelClickListener: function() {
                if (this.labelClickListener) {
                    var e = document.querySelector('label[for="'.concat(this.labelId, '"]'));
                    e && qE(e) && e.removeEventListener("click", this.labelClickListener)
                }
            },
            bindMatchMediaOrientationListener: function() {
                var e = this;
                if (!this.matchMediaOrientationListener) {
                    var t = matchMedia("(orientation: portrait)");
                    this.queryOrientation = t,
                    this.matchMediaOrientationListener = function() {
                        e.alignOverlay()
                    },
                    this.queryOrientation.addEventListener("change", this.matchMediaOrientationListener)
                }
            },
            unbindMatchMediaOrientationListener: function() {
                this.matchMediaOrientationListener && (this.queryOrientation.removeEventListener("change", this.matchMediaOrientationListener), this.queryOrientation = null, this.matchMediaOrientationListener = null)
            },
            hasFocusableElements: function() {
                return kE(this.overlay, ':not([data-p-hidden-focusable="true"])').length > 0
            },
            isOptionExactMatched: function(e) {
                var t;
                return this.isValidOption(e) && "string" == typeof this.getOptionLabel(e) && (null === (t = this.getOptionLabel(e)) || void 0 === t ? void 0 : t.toLocaleLowerCase(this.filterLocale)) == this.searchValue.toLocaleLowerCase(this.filterLocale)
            },
            isOptionStartsWith: function(e) {
                var t;
                return this.isValidOption(e) && "string" == typeof this.getOptionLabel(e) && (null === (t = this.getOptionLabel(e)) || void 0 === t ? void 0 : t.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue.toLocaleLowerCase(this.filterLocale)))
            },
            isValidOption: function(e) {
                return sS(e) && !(this.isOptionDisabled(e) || this.isOptionGroup(e))
            },
            isValidSelectedOption: function(e) {
                return this.isValidOption(e) && this.isSelected(e)
            },
            isSelected: function(e) {
                return cS(this.d_value, this.getOptionValue(e), this.equalityKey)
            },
            findFirstOptionIndex: function() {
                var e = this;
                return this.visibleOptions.findIndex(function(t) {
                    return e.isValidOption(t)
                })
            },
            findLastOptionIndex: function() {
                var e = this;
                return fS(this.visibleOptions, function(t) {
                    return e.isValidOption(t)
                })
            },
            findNextOptionIndex: function(e) {
                var t = this,
                    n = e < this.visibleOptions.length - 1 ? this.visibleOptions.slice(e + 1).findIndex(function(e) {
                        return t.isValidOption(e)
                    }) : -1;
                return n > -1 ? n + e + 1 : e
            },
            findPrevOptionIndex: function(e) {
                var t = this,
                    n = e > 0 ? fS(this.visibleOptions.slice(0, e), function(e) {
                        return t.isValidOption(e)
                    }) : -1;
                return n > -1 ? n : e
            },
            findSelectedOptionIndex: function() {
                var e = this;
                return this.visibleOptions.findIndex(function(t) {
                    return e.isValidSelectedOption(t)
                })
            },
            findFirstFocusedOptionIndex: function() {
                var e = this.findSelectedOptionIndex();
                return e < 0 ? this.findFirstOptionIndex() : e
            },
            findLastFocusedOptionIndex: function() {
                var e = this.findSelectedOptionIndex();
                return e < 0 ? this.findLastOptionIndex() : e
            },
            searchOptions: function(e, t) {
                var n = this;
                this.searchValue = (this.searchValue || "") + t;
                var r = -1,
                    o = !1;
                return sS(this.searchValue) && (-1 === (r = this.visibleOptions.findIndex(function(e) {
                    return n.isOptionExactMatched(e)
                })) && (r = this.visibleOptions.findIndex(function(e) {
                    return n.isOptionStartsWith(e)
                })), -1 !== r && (o = !0), -1 === r && -1 === this.focusedOptionIndex && (r = this.findFirstFocusedOptionIndex()), -1 !== r && this.changeFocusedOptionIndex(e, r)), this.searchTimeout && clearTimeout(this.searchTimeout), this.searchTimeout = setTimeout(function() {
                    n.searchValue = "",
                    n.searchTimeout = null
                }, 500), o
            },
            changeFocusedOptionIndex: function(e, t) {
                this.focusedOptionIndex !== t && (this.focusedOptionIndex = t, this.scrollInView(), this.selectOnFocus && this.onOptionSelect(e, this.visibleOptions[t], !1))
            },
            scrollInView: function() {
                var e = this,
                    t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
                this.$nextTick(function() {
                    var n = -1 !== t ? "".concat(e.$id, "_").concat(t) : e.focusedOptionId,
                        r = ME(e.list, 'li[id="'.concat(n, '"]'));
                    r ? r.scrollIntoView && r.scrollIntoView({
                        block: "nearest",
                        inline: "nearest"
                    }) : e.virtualScrollerDisabled || e.virtualScroller && e.virtualScroller.scrollToIndex(-1 !== t ? t : e.focusedOptionIndex)
                })
            },
            autoUpdateModel: function() {
                this.autoOptionFocus && (this.focusedOptionIndex = this.findFirstFocusedOptionIndex()),
                this.selectOnFocus && this.autoOptionFocus && !this.$filled && this.onOptionSelect(null, this.visibleOptions[this.focusedOptionIndex], !1)
            },
            updateModel: function(e, t) {
                this.writeValue(t, e),
                this.$emit("change", {
                    originalEvent: e,
                    value: t
                })
            },
            flatOptions: function(e) {
                var t = this;
                return (e || []).reduce(function(e, n, r) {
                    e.push({
                        optionGroup: n,
                        group: !0,
                        index: r
                    });
                    var o = t.getOptionGroupChildren(n);
                    return o && o.forEach(function(t) {
                        return e.push(t)
                    }), e
                }, [])
            },
            overlayRef: function(e) {
                this.overlay = e
            },
            listRef: function(e, t) {
                this.list = e,
                t && t(e)
            },
            virtualScrollerRef: function(e) {
                this.virtualScroller = e
            }
        },
        computed: {
            visibleOptions: function() {
                var e = this,
                    t = this.optionGroupLabel ? this.flatOptions(this.options) : this.options || [];
                if (this.filterValue) {
                    var n = HT.filter(t, this.searchFields, this.filterValue, this.filterMatchMode, this.filterLocale);
                    if (this.optionGroupLabel) {
                        var r = this.options || [],
                            o = [];
                        return r.forEach(function(t) {
                            var r,
                                i = e.getOptionGroupChildren(t).filter(function(e) {
                                    return n.includes(e)
                                });
                            i.length > 0 && o.push(_M(_M({}, t), {}, xM({}, "string" == typeof e.optionGroupChildren ? e.optionGroupChildren : "items", function(e) {
                                if (Array.isArray(e))
                                    return yM(e)
                            }(r = i) || function(e) {
                                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                                    return Array.from(e)
                            }(r) || function(e, t) {
                                if (e) {
                                    if ("string" == typeof e)
                                        return yM(e, t);
                                    var n = {}.toString.call(e).slice(8, -1);
                                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yM(e, t) : void 0
                                }
                            }(r) || function() {
                                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }())))
                        }), this.flatOptions(o)
                    }
                    return n
                }
                return t
            },
            hasSelectedOption: function() {
                return this.$filled
            },
            label: function() {
                var e = this.findSelectedOptionIndex();
                return -1 !== e ? this.getOptionLabel(this.visibleOptions[e]) : this.placeholder || "p-emptylabel"
            },
            editableInputValue: function() {
                var e = this.findSelectedOptionIndex();
                return -1 !== e ? this.getOptionLabel(this.visibleOptions[e]) : this.d_value || ""
            },
            equalityKey: function() {
                return this.optionValue ? null : this.dataKey
            },
            searchFields: function() {
                return this.filterFields || [this.optionLabel]
            },
            filterResultMessageText: function() {
                return sS(this.visibleOptions) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions.length) : this.emptyFilterMessageText
            },
            filterMessageText: function() {
                return this.filterMessage || this.$primevue.config.locale.searchMessage || ""
            },
            emptyFilterMessageText: function() {
                return this.emptyFilterMessage || this.$primevue.config.locale.emptySearchMessage || this.$primevue.config.locale.emptyFilterMessage || ""
            },
            emptyMessageText: function() {
                return this.emptyMessage || this.$primevue.config.locale.emptyMessage || ""
            },
            selectionMessageText: function() {
                return this.selectionMessage || this.$primevue.config.locale.selectionMessage || ""
            },
            emptySelectionMessageText: function() {
                return this.emptySelectionMessage || this.$primevue.config.locale.emptySelectionMessage || ""
            },
            selectedMessageText: function() {
                return this.$filled ? this.selectionMessageText.replaceAll("{0}", "1") : this.emptySelectionMessageText
            },
            focusedOptionId: function() {
                return -1 !== this.focusedOptionIndex ? "".concat(this.$id, "_").concat(this.focusedOptionIndex) : null
            },
            ariaSetSize: function() {
                var e = this;
                return this.visibleOptions.filter(function(t) {
                    return !e.isOptionGroup(t)
                }).length
            },
            isClearIconVisible: function() {
                return this.showClear && null != this.d_value && !this.disabled && !this.loading
            },
            virtualScrollerDisabled: function() {
                return !this.virtualScrollerOptions
            },
            containerDataP: function() {
                return RS(xM({
                    invalid: this.$invalid,
                    disabled: this.disabled,
                    focus: this.focused,
                    fluid: this.$fluid,
                    filled: "filled" === this.$variant
                }, this.size, this.size))
            },
            labelDataP: function() {
                return RS(xM(xM({
                    placeholder: !this.editable && this.label === this.placeholder,
                    clearable: this.showClear,
                    disabled: this.disabled,
                    editable: this.editable
                }, this.size, this.size), "empty", !(this.editable || this.$slots.value || "p-emptylabel" !== this.label && 0 !== this.label.length)))
            },
            dropdownIconDataP: function() {
                return RS(xM({}, this.size, this.size))
            },
            overlayDataP: function() {
                return RS(xM({}, "portal-" + this.appendTo, "portal-" + this.appendTo))
            }
        },
        directives: {
            ripple: ET
        },
        components: {
            InputText: aM,
            VirtualScroller: gM,
            Portal: cM,
            InputIcon: rM,
            IconField: nM,
            TimesIcon: yT,
            ChevronDownIcon: XT,
            SpinnerIcon: eM,
            SearchIcon: JT,
            CheckIcon: KT,
            BlankIcon: $T
        }
    },
    CM = ["id", "data-p"],
    EM = ["name", "id", "value", "placeholder", "tabindex", "disabled", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid", "data-p"],
    SM = ["name", "id", "tabindex", "aria-label", "aria-labelledby", "aria-expanded", "aria-controls", "aria-activedescendant", "aria-invalid", "aria-disabled", "data-p"],
    IM = ["data-p"],
    TM = ["id"],
    MM = ["id"],
    RM = ["id", "aria-label", "aria-selected", "aria-disabled", "aria-setsize", "aria-posinset", "onMousedown", "onMousemove", "data-p-selected", "data-p-focused", "data-p-disabled"];
wM.render = function(e, t, n, r, o, i) {
    var a = jn("SpinnerIcon"),
        s = jn("InputText"),
        l = jn("SearchIcon"),
        c = jn("InputIcon"),
        u = jn("IconField"),
        d = jn("CheckIcon"),
        p = jn("BlankIcon"),
        h = jn("VirtualScroller"),
        f = jn("Portal"),
        g = $n("ripple");
    return uo(), go("div", Mo({
        ref: "container",
        id: e.$id,
        class: e.cx("root"),
        onClick: t[12] || (t[12] = function() {
            return i.onContainerClick && i.onContainerClick.apply(i, arguments)
        }),
        "data-p": i.containerDataP
    }, e.ptmi("root")), [e.editable ? (uo(), go("input", Mo({
        key: 0,
        ref: "focusInput",
        name: e.name,
        id: e.labelId || e.inputId,
        type: "text",
        class: [e.cx("label"), e.inputClass, e.labelClass],
        style: [e.inputStyle, e.labelStyle],
        value: i.editableInputValue,
        placeholder: e.placeholder,
        tabindex: e.disabled ? -1 : e.tabindex,
        disabled: e.disabled,
        autocomplete: "off",
        role: "combobox",
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledby,
        "aria-haspopup": "listbox",
        "aria-expanded": o.overlayVisible,
        "aria-controls": o.overlayVisible ? e.$id + "_list" : void 0,
        "aria-activedescendant": o.focused ? i.focusedOptionId : void 0,
        "aria-invalid": e.invalid || void 0,
        onFocus: t[0] || (t[0] = function() {
            return i.onFocus && i.onFocus.apply(i, arguments)
        }),
        onBlur: t[1] || (t[1] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        }),
        onKeydown: t[2] || (t[2] = function() {
            return i.onKeyDown && i.onKeyDown.apply(i, arguments)
        }),
        onInput: t[3] || (t[3] = function() {
            return i.onEditableInput && i.onEditableInput.apply(i, arguments)
        }),
        "data-p": i.labelDataP
    }, e.ptm("label")), null, 16, EM)) : (uo(), go("span", Mo({
        key: 1,
        ref: "focusInput",
        name: e.name,
        id: e.labelId || e.inputId,
        class: [e.cx("label"), e.inputClass, e.labelClass],
        style: [e.inputStyle, e.labelStyle],
        tabindex: e.disabled ? -1 : e.tabindex,
        role: "combobox",
        "aria-label": e.ariaLabel || ("p-emptylabel" === i.label ? void 0 : i.label),
        "aria-labelledby": e.ariaLabelledby,
        "aria-haspopup": "listbox",
        "aria-expanded": o.overlayVisible,
        "aria-controls": e.$id + "_list",
        "aria-activedescendant": o.focused ? i.focusedOptionId : void 0,
        "aria-invalid": e.invalid || void 0,
        "aria-disabled": e.disabled,
        onFocus: t[4] || (t[4] = function() {
            return i.onFocus && i.onFocus.apply(i, arguments)
        }),
        onBlur: t[5] || (t[5] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        }),
        onKeydown: t[6] || (t[6] = function() {
            return i.onKeyDown && i.onKeyDown.apply(i, arguments)
        }),
        "data-p": i.labelDataP
    }, e.ptm("label")), [Yn(e.$slots, "value", {
        value: e.d_value,
        placeholder: e.placeholder
    }, function() {
        var e;
        return [Co(W("p-emptylabel" === i.label ? "" : null !== (e = i.label) && void 0 !== e ? e : "empty"), 1)]
    })], 16, SM)), i.isClearIconVisible ? Yn(e.$slots, "clearicon", {
        key: 2,
        class: G(e.cx("clearIcon")),
        clearCallback: i.onClearClick
    }, function() {
        return [(uo(), mo(Hn(e.clearIcon ? "i" : "TimesIcon"), Mo({
            ref: "clearIcon",
            class: [e.cx("clearIcon"), e.clearIcon],
            onClick: i.onClearClick
        }, e.ptm("clearIcon"), {
            "data-pc-section": "clearicon"
        }), null, 16, ["class", "onClick"]))]
    }) : Eo("", !0), _o("div", Mo({
        class: e.cx("dropdown")
    }, e.ptm("dropdown")), [e.loading ? Yn(e.$slots, "loadingicon", {
        key: 0,
        class: G(e.cx("loadingIcon"))
    }, function() {
        return [e.loadingIcon ? (uo(), go("span", Mo({
            key: 0,
            class: [e.cx("loadingIcon"), "pi-spin", e.loadingIcon],
            "aria-hidden": "true"
        }, e.ptm("loadingIcon")), null, 16)) : (uo(), mo(a, Mo({
            key: 1,
            class: e.cx("loadingIcon"),
            spin: "",
            "aria-hidden": "true"
        }, e.ptm("loadingIcon")), null, 16, ["class"]))]
    }) : Yn(e.$slots, "dropdownicon", {
        key: 1,
        class: G(e.cx("dropdownIcon"))
    }, function() {
        return [(uo(), mo(Hn(e.dropdownIcon ? "span" : "ChevronDownIcon"), Mo({
            class: [e.cx("dropdownIcon"), e.dropdownIcon],
            "aria-hidden": "true",
            "data-p": i.dropdownIconDataP
        }, e.ptm("dropdownIcon")), null, 16, ["class", "data-p"]))]
    })], 16), xo(f, {
        appendTo: e.appendTo
    }, {
        default: Vt(function() {
            return [xo(ii, Mo({
                name: "p-connected-overlay",
                onEnter: i.onOverlayEnter,
                onAfterEnter: i.onOverlayAfterEnter,
                onLeave: i.onOverlayLeave,
                onAfterLeave: i.onOverlayAfterLeave
            }, e.ptm("transition")), {
                default: Vt(function() {
                    return [o.overlayVisible ? (uo(), go("div", Mo({
                        key: 0,
                        ref: i.overlayRef,
                        class: [e.cx("overlay"), e.panelClass, e.overlayClass],
                        style: [e.panelStyle, e.overlayStyle],
                        onClick: t[10] || (t[10] = function() {
                            return i.onOverlayClick && i.onOverlayClick.apply(i, arguments)
                        }),
                        onKeydown: t[11] || (t[11] = function() {
                            return i.onOverlayKeyDown && i.onOverlayKeyDown.apply(i, arguments)
                        }),
                        "data-p": i.overlayDataP
                    }, e.ptm("overlay")), [_o("span", Mo({
                        ref: "firstHiddenFocusableElementOnOverlay",
                        role: "presentation",
                        "aria-hidden": "true",
                        class: "p-hidden-accessible p-hidden-focusable",
                        tabindex: 0,
                        onFocus: t[7] || (t[7] = function() {
                            return i.onFirstHiddenFocus && i.onFirstHiddenFocus.apply(i, arguments)
                        })
                    }, e.ptm("hiddenFirstFocusableEl"), {
                        "data-p-hidden-accessible": !0,
                        "data-p-hidden-focusable": !0
                    }), null, 16), Yn(e.$slots, "header", {
                        value: e.d_value,
                        options: i.visibleOptions
                    }), e.filter ? (uo(), go("div", Mo({
                        key: 0,
                        class: e.cx("header")
                    }, e.ptm("header")), [xo(u, {
                        unstyled: e.unstyled,
                        pt: e.ptm("pcFilterContainer")
                    }, {
                        default: Vt(function() {
                            return [xo(s, {
                                ref: "filterInput",
                                type: "text",
                                value: o.filterValue,
                                onVnodeMounted: i.onFilterUpdated,
                                onVnodeUpdated: i.onFilterUpdated,
                                class: G(e.cx("pcFilter")),
                                placeholder: e.filterPlaceholder,
                                variant: e.variant,
                                unstyled: e.unstyled,
                                role: "searchbox",
                                autocomplete: "off",
                                "aria-owns": e.$id + "_list",
                                "aria-activedescendant": i.focusedOptionId,
                                onKeydown: i.onFilterKeyDown,
                                onBlur: i.onFilterBlur,
                                onInput: i.onFilterChange,
                                pt: e.ptm("pcFilter"),
                                formControl: {
                                    novalidate: !0
                                }
                            }, null, 8, ["value", "onVnodeMounted", "onVnodeUpdated", "class", "placeholder", "variant", "unstyled", "aria-owns", "aria-activedescendant", "onKeydown", "onBlur", "onInput", "pt"]), xo(c, {
                                unstyled: e.unstyled,
                                pt: e.ptm("pcFilterIconContainer")
                            }, {
                                default: Vt(function() {
                                    return [Yn(e.$slots, "filtericon", {}, function() {
                                        return [e.filterIcon ? (uo(), go("span", Mo({
                                            key: 0,
                                            class: e.filterIcon
                                        }, e.ptm("filterIcon")), null, 16)) : (uo(), mo(l, j(Mo({
                                            key: 1
                                        }, e.ptm("filterIcon"))), null, 16))]
                                    })]
                                }),
                                _: 3
                            }, 8, ["unstyled", "pt"])]
                        }),
                        _: 3
                    }, 8, ["unstyled", "pt"]), _o("span", Mo({
                        role: "status",
                        "aria-live": "polite",
                        class: "p-hidden-accessible"
                    }, e.ptm("hiddenFilterResult"), {
                        "data-p-hidden-accessible": !0
                    }), W(i.filterResultMessageText), 17)], 16)) : Eo("", !0), _o("div", Mo({
                        class: e.cx("listContainer"),
                        style: {
                            "max-height": i.virtualScrollerDisabled ? e.scrollHeight : ""
                        }
                    }, e.ptm("listContainer")), [xo(h, Mo({
                        ref: i.virtualScrollerRef
                    }, e.virtualScrollerOptions, {
                        items: i.visibleOptions,
                        style: {
                            height: e.scrollHeight
                        },
                        tabindex: -1,
                        disabled: i.virtualScrollerDisabled,
                        pt: e.ptm("virtualScroller")
                    }), Xn({
                        content: Vt(function(n) {
                            var r = n.styleClass,
                                a = n.contentRef,
                                s = n.items,
                                l = n.getItemOptions,
                                c = n.contentStyle,
                                u = n.itemSize;
                            return [_o("ul", Mo({
                                ref: function(e) {
                                    return i.listRef(e, a)
                                },
                                id: e.$id + "_list",
                                class: [e.cx("list"), r],
                                style: c,
                                role: "listbox"
                            }, e.ptm("list")), [(uo(!0), go(oo, null, qn(s, function(n, r) {
                                return uo(), go(oo, {
                                    key: i.getOptionRenderKey(n, i.getOptionIndex(r, l))
                                }, [i.isOptionGroup(n) ? (uo(), go("li", Mo({
                                    key: 0,
                                    id: e.$id + "_" + i.getOptionIndex(r, l),
                                    style: {
                                        height: u ? u + "px" : void 0
                                    },
                                    class: e.cx("optionGroup"),
                                    role: "option"
                                }, {
                                    ref_for: !0
                                }, e.ptm("optionGroup")), [Yn(e.$slots, "optiongroup", {
                                    option: n.optionGroup,
                                    index: i.getOptionIndex(r, l)
                                }, function() {
                                    return [_o("span", Mo({
                                        class: e.cx("optionGroupLabel")
                                    }, {
                                        ref_for: !0
                                    }, e.ptm("optionGroupLabel")), W(i.getOptionGroupLabel(n.optionGroup)), 17)]
                                })], 16, MM)) : Ht((uo(), go("li", Mo({
                                    key: 1,
                                    id: e.$id + "_" + i.getOptionIndex(r, l),
                                    class: e.cx("option", {
                                        option: n,
                                        focusedOption: i.getOptionIndex(r, l)
                                    }),
                                    style: {
                                        height: u ? u + "px" : void 0
                                    },
                                    role: "option",
                                    "aria-label": i.getOptionLabel(n),
                                    "aria-selected": i.isSelected(n),
                                    "aria-disabled": i.isOptionDisabled(n),
                                    "aria-setsize": i.ariaSetSize,
                                    "aria-posinset": i.getAriaPosInset(i.getOptionIndex(r, l)),
                                    onMousedown: function(e) {
                                        return i.onOptionSelect(e, n)
                                    },
                                    onMousemove: function(e) {
                                        return i.onOptionMouseMove(e, i.getOptionIndex(r, l))
                                    },
                                    onClick: t[8] || (t[8] = Fi(function() {}, ["stop"])),
                                    "data-p-selected": !e.checkmark && i.isSelected(n),
                                    "data-p-focused": o.focusedOptionIndex === i.getOptionIndex(r, l),
                                    "data-p-disabled": i.isOptionDisabled(n)
                                }, {
                                    ref_for: !0
                                }, i.getPTItemOptions(n, l, r, "option")), [e.checkmark ? (uo(), go(oo, {
                                    key: 0
                                }, [i.isSelected(n) ? (uo(), mo(d, Mo({
                                    key: 0,
                                    class: e.cx("optionCheckIcon")
                                }, {
                                    ref_for: !0
                                }, e.ptm("optionCheckIcon")), null, 16, ["class"])) : (uo(), mo(p, Mo({
                                    key: 1,
                                    class: e.cx("optionBlankIcon")
                                }, {
                                    ref_for: !0
                                }, e.ptm("optionBlankIcon")), null, 16, ["class"]))], 64)) : Eo("", !0), Yn(e.$slots, "option", {
                                    option: n,
                                    selected: i.isSelected(n),
                                    index: i.getOptionIndex(r, l)
                                }, function() {
                                    return [_o("span", Mo({
                                        class: e.cx("optionLabel")
                                    }, {
                                        ref_for: !0
                                    }, e.ptm("optionLabel")), W(i.getOptionLabel(n)), 17)]
                                })], 16, RM)), [[g]])], 64)
                            }), 128)), o.filterValue && (!s || s && 0 === s.length) ? (uo(), go("li", Mo({
                                key: 0,
                                class: e.cx("emptyMessage"),
                                role: "option"
                            }, e.ptm("emptyMessage"), {
                                "data-p-hidden-accessible": !0
                            }), [Yn(e.$slots, "emptyfilter", {}, function() {
                                return [Co(W(i.emptyFilterMessageText), 1)]
                            })], 16)) : !e.options || e.options && 0 === e.options.length ? (uo(), go("li", Mo({
                                key: 1,
                                class: e.cx("emptyMessage"),
                                role: "option"
                            }, e.ptm("emptyMessage"), {
                                "data-p-hidden-accessible": !0
                            }), [Yn(e.$slots, "empty", {}, function() {
                                return [Co(W(i.emptyMessageText), 1)]
                            })], 16)) : Eo("", !0)], 16, TM)]
                        }),
                        _: 2
                    }, [e.$slots.loader ? {
                        name: "loader",
                        fn: Vt(function(t) {
                            var n = t.options;
                            return [Yn(e.$slots, "loader", {
                                options: n
                            })]
                        }),
                        key: "0"
                    } : void 0]), 1040, ["items", "style", "disabled", "pt"])], 16), Yn(e.$slots, "footer", {
                        value: e.d_value,
                        options: i.visibleOptions
                    }), !e.options || e.options && 0 === e.options.length ? (uo(), go("span", Mo({
                        key: 1,
                        role: "status",
                        "aria-live": "polite",
                        class: "p-hidden-accessible"
                    }, e.ptm("hiddenEmptyMessage"), {
                        "data-p-hidden-accessible": !0
                    }), W(i.emptyMessageText), 17)) : Eo("", !0), _o("span", Mo({
                        role: "status",
                        "aria-live": "polite",
                        class: "p-hidden-accessible"
                    }, e.ptm("hiddenSelectedMessage"), {
                        "data-p-hidden-accessible": !0
                    }), W(i.selectedMessageText), 17), _o("span", Mo({
                        ref: "lastHiddenFocusableElementOnOverlay",
                        role: "presentation",
                        "aria-hidden": "true",
                        class: "p-hidden-accessible p-hidden-focusable",
                        tabindex: 0,
                        onFocus: t[9] || (t[9] = function() {
                            return i.onLastHiddenFocus && i.onLastHiddenFocus.apply(i, arguments)
                        })
                    }, e.ptm("hiddenLastFocusableEl"), {
                        "data-p-hidden-accessible": !0,
                        "data-p-hidden-focusable": !0
                    }), null, 16)], 16, IM)) : Eo("", !0)]
                }),
                _: 3
            }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])]
        }),
        _: 3
    }, 8, ["appendTo"])], 16, CM)
};
var BM = kI.extend({
        name: "tabs",
        style: "\n    .p-tabs {\n        display: flex;\n        flex-direction: column;\n    }\n\n    .p-tablist {\n        display: flex;\n        position: relative;\n        overflow: hidden;\n        background: dt('tabs.tablist.background');\n    }\n\n    .p-tablist-viewport {\n        overflow-x: auto;\n        overflow-y: hidden;\n        scroll-behavior: smooth;\n        scrollbar-width: none;\n        overscroll-behavior: contain auto;\n    }\n\n    .p-tablist-viewport::-webkit-scrollbar {\n        display: none;\n    }\n\n    .p-tablist-tab-list {\n        position: relative;\n        display: flex;\n        border-style: solid;\n        border-color: dt('tabs.tablist.border.color');\n        border-width: dt('tabs.tablist.border.width');\n    }\n\n    .p-tablist-content {\n        flex-grow: 1;\n    }\n\n    .p-tablist-nav-button {\n        all: unset;\n        position: absolute !important;\n        flex-shrink: 0;\n        inset-block-start: 0;\n        z-index: 2;\n        height: 100%;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        background: dt('tabs.nav.button.background');\n        color: dt('tabs.nav.button.color');\n        width: dt('tabs.nav.button.width');\n        transition:\n            color dt('tabs.transition.duration'),\n            outline-color dt('tabs.transition.duration'),\n            box-shadow dt('tabs.transition.duration');\n        box-shadow: dt('tabs.nav.button.shadow');\n        outline-color: transparent;\n        cursor: pointer;\n    }\n\n    .p-tablist-nav-button:focus-visible {\n        z-index: 1;\n        box-shadow: dt('tabs.nav.button.focus.ring.shadow');\n        outline: dt('tabs.nav.button.focus.ring.width') dt('tabs.nav.button.focus.ring.style') dt('tabs.nav.button.focus.ring.color');\n        outline-offset: dt('tabs.nav.button.focus.ring.offset');\n    }\n\n    .p-tablist-nav-button:hover {\n        color: dt('tabs.nav.button.hover.color');\n    }\n\n    .p-tablist-prev-button {\n        inset-inline-start: 0;\n    }\n\n    .p-tablist-next-button {\n        inset-inline-end: 0;\n    }\n\n    .p-tablist-prev-button:dir(rtl),\n    .p-tablist-next-button:dir(rtl) {\n        transform: rotate(180deg);\n    }\n\n    .p-tab {\n        flex-shrink: 0;\n        cursor: pointer;\n        user-select: none;\n        position: relative;\n        border-style: solid;\n        white-space: nowrap;\n        gap: dt('tabs.tab.gap');\n        background: dt('tabs.tab.background');\n        border-width: dt('tabs.tab.border.width');\n        border-color: dt('tabs.tab.border.color');\n        color: dt('tabs.tab.color');\n        padding: dt('tabs.tab.padding');\n        font-weight: dt('tabs.tab.font.weight');\n        transition:\n            background dt('tabs.transition.duration'),\n            border-color dt('tabs.transition.duration'),\n            color dt('tabs.transition.duration'),\n            outline-color dt('tabs.transition.duration'),\n            box-shadow dt('tabs.transition.duration');\n        margin: dt('tabs.tab.margin');\n        outline-color: transparent;\n    }\n\n    .p-tab:not(.p-disabled):focus-visible {\n        z-index: 1;\n        box-shadow: dt('tabs.tab.focus.ring.shadow');\n        outline: dt('tabs.tab.focus.ring.width') dt('tabs.tab.focus.ring.style') dt('tabs.tab.focus.ring.color');\n        outline-offset: dt('tabs.tab.focus.ring.offset');\n    }\n\n    .p-tab:not(.p-tab-active):not(.p-disabled):hover {\n        background: dt('tabs.tab.hover.background');\n        border-color: dt('tabs.tab.hover.border.color');\n        color: dt('tabs.tab.hover.color');\n    }\n\n    .p-tab-active {\n        background: dt('tabs.tab.active.background');\n        border-color: dt('tabs.tab.active.border.color');\n        color: dt('tabs.tab.active.color');\n    }\n\n    .p-tabpanels {\n        background: dt('tabs.tabpanel.background');\n        color: dt('tabs.tabpanel.color');\n        padding: dt('tabs.tabpanel.padding');\n        outline: 0 none;\n    }\n\n    .p-tabpanel:focus-visible {\n        box-shadow: dt('tabs.tabpanel.focus.ring.shadow');\n        outline: dt('tabs.tabpanel.focus.ring.width') dt('tabs.tabpanel.focus.ring.style') dt('tabs.tabpanel.focus.ring.color');\n        outline-offset: dt('tabs.tabpanel.focus.ring.offset');\n    }\n\n    .p-tablist-active-bar {\n        z-index: 1;\n        display: block;\n        position: absolute;\n        inset-block-end: dt('tabs.active.bar.bottom');\n        height: dt('tabs.active.bar.height');\n        background: dt('tabs.active.bar.background');\n        transition: 250ms cubic-bezier(0.35, 0, 0.25, 1);\n    }\n",
        classes: {
            root: function(e) {
                return ["p-tabs p-component", {
                    "p-tabs-scrollable": e.props.scrollable
                }]
            }
        }
    }),
    kM = {
        name: "Tabs",
        extends: {
            name: "BaseTabs",
            extends: nT,
            props: {
                value: {
                    type: [String, Number],
                    default: void 0
                },
                lazy: {
                    type: Boolean,
                    default: !1
                },
                scrollable: {
                    type: Boolean,
                    default: !1
                },
                showNavigators: {
                    type: Boolean,
                    default: !0
                },
                tabindex: {
                    type: Number,
                    default: 0
                },
                selectOnFocus: {
                    type: Boolean,
                    default: !1
                }
            },
            style: BM,
            provide: function() {
                return {
                    $pcTabs: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["update:value"],
        data: function() {
            return {
                d_value: this.value
            }
        },
        watch: {
            value: function(e) {
                this.d_value = e
            }
        },
        methods: {
            updateValue: function(e) {
                this.d_value !== e && (this.d_value = e, this.$emit("update:value", e))
            },
            isVertical: function() {
                return "vertical" === this.orientation
            }
        },
        render: function(e, t, n, r, o, i) {
            return uo(), go("div", Mo({
                class: e.cx("root")
            }, e.ptmi("root")), [Yn(e.$slots, "default")], 16)
        }
    },
    DM = {
        name: "ChevronLeftIcon",
        extends: AT
    };
function PM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
DM.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return PM(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M9.61296 13C9.50997 13.0005 9.40792 12.9804 9.3128 12.9409C9.21767 12.9014 9.13139 12.8433 9.05902 12.7701L3.83313 7.54416C3.68634 7.39718 3.60388 7.19795 3.60388 6.99022C3.60388 6.78249 3.68634 6.58325 3.83313 6.43628L9.05902 1.21039C9.20762 1.07192 9.40416 0.996539 9.60724 1.00012C9.81032 1.00371 10.0041 1.08597 10.1477 1.22959C10.2913 1.37322 10.3736 1.56698 10.3772 1.77005C10.3808 1.97313 10.3054 2.16968 10.1669 2.31827L5.49496 6.99022L10.1669 11.6622C10.3137 11.8091 10.3962 12.0084 10.3962 12.2161C10.3962 12.4238 10.3137 12.6231 10.1669 12.7701C10.0945 12.8433 10.0083 12.9014 9.91313 12.9409C9.81801 12.9804 9.71596 13.0005 9.61296 13Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return PM(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? PM(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var OM = {
    name: "ChevronRightIcon",
    extends: AT
};
function LM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
OM.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return LM(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M4.38708 13C4.28408 13.0005 4.18203 12.9804 4.08691 12.9409C3.99178 12.9014 3.9055 12.8433 3.83313 12.7701C3.68634 12.6231 3.60388 12.4238 3.60388 12.2161C3.60388 12.0084 3.68634 11.8091 3.83313 11.6622L8.50507 6.99022L3.83313 2.31827C3.69467 2.16968 3.61928 1.97313 3.62287 1.77005C3.62645 1.56698 3.70872 1.37322 3.85234 1.22959C3.99596 1.08597 4.18972 1.00371 4.3928 1.00012C4.59588 0.996539 4.79242 1.07192 4.94102 1.21039L10.1669 6.43628C10.3137 6.58325 10.3962 6.78249 10.3962 6.99022C10.3962 7.19795 10.3137 7.39718 10.1669 7.54416L4.94102 12.7701C4.86865 12.8433 4.78237 12.9014 4.68724 12.9409C4.59212 12.9804 4.49007 13.0005 4.38708 13Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return LM(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? LM(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var NM = {
        name: "TabList",
        extends: {
            name: "BaseTabList",
            extends: nT,
            props: {},
            style: kI.extend({
                name: "tablist",
                classes: {
                    root: "p-tablist",
                    content: "p-tablist-content p-tablist-viewport",
                    tabList: "p-tablist-tab-list",
                    activeBar: "p-tablist-active-bar",
                    prevButton: "p-tablist-prev-button p-tablist-nav-button",
                    nextButton: "p-tablist-next-button p-tablist-nav-button"
                }
            }),
            provide: function() {
                return {
                    $pcTabList: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        inject: ["$pcTabs"],
        data: function() {
            return {
                isPrevButtonEnabled: !1,
                isNextButtonEnabled: !0
            }
        },
        resizeObserver: void 0,
        watch: {
            showNavigators: function(e) {
                e ? this.bindResizeObserver() : this.unbindResizeObserver()
            },
            activeValue: {
                flush: "post",
                handler: function() {
                    this.updateInkBar()
                }
            }
        },
        mounted: function() {
            var e = this;
            setTimeout(function() {
                e.updateInkBar()
            }, 150),
            this.showNavigators && (this.updateButtonState(), this.bindResizeObserver())
        },
        updated: function() {
            this.showNavigators && this.updateButtonState()
        },
        beforeUnmount: function() {
            this.unbindResizeObserver()
        },
        methods: {
            onScroll: function(e) {
                this.showNavigators && this.updateButtonState(),
                e.preventDefault()
            },
            onPrevButtonClick: function() {
                var e = this.$refs.content,
                    t = this.getVisibleButtonWidths(),
                    n = VE(e) - t,
                    r = Math.abs(e.scrollLeft) - .8 * n,
                    o = Math.max(r, 0);
                e.scrollLeft = AE(e) ? -1 * o : o
            },
            onNextButtonClick: function() {
                var e = this.$refs.content,
                    t = this.getVisibleButtonWidths(),
                    n = VE(e) - t,
                    r = Math.abs(e.scrollLeft) + .8 * n,
                    o = e.scrollWidth - n,
                    i = Math.min(r, o);
                e.scrollLeft = AE(e) ? -1 * i : i
            },
            bindResizeObserver: function() {
                var e = this;
                this.resizeObserver = new ResizeObserver(function() {
                    return e.updateButtonState()
                }),
                this.resizeObserver.observe(this.$refs.list)
            },
            unbindResizeObserver: function() {
                var e;
                null === (e = this.resizeObserver) || void 0 === e || e.unobserve(this.$refs.list),
                this.resizeObserver = void 0
            },
            updateInkBar: function() {
                var e = this.$refs,
                    t = e.content,
                    n = e.inkbar,
                    r = e.tabs;
                if (n) {
                    var o = ME(t, '[data-pc-name="tab"][data-p-active="true"]');
                    this.$pcTabs.isVertical() ? (n.style.height = UE(o) + "px", n.style.top = FE(o).top - FE(r).top + "px") : (n.style.width = _E(o) + "px", n.style.left = FE(o).left - FE(r).left + "px")
                }
            },
            updateButtonState: function() {
                var e = this.$refs,
                    t = e.list,
                    n = e.content,
                    r = n.scrollTop,
                    o = n.scrollWidth,
                    i = n.scrollHeight,
                    a = n.offsetWidth,
                    s = n.offsetHeight,
                    l = Math.abs(n.scrollLeft),
                    c = [VE(n), PE(n)],
                    u = c[0],
                    d = c[1];
                this.$pcTabs.isVertical() ? (this.isPrevButtonEnabled = 0 !== r, this.isNextButtonEnabled = t.offsetHeight >= s && parseInt(r) !== i - d) : (this.isPrevButtonEnabled = 0 !== l, this.isNextButtonEnabled = t.offsetWidth >= a && parseInt(l) !== o - u)
            },
            getVisibleButtonWidths: function() {
                var e = this.$refs,
                    t = e.prevButton,
                    n = e.nextButton,
                    r = 0;
                return this.showNavigators && (r = ((null == t ? void 0 : t.offsetWidth) || 0) + ((null == n ? void 0 : n.offsetWidth) || 0)), r
            }
        },
        computed: {
            templates: function() {
                return this.$pcTabs.$slots
            },
            activeValue: function() {
                return this.$pcTabs.d_value
            },
            showNavigators: function() {
                return this.$pcTabs.showNavigators
            },
            prevButtonAriaLabel: function() {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.previous : void 0
            },
            nextButtonAriaLabel: function() {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.next : void 0
            },
            dataP: function() {
                return RS({
                    scrollable: this.$pcTabs.scrollable
                })
            }
        },
        components: {
            ChevronLeftIcon: DM,
            ChevronRightIcon: OM
        },
        directives: {
            ripple: ET
        }
    },
    FM = ["data-p"],
    UM = ["aria-label", "tabindex"],
    zM = ["data-p"],
    QM = ["aria-orientation"],
    GM = ["aria-label", "tabindex"];
NM.render = function(e, t, n, r, o, i) {
    var a = $n("ripple");
    return uo(), go("div", Mo({
        ref: "list",
        class: e.cx("root"),
        "data-p": i.dataP
    }, e.ptmi("root")), [i.showNavigators && o.isPrevButtonEnabled ? Ht((uo(), go("button", Mo({
        key: 0,
        ref: "prevButton",
        type: "button",
        class: e.cx("prevButton"),
        "aria-label": i.prevButtonAriaLabel,
        tabindex: i.$pcTabs.tabindex,
        onClick: t[0] || (t[0] = function() {
            return i.onPrevButtonClick && i.onPrevButtonClick.apply(i, arguments)
        })
    }, e.ptm("prevButton"), {
        "data-pc-group-section": "navigator"
    }), [(uo(), mo(Hn(i.templates.previcon || "ChevronLeftIcon"), Mo({
        "aria-hidden": "true"
    }, e.ptm("prevIcon")), null, 16))], 16, UM)), [[a]]) : Eo("", !0), _o("div", Mo({
        ref: "content",
        class: e.cx("content"),
        onScroll: t[1] || (t[1] = function() {
            return i.onScroll && i.onScroll.apply(i, arguments)
        }),
        "data-p": i.dataP
    }, e.ptm("content")), [_o("div", Mo({
        ref: "tabs",
        class: e.cx("tabList"),
        role: "tablist",
        "aria-orientation": i.$pcTabs.orientation || "horizontal"
    }, e.ptm("tabList")), [Yn(e.$slots, "default"), _o("span", Mo({
        ref: "inkbar",
        class: e.cx("activeBar"),
        role: "presentation",
        "aria-hidden": "true"
    }, e.ptm("activeBar")), null, 16)], 16, QM)], 16, zM), i.showNavigators && o.isNextButtonEnabled ? Ht((uo(), go("button", Mo({
        key: 1,
        ref: "nextButton",
        type: "button",
        class: e.cx("nextButton"),
        "aria-label": i.nextButtonAriaLabel,
        tabindex: i.$pcTabs.tabindex,
        onClick: t[2] || (t[2] = function() {
            return i.onNextButtonClick && i.onNextButtonClick.apply(i, arguments)
        })
    }, e.ptm("nextButton"), {
        "data-pc-group-section": "navigator"
    }), [(uo(), mo(Hn(i.templates.nexticon || "ChevronRightIcon"), Mo({
        "aria-hidden": "true"
    }, e.ptm("nextIcon")), null, 16))], 16, GM)), [[a]]) : Eo("", !0)], 16, FM)
};
var jM = kI.extend({
        name: "tab",
        classes: {
            root: function(e) {
                var t = e.instance,
                    n = e.props;
                return ["p-tab", {
                    "p-tab-active": t.active,
                    "p-disabled": n.disabled
                }]
            }
        }
    }),
    VM = {
        name: "Tab",
        extends: {
            name: "BaseTab",
            extends: nT,
            props: {
                value: {
                    type: [String, Number],
                    default: void 0
                },
                disabled: {
                    type: Boolean,
                    default: !1
                },
                as: {
                    type: [String, Object],
                    default: "BUTTON"
                },
                asChild: {
                    type: Boolean,
                    default: !1
                }
            },
            style: jM,
            provide: function() {
                return {
                    $pcTab: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        inject: ["$pcTabs", "$pcTabList"],
        methods: {
            onFocus: function() {
                this.$pcTabs.selectOnFocus && this.changeActiveValue()
            },
            onClick: function() {
                this.changeActiveValue()
            },
            onKeydown: function(e) {
                switch (e.code) {
                case "ArrowRight":
                    this.onArrowRightKey(e);
                    break;
                case "ArrowLeft":
                    this.onArrowLeftKey(e);
                    break;
                case "Home":
                    this.onHomeKey(e);
                    break;
                case "End":
                    this.onEndKey(e);
                    break;
                case "PageDown":
                    this.onPageDownKey(e);
                    break;
                case "PageUp":
                    this.onPageUpKey(e);
                    break;
                case "Enter":
                case "NumpadEnter":
                case "Space":
                    this.onEnterKey(e)
                }
            },
            onArrowRightKey: function(e) {
                var t = this.findNextTab(e.currentTarget);
                t ? this.changeFocusedTab(e, t) : this.onHomeKey(e),
                e.preventDefault()
            },
            onArrowLeftKey: function(e) {
                var t = this.findPrevTab(e.currentTarget);
                t ? this.changeFocusedTab(e, t) : this.onEndKey(e),
                e.preventDefault()
            },
            onHomeKey: function(e) {
                var t = this.findFirstTab();
                this.changeFocusedTab(e, t),
                e.preventDefault()
            },
            onEndKey: function(e) {
                var t = this.findLastTab();
                this.changeFocusedTab(e, t),
                e.preventDefault()
            },
            onPageDownKey: function(e) {
                this.scrollInView(this.findLastTab()),
                e.preventDefault()
            },
            onPageUpKey: function(e) {
                this.scrollInView(this.findFirstTab()),
                e.preventDefault()
            },
            onEnterKey: function(e) {
                this.changeActiveValue()
            },
            findNextTab: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? e : e.nextElementSibling;
                return t ? BE(t, "data-p-disabled") || "activebar" === BE(t, "data-pc-section") ? this.findNextTab(t) : ME(t, '[data-pc-name="tab"]') : null
            },
            findPrevTab: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? e : e.previousElementSibling;
                return t ? BE(t, "data-p-disabled") || "activebar" === BE(t, "data-pc-section") ? this.findPrevTab(t) : ME(t, '[data-pc-name="tab"]') : null
            },
            findFirstTab: function() {
                return this.findNextTab(this.$pcTabList.$refs.tabs.firstElementChild, !0)
            },
            findLastTab: function() {
                return this.findPrevTab(this.$pcTabList.$refs.tabs.lastElementChild, !0)
            },
            changeActiveValue: function() {
                this.$pcTabs.updateValue(this.value)
            },
            changeFocusedTab: function(e, t) {
                RE(t),
                this.scrollInView(t)
            },
            scrollInView: function(e) {
                var t;
                null == e || null === (t = e.scrollIntoView) || void 0 === t || t.call(e, {
                    block: "nearest"
                })
            }
        },
        computed: {
            active: function() {
                var e;
                return cS(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.d_value, this.value)
            },
            id: function() {
                var e;
                return "".concat(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.$id, "_tab_").concat(this.value)
            },
            ariaControls: function() {
                var e;
                return "".concat(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.$id, "_tabpanel_").concat(this.value)
            },
            attrs: function() {
                return Mo(this.asAttrs, this.a11yAttrs, this.ptmi("root", this.ptParams))
            },
            asAttrs: function() {
                return "BUTTON" === this.as ? {
                    type: "button",
                    disabled: this.disabled
                } : void 0
            },
            a11yAttrs: function() {
                return {
                    id: this.id,
                    tabindex: this.active ? this.$pcTabs.tabindex : -1,
                    role: "tab",
                    "aria-selected": this.active,
                    "aria-controls": this.ariaControls,
                    "data-pc-name": "tab",
                    "data-p-disabled": this.disabled,
                    "data-p-active": this.active,
                    onFocus: this.onFocus,
                    onKeydown: this.onKeydown
                }
            },
            ptParams: function() {
                return {
                    context: {
                        active: this.active
                    }
                }
            },
            dataP: function() {
                return RS({
                    active: this.active
                })
            }
        },
        directives: {
            ripple: ET
        },
        render: function(e, t, n, r, o, i) {
            var a = $n("ripple");
            return e.asChild ? Yn(e.$slots, "default", {
                key: 1,
                dataP: i.dataP,
                class: G(e.cx("root")),
                active: i.active,
                a11yAttrs: i.a11yAttrs,
                onClick: i.onClick
            }) : Ht((uo(), mo(Hn(e.as), Mo({
                key: 0,
                class: e.cx("root"),
                "data-p": i.dataP,
                onClick: i.onClick
            }, i.attrs), {
                default: Vt(function() {
                    return [Yn(e.$slots, "default")]
                }),
                _: 3
            }, 16, ["class", "data-p", "onClick"])), [[a]])
        }
    },
    HM = {
        name: "TabPanels",
        extends: {
            name: "BaseTabPanels",
            extends: nT,
            props: {},
            style: kI.extend({
                name: "tabpanels",
                classes: {
                    root: "p-tabpanels"
                }
            }),
            provide: function() {
                return {
                    $pcTabPanels: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        render: function(e, t, n, r, o, i) {
            return uo(), go("div", Mo({
                class: e.cx("root"),
                role: "presentation"
            }, e.ptmi("root")), [Yn(e.$slots, "default")], 16)
        }
    },
    $M = kI.extend({
        name: "tabpanel",
        classes: {
            root: function(e) {
                return ["p-tabpanel", {
                    "p-tabpanel-active": e.instance.active
                }]
            }
        }
    }),
    WM = {
        name: "TabPanel",
        extends: {
            name: "BaseTabPanel",
            extends: nT,
            props: {
                value: {
                    type: [String, Number],
                    default: void 0
                },
                as: {
                    type: [String, Object],
                    default: "DIV"
                },
                asChild: {
                    type: Boolean,
                    default: !1
                },
                header: null,
                headerStyle: null,
                headerClass: null,
                headerProps: null,
                headerActionProps: null,
                contentStyle: null,
                contentClass: null,
                contentProps: null,
                disabled: Boolean
            },
            style: $M,
            provide: function() {
                return {
                    $pcTabPanel: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        inject: ["$pcTabs"],
        computed: {
            active: function() {
                var e;
                return cS(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.d_value, this.value)
            },
            id: function() {
                var e;
                return "".concat(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.$id, "_tabpanel_").concat(this.value)
            },
            ariaLabelledby: function() {
                var e;
                return "".concat(null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.$id, "_tab_").concat(this.value)
            },
            attrs: function() {
                return Mo(this.a11yAttrs, this.ptmi("root", this.ptParams))
            },
            a11yAttrs: function() {
                var e;
                return {
                    id: this.id,
                    tabindex: null === (e = this.$pcTabs) || void 0 === e ? void 0 : e.tabindex,
                    role: "tabpanel",
                    "aria-labelledby": this.ariaLabelledby,
                    "data-pc-name": "tabpanel",
                    "data-p-active": this.active
                }
            },
            ptParams: function() {
                return {
                    context: {
                        active: this.active
                    }
                }
            }
        },
        render: function(e, t, n, r, o, i) {
            var a,
                s;
            return i.$pcTabs ? (uo(), go(oo, {
                key: 1
            }, [e.asChild ? Yn(e.$slots, "default", {
                key: 1,
                class: G(e.cx("root")),
                active: i.active,
                a11yAttrs: i.a11yAttrs
            }) : (uo(), go(oo, {
                key: 0
            }, [null === (a = i.$pcTabs) || void 0 === a || !a.lazy || i.active ? Ht((uo(), mo(Hn(e.as), Mo({
                key: 0,
                class: e.cx("root")
            }, i.attrs), {
                default: Vt(function() {
                    return [Yn(e.$slots, "default")]
                }),
                _: 3
            }, 16, ["class"])), [[yi, !(null === (s = i.$pcTabs) || void 0 === s || !s.lazy) || i.active]]) : Eo("", !0)], 64))], 64)) : Yn(e.$slots, "default", {
                key: 0
            })
        }
    },
    KM = {
        name: "MinusIcon",
        extends: AT
    };
function qM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
KM.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return qM(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M13.2222 7.77778H0.777778C0.571498 7.77778 0.373667 7.69584 0.227806 7.54998C0.0819442 7.40412 0 7.20629 0 7.00001C0 6.79373 0.0819442 6.5959 0.227806 6.45003C0.373667 6.30417 0.571498 6.22223 0.777778 6.22223H13.2222C13.4285 6.22223 13.6263 6.30417 13.7722 6.45003C13.9181 6.5959 14 6.79373 14 7.00001C14 7.20629 13.9181 7.40412 13.7722 7.54998C13.6263 7.69584 13.4285 7.77778 13.2222 7.77778Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return qM(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? qM(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var XM = {
    name: "PlusIcon",
    extends: AT
};
function YM(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
XM.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return YM(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M7.67742 6.32258V0.677419C7.67742 0.497757 7.60605 0.325452 7.47901 0.198411C7.35197 0.0713707 7.17966 0 7 0C6.82034 0 6.64803 0.0713707 6.52099 0.198411C6.39395 0.325452 6.32258 0.497757 6.32258 0.677419V6.32258H0.677419C0.497757 6.32258 0.325452 6.39395 0.198411 6.52099C0.0713707 6.64803 0 6.82034 0 7C0 7.17966 0.0713707 7.35197 0.198411 7.47901C0.325452 7.60605 0.497757 7.67742 0.677419 7.67742H6.32258V13.3226C6.32492 13.5015 6.39704 13.6725 6.52358 13.799C6.65012 13.9255 6.82106 13.9977 7 14C7.17966 14 7.35197 13.9286 7.47901 13.8016C7.60605 13.6745 7.67742 13.5022 7.67742 13.3226V7.67742H13.3226C13.5022 7.67742 13.6745 7.60605 13.8016 7.47901C13.9286 7.35197 14 7.17966 14 7C13.9977 6.82106 13.9255 6.65012 13.799 6.52358C13.6725 6.39704 13.5015 6.32492 13.3226 6.32258H7.67742Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return YM(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? YM(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var JM = kI.extend({
        name: "fieldset",
        style: "\n    .p-fieldset {\n        background: dt('fieldset.background');\n        border: 1px solid dt('fieldset.border.color');\n        border-radius: dt('fieldset.border.radius');\n        color: dt('fieldset.color');\n        padding: dt('fieldset.padding');\n        margin: 0;\n    }\n\n    .p-fieldset-legend {\n        background: dt('fieldset.legend.background');\n        border-radius: dt('fieldset.legend.border.radius');\n        border-width: dt('fieldset.legend.border.width');\n        border-style: solid;\n        border-color: dt('fieldset.legend.border.color');\n        padding: dt('fieldset.legend.padding');\n        transition:\n            background dt('fieldset.transition.duration'),\n            color dt('fieldset.transition.duration'),\n            outline-color dt('fieldset.transition.duration'),\n            box-shadow dt('fieldset.transition.duration');\n    }\n\n    .p-fieldset-toggleable > .p-fieldset-legend {\n        padding: 0;\n    }\n\n    .p-fieldset-toggle-button {\n        cursor: pointer;\n        user-select: none;\n        overflow: hidden;\n        position: relative;\n        text-decoration: none;\n        display: flex;\n        gap: dt('fieldset.legend.gap');\n        align-items: center;\n        justify-content: center;\n        padding: dt('fieldset.legend.padding');\n        background: transparent;\n        border: 0 none;\n        border-radius: dt('fieldset.legend.border.radius');\n        transition:\n            background dt('fieldset.transition.duration'),\n            color dt('fieldset.transition.duration'),\n            outline-color dt('fieldset.transition.duration'),\n            box-shadow dt('fieldset.transition.duration');\n        outline-color: transparent;\n    }\n\n    .p-fieldset-legend-label {\n        font-weight: dt('fieldset.legend.font.weight');\n    }\n\n    .p-fieldset-toggle-button:focus-visible {\n        box-shadow: dt('fieldset.legend.focus.ring.shadow');\n        outline: dt('fieldset.legend.focus.ring.width') dt('fieldset.legend.focus.ring.style') dt('fieldset.legend.focus.ring.color');\n        outline-offset: dt('fieldset.legend.focus.ring.offset');\n    }\n\n    .p-fieldset-toggleable > .p-fieldset-legend:hover {\n        color: dt('fieldset.legend.hover.color');\n        background: dt('fieldset.legend.hover.background');\n    }\n\n    .p-fieldset-toggle-icon {\n        color: dt('fieldset.toggle.icon.color');\n        transition: color dt('fieldset.transition.duration');\n    }\n\n    .p-fieldset-toggleable > .p-fieldset-legend:hover .p-fieldset-toggle-icon {\n        color: dt('fieldset.toggle.icon.hover.color');\n    }\n\n    .p-fieldset .p-fieldset-content {\n        padding: dt('fieldset.content.padding');\n    }\n",
        classes: {
            root: function(e) {
                return ["p-fieldset p-component", {
                    "p-fieldset-toggleable": e.props.toggleable
                }]
            },
            legend: "p-fieldset-legend",
            legendLabel: "p-fieldset-legend-label",
            toggleButton: "p-fieldset-toggle-button",
            toggleIcon: "p-fieldset-toggle-icon",
            contentContainer: "p-fieldset-content-container",
            content: "p-fieldset-content"
        }
    }),
    ZM = {
        name: "Fieldset",
        extends: {
            name: "BaseFieldset",
            extends: nT,
            props: {
                legend: String,
                toggleable: Boolean,
                collapsed: Boolean,
                toggleButtonProps: {
                    type: null,
                    default: null
                }
            },
            style: JM,
            provide: function() {
                return {
                    $pcFieldset: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["update:collapsed", "toggle"],
        data: function() {
            return {
                d_collapsed: this.collapsed
            }
        },
        watch: {
            collapsed: function(e) {
                this.d_collapsed = e
            }
        },
        methods: {
            toggle: function(e) {
                this.d_collapsed = !this.d_collapsed,
                this.$emit("update:collapsed", this.d_collapsed),
                this.$emit("toggle", {
                    originalEvent: e,
                    value: this.d_collapsed
                })
            },
            onKeyDown: function(e) {
                "Enter" !== e.code && "NumpadEnter" !== e.code && "Space" !== e.code || (this.toggle(e), e.preventDefault())
            }
        },
        computed: {
            buttonAriaLabel: function() {
                return this.toggleButtonProps && this.toggleButtonProps.ariaLabel ? this.toggleButtonProps.ariaLabel : this.legend
            },
            dataP: function() {
                return RS({
                    toggleable: this.toggleable
                })
            }
        },
        directives: {
            ripple: ET
        },
        components: {
            PlusIcon: XM,
            MinusIcon: KM
        }
    };
function eR(e) {
    return (eR = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function tR(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function nR(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? tR(Object(n), !0).forEach(function(t) {
            rR(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tR(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function rR(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != eR(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != eR(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == eR(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var oR = ["data-p"],
    iR = ["data-p"],
    aR = ["id"],
    sR = ["id", "aria-controls", "aria-expanded", "aria-label"],
    lR = ["id", "aria-labelledby"];
ZM.render = function(e, t, n, r, o, i) {
    var a = $n("ripple");
    return uo(), go("fieldset", Mo({
        class: e.cx("root"),
        "data-p": i.dataP
    }, e.ptmi("root")), [_o("legend", Mo({
        class: e.cx("legend"),
        "data-p": i.dataP
    }, e.ptm("legend")), [Yn(e.$slots, "legend", {
        toggleCallback: i.toggle
    }, function() {
        return [e.toggleable ? Eo("", !0) : (uo(), go("span", Mo({
            key: 0,
            id: e.$id + "_header",
            class: e.cx("legendLabel")
        }, e.ptm("legendLabel")), W(e.legend), 17, aR)), e.toggleable ? Ht((uo(), go("button", Mo({
            key: 1,
            id: e.$id + "_header",
            type: "button",
            "aria-controls": e.$id + "_content",
            "aria-expanded": !o.d_collapsed,
            "aria-label": i.buttonAriaLabel,
            class: e.cx("toggleButton"),
            onClick: t[0] || (t[0] = function() {
                return i.toggle && i.toggle.apply(i, arguments)
            }),
            onKeydown: t[1] || (t[1] = function() {
                return i.onKeyDown && i.onKeyDown.apply(i, arguments)
            })
        }, nR(nR({}, e.toggleButtonProps), e.ptm("toggleButton"))), [Yn(e.$slots, e.$slots.toggleicon ? "toggleicon" : "togglericon", {
            collapsed: o.d_collapsed,
            class: G(e.cx("toggleIcon"))
        }, function() {
            return [(uo(), mo(Hn(o.d_collapsed ? "PlusIcon" : "MinusIcon"), Mo({
                class: e.cx("toggleIcon")
            }, e.ptm("toggleIcon")), null, 16, ["class"]))]
        }), _o("span", Mo({
            class: e.cx("legendLabel")
        }, e.ptm("legendLabel")), W(e.legend), 17)], 16, sR)), [[a]]) : Eo("", !0)]
    })], 16, iR), xo(ii, Mo({
        name: "p-toggleable-content"
    }, e.ptm("transition")), {
        default: Vt(function() {
            return [Ht(_o("div", Mo({
                id: e.$id + "_content",
                class: e.cx("contentContainer"),
                role: "region",
                "aria-labelledby": e.$id + "_header"
            }, e.ptm("contentContainer")), [_o("div", Mo({
                class: e.cx("content")
            }, e.ptm("content")), [Yn(e.$slots, "default")], 16)], 16, lR), [[yi, !o.d_collapsed]])]
        }),
        _: 3
    }, 16)], 16, oR)
};
var cR = {
        root: function(e) {
            var t = e.props,
                n = e.instance;
            return ["p-badge p-component", {
                "p-badge-circle": sS(t.value) && 1 === String(t.value).length,
                "p-badge-dot": rS(t.value) && !n.$slots.default,
                "p-badge-sm": "small" === t.size,
                "p-badge-lg": "large" === t.size,
                "p-badge-xl": "xlarge" === t.size,
                "p-badge-info": "info" === t.severity,
                "p-badge-success": "success" === t.severity,
                "p-badge-warn": "warn" === t.severity,
                "p-badge-danger": "danger" === t.severity,
                "p-badge-secondary": "secondary" === t.severity,
                "p-badge-contrast": "contrast" === t.severity
            }]
        }
    },
    uR = kI.extend({
        name: "badge",
        style: "\n    .p-badge {\n        display: inline-flex;\n        border-radius: dt('badge.border.radius');\n        align-items: center;\n        justify-content: center;\n        padding: dt('badge.padding');\n        background: dt('badge.primary.background');\n        color: dt('badge.primary.color');\n        font-size: dt('badge.font.size');\n        font-weight: dt('badge.font.weight');\n        min-width: dt('badge.min.width');\n        height: dt('badge.height');\n    }\n\n    .p-badge-dot {\n        width: dt('badge.dot.size');\n        min-width: dt('badge.dot.size');\n        height: dt('badge.dot.size');\n        border-radius: 50%;\n        padding: 0;\n    }\n\n    .p-badge-circle {\n        padding: 0;\n        border-radius: 50%;\n    }\n\n    .p-badge-secondary {\n        background: dt('badge.secondary.background');\n        color: dt('badge.secondary.color');\n    }\n\n    .p-badge-success {\n        background: dt('badge.success.background');\n        color: dt('badge.success.color');\n    }\n\n    .p-badge-info {\n        background: dt('badge.info.background');\n        color: dt('badge.info.color');\n    }\n\n    .p-badge-warn {\n        background: dt('badge.warn.background');\n        color: dt('badge.warn.color');\n    }\n\n    .p-badge-danger {\n        background: dt('badge.danger.background');\n        color: dt('badge.danger.color');\n    }\n\n    .p-badge-contrast {\n        background: dt('badge.contrast.background');\n        color: dt('badge.contrast.color');\n    }\n\n    .p-badge-sm {\n        font-size: dt('badge.sm.font.size');\n        min-width: dt('badge.sm.min.width');\n        height: dt('badge.sm.height');\n    }\n\n    .p-badge-lg {\n        font-size: dt('badge.lg.font.size');\n        min-width: dt('badge.lg.min.width');\n        height: dt('badge.lg.height');\n    }\n\n    .p-badge-xl {\n        font-size: dt('badge.xl.font.size');\n        min-width: dt('badge.xl.min.width');\n        height: dt('badge.xl.height');\n    }\n",
        classes: cR
    });
function dR(e) {
    return (dR = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function pR(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != dR(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != dR(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == dR(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var hR = {
        name: "Badge",
        extends: {
            name: "BaseBadge",
            extends: nT,
            props: {
                value: {
                    type: [String, Number],
                    default: null
                },
                severity: {
                    type: String,
                    default: null
                },
                size: {
                    type: String,
                    default: null
                }
            },
            style: uR,
            provide: function() {
                return {
                    $pcBadge: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        computed: {
            dataP: function() {
                return RS(pR(pR({
                    circle: null != this.value && 1 === String(this.value).length,
                    empty: null == this.value && !this.$slots.default
                }, this.severity, this.severity), this.size, this.size))
            }
        }
    },
    fR = ["data-p"];
function gR(e) {
    return (gR = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function mR(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != gR(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != gR(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == gR(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
hR.render = function(e, t, n, r, o, i) {
    return uo(), go("span", Mo({
        class: e.cx("root"),
        "data-p": i.dataP
    }, e.ptmi("root")), [Yn(e.$slots, "default", {}, function() {
        return [Co(W(e.value), 1)]
    })], 16, fR)
};
var bR = {
        root: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-button p-component", mR(mR(mR(mR(mR(mR(mR(mR(mR({
                "p-button-icon-only": t.hasIcon && !n.label && !n.badge,
                "p-button-vertical": ("top" === n.iconPos || "bottom" === n.iconPos) && n.label,
                "p-button-loading": n.loading,
                "p-button-link": n.link || "link" === n.variant
            }, "p-button-".concat(n.severity), n.severity), "p-button-raised", n.raised), "p-button-rounded", n.rounded), "p-button-text", n.text || "text" === n.variant), "p-button-outlined", n.outlined || "outlined" === n.variant), "p-button-sm", "small" === n.size), "p-button-lg", "large" === n.size), "p-button-plain", n.plain), "p-button-fluid", t.hasFluid)]
        },
        loadingIcon: "p-button-loading-icon",
        icon: function(e) {
            var t = e.props;
            return ["p-button-icon", mR({}, "p-button-icon-".concat(t.iconPos), t.label)]
        },
        label: "p-button-label"
    },
    AR = kI.extend({
        name: "button",
        style: "\n    .p-button {\n        display: inline-flex;\n        cursor: pointer;\n        user-select: none;\n        align-items: center;\n        justify-content: center;\n        overflow: hidden;\n        position: relative;\n        color: dt('button.primary.color');\n        background: dt('button.primary.background');\n        border: 1px solid dt('button.primary.border.color');\n        padding: dt('button.padding.y') dt('button.padding.x');\n        font-size: 1rem;\n        font-family: inherit;\n        font-feature-settings: inherit;\n        transition:\n            background dt('button.transition.duration'),\n            color dt('button.transition.duration'),\n            border-color dt('button.transition.duration'),\n            outline-color dt('button.transition.duration'),\n            box-shadow dt('button.transition.duration');\n        border-radius: dt('button.border.radius');\n        outline-color: transparent;\n        gap: dt('button.gap');\n    }\n\n    .p-button:disabled {\n        cursor: default;\n    }\n\n    .p-button-icon-right {\n        order: 1;\n    }\n\n    .p-button-icon-right:dir(rtl) {\n        order: -1;\n    }\n\n    .p-button:not(.p-button-vertical) .p-button-icon:not(.p-button-icon-right):dir(rtl) {\n        order: 1;\n    }\n\n    .p-button-icon-bottom {\n        order: 2;\n    }\n\n    .p-button-icon-only {\n        width: dt('button.icon.only.width');\n        padding-inline-start: 0;\n        padding-inline-end: 0;\n        gap: 0;\n    }\n\n    .p-button-icon-only.p-button-rounded {\n        border-radius: 50%;\n        height: dt('button.icon.only.width');\n    }\n\n    .p-button-icon-only .p-button-label {\n        visibility: hidden;\n        width: 0;\n    }\n\n    .p-button-icon-only::after {\n        content: \"\0A0\";\n        visibility: hidden;\n        width: 0;\n    }\n\n    .p-button-sm {\n        font-size: dt('button.sm.font.size');\n        padding: dt('button.sm.padding.y') dt('button.sm.padding.x');\n    }\n\n    .p-button-sm .p-button-icon {\n        font-size: dt('button.sm.font.size');\n    }\n\n    .p-button-sm.p-button-icon-only {\n        width: dt('button.sm.icon.only.width');\n    }\n\n    .p-button-sm.p-button-icon-only.p-button-rounded {\n        height: dt('button.sm.icon.only.width');\n    }\n\n    .p-button-lg {\n        font-size: dt('button.lg.font.size');\n        padding: dt('button.lg.padding.y') dt('button.lg.padding.x');\n    }\n\n    .p-button-lg .p-button-icon {\n        font-size: dt('button.lg.font.size');\n    }\n\n    .p-button-lg.p-button-icon-only {\n        width: dt('button.lg.icon.only.width');\n    }\n\n    .p-button-lg.p-button-icon-only.p-button-rounded {\n        height: dt('button.lg.icon.only.width');\n    }\n\n    .p-button-vertical {\n        flex-direction: column;\n    }\n\n    .p-button-label {\n        font-weight: dt('button.label.font.weight');\n    }\n\n    .p-button-fluid {\n        width: 100%;\n    }\n\n    .p-button-fluid.p-button-icon-only {\n        width: dt('button.icon.only.width');\n    }\n\n    .p-button:not(:disabled):hover {\n        background: dt('button.primary.hover.background');\n        border: 1px solid dt('button.primary.hover.border.color');\n        color: dt('button.primary.hover.color');\n    }\n\n    .p-button:not(:disabled):active {\n        background: dt('button.primary.active.background');\n        border: 1px solid dt('button.primary.active.border.color');\n        color: dt('button.primary.active.color');\n    }\n\n    .p-button:focus-visible {\n        box-shadow: dt('button.primary.focus.ring.shadow');\n        outline: dt('button.focus.ring.width') dt('button.focus.ring.style') dt('button.primary.focus.ring.color');\n        outline-offset: dt('button.focus.ring.offset');\n    }\n\n    .p-button .p-badge {\n        min-width: dt('button.badge.size');\n        height: dt('button.badge.size');\n        line-height: dt('button.badge.size');\n    }\n\n    .p-button-raised {\n        box-shadow: dt('button.raised.shadow');\n    }\n\n    .p-button-rounded {\n        border-radius: dt('button.rounded.border.radius');\n    }\n\n    .p-button-secondary {\n        background: dt('button.secondary.background');\n        border: 1px solid dt('button.secondary.border.color');\n        color: dt('button.secondary.color');\n    }\n\n    .p-button-secondary:not(:disabled):hover {\n        background: dt('button.secondary.hover.background');\n        border: 1px solid dt('button.secondary.hover.border.color');\n        color: dt('button.secondary.hover.color');\n    }\n\n    .p-button-secondary:not(:disabled):active {\n        background: dt('button.secondary.active.background');\n        border: 1px solid dt('button.secondary.active.border.color');\n        color: dt('button.secondary.active.color');\n    }\n\n    .p-button-secondary:focus-visible {\n        outline-color: dt('button.secondary.focus.ring.color');\n        box-shadow: dt('button.secondary.focus.ring.shadow');\n    }\n\n    .p-button-success {\n        background: dt('button.success.background');\n        border: 1px solid dt('button.success.border.color');\n        color: dt('button.success.color');\n    }\n\n    .p-button-success:not(:disabled):hover {\n        background: dt('button.success.hover.background');\n        border: 1px solid dt('button.success.hover.border.color');\n        color: dt('button.success.hover.color');\n    }\n\n    .p-button-success:not(:disabled):active {\n        background: dt('button.success.active.background');\n        border: 1px solid dt('button.success.active.border.color');\n        color: dt('button.success.active.color');\n    }\n\n    .p-button-success:focus-visible {\n        outline-color: dt('button.success.focus.ring.color');\n        box-shadow: dt('button.success.focus.ring.shadow');\n    }\n\n    .p-button-info {\n        background: dt('button.info.background');\n        border: 1px solid dt('button.info.border.color');\n        color: dt('button.info.color');\n    }\n\n    .p-button-info:not(:disabled):hover {\n        background: dt('button.info.hover.background');\n        border: 1px solid dt('button.info.hover.border.color');\n        color: dt('button.info.hover.color');\n    }\n\n    .p-button-info:not(:disabled):active {\n        background: dt('button.info.active.background');\n        border: 1px solid dt('button.info.active.border.color');\n        color: dt('button.info.active.color');\n    }\n\n    .p-button-info:focus-visible {\n        outline-color: dt('button.info.focus.ring.color');\n        box-shadow: dt('button.info.focus.ring.shadow');\n    }\n\n    .p-button-warn {\n        background: dt('button.warn.background');\n        border: 1px solid dt('button.warn.border.color');\n        color: dt('button.warn.color');\n    }\n\n    .p-button-warn:not(:disabled):hover {\n        background: dt('button.warn.hover.background');\n        border: 1px solid dt('button.warn.hover.border.color');\n        color: dt('button.warn.hover.color');\n    }\n\n    .p-button-warn:not(:disabled):active {\n        background: dt('button.warn.active.background');\n        border: 1px solid dt('button.warn.active.border.color');\n        color: dt('button.warn.active.color');\n    }\n\n    .p-button-warn:focus-visible {\n        outline-color: dt('button.warn.focus.ring.color');\n        box-shadow: dt('button.warn.focus.ring.shadow');\n    }\n\n    .p-button-help {\n        background: dt('button.help.background');\n        border: 1px solid dt('button.help.border.color');\n        color: dt('button.help.color');\n    }\n\n    .p-button-help:not(:disabled):hover {\n        background: dt('button.help.hover.background');\n        border: 1px solid dt('button.help.hover.border.color');\n        color: dt('button.help.hover.color');\n    }\n\n    .p-button-help:not(:disabled):active {\n        background: dt('button.help.active.background');\n        border: 1px solid dt('button.help.active.border.color');\n        color: dt('button.help.active.color');\n    }\n\n    .p-button-help:focus-visible {\n        outline-color: dt('button.help.focus.ring.color');\n        box-shadow: dt('button.help.focus.ring.shadow');\n    }\n\n    .p-button-danger {\n        background: dt('button.danger.background');\n        border: 1px solid dt('button.danger.border.color');\n        color: dt('button.danger.color');\n    }\n\n    .p-button-danger:not(:disabled):hover {\n        background: dt('button.danger.hover.background');\n        border: 1px solid dt('button.danger.hover.border.color');\n        color: dt('button.danger.hover.color');\n    }\n\n    .p-button-danger:not(:disabled):active {\n        background: dt('button.danger.active.background');\n        border: 1px solid dt('button.danger.active.border.color');\n        color: dt('button.danger.active.color');\n    }\n\n    .p-button-danger:focus-visible {\n        outline-color: dt('button.danger.focus.ring.color');\n        box-shadow: dt('button.danger.focus.ring.shadow');\n    }\n\n    .p-button-contrast {\n        background: dt('button.contrast.background');\n        border: 1px solid dt('button.contrast.border.color');\n        color: dt('button.contrast.color');\n    }\n\n    .p-button-contrast:not(:disabled):hover {\n        background: dt('button.contrast.hover.background');\n        border: 1px solid dt('button.contrast.hover.border.color');\n        color: dt('button.contrast.hover.color');\n    }\n\n    .p-button-contrast:not(:disabled):active {\n        background: dt('button.contrast.active.background');\n        border: 1px solid dt('button.contrast.active.border.color');\n        color: dt('button.contrast.active.color');\n    }\n\n    .p-button-contrast:focus-visible {\n        outline-color: dt('button.contrast.focus.ring.color');\n        box-shadow: dt('button.contrast.focus.ring.shadow');\n    }\n\n    .p-button-outlined {\n        background: transparent;\n        border-color: dt('button.outlined.primary.border.color');\n        color: dt('button.outlined.primary.color');\n    }\n\n    .p-button-outlined:not(:disabled):hover {\n        background: dt('button.outlined.primary.hover.background');\n        border-color: dt('button.outlined.primary.border.color');\n        color: dt('button.outlined.primary.color');\n    }\n\n    .p-button-outlined:not(:disabled):active {\n        background: dt('button.outlined.primary.active.background');\n        border-color: dt('button.outlined.primary.border.color');\n        color: dt('button.outlined.primary.color');\n    }\n\n    .p-button-outlined.p-button-secondary {\n        border-color: dt('button.outlined.secondary.border.color');\n        color: dt('button.outlined.secondary.color');\n    }\n\n    .p-button-outlined.p-button-secondary:not(:disabled):hover {\n        background: dt('button.outlined.secondary.hover.background');\n        border-color: dt('button.outlined.secondary.border.color');\n        color: dt('button.outlined.secondary.color');\n    }\n\n    .p-button-outlined.p-button-secondary:not(:disabled):active {\n        background: dt('button.outlined.secondary.active.background');\n        border-color: dt('button.outlined.secondary.border.color');\n        color: dt('button.outlined.secondary.color');\n    }\n\n    .p-button-outlined.p-button-success {\n        border-color: dt('button.outlined.success.border.color');\n        color: dt('button.outlined.success.color');\n    }\n\n    .p-button-outlined.p-button-success:not(:disabled):hover {\n        background: dt('button.outlined.success.hover.background');\n        border-color: dt('button.outlined.success.border.color');\n        color: dt('button.outlined.success.color');\n    }\n\n    .p-button-outlined.p-button-success:not(:disabled):active {\n        background: dt('button.outlined.success.active.background');\n        border-color: dt('button.outlined.success.border.color');\n        color: dt('button.outlined.success.color');\n    }\n\n    .p-button-outlined.p-button-info {\n        border-color: dt('button.outlined.info.border.color');\n        color: dt('button.outlined.info.color');\n    }\n\n    .p-button-outlined.p-button-info:not(:disabled):hover {\n        background: dt('button.outlined.info.hover.background');\n        border-color: dt('button.outlined.info.border.color');\n        color: dt('button.outlined.info.color');\n    }\n\n    .p-button-outlined.p-button-info:not(:disabled):active {\n        background: dt('button.outlined.info.active.background');\n        border-color: dt('button.outlined.info.border.color');\n        color: dt('button.outlined.info.color');\n    }\n\n    .p-button-outlined.p-button-warn {\n        border-color: dt('button.outlined.warn.border.color');\n        color: dt('button.outlined.warn.color');\n    }\n\n    .p-button-outlined.p-button-warn:not(:disabled):hover {\n        background: dt('button.outlined.warn.hover.background');\n        border-color: dt('button.outlined.warn.border.color');\n        color: dt('button.outlined.warn.color');\n    }\n\n    .p-button-outlined.p-button-warn:not(:disabled):active {\n        background: dt('button.outlined.warn.active.background');\n        border-color: dt('button.outlined.warn.border.color');\n        color: dt('button.outlined.warn.color');\n    }\n\n    .p-button-outlined.p-button-help {\n        border-color: dt('button.outlined.help.border.color');\n        color: dt('button.outlined.help.color');\n    }\n\n    .p-button-outlined.p-button-help:not(:disabled):hover {\n        background: dt('button.outlined.help.hover.background');\n        border-color: dt('button.outlined.help.border.color');\n        color: dt('button.outlined.help.color');\n    }\n\n    .p-button-outlined.p-button-help:not(:disabled):active {\n        background: dt('button.outlined.help.active.background');\n        border-color: dt('button.outlined.help.border.color');\n        color: dt('button.outlined.help.color');\n    }\n\n    .p-button-outlined.p-button-danger {\n        border-color: dt('button.outlined.danger.border.color');\n        color: dt('button.outlined.danger.color');\n    }\n\n    .p-button-outlined.p-button-danger:not(:disabled):hover {\n        background: dt('button.outlined.danger.hover.background');\n        border-color: dt('button.outlined.danger.border.color');\n        color: dt('button.outlined.danger.color');\n    }\n\n    .p-button-outlined.p-button-danger:not(:disabled):active {\n        background: dt('button.outlined.danger.active.background');\n        border-color: dt('button.outlined.danger.border.color');\n        color: dt('button.outlined.danger.color');\n    }\n\n    .p-button-outlined.p-button-contrast {\n        border-color: dt('button.outlined.contrast.border.color');\n        color: dt('button.outlined.contrast.color');\n    }\n\n    .p-button-outlined.p-button-contrast:not(:disabled):hover {\n        background: dt('button.outlined.contrast.hover.background');\n        border-color: dt('button.outlined.contrast.border.color');\n        color: dt('button.outlined.contrast.color');\n    }\n\n    .p-button-outlined.p-button-contrast:not(:disabled):active {\n        background: dt('button.outlined.contrast.active.background');\n        border-color: dt('button.outlined.contrast.border.color');\n        color: dt('button.outlined.contrast.color');\n    }\n\n    .p-button-outlined.p-button-plain {\n        border-color: dt('button.outlined.plain.border.color');\n        color: dt('button.outlined.plain.color');\n    }\n\n    .p-button-outlined.p-button-plain:not(:disabled):hover {\n        background: dt('button.outlined.plain.hover.background');\n        border-color: dt('button.outlined.plain.border.color');\n        color: dt('button.outlined.plain.color');\n    }\n\n    .p-button-outlined.p-button-plain:not(:disabled):active {\n        background: dt('button.outlined.plain.active.background');\n        border-color: dt('button.outlined.plain.border.color');\n        color: dt('button.outlined.plain.color');\n    }\n\n    .p-button-text {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.primary.color');\n    }\n\n    .p-button-text:not(:disabled):hover {\n        background: dt('button.text.primary.hover.background');\n        border-color: transparent;\n        color: dt('button.text.primary.color');\n    }\n\n    .p-button-text:not(:disabled):active {\n        background: dt('button.text.primary.active.background');\n        border-color: transparent;\n        color: dt('button.text.primary.color');\n    }\n\n    .p-button-text.p-button-secondary {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.secondary.color');\n    }\n\n    .p-button-text.p-button-secondary:not(:disabled):hover {\n        background: dt('button.text.secondary.hover.background');\n        border-color: transparent;\n        color: dt('button.text.secondary.color');\n    }\n\n    .p-button-text.p-button-secondary:not(:disabled):active {\n        background: dt('button.text.secondary.active.background');\n        border-color: transparent;\n        color: dt('button.text.secondary.color');\n    }\n\n    .p-button-text.p-button-success {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.success.color');\n    }\n\n    .p-button-text.p-button-success:not(:disabled):hover {\n        background: dt('button.text.success.hover.background');\n        border-color: transparent;\n        color: dt('button.text.success.color');\n    }\n\n    .p-button-text.p-button-success:not(:disabled):active {\n        background: dt('button.text.success.active.background');\n        border-color: transparent;\n        color: dt('button.text.success.color');\n    }\n\n    .p-button-text.p-button-info {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.info.color');\n    }\n\n    .p-button-text.p-button-info:not(:disabled):hover {\n        background: dt('button.text.info.hover.background');\n        border-color: transparent;\n        color: dt('button.text.info.color');\n    }\n\n    .p-button-text.p-button-info:not(:disabled):active {\n        background: dt('button.text.info.active.background');\n        border-color: transparent;\n        color: dt('button.text.info.color');\n    }\n\n    .p-button-text.p-button-warn {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.warn.color');\n    }\n\n    .p-button-text.p-button-warn:not(:disabled):hover {\n        background: dt('button.text.warn.hover.background');\n        border-color: transparent;\n        color: dt('button.text.warn.color');\n    }\n\n    .p-button-text.p-button-warn:not(:disabled):active {\n        background: dt('button.text.warn.active.background');\n        border-color: transparent;\n        color: dt('button.text.warn.color');\n    }\n\n    .p-button-text.p-button-help {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.help.color');\n    }\n\n    .p-button-text.p-button-help:not(:disabled):hover {\n        background: dt('button.text.help.hover.background');\n        border-color: transparent;\n        color: dt('button.text.help.color');\n    }\n\n    .p-button-text.p-button-help:not(:disabled):active {\n        background: dt('button.text.help.active.background');\n        border-color: transparent;\n        color: dt('button.text.help.color');\n    }\n\n    .p-button-text.p-button-danger {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.danger.color');\n    }\n\n    .p-button-text.p-button-danger:not(:disabled):hover {\n        background: dt('button.text.danger.hover.background');\n        border-color: transparent;\n        color: dt('button.text.danger.color');\n    }\n\n    .p-button-text.p-button-danger:not(:disabled):active {\n        background: dt('button.text.danger.active.background');\n        border-color: transparent;\n        color: dt('button.text.danger.color');\n    }\n\n    .p-button-text.p-button-contrast {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.contrast.color');\n    }\n\n    .p-button-text.p-button-contrast:not(:disabled):hover {\n        background: dt('button.text.contrast.hover.background');\n        border-color: transparent;\n        color: dt('button.text.contrast.color');\n    }\n\n    .p-button-text.p-button-contrast:not(:disabled):active {\n        background: dt('button.text.contrast.active.background');\n        border-color: transparent;\n        color: dt('button.text.contrast.color');\n    }\n\n    .p-button-text.p-button-plain {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.text.plain.color');\n    }\n\n    .p-button-text.p-button-plain:not(:disabled):hover {\n        background: dt('button.text.plain.hover.background');\n        border-color: transparent;\n        color: dt('button.text.plain.color');\n    }\n\n    .p-button-text.p-button-plain:not(:disabled):active {\n        background: dt('button.text.plain.active.background');\n        border-color: transparent;\n        color: dt('button.text.plain.color');\n    }\n\n    .p-button-link {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.link.color');\n    }\n\n    .p-button-link:not(:disabled):hover {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.link.hover.color');\n    }\n\n    .p-button-link:not(:disabled):hover .p-button-label {\n        text-decoration: underline;\n    }\n\n    .p-button-link:not(:disabled):active {\n        background: transparent;\n        border-color: transparent;\n        color: dt('button.link.active.color');\n    }\n",
        classes: bR
    });
function yR(e) {
    return (yR = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function vR(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != yR(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != yR(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == yR(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var _R = {
        name: "Button",
        extends: {
            name: "BaseButton",
            extends: nT,
            props: {
                label: {
                    type: String,
                    default: null
                },
                icon: {
                    type: String,
                    default: null
                },
                iconPos: {
                    type: String,
                    default: "left"
                },
                iconClass: {
                    type: [String, Object],
                    default: null
                },
                badge: {
                    type: String,
                    default: null
                },
                badgeClass: {
                    type: [String, Object],
                    default: null
                },
                badgeSeverity: {
                    type: String,
                    default: "secondary"
                },
                loading: {
                    type: Boolean,
                    default: !1
                },
                loadingIcon: {
                    type: String,
                    default: void 0
                },
                as: {
                    type: [String, Object],
                    default: "BUTTON"
                },
                asChild: {
                    type: Boolean,
                    default: !1
                },
                link: {
                    type: Boolean,
                    default: !1
                },
                severity: {
                    type: String,
                    default: null
                },
                raised: {
                    type: Boolean,
                    default: !1
                },
                rounded: {
                    type: Boolean,
                    default: !1
                },
                text: {
                    type: Boolean,
                    default: !1
                },
                outlined: {
                    type: Boolean,
                    default: !1
                },
                size: {
                    type: String,
                    default: null
                },
                variant: {
                    type: String,
                    default: null
                },
                plain: {
                    type: Boolean,
                    default: !1
                },
                fluid: {
                    type: Boolean,
                    default: null
                }
            },
            style: AR,
            provide: function() {
                return {
                    $pcButton: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        inject: {
            $pcFluid: {
                default: null
            }
        },
        methods: {
            getPTOptions: function(e) {
                return ("root" === e ? this.ptmi : this.ptm)(e, {
                    context: {
                        disabled: this.disabled
                    }
                })
            }
        },
        computed: {
            disabled: function() {
                return this.$attrs.disabled || "" === this.$attrs.disabled || this.loading
            },
            defaultAriaLabel: function() {
                return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel
            },
            hasIcon: function() {
                return this.icon || this.$slots.icon
            },
            attrs: function() {
                return Mo(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"))
            },
            asAttrs: function() {
                return "BUTTON" === this.as ? {
                    type: "button",
                    disabled: this.disabled
                } : void 0
            },
            a11yAttrs: function() {
                return {
                    "aria-label": this.defaultAriaLabel,
                    "data-pc-name": "button",
                    "data-p-disabled": this.disabled,
                    "data-p-severity": this.severity
                }
            },
            hasFluid: function() {
                return rS(this.fluid) ? !!this.$pcFluid : this.fluid
            },
            dataP: function() {
                return RS(vR(vR(vR(vR(vR(vR(vR(vR(vR(vR({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge), "loading", this.loading), "fluid", this.hasFluid), "rounded", this.rounded), "raised", this.raised), "outlined", this.outlined || "outlined" === this.variant), "text", this.text || "text" === this.variant), "link", this.link || "link" === this.variant), "vertical", ("top" === this.iconPos || "bottom" === this.iconPos) && this.label))
            },
            dataIconP: function() {
                return RS(vR(vR({}, this.iconPos, this.iconPos), this.size, this.size))
            },
            dataLabelP: function() {
                return RS(vR(vR({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge))
            }
        },
        components: {
            SpinnerIcon: eM,
            Badge: hR
        },
        directives: {
            ripple: ET
        }
    },
    xR = ["data-p"],
    wR = ["data-p"];
_R.render = function(e, t, n, r, o, i) {
    var a = jn("SpinnerIcon"),
        s = jn("Badge"),
        l = $n("ripple");
    return e.asChild ? Yn(e.$slots, "default", {
        key: 1,
        class: G(e.cx("root")),
        a11yAttrs: i.a11yAttrs
    }) : Ht((uo(), mo(Hn(e.as), Mo({
        key: 0,
        class: e.cx("root"),
        "data-p": i.dataP
    }, i.attrs), {
        default: Vt(function() {
            return [Yn(e.$slots, "default", {}, function() {
                return [e.loading ? Yn(e.$slots, "loadingicon", Mo({
                    key: 0,
                    class: [e.cx("loadingIcon"), e.cx("icon")]
                }, e.ptm("loadingIcon")), function() {
                    return [e.loadingIcon ? (uo(), go("span", Mo({
                        key: 0,
                        class: [e.cx("loadingIcon"), e.cx("icon"), e.loadingIcon]
                    }, e.ptm("loadingIcon")), null, 16)) : (uo(), mo(a, Mo({
                        key: 1,
                        class: [e.cx("loadingIcon"), e.cx("icon")],
                        spin: ""
                    }, e.ptm("loadingIcon")), null, 16, ["class"]))]
                }) : Yn(e.$slots, "icon", Mo({
                    key: 1,
                    class: [e.cx("icon")]
                }, e.ptm("icon")), function() {
                    return [e.icon ? (uo(), go("span", Mo({
                        key: 0,
                        class: [e.cx("icon"), e.icon, e.iconClass],
                        "data-p": i.dataIconP
                    }, e.ptm("icon")), null, 16, xR)) : Eo("", !0)]
                }), e.label ? (uo(), go("span", Mo({
                    key: 2,
                    class: e.cx("label")
                }, e.ptm("label"), {
                    "data-p": i.dataLabelP
                }), W(e.label), 17, wR)) : Eo("", !0), e.badge ? (uo(), mo(s, {
                    key: 3,
                    value: e.badge,
                    class: G(e.badgeClass),
                    severity: e.badgeSeverity,
                    unstyled: e.unstyled,
                    pt: e.ptm("pcBadge")
                }, null, 8, ["value", "class", "severity", "unstyled", "pt"])) : Eo("", !0)]
            })]
        }),
        _: 3
    }, 16, ["class", "data-p"])), [[l]])
};
var CR = kI.extend({
    name: "checkbox",
    style: "\n    .p-checkbox {\n        position: relative;\n        display: inline-flex;\n        user-select: none;\n        vertical-align: bottom;\n        width: dt('checkbox.width');\n        height: dt('checkbox.height');\n    }\n\n    .p-checkbox-input {\n        cursor: pointer;\n        appearance: none;\n        position: absolute;\n        inset-block-start: 0;\n        inset-inline-start: 0;\n        width: 100%;\n        height: 100%;\n        padding: 0;\n        margin: 0;\n        opacity: 0;\n        z-index: 1;\n        outline: 0 none;\n        border: 1px solid transparent;\n        border-radius: dt('checkbox.border.radius');\n    }\n\n    .p-checkbox-box {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        border-radius: dt('checkbox.border.radius');\n        border: 1px solid dt('checkbox.border.color');\n        background: dt('checkbox.background');\n        width: dt('checkbox.width');\n        height: dt('checkbox.height');\n        transition:\n            background dt('checkbox.transition.duration'),\n            color dt('checkbox.transition.duration'),\n            border-color dt('checkbox.transition.duration'),\n            box-shadow dt('checkbox.transition.duration'),\n            outline-color dt('checkbox.transition.duration');\n        outline-color: transparent;\n        box-shadow: dt('checkbox.shadow');\n    }\n\n    .p-checkbox-icon {\n        transition-duration: dt('checkbox.transition.duration');\n        color: dt('checkbox.icon.color');\n        font-size: dt('checkbox.icon.size');\n        width: dt('checkbox.icon.size');\n        height: dt('checkbox.icon.size');\n    }\n\n    .p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n        border-color: dt('checkbox.hover.border.color');\n    }\n\n    .p-checkbox-checked .p-checkbox-box {\n        border-color: dt('checkbox.checked.border.color');\n        background: dt('checkbox.checked.background');\n    }\n\n    .p-checkbox-checked .p-checkbox-icon {\n        color: dt('checkbox.icon.checked.color');\n    }\n\n    .p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n        background: dt('checkbox.checked.hover.background');\n        border-color: dt('checkbox.checked.hover.border.color');\n    }\n\n    .p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-icon {\n        color: dt('checkbox.icon.checked.hover.color');\n    }\n\n    .p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n        border-color: dt('checkbox.focus.border.color');\n        box-shadow: dt('checkbox.focus.ring.shadow');\n        outline: dt('checkbox.focus.ring.width') dt('checkbox.focus.ring.style') dt('checkbox.focus.ring.color');\n        outline-offset: dt('checkbox.focus.ring.offset');\n    }\n\n    .p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) .p-checkbox-box {\n        border-color: dt('checkbox.checked.focus.border.color');\n    }\n\n    .p-checkbox.p-invalid > .p-checkbox-box {\n        border-color: dt('checkbox.invalid.border.color');\n    }\n\n    .p-checkbox.p-variant-filled .p-checkbox-box {\n        background: dt('checkbox.filled.background');\n    }\n\n    .p-checkbox-checked.p-variant-filled .p-checkbox-box {\n        background: dt('checkbox.checked.background');\n    }\n\n    .p-checkbox-checked.p-variant-filled:not(.p-disabled):has(.p-checkbox-input:hover) .p-checkbox-box {\n        background: dt('checkbox.checked.hover.background');\n    }\n\n    .p-checkbox.p-disabled {\n        opacity: 1;\n    }\n\n    .p-checkbox.p-disabled .p-checkbox-box {\n        background: dt('checkbox.disabled.background');\n        border-color: dt('checkbox.checked.disabled.border.color');\n    }\n\n    .p-checkbox.p-disabled .p-checkbox-box .p-checkbox-icon {\n        color: dt('checkbox.icon.disabled.color');\n    }\n\n    .p-checkbox-sm,\n    .p-checkbox-sm .p-checkbox-box {\n        width: dt('checkbox.sm.width');\n        height: dt('checkbox.sm.height');\n    }\n\n    .p-checkbox-sm .p-checkbox-icon {\n        font-size: dt('checkbox.icon.sm.size');\n        width: dt('checkbox.icon.sm.size');\n        height: dt('checkbox.icon.sm.size');\n    }\n\n    .p-checkbox-lg,\n    .p-checkbox-lg .p-checkbox-box {\n        width: dt('checkbox.lg.width');\n        height: dt('checkbox.lg.height');\n    }\n\n    .p-checkbox-lg .p-checkbox-icon {\n        font-size: dt('checkbox.icon.lg.size');\n        width: dt('checkbox.icon.lg.size');\n        height: dt('checkbox.icon.lg.size');\n    }\n",
    classes: {
        root: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-checkbox p-component", {
                "p-checkbox-checked": t.checked,
                "p-disabled": n.disabled,
                "p-invalid": t.$pcCheckboxGroup ? t.$pcCheckboxGroup.$invalid : t.$invalid,
                "p-variant-filled": "filled" === t.$variant,
                "p-checkbox-sm p-inputfield-sm": "small" === n.size,
                "p-checkbox-lg p-inputfield-lg": "large" === n.size
            }]
        },
        box: "p-checkbox-box",
        input: "p-checkbox-input",
        icon: "p-checkbox-icon"
    }
});
function ER(e) {
    return (ER = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function SR(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var IR = {
        name: "Checkbox",
        extends: {
            name: "BaseCheckbox",
            extends: oM,
            props: {
                value: null,
                binary: Boolean,
                indeterminate: {
                    type: Boolean,
                    default: !1
                },
                trueValue: {
                    type: null,
                    default: !0
                },
                falseValue: {
                    type: null,
                    default: !1
                },
                readonly: {
                    type: Boolean,
                    default: !1
                },
                required: {
                    type: Boolean,
                    default: !1
                },
                tabindex: {
                    type: Number,
                    default: null
                },
                inputId: {
                    type: String,
                    default: null
                },
                inputClass: {
                    type: [String, Object],
                    default: null
                },
                inputStyle: {
                    type: Object,
                    default: null
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                ariaLabel: {
                    type: String,
                    default: null
                }
            },
            style: CR,
            provide: function() {
                return {
                    $pcCheckbox: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change", "focus", "blur", "update:indeterminate"],
        inject: {
            $pcCheckboxGroup: {
                default: void 0
            }
        },
        data: function() {
            return {
                d_indeterminate: this.indeterminate
            }
        },
        watch: {
            indeterminate: function(e) {
                this.d_indeterminate = e,
                this.updateIndeterminate()
            }
        },
        mounted: function() {
            this.updateIndeterminate()
        },
        updated: function() {
            this.updateIndeterminate()
        },
        methods: {
            getPTOptions: function(e) {
                return ("root" === e ? this.ptmi : this.ptm)(e, {
                    context: {
                        checked: this.checked,
                        indeterminate: this.d_indeterminate,
                        disabled: this.disabled
                    }
                })
            },
            onChange: function(e) {
                var t,
                    n = this;
                if (!this.disabled && !this.readonly) {
                    var r,
                        o = this.$pcCheckboxGroup ? this.$pcCheckboxGroup.d_value : this.d_value;
                    r = this.binary ? this.d_indeterminate ? this.trueValue : this.checked ? this.falseValue : this.trueValue : this.checked || this.d_indeterminate ? o.filter(function(e) {
                        return !cS(e, n.value)
                    }) : o ? [].concat(function(e) {
                        if (Array.isArray(e))
                            return SR(e)
                    }(t = o) || function(e) {
                        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                            return Array.from(e)
                    }(t) || function(e, t) {
                        if (e) {
                            if ("string" == typeof e)
                                return SR(e, t);
                            var n = {}.toString.call(e).slice(8, -1);
                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? SR(e, t) : void 0
                        }
                    }(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }(), [this.value]) : [this.value],
                    this.d_indeterminate && (this.d_indeterminate = !1, this.$emit("update:indeterminate", this.d_indeterminate)),
                    this.$pcCheckboxGroup ? this.$pcCheckboxGroup.writeValue(r, e) : this.writeValue(r, e),
                    this.$emit("change", e)
                }
            },
            onFocus: function(e) {
                this.$emit("focus", e)
            },
            onBlur: function(e) {
                var t,
                    n;
                this.$emit("blur", e),
                null === (t = (n = this.formField).onBlur) || void 0 === t || t.call(n, e)
            },
            updateIndeterminate: function() {
                this.$refs.input && (this.$refs.input.indeterminate = this.d_indeterminate)
            }
        },
        computed: {
            groupName: function() {
                return this.$pcCheckboxGroup ? this.$pcCheckboxGroup.groupName : this.$formName
            },
            checked: function() {
                var e = this.$pcCheckboxGroup ? this.$pcCheckboxGroup.d_value : this.d_value;
                return !this.d_indeterminate && (this.binary ? e === this.trueValue : function(e, t) {
                        if (null != e && t && t.length)
                            for (let n of t)
                                if (cS(e, n))
                                    return !0;
                        return !1
                    }(this.value, e))
            },
            dataP: function() {
                return RS((e = {
                    invalid: this.$invalid,
                    checked: this.checked,
                    disabled: this.disabled,
                    filled: "filled" === this.$variant
                }, t = this.size, n = this.size, (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != ER(e) || !e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t);
                            if ("object" != ER(r))
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(e)
                    }(e, "string");
                    return "symbol" == ER(t) ? t : t + ""
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e));
                var e,
                    t,
                    n
            }
        },
        components: {
            CheckIcon: KT,
            MinusIcon: KM
        }
    },
    TR = ["data-p-checked", "data-p-indeterminate", "data-p-disabled", "data-p"],
    MR = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "required", "aria-labelledby", "aria-label", "aria-invalid"],
    RR = ["data-p"];
IR.render = function(e, t, n, r, o, i) {
    var a = jn("CheckIcon"),
        s = jn("MinusIcon");
    return uo(), go("div", Mo({
        class: e.cx("root")
    }, i.getPTOptions("root"), {
        "data-p-checked": i.checked,
        "data-p-indeterminate": o.d_indeterminate || void 0,
        "data-p-disabled": e.disabled,
        "data-p": i.dataP
    }), [_o("input", Mo({
        ref: "input",
        id: e.inputId,
        type: "checkbox",
        class: [e.cx("input"), e.inputClass],
        style: e.inputStyle,
        value: e.value,
        name: i.groupName,
        checked: i.checked,
        tabindex: e.tabindex,
        disabled: e.disabled,
        readonly: e.readonly,
        required: e.required,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        "aria-invalid": e.invalid || void 0,
        onFocus: t[0] || (t[0] = function() {
            return i.onFocus && i.onFocus.apply(i, arguments)
        }),
        onBlur: t[1] || (t[1] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        }),
        onChange: t[2] || (t[2] = function() {
            return i.onChange && i.onChange.apply(i, arguments)
        })
    }, i.getPTOptions("input")), null, 16, MR), _o("div", Mo({
        class: e.cx("box")
    }, i.getPTOptions("box"), {
        "data-p": i.dataP
    }), [Yn(e.$slots, "icon", {
        checked: i.checked,
        indeterminate: o.d_indeterminate,
        class: G(e.cx("icon")),
        dataP: i.dataP
    }, function() {
        return [i.checked ? (uo(), mo(a, Mo({
            key: 0,
            class: e.cx("icon")
        }, i.getPTOptions("icon"), {
            "data-p": i.dataP
        }), null, 16, ["class", "data-p"])) : o.d_indeterminate ? (uo(), mo(s, Mo({
            key: 1,
            class: e.cx("icon")
        }, i.getPTOptions("icon"), {
            "data-p": i.dataP
        }), null, 16, ["class", "data-p"])) : Eo("", !0)]
    })], 16, RR)], 16, TR)
};
const BR = {
        class: "flex-column"
    },
    kR = ["for"],
    DR = {
        class: "flex-column flex-1 align-stretch gap-2"
    },
    PR = {
        class: "flex-row"
    },
    OR = {
        class: "flex-1"
    },
    LR = {
        class: "flex-1"
    },
    NR = {
        class: "flex-column align-stretch gap-1"
    },
    FR = {
        class: "flex-row flex-1 align-center gap-1"
    },
    UR = {
        class: "flex-row flex-1 align-center gap-1"
    },
    zR = {
        class: "flex-column align-stretch gap-2"
    },
    QR = {
        class: "flex-row flex-1 align-center gap-1"
    },
    GR = {
        class: "flex-column"
    },
    jR = {
        class: "flex-column flex-1 align-stretch gap-1"
    },
    VR = {
        class: "flex-row"
    },
    HR = {
        class: "flex-row flex-1 align-center gap-1"
    },
    $R = {
        key: 0,
        class: "flex-column gap-1"
    },
    WR = {
        class: "flex-row align-center gap-1"
    },
    KR = {
        class: "flex-column flex-1 align-stretch"
    },
    qR = {
        class: "flex-row"
    },
    XR = {
        class: "flex-column flex-1 align-stretch"
    },
    YR = {
        class: "flex-row"
    },
    JR = {
        key: 1,
        class: "flex-column gap-1"
    },
    ZR = {
        class: "flex-row align-center gap-1"
    },
    eB = {
        class: "flex-column flex-1 align-stretch gap-1"
    },
    tB = {
        class: "flex-row"
    },
    nB = {
        key: 0,
        class: ""
    },
    rB = {
        key: 1,
        class: "mt-2"
    },
    oB = {
        key: 2,
        class: "mt-2"
    },
    iB = {
        key: 3,
        class: "mt-2"
    },
    aB = "Generate mipmaps and store them, rather than generating them at runtime.",
    sB = sE(yn({
        __name: "compression-controls",
        setup(e) {
            const t = ft(!1),
                n = ft(!1),
                r = ft("draco"),
                o = ft(["flatten", "dedup", "join", "reorder", "instance", "weld"]),
                i = ft(1),
                a = ft(1),
                s = ft(1),
                l = ft(1),
                c = ft(1),
                u = ft([{
                    name: "positions",
                    label: "Positions",
                    model: i
                }, {
                    name: "texcoords",
                    label: "Texcoords",
                    model: l
                }, {
                    name: "colors",
                    label: "Colors",
                    model: s
                }, {
                    name: "normals",
                    label: "Normals",
                    model: a
                }, {
                    name: "other",
                    label: "Other",
                    model: c
                }]),
                d = ft("edgebreaker"),
                p = ft([{
                    name: "edgebreaker",
                    label: "Edgebreaker"
                }, {
                    name: "sequential",
                    label: "Sequential"
                }]),
                h = ft("mesh"),
                f = ft([{
                    name: "mesh",
                    label: "Mesh"
                }, {
                    name: "scene",
                    label: "Scene"
                }]),
                g = ft("medium"),
                m = ft([{
                    name: "medium",
                    label: "Medium"
                }, {
                    name: "high",
                    label: "High"
                }]),
                b = [{
                    name: "flatten",
                    tooltip: "Flattens the scene graph, leaving Nodes with Meshes, Cameras, and other attachments as direct children of the Scene. Skeletons and their descendants are left in their original Node structure."
                }, {
                    name: "dedup",
                    tooltip: "Removes duplicate vertices and other redundant data to optimize the mesh."
                }, {
                    name: "join",
                    tooltip: "Joins multiple meshes into a single mesh to reduce draw calls."
                }, {
                    name: "weld",
                    tooltip: "Weld mesh geometry, removing bitwise identical vertices."
                }, {
                    name: "reorder",
                    tooltip: "Reorders vertices and indices to improve rendering performance."
                }, {
                    name: "instance",
                    tooltip: "Converts repeated geometry into instances to save memory."
                }],
                A = ft(10),
                y = ft("etc1s"),
                v = ft([{
                    name: "etc1s",
                    label: "ETC1S"
                }, {
                    name: "uastc",
                    label: "UASTC"
                }, {
                    name: "avif",
                    label: "AVIF"
                }, {
                    name: "webp",
                    label: "WebP"
                }, {
                    name: "jpeg",
                    label: "JPEG"
                }, {
                    name: "png",
                    label: "PNG"
                }]),
                _ = ft(75),
                x = ft(!0),
                w = ft(128),
                C = ft(1),
                E = ft(1);
            function S(e) {
                return 0 === e ? 8 : 1 === e ? 16 : 32
            }
            function I(e) {
                r.value = e
            }
            function T() {
                let e = null;
                "draco" === r.value ? e = {
                    type: "draco",
                    method: "edgebreaker" === d.value ? "edgebreaker" : "sequential",
                    quantization: "mesh" === h.value ? "mesh" : "scene"
                } : "meshopt" === r.value && (e = {
                    type: "meshopt",
                    level: "medium" === g.value ? "medium" : "high"
                });
                let t = {
                    type: "avif",
                    quality: 75
                };
                switch (y.value) {
                case "etc1s":
                    t = {
                        type: "etc1s",
                        generateMipmaps: x.value,
                        quality: w.value,
                        compression: C.value
                    };
                    break;
                case "uastc":
                    t = {
                        type: "uastc",
                        generateMipmaps: x.value,
                        quality: E.value
                    };
                    break;
                case "avif":
                case "webp":
                case "jpeg":
                case "png":
                    t = {
                        type: y.value,
                        quality: _.value
                    }
                }
                const u = {
                    mesh: {
                        flatten: o.value.includes("flatten"),
                        dedup: o.value.includes("dedup"),
                        join: o.value.includes("join"),
                        reorder: o.value.includes("reorder"),
                        instance: o.value.includes("instance"),
                        weld: o.value.includes("weld")
                    },
                    vertices: {
                        quantization: {
                            position: S(i.value),
                            normal: S(a.value),
                            color: S(s.value),
                            texcoord: S(l.value),
                            other: S(c.value)
                        },
                        compression: e
                    },
                    textures: {
                        resize: 2 ** A.value,
                        format: t
                    }
                };
                iE("applyChanges", {
                    settings: u
                }),
                n.value = !0
            }
            return oE("compressionCompleted", () => {
                n.value = !1
            }), oE("loaded", ({error: e}) => {
                e || (t.value = !0)
            }), (e, r) => {
                const i = sT,
                    a = HI;
                return t.value ? (uo(), go("div", Mo({
                    key: 0
                }, e.$attrs, {
                    class: "flex-column poop gap-1"
                }), [xo(mt(_R), {
                    label: "Apply Changes",
                    onClick: T,
                    disabled: n.value
                }, null, 8, ["disabled"]), xo(mt(kM), {
                    value: "mesh"
                }, {
                    default: Vt(() => [xo(mt(NM), null, {
                        default: Vt(() => [xo(mt(VM), {
                            value: "mesh"
                        }, {
                            default: Vt(() => [...r[12] || (r[12] = [Co("Mesh", -1)])]),
                            _: 1
                        }), xo(mt(VM), {
                            value: "vertex"
                        }, {
                            default: Vt(() => [...r[13] || (r[13] = [Co("Vertex", -1)])]),
                            _: 1
                        }), xo(mt(VM), {
                            value: "texture"
                        }, {
                            default: Vt(() => [...r[14] || (r[14] = [Co("Texture", -1)])]),
                            _: 1
                        })]),
                        _: 1
                    }), xo(mt(HM), null, {
                        default: Vt(() => [xo(mt(WM), {
                            value: "mesh"
                        }, {
                            default: Vt(() => [xo(mt(ZM), {
                                legend: "Mesh Options",
                                toggleable: !0
                            }, {
                                default: Vt(() => [r[15] || (r[15] = _o("p", null, "Various options related to the mesh/scene hierarchy.", -1)), _o("div", BR, [(uo(), go(oo, null, qn(b, e => {
                                    return _o("div", {
                                        key: e.name,
                                        class: "flex-row align-center gap-1"
                                    }, [xo(mt(IR), {
                                        modelValue: o.value,
                                        "onUpdate:modelValue": r[0] || (r[0] = e => o.value = e),
                                        name: e.name,
                                        value: e.name
                                    }, null, 8, ["modelValue", "name", "value"]), Ht((uo(), go("label", {
                                        for: e.name
                                    }, [Co(W((t = e.name, t.charAt(0).toUpperCase() + t.slice(1))), 1)], 8, kR)), [[a, e.tooltip]])]);
                                    var t
                                }), 64))])]),
                                _: 1
                            })]),
                            _: 1
                        }), xo(mt(WM), {
                            value: "vertex"
                        }, {
                            default: Vt(() => [xo(mt(ZM), {
                                legend: "Quantization",
                                toggleable: !0
                            }, {
                                default: Vt(() => [r[17] || (r[17] = _o("p", null, "Quantization effects size in GPU memory.", -1)), _o("div", DR, [(uo(!0), go(oo, null, qn(u.value, e => {
                                    return uo(), go("div", {
                                        key: e.name,
                                        class: "flex-column flex-1 align-stretch"
                                    }, [_o("div", PR, [e.model <= 1 ? (uo(), go(oo, {
                                        key: 0
                                    }, [_o("span", OR, W(e.label), 1), _o("span", null, W((t = e.model, 0 === t ? "8" : 1 === t ? "16" : "Full")) + " bit", 1)], 64)) : (uo(), go(oo, {
                                        key: 1
                                    }, [_o("span", LR, W(e.label), 1), r[16] || (r[16] = _o("span", null, "Full Precision", -1))], 64))]), xo(i, {
                                        small: "",
                                        class: "flex",
                                        modelValue: e.model,
                                        "onUpdate:modelValue": t => e.model = t,
                                        step: 1,
                                        min: 0,
                                        max: 2,
                                        "default-value": 1
                                    }, null, 8, ["modelValue", "onUpdate:modelValue"])]);
                                    var t
                                }), 128))])]),
                                _: 1
                            }), xo(mt(ZM), {
                                legend: "Compression",
                                toggleable: !0
                            }, {
                                default: Vt(() => [xo(mt(kM), {
                                    value: "draco",
                                    "onUpdate:value": I
                                }, {
                                    default: Vt(() => [r[24] || (r[24] = _o("p", null, "Compression effects file size and load time.", -1)), xo(mt(NM), null, {
                                        default: Vt(() => [xo(mt(VM), {
                                            value: "draco"
                                        }, {
                                            default: Vt(() => [...r[18] || (r[18] = [Co("Draco", -1)])]),
                                            _: 1
                                        }), xo(mt(VM), {
                                            value: "none"
                                        }, {
                                            default: Vt(() => [...r[19] || (r[19] = [Co("None", -1)])]),
                                            _: 1
                                        })]),
                                        _: 1
                                    }), xo(mt(HM), null, {
                                        default: Vt(() => [xo(mt(WM), {
                                            value: "draco"
                                        }, {
                                            default: Vt(() => [_o("div", NR, [_o("div", FR, [r[20] || (r[20] = _o("label", {
                                                class: "flex-1"
                                            }, "Method", -1)), xo(mt(wM), {
                                                class: "flex-2",
                                                modelValue: d.value,
                                                "onUpdate:modelValue": r[1] || (r[1] = e => d.value = e),
                                                options: p.value,
                                                "option-label": "label",
                                                "option-value": "name"
                                            }, null, 8, ["modelValue", "options"])]), _o("div", UR, [r[21] || (r[21] = _o("label", {
                                                class: "flex-1"
                                            }, "Quantization", -1)), xo(mt(wM), {
                                                class: "flex-2",
                                                modelValue: h.value,
                                                "onUpdate:modelValue": r[2] || (r[2] = e => h.value = e),
                                                options: f.value,
                                                "option-label": "label",
                                                "option-value": "name"
                                            }, null, 8, ["modelValue", "options"])])])]),
                                            _: 1
                                        }), xo(mt(WM), {
                                            value: "meshopt"
                                        }, {
                                            default: Vt(() => [_o("div", zR, [_o("div", QR, [r[22] || (r[22] = _o("label", {
                                                class: "flex-1"
                                            }, "Level", -1)), xo(mt(wM), {
                                                class: "flex-2",
                                                modelValue: g.value,
                                                "onUpdate:modelValue": r[3] || (r[3] = e => g.value = e),
                                                options: m.value,
                                                "option-label": "label",
                                                "option-value": "name"
                                            }, null, 8, ["modelValue", "options"])])])]),
                                            _: 1
                                        }), xo(mt(WM), {
                                            value: "none"
                                        }, {
                                            default: Vt(() => [...r[23] || (r[23] = [_o("div", {
                                                class: "flex-column gap-2"
                                            }, [_o("p", null, "No vertex compression selected.")], -1)])]),
                                            _: 1
                                        })]),
                                        _: 1
                                    })]),
                                    _: 1
                                })]),
                                _: 1
                            })]),
                            _: 1
                        }), xo(mt(WM), {
                            value: "texture"
                        }, {
                            default: Vt(() => [_o("div", GR, [xo(mt(ZM), {
                                legend: "Resize",
                                toggleable: !0
                            }, {
                                default: Vt(() => [r[26] || (r[26] = _o("p", null, "Set a maximum texture size.", -1)), _o("div", jR, [_o("div", VR, [r[25] || (r[25] = _o("label", {
                                    class: "flex-1"
                                }, "Max. Resolution", -1)), _o("span", null, W(2 ** A.value) + "x" + W(2 ** A.value), 1)]), xo(i, {
                                    class: "flex",
                                    modelValue: A.value,
                                    "onUpdate:modelValue": r[4] || (r[4] = e => A.value = e),
                                    step: 1,
                                    min: 5,
                                    max: 12,
                                    "default-value": A.value
                                }, null, 8, ["modelValue", "default-value"])])]),
                                _: 1
                            }), xo(mt(ZM), {
                                legend: "Format",
                                toggleable: !0
                            }, {
                                default: Vt(() => [_o("div", HR, [r[27] || (r[27] = _o("label", {
                                    class: "flex-1"
                                }, "Format", -1)), xo(mt(wM), {
                                    class: "flex-2",
                                    modelValue: y.value,
                                    "onUpdate:modelValue": r[5] || (r[5] = e => y.value = e),
                                    options: v.value,
                                    "option-label": "label",
                                    "option-value": "name"
                                }, null, 8, ["modelValue", "options"])]), "etc1s" === y.value ? (uo(), go("div", $R, [r[32] || (r[32] = _o("p", null, "ETC1S is a highly compressed GPU texture format suitable for general assets. It's optimized for minimum size over quality. Alpha is supported.", -1)), _o("div", WR, [xo(mt(IR), {
                                    name: "ktx2-genmipmap",
                                    modelValue: x.value,
                                    "onUpdate:modelValue": r[6] || (r[6] = e => x.value = e),
                                    binary: ""
                                }, null, 8, ["modelValue"]), Ht((uo(), go("label", null, [...r[28] || (r[28] = [Co("Generate Mipmaps", -1)])])), [[a, aB]])]), _o("div", KR, [_o("div", qR, [r[29] || (r[29] = _o("label", {
                                    class: "flex-1"
                                }, "Quality", -1)), _o("span", null, W(w.value), 1)]), xo(i, {
                                    class: "flex",
                                    modelValue: w.value,
                                    "onUpdate:modelValue": r[7] || (r[7] = e => w.value = e),
                                    step: 1,
                                    min: 1,
                                    max: 255,
                                    "default-value": w.value
                                }, null, 8, ["modelValue", "default-value"])]), _o("div", XR, [_o("div", YR, [r[30] || (r[30] = _o("label", {
                                    class: "flex-1"
                                }, "Encoding Effort", -1)), _o("span", null, W(C.value), 1)]), xo(i, {
                                    class: "flex",
                                    modelValue: C.value,
                                    "onUpdate:modelValue": r[8] || (r[8] = e => C.value = e),
                                    step: 1,
                                    min: 0,
                                    max: 4,
                                    "default-value": C.value
                                }, null, 8, ["modelValue", "default-value"])]), C.value > 2 ? (uo(), mo(mt(MT), {
                                    key: 0,
                                    icon: "pi pi-exclamation-triangle",
                                    severity: "warn"
                                }, {
                                    default: Vt(() => [...r[31] || (r[31] = [Co("Choosing a high level may result in excessively long compression times.", -1)])]),
                                    _: 1
                                })) : Eo("", !0)])) : "uastc" === y.value ? (uo(), go("div", JR, [r[36] || (r[36] = _o("p", null, "UASTC is a higher quality GPU texture format that offers better visual quality compared to ETC1S, at the cost of larger file sizes. Alpha is supported.", -1)), _o("div", ZR, [xo(mt(IR), {
                                    name: "ktx2-genmipmap",
                                    modelValue: x.value,
                                    "onUpdate:modelValue": r[9] || (r[9] = e => x.value = e),
                                    binary: ""
                                }, null, 8, ["modelValue"]), Ht((uo(), go("label", null, [...r[33] || (r[33] = [Co("Generate Mipmaps", -1)])])), [[a, aB]])]), _o("div", eB, [_o("div", tB, [r[34] || (r[34] = _o("label", {
                                    class: "flex-1"
                                }, "Quality", -1)), _o("span", null, W(E.value), 1)]), xo(i, {
                                    class: "flex",
                                    modelValue: E.value,
                                    "onUpdate:modelValue": r[10] || (r[10] = e => E.value = e),
                                    step: 1,
                                    min: 0,
                                    max: 3,
                                    "default-value": E.value
                                }, null, 8, ["modelValue", "default-value"])]), E.value > 1 ? (uo(), mo(mt(MT), {
                                    key: 0,
                                    icon: "pi pi-exclamation-triangle",
                                    severity: "warn"
                                }, {
                                    default: Vt(() => [...r[35] || (r[35] = [Co("Choosing a high level of compression may result in excessively long", -1)])]),
                                    _: 1
                                })) : Eo("", !0)])) : (uo(), go(oo, {
                                    key: 2
                                }, [xo(mt(MT), {
                                    class: "mt-1",
                                    icon: "pi pi-info-circle mr-0_5",
                                    severity: "warn"
                                }, {
                                    default: Vt(() => [...r[37] || (r[37] = [Co("These are not GPU compressed formats and while the file size may be smaller, these will be reinflated to full size in memory.", -1)])]),
                                    _: 1
                                }), "avif" === y.value ? (uo(), go("div", nB, [...r[38] || (r[38] = [_o("p", null, "AVIF is a modern image format that offers very high compression efficiency and good visual quality at low bitrates. It supports alpha, including high-quality transparency.", -1)])])) : "webp" === y.value ? (uo(), go("div", rB, [...r[39] || (r[39] = [_o("p", null, "WebP is an image format designed for the web that provides better compression than JPG in both lossy and lossless modes. Alpha is supported, with good quality for UI and general assets.", -1)])])) : "jpeg" === y.value ? (uo(), go("div", oB, [...r[40] || (r[40] = [_o("p", null, "JPG is a widely used lossy image format that offers good visual quality at relatively small file sizes. Alpha is not supported.", -1)])])) : "png" === y.value ? (uo(), go("div", iB, [...r[41] || (r[41] = [_o("p", null, "PNG is a lossless image format that preserves exact pixel data, making it suitable for UI, text, and graphics where quality must not degrade. Alpha is supported with high-quality transparency.", -1)])])) : Eo("", !0)], 64)), ("etc1s" !== y.value && "uastc" !== y.value && y.value, Eo("", !0))]),
                                _: 1
                            })])]),
                            _: 1
                        })]),
                        _: 1
                    })]),
                    _: 1
                })], 16)) : Eo("", !0)
            }
        }
    }), [["__scopeId", "data-v-23369e2e"]]);
var lB = {
        name: "Card",
        extends: {
            name: "BaseCard",
            extends: nT,
            style: kI.extend({
                name: "card",
                style: "\n    .p-card {\n        background: dt('card.background');\n        color: dt('card.color');\n        box-shadow: dt('card.shadow');\n        border-radius: dt('card.border.radius');\n        display: flex;\n        flex-direction: column;\n    }\n\n    .p-card-caption {\n        display: flex;\n        flex-direction: column;\n        gap: dt('card.caption.gap');\n    }\n\n    .p-card-body {\n        padding: dt('card.body.padding');\n        display: flex;\n        flex-direction: column;\n        gap: dt('card.body.gap');\n    }\n\n    .p-card-title {\n        font-size: dt('card.title.font.size');\n        font-weight: dt('card.title.font.weight');\n    }\n\n    .p-card-subtitle {\n        color: dt('card.subtitle.color');\n    }\n",
                classes: {
                    root: "p-card p-component",
                    header: "p-card-header",
                    body: "p-card-body",
                    caption: "p-card-caption",
                    title: "p-card-title",
                    subtitle: "p-card-subtitle",
                    content: "p-card-content",
                    footer: "p-card-footer"
                }
            }),
            provide: function() {
                return {
                    $pcCard: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        render: function(e, t, n, r, o, i) {
            return uo(), go("div", Mo({
                class: e.cx("root")
            }, e.ptmi("root")), [e.$slots.header ? (uo(), go("div", Mo({
                key: 0,
                class: e.cx("header")
            }, e.ptm("header")), [Yn(e.$slots, "header")], 16)) : Eo("", !0), _o("div", Mo({
                class: e.cx("body")
            }, e.ptm("body")), [e.$slots.title || e.$slots.subtitle ? (uo(), go("div", Mo({
                key: 0,
                class: e.cx("caption")
            }, e.ptm("caption")), [e.$slots.title ? (uo(), go("div", Mo({
                key: 0,
                class: e.cx("title")
            }, e.ptm("title")), [Yn(e.$slots, "title")], 16)) : Eo("", !0), e.$slots.subtitle ? (uo(), go("div", Mo({
                key: 1,
                class: e.cx("subtitle")
            }, e.ptm("subtitle")), [Yn(e.$slots, "subtitle")], 16)) : Eo("", !0)], 16)) : Eo("", !0), _o("div", Mo({
                class: e.cx("content")
            }, e.ptm("content")), [Yn(e.$slots, "content")], 16), e.$slots.footer ? (uo(), go("div", Mo({
                key: 1,
                class: e.cx("footer")
            }, e.ptm("footer")), [Yn(e.$slots, "footer")], 16)) : Eo("", !0)], 16)], 16)
        }
    },
    cB = {
        name: "ArrowDownIcon",
        extends: AT
    };
function uB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
cB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return uB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M6.99994 14C6.91097 14.0004 6.82281 13.983 6.74064 13.9489C6.65843 13.9148 6.58387 13.8646 6.52133 13.8013L1.10198 8.38193C0.982318 8.25351 0.917175 8.08367 0.920272 7.90817C0.923368 7.73267 0.994462 7.56523 1.11858 7.44111C1.24269 7.317 1.41014 7.2459 1.58563 7.2428C1.76113 7.23971 1.93098 7.30485 2.0594 7.42451L6.32263 11.6877V0.677419C6.32263 0.497756 6.394 0.325452 6.52104 0.198411C6.64808 0.0713706 6.82039 0 7.00005 0C7.17971 0 7.35202 0.0713706 7.47906 0.198411C7.6061 0.325452 7.67747 0.497756 7.67747 0.677419V11.6877L11.9407 7.42451C12.0691 7.30485 12.2389 7.23971 12.4144 7.2428C12.5899 7.2459 12.7574 7.317 12.8815 7.44111C13.0056 7.56523 13.0767 7.73267 13.0798 7.90817C13.0829 8.08367 13.0178 8.25351 12.8981 8.38193L7.47875 13.8013C7.41621 13.8646 7.34164 13.9148 7.25944 13.9489C7.17727 13.983 7.08912 14.0004 7.00015 14C7.00012 14 7.00009 14 7.00005 14C7.00001 14 6.99998 14 6.99994 14Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return uB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? uB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var dB = {
    name: "ArrowUpIcon",
    extends: AT
};
function pB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function hB(e) {
    return (hB = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
dB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return pB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M6.51551 13.799C6.64205 13.9255 6.813 13.9977 6.99193 14C7.17087 13.9977 7.34182 13.9255 7.46835 13.799C7.59489 13.6725 7.66701 13.5015 7.66935 13.3226V2.31233L11.9326 6.57554C11.9951 6.63887 12.0697 6.68907 12.1519 6.72319C12.2341 6.75731 12.3223 6.77467 12.4113 6.77425C12.5003 6.77467 12.5885 6.75731 12.6707 6.72319C12.7529 6.68907 12.8274 6.63887 12.89 6.57554C13.0168 6.44853 13.0881 6.27635 13.0881 6.09683C13.0881 5.91732 13.0168 5.74514 12.89 5.61812L7.48846 0.216594C7.48274 0.210436 7.4769 0.204374 7.47094 0.198411C7.3439 0.0713707 7.1716 0 6.99193 0C6.81227 0 6.63997 0.0713707 6.51293 0.198411C6.50704 0.204296 6.50128 0.210278 6.49563 0.216354L1.09386 5.61812C0.974201 5.74654 0.909057 5.91639 0.912154 6.09189C0.91525 6.26738 0.986345 6.43483 1.11046 6.55894C1.23457 6.68306 1.40202 6.75415 1.57752 6.75725C1.75302 6.76035 1.92286 6.6952 2.05128 6.57554L6.31451 2.31231V13.3226C6.31685 13.5015 6.38898 13.6725 6.51551 13.799Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return pB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? pB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var fB = {
        paginator: function(e) {
            var t,
                n,
                r,
                o = e.instance,
                i = e.key;
            return ["p-paginator p-component", (t = {
                "p-paginator-default": !o.hasBreakpoints()
            }, n = "p-paginator-".concat(i), r = o.hasBreakpoints(), (n = function(e) {
                var t = function(e, t) {
                    if ("object" != hB(e) || !e)
                        return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t);
                        if ("object" != hB(r))
                            return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return String(e)
                }(e, "string");
                return "symbol" == hB(t) ? t : t + ""
            }(n)) in t ? Object.defineProperty(t, n, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[n] = r, t)]
        },
        content: "p-paginator-content",
        contentStart: "p-paginator-content-start",
        contentEnd: "p-paginator-content-end",
        first: function(e) {
            return ["p-paginator-first", {
                "p-disabled": e.instance.$attrs.disabled
            }]
        },
        firstIcon: "p-paginator-first-icon",
        prev: function(e) {
            return ["p-paginator-prev", {
                "p-disabled": e.instance.$attrs.disabled
            }]
        },
        prevIcon: "p-paginator-prev-icon",
        next: function(e) {
            return ["p-paginator-next", {
                "p-disabled": e.instance.$attrs.disabled
            }]
        },
        nextIcon: "p-paginator-next-icon",
        last: function(e) {
            return ["p-paginator-last", {
                "p-disabled": e.instance.$attrs.disabled
            }]
        },
        lastIcon: "p-paginator-last-icon",
        pages: "p-paginator-pages",
        page: function(e) {
            var t = e.props;
            return ["p-paginator-page", {
                "p-paginator-page-selected": e.pageLink - 1 === t.page
            }]
        },
        current: "p-paginator-current",
        pcRowPerPageDropdown: "p-paginator-rpp-dropdown",
        pcJumpToPageDropdown: "p-paginator-jtp-dropdown",
        pcJumpToPageInputText: "p-paginator-jtp-input"
    },
    gB = kI.extend({
        name: "paginator",
        style: "\n    .p-paginator {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-wrap: wrap;\n        background: dt('paginator.background');\n        color: dt('paginator.color');\n        padding: dt('paginator.padding');\n        border-radius: dt('paginator.border.radius');\n        gap: dt('paginator.gap');\n    }\n\n    .p-paginator-content {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-wrap: wrap;\n        gap: dt('paginator.gap');\n    }\n\n    .p-paginator-content-start {\n        margin-inline-end: auto;\n    }\n\n    .p-paginator-content-end {\n        margin-inline-start: auto;\n    }\n\n    .p-paginator-page,\n    .p-paginator-next,\n    .p-paginator-last,\n    .p-paginator-first,\n    .p-paginator-prev {\n        cursor: pointer;\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        line-height: 1;\n        user-select: none;\n        overflow: hidden;\n        position: relative;\n        background: dt('paginator.nav.button.background');\n        border: 0 none;\n        color: dt('paginator.nav.button.color');\n        min-width: dt('paginator.nav.button.width');\n        height: dt('paginator.nav.button.height');\n        transition:\n            background dt('paginator.transition.duration'),\n            color dt('paginator.transition.duration'),\n            outline-color dt('paginator.transition.duration'),\n            box-shadow dt('paginator.transition.duration');\n        border-radius: dt('paginator.nav.button.border.radius');\n        padding: 0;\n        margin: 0;\n    }\n\n    .p-paginator-page:focus-visible,\n    .p-paginator-next:focus-visible,\n    .p-paginator-last:focus-visible,\n    .p-paginator-first:focus-visible,\n    .p-paginator-prev:focus-visible {\n        box-shadow: dt('paginator.nav.button.focus.ring.shadow');\n        outline: dt('paginator.nav.button.focus.ring.width') dt('paginator.nav.button.focus.ring.style') dt('paginator.nav.button.focus.ring.color');\n        outline-offset: dt('paginator.nav.button.focus.ring.offset');\n    }\n\n    .p-paginator-page:not(.p-disabled):not(.p-paginator-page-selected):hover,\n    .p-paginator-first:not(.p-disabled):hover,\n    .p-paginator-prev:not(.p-disabled):hover,\n    .p-paginator-next:not(.p-disabled):hover,\n    .p-paginator-last:not(.p-disabled):hover {\n        background: dt('paginator.nav.button.hover.background');\n        color: dt('paginator.nav.button.hover.color');\n    }\n\n    .p-paginator-page.p-paginator-page-selected {\n        background: dt('paginator.nav.button.selected.background');\n        color: dt('paginator.nav.button.selected.color');\n    }\n\n    .p-paginator-current {\n        color: dt('paginator.current.page.report.color');\n    }\n\n    .p-paginator-pages {\n        display: flex;\n        align-items: center;\n        gap: dt('paginator.gap');\n    }\n\n    .p-paginator-jtp-input .p-inputtext {\n        max-width: dt('paginator.jump.to.page.input.max.width');\n    }\n\n    .p-paginator-first:dir(rtl),\n    .p-paginator-prev:dir(rtl),\n    .p-paginator-next:dir(rtl),\n    .p-paginator-last:dir(rtl) {\n        transform: rotate(180deg);\n    }\n",
        classes: fB
    }),
    mB = {
        name: "AngleDoubleLeftIcon",
        extends: AT
    };
function bB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
mB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return bB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M5.71602 11.164C5.80782 11.2021 5.9063 11.2215 6.00569 11.221C6.20216 11.2301 6.39427 11.1612 6.54025 11.0294C6.68191 10.8875 6.76148 10.6953 6.76148 10.4948C6.76148 10.2943 6.68191 10.1021 6.54025 9.96024L3.51441 6.9344L6.54025 3.90855C6.624 3.76126 6.65587 3.59011 6.63076 3.42254C6.60564 3.25498 6.525 3.10069 6.40175 2.98442C6.2785 2.86815 6.11978 2.79662 5.95104 2.7813C5.78229 2.76598 5.61329 2.80776 5.47112 2.89994L1.97123 6.39983C1.82957 6.54167 1.75 6.73393 1.75 6.9344C1.75 7.13486 1.82957 7.32712 1.97123 7.46896L5.47112 10.9991C5.54096 11.0698 5.62422 11.1259 5.71602 11.164ZM11.0488 10.9689C11.1775 11.1156 11.3585 11.2061 11.5531 11.221C11.7477 11.2061 11.9288 11.1156 12.0574 10.9689C12.1815 10.8302 12.25 10.6506 12.25 10.4645C12.25 10.2785 12.1815 10.0989 12.0574 9.96024L9.03158 6.93439L12.0574 3.90855C12.1248 3.76739 12.1468 3.60881 12.1204 3.45463C12.0939 3.30045 12.0203 3.15826 11.9097 3.04765C11.7991 2.93703 11.6569 2.86343 11.5027 2.83698C11.3486 2.81053 11.19 2.83252 11.0488 2.89994L7.51865 6.36957C7.37699 6.51141 7.29742 6.70367 7.29742 6.90414C7.29742 7.1046 7.37699 7.29686 7.51865 7.4387L11.0488 10.9689Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return bB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? bB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var AB = {
    name: "AngleDownIcon",
    extends: AT
};
function yB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
AB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return yB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M3.58659 4.5007C3.68513 4.50023 3.78277 4.51945 3.87379 4.55723C3.9648 4.59501 4.04735 4.65058 4.11659 4.7207L7.11659 7.7207L10.1166 4.7207C10.2619 4.65055 10.4259 4.62911 10.5843 4.65956C10.7427 4.69002 10.8871 4.77074 10.996 4.88976C11.1049 5.00877 11.1726 5.15973 11.1889 5.32022C11.2052 5.48072 11.1693 5.6422 11.0866 5.7807L7.58659 9.2807C7.44597 9.42115 7.25534 9.50004 7.05659 9.50004C6.85784 9.50004 6.66722 9.42115 6.52659 9.2807L3.02659 5.7807C2.88614 5.64007 2.80725 5.44945 2.80725 5.2507C2.80725 5.05195 2.88614 4.86132 3.02659 4.7207C3.09932 4.64685 3.18675 4.58911 3.28322 4.55121C3.37969 4.51331 3.48305 4.4961 3.58659 4.5007Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return yB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var vB = {
    name: "AngleUpIcon",
    extends: AT
};
function _B(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
vB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return _B(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M10.4134 9.49931C10.3148 9.49977 10.2172 9.48055 10.1262 9.44278C10.0352 9.405 9.95263 9.34942 9.88338 9.27931L6.88338 6.27931L3.88338 9.27931C3.73811 9.34946 3.57409 9.3709 3.41567 9.34044C3.25724 9.30999 3.11286 9.22926 3.00395 9.11025C2.89504 8.99124 2.82741 8.84028 2.8111 8.67978C2.79478 8.51928 2.83065 8.35781 2.91338 8.21931L6.41338 4.71931C6.55401 4.57886 6.74463 4.49997 6.94338 4.49997C7.14213 4.49997 7.33276 4.57886 7.47338 4.71931L10.9734 8.21931C11.1138 8.35994 11.1927 8.55056 11.1927 8.74931C11.1927 8.94806 11.1138 9.13868 10.9734 9.27931C10.9007 9.35315 10.8132 9.41089 10.7168 9.44879C10.6203 9.48669 10.5169 9.5039 10.4134 9.49931Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return _B(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _B(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var xB = kI.extend({
    name: "inputnumber",
    style: "\n    .p-inputnumber {\n        display: inline-flex;\n        position: relative;\n    }\n\n    .p-inputnumber-button {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex: 0 0 auto;\n        cursor: pointer;\n        background: dt('inputnumber.button.background');\n        color: dt('inputnumber.button.color');\n        width: dt('inputnumber.button.width');\n        transition:\n            background dt('inputnumber.transition.duration'),\n            color dt('inputnumber.transition.duration'),\n            border-color dt('inputnumber.transition.duration'),\n            outline-color dt('inputnumber.transition.duration');\n    }\n\n    .p-inputnumber-button:disabled {\n        cursor: auto;\n    }\n\n    .p-inputnumber-button:not(:disabled):hover {\n        background: dt('inputnumber.button.hover.background');\n        color: dt('inputnumber.button.hover.color');\n    }\n\n    .p-inputnumber-button:not(:disabled):active {\n        background: dt('inputnumber.button.active.background');\n        color: dt('inputnumber.button.active.color');\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-button {\n        position: relative;\n        flex: 1 1 auto;\n        border: 0 none;\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-button-group {\n        display: flex;\n        flex-direction: column;\n        position: absolute;\n        inset-block-start: 1px;\n        inset-inline-end: 1px;\n        height: calc(100% - 2px);\n        z-index: 1;\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-increment-button {\n        padding: 0;\n        border-start-end-radius: calc(dt('inputnumber.button.border.radius') - 1px);\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-decrement-button {\n        padding: 0;\n        border-end-end-radius: calc(dt('inputnumber.button.border.radius') - 1px);\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-input {\n        padding-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-button {\n        border: 1px solid dt('inputnumber.button.border.color');\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-button:hover {\n        border-color: dt('inputnumber.button.hover.border.color');\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-button:active {\n        border-color: dt('inputnumber.button.active.border.color');\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-increment-button {\n        order: 3;\n        border-start-end-radius: dt('inputnumber.button.border.radius');\n        border-end-end-radius: dt('inputnumber.button.border.radius');\n        border-inline-start: 0 none;\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-input {\n        order: 2;\n        border-radius: 0;\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-decrement-button {\n        order: 1;\n        border-start-start-radius: dt('inputnumber.button.border.radius');\n        border-end-start-radius: dt('inputnumber.button.border.radius');\n        border-inline-end: 0 none;\n    }\n\n    .p-floatlabel:has(.p-inputnumber-horizontal) label {\n        margin-inline-start: dt('inputnumber.button.width');\n    }\n\n    .p-inputnumber-vertical {\n        flex-direction: column;\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-button {\n        border: 1px solid dt('inputnumber.button.border.color');\n        padding: dt('inputnumber.button.vertical.padding');\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-button:hover {\n        border-color: dt('inputnumber.button.hover.border.color');\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-button:active {\n        border-color: dt('inputnumber.button.active.border.color');\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-increment-button {\n        order: 1;\n        border-start-start-radius: dt('inputnumber.button.border.radius');\n        border-start-end-radius: dt('inputnumber.button.border.radius');\n        width: 100%;\n        border-block-end: 0 none;\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-input {\n        order: 2;\n        border-radius: 0;\n        text-align: center;\n    }\n\n    .p-inputnumber-vertical .p-inputnumber-decrement-button {\n        order: 3;\n        border-end-start-radius: dt('inputnumber.button.border.radius');\n        border-end-end-radius: dt('inputnumber.button.border.radius');\n        width: 100%;\n        border-block-start: 0 none;\n    }\n\n    .p-inputnumber-input {\n        flex: 1 1 auto;\n    }\n\n    .p-inputnumber-fluid {\n        width: 100%;\n    }\n\n    .p-inputnumber-fluid .p-inputnumber-input {\n        width: 1%;\n    }\n\n    .p-inputnumber-fluid.p-inputnumber-vertical .p-inputnumber-input {\n        width: 100%;\n    }\n\n    .p-inputnumber:has(.p-inputtext-sm) .p-inputnumber-button .p-icon {\n        font-size: dt('form.field.sm.font.size');\n        width: dt('form.field.sm.font.size');\n        height: dt('form.field.sm.font.size');\n    }\n\n    .p-inputnumber:has(.p-inputtext-lg) .p-inputnumber-button .p-icon {\n        font-size: dt('form.field.lg.font.size');\n        width: dt('form.field.lg.font.size');\n        height: dt('form.field.lg.font.size');\n    }\n\n    .p-inputnumber-clear-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -0.5rem;\n        cursor: pointer;\n        inset-inline-end: dt('form.field.padding.x');\n        color: dt('form.field.icon.color');\n    }\n\n    .p-inputnumber:has(.p-inputnumber-clear-icon) .p-inputnumber-input {\n        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-inputnumber-stacked .p-inputnumber-clear-icon {\n        inset-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));\n    }\n\n    .p-inputnumber-stacked:has(.p-inputnumber-clear-icon) .p-inputnumber-input {\n        padding-inline-end: calc(dt('inputnumber.button.width') + (dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-inputnumber-horizontal .p-inputnumber-clear-icon {\n        inset-inline-end: calc(dt('inputnumber.button.width') + dt('form.field.padding.x'));\n    }\n",
    classes: {
        root: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-inputnumber p-component p-inputwrapper", {
                "p-invalid": t.$invalid,
                "p-inputwrapper-filled": t.$filled || !1 === n.allowEmpty,
                "p-inputwrapper-focus": t.focused,
                "p-inputnumber-stacked": n.showButtons && "stacked" === n.buttonLayout,
                "p-inputnumber-horizontal": n.showButtons && "horizontal" === n.buttonLayout,
                "p-inputnumber-vertical": n.showButtons && "vertical" === n.buttonLayout,
                "p-inputnumber-fluid": t.$fluid
            }]
        },
        pcInputText: "p-inputnumber-input",
        clearIcon: "p-inputnumber-clear-icon",
        buttonGroup: "p-inputnumber-button-group",
        incrementButton: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-inputnumber-button p-inputnumber-increment-button", {
                "p-disabled": n.showButtons && null !== n.max && t.maxBoundry()
            }]
        },
        decrementButton: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-inputnumber-button p-inputnumber-decrement-button", {
                "p-disabled": n.showButtons && null !== n.min && t.minBoundry()
            }]
        }
    }
});
function wB(e) {
    return (wB = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function CB(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function EB(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? CB(Object(n), !0).forEach(function(t) {
            SB(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CB(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function SB(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != wB(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != wB(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == wB(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
function IB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var TB = {
        name: "InputNumber",
        extends: {
            name: "BaseInputNumber",
            extends: oM,
            props: {
                format: {
                    type: Boolean,
                    default: !0
                },
                showButtons: {
                    type: Boolean,
                    default: !1
                },
                buttonLayout: {
                    type: String,
                    default: "stacked"
                },
                incrementButtonClass: {
                    type: String,
                    default: null
                },
                decrementButtonClass: {
                    type: String,
                    default: null
                },
                incrementButtonIcon: {
                    type: String,
                    default: void 0
                },
                incrementIcon: {
                    type: String,
                    default: void 0
                },
                decrementButtonIcon: {
                    type: String,
                    default: void 0
                },
                decrementIcon: {
                    type: String,
                    default: void 0
                },
                locale: {
                    type: String,
                    default: void 0
                },
                localeMatcher: {
                    type: String,
                    default: void 0
                },
                mode: {
                    type: String,
                    default: "decimal"
                },
                prefix: {
                    type: String,
                    default: null
                },
                suffix: {
                    type: String,
                    default: null
                },
                currency: {
                    type: String,
                    default: void 0
                },
                currencyDisplay: {
                    type: String,
                    default: void 0
                },
                useGrouping: {
                    type: Boolean,
                    default: !0
                },
                minFractionDigits: {
                    type: Number,
                    default: void 0
                },
                maxFractionDigits: {
                    type: Number,
                    default: void 0
                },
                roundingMode: {
                    type: String,
                    default: "halfExpand",
                    validator: function(e) {
                        return ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"].includes(e)
                    }
                },
                min: {
                    type: Number,
                    default: null
                },
                max: {
                    type: Number,
                    default: null
                },
                step: {
                    type: Number,
                    default: 1
                },
                allowEmpty: {
                    type: Boolean,
                    default: !0
                },
                highlightOnFocus: {
                    type: Boolean,
                    default: !1
                },
                showClear: {
                    type: Boolean,
                    default: !1
                },
                readonly: {
                    type: Boolean,
                    default: !1
                },
                placeholder: {
                    type: String,
                    default: null
                },
                inputId: {
                    type: String,
                    default: null
                },
                inputClass: {
                    type: [String, Object],
                    default: null
                },
                inputStyle: {
                    type: Object,
                    default: null
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                ariaLabel: {
                    type: String,
                    default: null
                },
                required: {
                    type: Boolean,
                    default: !1
                }
            },
            style: xB,
            provide: function() {
                return {
                    $pcInputNumber: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["input", "focus", "blur"],
        inject: {
            $pcFluid: {
                default: null
            }
        },
        numberFormat: null,
        _numeral: null,
        _decimal: null,
        _group: null,
        _minusSign: null,
        _currency: null,
        _suffix: null,
        _prefix: null,
        _index: null,
        groupChar: "",
        isSpecialChar: null,
        prefixChar: null,
        suffixChar: null,
        timer: null,
        data: function() {
            return {
                d_modelValue: this.d_value,
                focused: !1
            }
        },
        watch: {
            d_value: {
                immediate: !0,
                handler: function(e) {
                    var t;
                    this.d_modelValue = e,
                    null !== (t = this.$refs.clearIcon) && void 0 !== t && null !== (t = t.$el) && void 0 !== t && t.style && (this.$refs.clearIcon.$el.style.display = rS(e) ? "none" : "block")
                }
            },
            locale: function(e, t) {
                this.updateConstructParser(e, t)
            },
            localeMatcher: function(e, t) {
                this.updateConstructParser(e, t)
            },
            mode: function(e, t) {
                this.updateConstructParser(e, t)
            },
            currency: function(e, t) {
                this.updateConstructParser(e, t)
            },
            currencyDisplay: function(e, t) {
                this.updateConstructParser(e, t)
            },
            useGrouping: function(e, t) {
                this.updateConstructParser(e, t)
            },
            minFractionDigits: function(e, t) {
                this.updateConstructParser(e, t)
            },
            maxFractionDigits: function(e, t) {
                this.updateConstructParser(e, t)
            },
            suffix: function(e, t) {
                this.updateConstructParser(e, t)
            },
            prefix: function(e, t) {
                this.updateConstructParser(e, t)
            }
        },
        created: function() {
            this.constructParser()
        },
        mounted: function() {
            var e;
            null !== (e = this.$refs.clearIcon) && void 0 !== e && null !== (e = e.$el) && void 0 !== e && e.style && (this.$refs.clearIcon.$el.style.display = this.$filled ? "block" : "none")
        },
        methods: {
            getOptions: function() {
                return {
                    localeMatcher: this.localeMatcher,
                    style: this.mode,
                    currency: this.currency,
                    currencyDisplay: this.currencyDisplay,
                    useGrouping: this.useGrouping,
                    minimumFractionDigits: this.minFractionDigits,
                    maximumFractionDigits: this.maxFractionDigits,
                    roundingMode: this.roundingMode
                }
            },
            constructParser: function() {
                this.numberFormat = new Intl.NumberFormat(this.locale, this.getOptions());
                var e,
                    t = (e = new Intl.NumberFormat(this.locale, {
                        useGrouping: !1
                    }).format(9876543210), function(e) {
                        if (Array.isArray(e))
                            return IB(e)
                    }(e) || function(e) {
                        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                            return Array.from(e)
                    }(e) || function(e, t) {
                        if (e) {
                            if ("string" == typeof e)
                                return IB(e, t);
                            var n = {}.toString.call(e).slice(8, -1);
                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? IB(e, t) : void 0
                        }
                    }(e) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()).reverse(),
                    n = new Map(t.map(function(e, t) {
                        return [e, t]
                    }));
                this._numeral = new RegExp("[".concat(t.join(""), "]"), "g"),
                this._group = this.getGroupingExpression(),
                this._minusSign = this.getMinusSignExpression(),
                this._currency = this.getCurrencyExpression(),
                this._decimal = this.getDecimalExpression(),
                this._suffix = this.getSuffixExpression(),
                this._prefix = this.getPrefixExpression(),
                this._index = function(e) {
                    return n.get(e)
                }
            },
            updateConstructParser: function(e, t) {
                e !== t && this.constructParser()
            },
            escapeRegExp: function(e) {
                return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
            },
            getDecimalExpression: function() {
                var e = new Intl.NumberFormat(this.locale, EB(EB({}, this.getOptions()), {}, {
                    useGrouping: !1
                }));
                return new RegExp("[".concat(e.format(1.1).replace(this._currency, "").trim().replace(this._numeral, ""), "]"), "g")
            },
            getGroupingExpression: function() {
                var e = new Intl.NumberFormat(this.locale, {
                    useGrouping: !0
                });
                return this.groupChar = e.format(1e6).trim().replace(this._numeral, "").charAt(0), new RegExp("[".concat(this.groupChar, "]"), "g")
            },
            getMinusSignExpression: function() {
                var e = new Intl.NumberFormat(this.locale, {
                    useGrouping: !1
                });
                return new RegExp("[".concat(e.format(-1).trim().replace(this._numeral, ""), "]"), "g")
            },
            getCurrencyExpression: function() {
                if (this.currency) {
                    var e = new Intl.NumberFormat(this.locale, {
                        style: "currency",
                        currency: this.currency,
                        currencyDisplay: this.currencyDisplay,
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0,
                        roundingMode: this.roundingMode
                    });
                    return new RegExp("[".concat(e.format(1).replace(/\s/g, "").replace(this._numeral, "").replace(this._group, ""), "]"), "g")
                }
                return new RegExp("[]", "g")
            },
            getPrefixExpression: function() {
                if (this.prefix)
                    this.prefixChar = this.prefix;
                else {
                    var e = new Intl.NumberFormat(this.locale, {
                        style: this.mode,
                        currency: this.currency,
                        currencyDisplay: this.currencyDisplay
                    });
                    this.prefixChar = e.format(1).split("1")[0]
                }
                return new RegExp("".concat(this.escapeRegExp(this.prefixChar || "")), "g")
            },
            getSuffixExpression: function() {
                if (this.suffix)
                    this.suffixChar = this.suffix;
                else {
                    var e = new Intl.NumberFormat(this.locale, {
                        style: this.mode,
                        currency: this.currency,
                        currencyDisplay: this.currencyDisplay,
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0,
                        roundingMode: this.roundingMode
                    });
                    this.suffixChar = e.format(1).split("1")[1]
                }
                return new RegExp("".concat(this.escapeRegExp(this.suffixChar || "")), "g")
            },
            formatValue: function(e) {
                if (null != e) {
                    if ("-" === e)
                        return e;
                    if (this.format) {
                        var t = new Intl.NumberFormat(this.locale, this.getOptions()).format(e);
                        return this.prefix && (t = this.prefix + t), this.suffix && (t += this.suffix), t
                    }
                    return e.toString()
                }
                return ""
            },
            parseValue: function(e) {
                var t = e.replace(this._suffix, "").replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").replace(this._group, "").replace(this._minusSign, "-").replace(this._decimal, ".").replace(this._numeral, this._index);
                if (t) {
                    if ("-" === t)
                        return t;
                    var n = +t;
                    return isNaN(n) ? null : n
                }
                return null
            },
            repeat: function(e, t, n) {
                var r = this;
                if (!this.readonly) {
                    var o = t || 500;
                    this.clearTimer(),
                    this.timer = setTimeout(function() {
                        r.repeat(e, 40, n)
                    }, o),
                    this.spin(e, n)
                }
            },
            addWithPrecision: function(e, t) {
                var n = e.toString(),
                    r = t.toString(),
                    o = n.includes(".") ? n.split(".")[1].length : 0,
                    i = r.includes(".") ? r.split(".")[1].length : 0,
                    a = Math.max(o, i),
                    s = Math.pow(10, a);
                return Math.round((e + t) * s) / s
            },
            spin: function(e, t) {
                if (this.$refs.input) {
                    var n = this.step * t,
                        r = this.parseValue(this.$refs.input.$el.value) || 0,
                        o = this.validateValue(this.addWithPrecision(r, n));
                    this.updateInput(o, null, "spin"),
                    this.updateModel(e, o),
                    this.handleOnInput(e, r, o)
                }
            },
            onUpButtonMouseDown: function(e) {
                this.disabled || (this.$refs.input.$el.focus(), this.repeat(e, null, 1), e.preventDefault())
            },
            onUpButtonMouseUp: function() {
                this.disabled || this.clearTimer()
            },
            onUpButtonMouseLeave: function() {
                this.disabled || this.clearTimer()
            },
            onUpButtonKeyUp: function() {
                this.disabled || this.clearTimer()
            },
            onUpButtonKeyDown: function(e) {
                "Space" !== e.code && "Enter" !== e.code && "NumpadEnter" !== e.code || this.repeat(e, null, 1)
            },
            onDownButtonMouseDown: function(e) {
                this.disabled || (this.$refs.input.$el.focus(), this.repeat(e, null, -1), e.preventDefault())
            },
            onDownButtonMouseUp: function() {
                this.disabled || this.clearTimer()
            },
            onDownButtonMouseLeave: function() {
                this.disabled || this.clearTimer()
            },
            onDownButtonKeyUp: function() {
                this.disabled || this.clearTimer()
            },
            onDownButtonKeyDown: function(e) {
                "Space" !== e.code && "Enter" !== e.code && "NumpadEnter" !== e.code || this.repeat(e, null, -1)
            },
            onUserInput: function() {
                this.isSpecialChar && (this.$refs.input.$el.value = this.lastValue),
                this.isSpecialChar = !1
            },
            onInputKeyDown: function(e) {
                if (!this.readonly && !e.isComposing) {
                    if (e.altKey || e.ctrlKey || e.metaKey)
                        return this.isSpecialChar = !0, void (this.lastValue = this.$refs.input.$el.value);
                    this.lastValue = e.target.value;
                    var t = e.target.selectionStart,
                        n = e.target.selectionEnd,
                        r = n - t,
                        o = e.target.value,
                        i = null;
                    switch (e.code || e.key) {
                    case "ArrowUp":
                        this.spin(e, 1),
                        e.preventDefault();
                        break;
                    case "ArrowDown":
                        this.spin(e, -1),
                        e.preventDefault();
                        break;
                    case "ArrowLeft":
                        if (r > 1) {
                            var a = this.isNumeralChar(o.charAt(t)) ? t + 1 : t + 2;
                            this.$refs.input.$el.setSelectionRange(a, a)
                        } else
                            this.isNumeralChar(o.charAt(t - 1)) || e.preventDefault();
                        break;
                    case "ArrowRight":
                        if (r > 1) {
                            var s = n - 1;
                            this.$refs.input.$el.setSelectionRange(s, s)
                        } else
                            this.isNumeralChar(o.charAt(t)) || e.preventDefault();
                        break;
                    case "Tab":
                    case "Enter":
                    case "NumpadEnter":
                        i = this.validateValue(this.parseValue(o)),
                        this.$refs.input.$el.value = this.formatValue(i),
                        this.$refs.input.$el.setAttribute("aria-valuenow", i),
                        this.updateModel(e, i);
                        break;
                    case "Backspace":
                        if (e.preventDefault(), t === n) {
                            t >= o.length && null !== this.suffixChar && (t = o.length - this.suffixChar.length, this.$refs.input.$el.setSelectionRange(t, t));
                            var l = o.charAt(t - 1),
                                c = this.getDecimalCharIndexes(o),
                                u = c.decimalCharIndex,
                                d = c.decimalCharIndexWithoutPrefix;
                            if (this.isNumeralChar(l)) {
                                var p = this.getDecimalLength(o);
                                if (this._group.test(l))
                                    this._group.lastIndex = 0,
                                    i = o.slice(0, t - 2) + o.slice(t - 1);
                                else if (this._decimal.test(l))
                                    this._decimal.lastIndex = 0,
                                    p ? this.$refs.input.$el.setSelectionRange(t - 1, t - 1) : i = o.slice(0, t - 1) + o.slice(t);
                                else if (u > 0 && t > u) {
                                    var h = this.isDecimalMode() && (this.minFractionDigits || 0) < p ? "" : "0";
                                    i = o.slice(0, t - 1) + h + o.slice(t)
                                } else
                                    1 === d ? (i = o.slice(0, t - 1) + "0" + o.slice(t), i = this.parseValue(i) > 0 ? i : "") : i = o.slice(0, t - 1) + o.slice(t)
                            }
                            this.updateValue(e, i, null, "delete-single")
                        } else
                            i = this.deleteRange(o, t, n),
                            this.updateValue(e, i, null, "delete-range");
                        break;
                    case "Delete":
                        if (e.preventDefault(), t === n) {
                            var f = o.charAt(t),
                                g = this.getDecimalCharIndexes(o),
                                m = g.decimalCharIndex,
                                b = g.decimalCharIndexWithoutPrefix;
                            if (this.isNumeralChar(f)) {
                                var A = this.getDecimalLength(o);
                                if (this._group.test(f))
                                    this._group.lastIndex = 0,
                                    i = o.slice(0, t) + o.slice(t + 2);
                                else if (this._decimal.test(f))
                                    this._decimal.lastIndex = 0,
                                    A ? this.$refs.input.$el.setSelectionRange(t + 1, t + 1) : i = o.slice(0, t) + o.slice(t + 1);
                                else if (m > 0 && t > m) {
                                    var y = this.isDecimalMode() && (this.minFractionDigits || 0) < A ? "" : "0";
                                    i = o.slice(0, t) + y + o.slice(t + 1)
                                } else
                                    1 === b ? (i = o.slice(0, t) + "0" + o.slice(t + 1), i = this.parseValue(i) > 0 ? i : "") : i = o.slice(0, t) + o.slice(t + 1)
                            }
                            this.updateValue(e, i, null, "delete-back-single")
                        } else
                            i = this.deleteRange(o, t, n),
                            this.updateValue(e, i, null, "delete-range");
                        break;
                    case "Home":
                        e.preventDefault(),
                        sS(this.min) && this.updateModel(e, this.min);
                        break;
                    case "End":
                        e.preventDefault(),
                        sS(this.max) && this.updateModel(e, this.max)
                    }
                }
            },
            onInputKeyPress: function(e) {
                if (!this.readonly) {
                    var t = e.key,
                        n = this.isDecimalSign(t),
                        r = this.isMinusSign(t);
                    "Enter" !== e.code && e.preventDefault(),
                    (Number(t) >= 0 && Number(t) <= 9 || r || n) && this.insert(e, t, {
                        isDecimalSign: n,
                        isMinusSign: r
                    })
                }
            },
            onPaste: function(e) {
                if (!this.readonly) {
                    e.preventDefault();
                    var t = (e.clipboardData || window.clipboardData).getData("Text");
                    if (("integeronly" !== this.inputId || !/[^\d-]/.test(t)) && t) {
                        var n = this.parseValue(t);
                        null != n && this.insert(e, n.toString())
                    }
                }
            },
            onClearClick: function(e) {
                this.updateModel(e, null),
                this.$refs.input.$el.focus()
            },
            allowMinusSign: function() {
                return null === this.min || this.min < 0
            },
            isMinusSign: function(e) {
                return !(!this._minusSign.test(e) && "-" !== e || (this._minusSign.lastIndex = 0, 0))
            },
            isDecimalSign: function(e) {
                var t;
                return !!(null !== (t = this.locale) && void 0 !== t && t.includes("fr") && [".", ","].includes(e) || this._decimal.test(e)) && (this._decimal.lastIndex = 0, !0)
            },
            isDecimalMode: function() {
                return "decimal" === this.mode
            },
            getDecimalCharIndexes: function(e) {
                var t = e.search(this._decimal);
                this._decimal.lastIndex = 0;
                var n = e.replace(this._prefix, "").trim().replace(/\s/g, "").replace(this._currency, "").search(this._decimal);
                return this._decimal.lastIndex = 0, {
                    decimalCharIndex: t,
                    decimalCharIndexWithoutPrefix: n
                }
            },
            getCharIndexes: function(e) {
                var t = e.search(this._decimal);
                this._decimal.lastIndex = 0;
                var n = e.search(this._minusSign);
                this._minusSign.lastIndex = 0;
                var r = e.search(this._suffix);
                this._suffix.lastIndex = 0;
                var o = e.search(this._currency);
                return this._currency.lastIndex = 0, {
                    decimalCharIndex: t,
                    minusCharIndex: n,
                    suffixCharIndex: r,
                    currencyCharIndex: o
                }
            },
            insert: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                        isDecimalSign: !1,
                        isMinusSign: !1
                    },
                    r = t.search(this._minusSign);
                if (this._minusSign.lastIndex = 0, this.allowMinusSign() || -1 === r) {
                    var o,
                        i = this.$refs.input.$el.selectionStart,
                        a = this.$refs.input.$el.selectionEnd,
                        s = this.$refs.input.$el.value.trim(),
                        l = this.getCharIndexes(s),
                        c = l.decimalCharIndex,
                        u = l.minusCharIndex,
                        d = l.suffixCharIndex,
                        p = l.currencyCharIndex;
                    if (n.isMinusSign)
                        0 !== i && i !== p + 1 || (o = s, (-1 === u || 0 !== a) && (o = this.insertText(s, t, 0, a)), this.updateValue(e, o, t, "insert"));
                    else if (n.isDecimalSign)
                        c > 0 && i === c ? this.updateValue(e, s, t, "insert") : (c > i && c < a || -1 === c && this.maxFractionDigits) && (o = this.insertText(s, t, i, a), this.updateValue(e, o, t, "insert"));
                    else {
                        var h = this.numberFormat.resolvedOptions().maximumFractionDigits,
                            f = i !== a ? "range-insert" : "insert";
                        if (c > 0 && i > c) {
                            if (i + t.length - (c + 1) <= h) {
                                var g = p >= i ? p - 1 : d >= i ? d : s.length;
                                o = s.slice(0, i) + t + s.slice(i + t.length, g) + s.slice(g),
                                this.updateValue(e, o, t, f)
                            }
                        } else
                            o = this.insertText(s, t, i, a),
                            this.updateValue(e, o, t, f)
                    }
                }
            },
            insertText: function(e, t, n, r) {
                if (2 === ("." === t ? t : t.split(".")).length) {
                    var o = e.slice(n, r).search(this._decimal);
                    return this._decimal.lastIndex = 0, o > 0 ? e.slice(0, n) + this.formatValue(t) + e.slice(r) : this.formatValue(t) || e
                }
                return r - n === e.length ? this.formatValue(t) : 0 === n ? t + e.slice(r) : r === e.length ? e.slice(0, n) + t : e.slice(0, n) + t + e.slice(r)
            },
            deleteRange: function(e, t, n) {
                return n - t === e.length ? "" : 0 === t ? e.slice(n) : n === e.length ? e.slice(0, t) : e.slice(0, t) + e.slice(n)
            },
            initCursor: function() {
                var e = this.$refs.input.$el.selectionStart,
                    t = this.$refs.input.$el.value,
                    n = t.length,
                    r = null,
                    o = (this.prefixChar || "").length;
                e -= o;
                var i = (t = t.replace(this._prefix, "")).charAt(e);
                if (this.isNumeralChar(i))
                    return e + o;
                for (var a = e - 1; a >= 0;) {
                    if (i = t.charAt(a), this.isNumeralChar(i)) {
                        r = a + o;
                        break
                    }
                    a--
                }
                if (null !== r)
                    this.$refs.input.$el.setSelectionRange(r + 1, r + 1);
                else {
                    for (a = e; a < n;) {
                        if (i = t.charAt(a), this.isNumeralChar(i)) {
                            r = a + o;
                            break
                        }
                        a++
                    }
                    null !== r && this.$refs.input.$el.setSelectionRange(r, r)
                }
                return r || 0
            },
            onInputClick: function() {
                var e = this.$refs.input.$el.value;
                this.readonly || e === jE() || this.initCursor()
            },
            isNumeralChar: function(e) {
                return !(1 !== e.length || !(this._numeral.test(e) || this._decimal.test(e) || this._group.test(e) || this._minusSign.test(e)) || (this.resetRegex(), 0))
            },
            resetRegex: function() {
                this._numeral.lastIndex = 0,
                this._decimal.lastIndex = 0,
                this._group.lastIndex = 0,
                this._minusSign.lastIndex = 0
            },
            updateValue: function(e, t, n, r) {
                var o = this.$refs.input.$el.value,
                    i = null;
                null != t && (i = (i = this.parseValue(t)) || this.allowEmpty ? i : 0, this.updateInput(i, n, r, t), this.handleOnInput(e, o, i))
            },
            handleOnInput: function(e, t, n) {
                var r,
                    o;
                this.isValueChanged(t, n) && (this.$emit("input", {
                    originalEvent: e,
                    value: n,
                    formattedValue: t
                }), null === (r = (o = this.formField).onInput) || void 0 === r || r.call(o, {
                    originalEvent: e,
                    value: n
                }))
            },
            isValueChanged: function(e, t) {
                return null === t && null !== e || null != t && t !== ("string" == typeof e ? this.parseValue(e) : e)
            },
            validateValue: function(e) {
                return "-" === e || null == e ? null : null != this.min && e < this.min ? this.min : null != this.max && e > this.max ? this.max : e
            },
            updateInput: function(e, t, n, r) {
                var o;
                t = t || "";
                var i = this.$refs.input.$el.value,
                    a = this.formatValue(e),
                    s = i.length;
                if (a !== r && (a = this.concatValues(a, r)), 0 === s) {
                    this.$refs.input.$el.value = a,
                    this.$refs.input.$el.setSelectionRange(0, 0);
                    var l = this.initCursor() + t.length;
                    this.$refs.input.$el.setSelectionRange(l, l)
                } else {
                    var c = this.$refs.input.$el.selectionStart,
                        u = this.$refs.input.$el.selectionEnd;
                    this.$refs.input.$el.value = a;
                    var d = a.length;
                    if ("range-insert" === n) {
                        var p = this.parseValue((i || "").slice(0, c)),
                            h = (null !== p ? p.toString() : "").split("").join("(".concat(this.groupChar, ")?")),
                            f = new RegExp(h, "g");
                        f.test(a);
                        var g = t.split("").join("(".concat(this.groupChar, ")?")),
                            m = new RegExp(g, "g");
                        m.test(a.slice(f.lastIndex)),
                        u = f.lastIndex + m.lastIndex,
                        this.$refs.input.$el.setSelectionRange(u, u)
                    } else if (d === s)
                        "insert" === n || "delete-back-single" === n ? this.$refs.input.$el.setSelectionRange(u + 1, u + 1) : "delete-single" === n ? this.$refs.input.$el.setSelectionRange(u - 1, u - 1) : "delete-range" !== n && "spin" !== n || this.$refs.input.$el.setSelectionRange(u, u);
                    else if ("delete-back-single" === n) {
                        var b = i.charAt(u - 1),
                            A = i.charAt(u),
                            y = s - d,
                            v = this._group.test(A);
                        v && 1 === y ? u += 1 : !v && this.isNumeralChar(b) && (u += -1 * y + 1),
                        this._group.lastIndex = 0,
                        this.$refs.input.$el.setSelectionRange(u, u)
                    } else if ("-" === i && "insert" === n) {
                        this.$refs.input.$el.setSelectionRange(0, 0);
                        var _ = this.initCursor() + t.length + 1;
                        this.$refs.input.$el.setSelectionRange(_, _)
                    } else
                        u += d - s,
                        this.$refs.input.$el.setSelectionRange(u, u)
                }
                this.$refs.input.$el.setAttribute("aria-valuenow", e),
                null !== (o = this.$refs.clearIcon) && void 0 !== o && null !== (o = o.$el) && void 0 !== o && o.style && (this.$refs.clearIcon.$el.style.display = rS(a) ? "none" : "block")
            },
            concatValues: function(e, t) {
                if (e && t) {
                    var n = t.search(this._decimal);
                    return this._decimal.lastIndex = 0, this.suffixChar ? -1 !== n ? e.replace(this.suffixChar, "").split(this._decimal)[0] + t.replace(this.suffixChar, "").slice(n) + this.suffixChar : e : -1 !== n ? e.split(this._decimal)[0] + t.slice(n) : e
                }
                return e
            },
            getDecimalLength: function(e) {
                if (e) {
                    var t = e.split(this._decimal);
                    if (2 === t.length)
                        return t[1].replace(this._suffix, "").trim().replace(/\s/g, "").replace(this._currency, "").length
                }
                return 0
            },
            updateModel: function(e, t) {
                this.writeValue(t, e)
            },
            onInputFocus: function(e) {
                this.focused = !0,
                this.disabled || this.readonly || this.$refs.input.$el.value === jE() || !this.highlightOnFocus || e.target.select(),
                this.$emit("focus", e)
            },
            onInputBlur: function(e) {
                var t,
                    n;
                this.focused = !1;
                var r = e.target,
                    o = this.validateValue(this.parseValue(r.value));
                this.$emit("blur", {
                    originalEvent: e,
                    value: r.value
                }),
                null === (t = (n = this.formField).onBlur) || void 0 === t || t.call(n, e),
                r.value = this.formatValue(o),
                r.setAttribute("aria-valuenow", o),
                this.updateModel(e, o),
                this.disabled || this.readonly || !this.highlightOnFocus || EE()
            },
            clearTimer: function() {
                this.timer && clearTimeout(this.timer)
            },
            maxBoundry: function() {
                return this.d_value >= this.max
            },
            minBoundry: function() {
                return this.d_value <= this.min
            }
        },
        computed: {
            upButtonListeners: function() {
                var e = this;
                return {
                    mousedown: function(t) {
                        return e.onUpButtonMouseDown(t)
                    },
                    mouseup: function(t) {
                        return e.onUpButtonMouseUp(t)
                    },
                    mouseleave: function(t) {
                        return e.onUpButtonMouseLeave(t)
                    },
                    keydown: function(t) {
                        return e.onUpButtonKeyDown(t)
                    },
                    keyup: function(t) {
                        return e.onUpButtonKeyUp(t)
                    }
                }
            },
            downButtonListeners: function() {
                var e = this;
                return {
                    mousedown: function(t) {
                        return e.onDownButtonMouseDown(t)
                    },
                    mouseup: function(t) {
                        return e.onDownButtonMouseUp(t)
                    },
                    mouseleave: function(t) {
                        return e.onDownButtonMouseLeave(t)
                    },
                    keydown: function(t) {
                        return e.onDownButtonKeyDown(t)
                    },
                    keyup: function(t) {
                        return e.onDownButtonKeyUp(t)
                    }
                }
            },
            formattedValue: function() {
                var e = this.d_value || this.allowEmpty ? this.d_value : 0;
                return this.formatValue(e)
            },
            getFormatter: function() {
                return this.numberFormat
            },
            dataP: function() {
                return RS(SB(SB({
                    invalid: this.$invalid,
                    fluid: this.$fluid,
                    filled: "filled" === this.$variant
                }, this.size, this.size), this.buttonLayout, this.showButtons && this.buttonLayout))
            }
        },
        components: {
            InputText: aM,
            AngleUpIcon: vB,
            AngleDownIcon: AB,
            TimesIcon: yT
        }
    },
    MB = ["data-p"],
    RB = ["data-p"],
    BB = ["disabled", "data-p"],
    kB = ["disabled", "data-p"],
    DB = ["disabled", "data-p"],
    PB = ["disabled", "data-p"];
TB.render = function(e, t, n, r, o, i) {
    var a = jn("InputText"),
        s = jn("TimesIcon");
    return uo(), go("span", Mo({
        class: e.cx("root")
    }, e.ptmi("root"), {
        "data-p": i.dataP
    }), [xo(a, {
        ref: "input",
        id: e.inputId,
        name: e.$formName,
        role: "spinbutton",
        class: G([e.cx("pcInputText"), e.inputClass]),
        style: N(e.inputStyle),
        defaultValue: i.formattedValue,
        "aria-valuemin": e.min,
        "aria-valuemax": e.max,
        "aria-valuenow": e.d_value,
        inputmode: "decimal" !== e.mode || e.minFractionDigits ? "decimal" : "numeric",
        disabled: e.disabled,
        readonly: e.readonly,
        placeholder: e.placeholder,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        required: e.required,
        size: e.size,
        invalid: e.invalid,
        variant: e.variant,
        onInput: i.onUserInput,
        onKeydown: i.onInputKeyDown,
        onKeypress: i.onInputKeyPress,
        onPaste: i.onPaste,
        onClick: i.onInputClick,
        onFocus: i.onInputFocus,
        onBlur: i.onInputBlur,
        pt: e.ptm("pcInputText"),
        unstyled: e.unstyled,
        "data-p": i.dataP
    }, null, 8, ["id", "name", "class", "style", "defaultValue", "aria-valuemin", "aria-valuemax", "aria-valuenow", "inputmode", "disabled", "readonly", "placeholder", "aria-labelledby", "aria-label", "required", "size", "invalid", "variant", "onInput", "onKeydown", "onKeypress", "onPaste", "onClick", "onFocus", "onBlur", "pt", "unstyled", "data-p"]), e.showClear && "vertical" !== e.buttonLayout ? Yn(e.$slots, "clearicon", {
        key: 0,
        class: G(e.cx("clearIcon")),
        clearCallback: i.onClearClick
    }, function() {
        return [xo(s, Mo({
            ref: "clearIcon",
            class: [e.cx("clearIcon")],
            onClick: i.onClearClick
        }, e.ptm("clearIcon")), null, 16, ["class", "onClick"])]
    }) : Eo("", !0), e.showButtons && "stacked" === e.buttonLayout ? (uo(), go("span", Mo({
        key: 1,
        class: e.cx("buttonGroup")
    }, e.ptm("buttonGroup"), {
        "data-p": i.dataP
    }), [Yn(e.$slots, "incrementbutton", {
        listeners: i.upButtonListeners
    }, function() {
        return [_o("button", Mo({
            class: [e.cx("incrementButton"), e.incrementButtonClass]
        }, Zn(i.upButtonListeners), {
            disabled: e.disabled,
            tabindex: -1,
            "aria-hidden": "true",
            type: "button"
        }, e.ptm("incrementButton"), {
            "data-p": i.dataP
        }), [Yn(e.$slots, e.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
            return [(uo(), mo(Hn(e.incrementIcon || e.incrementButtonIcon ? "span" : "AngleUpIcon"), Mo({
                class: [e.incrementIcon, e.incrementButtonIcon]
            }, e.ptm("incrementIcon"), {
                "data-pc-section": "incrementicon"
            }), null, 16, ["class"]))]
        })], 16, BB)]
    }), Yn(e.$slots, "decrementbutton", {
        listeners: i.downButtonListeners
    }, function() {
        return [_o("button", Mo({
            class: [e.cx("decrementButton"), e.decrementButtonClass]
        }, Zn(i.downButtonListeners), {
            disabled: e.disabled,
            tabindex: -1,
            "aria-hidden": "true",
            type: "button"
        }, e.ptm("decrementButton"), {
            "data-p": i.dataP
        }), [Yn(e.$slots, e.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
            return [(uo(), mo(Hn(e.decrementIcon || e.decrementButtonIcon ? "span" : "AngleDownIcon"), Mo({
                class: [e.decrementIcon, e.decrementButtonIcon]
            }, e.ptm("decrementIcon"), {
                "data-pc-section": "decrementicon"
            }), null, 16, ["class"]))]
        })], 16, kB)]
    })], 16, RB)) : Eo("", !0), Yn(e.$slots, "incrementbutton", {
        listeners: i.upButtonListeners
    }, function() {
        return [e.showButtons && "stacked" !== e.buttonLayout ? (uo(), go("button", Mo({
            key: 0,
            class: [e.cx("incrementButton"), e.incrementButtonClass]
        }, Zn(i.upButtonListeners), {
            disabled: e.disabled,
            tabindex: -1,
            "aria-hidden": "true",
            type: "button"
        }, e.ptm("incrementButton"), {
            "data-p": i.dataP
        }), [Yn(e.$slots, e.$slots.incrementicon ? "incrementicon" : "incrementbuttonicon", {}, function() {
            return [(uo(), mo(Hn(e.incrementIcon || e.incrementButtonIcon ? "span" : "AngleUpIcon"), Mo({
                class: [e.incrementIcon, e.incrementButtonIcon]
            }, e.ptm("incrementIcon"), {
                "data-pc-section": "incrementicon"
            }), null, 16, ["class"]))]
        })], 16, DB)) : Eo("", !0)]
    }), Yn(e.$slots, "decrementbutton", {
        listeners: i.downButtonListeners
    }, function() {
        return [e.showButtons && "stacked" !== e.buttonLayout ? (uo(), go("button", Mo({
            key: 0,
            class: [e.cx("decrementButton"), e.decrementButtonClass]
        }, Zn(i.downButtonListeners), {
            disabled: e.disabled,
            tabindex: -1,
            "aria-hidden": "true",
            type: "button"
        }, e.ptm("decrementButton"), {
            "data-p": i.dataP
        }), [Yn(e.$slots, e.$slots.decrementicon ? "decrementicon" : "decrementbuttonicon", {}, function() {
            return [(uo(), mo(Hn(e.decrementIcon || e.decrementButtonIcon ? "span" : "AngleDownIcon"), Mo({
                class: [e.decrementIcon, e.decrementButtonIcon]
            }, e.ptm("decrementIcon"), {
                "data-pc-section": "decrementicon"
            }), null, 16, ["class"]))]
        })], 16, PB)) : Eo("", !0)]
    })], 16, MB)
};
var OB = {
    name: "AngleDoubleRightIcon",
    extends: AT
};
function LB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
OB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return LB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M7.68757 11.1451C7.7791 11.1831 7.8773 11.2024 7.9764 11.2019C8.07769 11.1985 8.17721 11.1745 8.26886 11.1312C8.36052 11.088 8.44238 11.0265 8.50943 10.9505L12.0294 7.49085C12.1707 7.34942 12.25 7.15771 12.25 6.95782C12.25 6.75794 12.1707 6.56622 12.0294 6.42479L8.50943 2.90479C8.37014 2.82159 8.20774 2.78551 8.04633 2.80192C7.88491 2.81833 7.73309 2.88635 7.6134 2.99588C7.4937 3.10541 7.41252 3.25061 7.38189 3.40994C7.35126 3.56927 7.37282 3.73423 7.44337 3.88033L10.4605 6.89748L7.44337 9.91463C7.30212 10.0561 7.22278 10.2478 7.22278 10.4477C7.22278 10.6475 7.30212 10.8393 7.44337 10.9807C7.51301 11.0512 7.59603 11.1071 7.68757 11.1451ZM1.94207 10.9505C2.07037 11.0968 2.25089 11.1871 2.44493 11.2019C2.63898 11.1871 2.81949 11.0968 2.94779 10.9505L6.46779 7.49085C6.60905 7.34942 6.68839 7.15771 6.68839 6.95782C6.68839 6.75793 6.60905 6.56622 6.46779 6.42479L2.94779 2.90479C2.80704 2.83757 2.6489 2.81563 2.49517 2.84201C2.34143 2.86839 2.19965 2.94178 2.08936 3.05207C1.97906 3.16237 1.90567 3.30415 1.8793 3.45788C1.85292 3.61162 1.87485 3.76975 1.94207 3.9105L4.95922 6.92765L1.94207 9.9448C1.81838 10.0831 1.75 10.2621 1.75 10.4477C1.75 10.6332 1.81838 10.8122 1.94207 10.9505Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return LB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? LB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var NB = {
    name: "AngleRightIcon",
    extends: AT
};
function FB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
NB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return FB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M5.25 11.1728C5.14929 11.1694 5.05033 11.1455 4.9592 11.1025C4.86806 11.0595 4.78666 10.9984 4.72 10.9228C4.57955 10.7822 4.50066 10.5916 4.50066 10.3928C4.50066 10.1941 4.57955 10.0035 4.72 9.86283L7.72 6.86283L4.72 3.86283C4.66067 3.71882 4.64765 3.55991 4.68275 3.40816C4.71785 3.25642 4.79932 3.11936 4.91585 3.01602C5.03238 2.91268 5.17819 2.84819 5.33305 2.83149C5.4879 2.81479 5.64411 2.84671 5.78 2.92283L9.28 6.42283C9.42045 6.56346 9.49934 6.75408 9.49934 6.95283C9.49934 7.15158 9.42045 7.34221 9.28 7.48283L5.78 10.9228C5.71333 10.9984 5.63193 11.0595 5.5408 11.1025C5.44966 11.1455 5.35071 11.1694 5.25 11.1728Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return FB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? FB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var UB = {
    name: "AngleLeftIcon",
    extends: AT
};
function zB(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
UB.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return zB(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M8.75 11.185C8.65146 11.1854 8.55381 11.1662 8.4628 11.1284C8.37179 11.0906 8.28924 11.0351 8.22 10.965L4.72 7.46496C4.57955 7.32433 4.50066 7.13371 4.50066 6.93496C4.50066 6.73621 4.57955 6.54558 4.72 6.40496L8.22 2.93496C8.36095 2.84357 8.52851 2.80215 8.69582 2.81733C8.86312 2.83252 9.02048 2.90344 9.14268 3.01872C9.26487 3.134 9.34483 3.28696 9.36973 3.4531C9.39463 3.61924 9.36303 3.78892 9.28 3.93496L6.28 6.93496L9.28 9.93496C9.42045 10.0756 9.49934 10.2662 9.49934 10.465C9.49934 10.6637 9.42045 10.8543 9.28 10.995C9.13526 11.1257 8.9448 11.1939 8.75 11.185Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return zB(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? zB(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var QB = {
        name: "BasePaginator",
        extends: nT,
        props: {
            totalRecords: {
                type: Number,
                default: 0
            },
            rows: {
                type: Number,
                default: 0
            },
            first: {
                type: Number,
                default: 0
            },
            pageLinkSize: {
                type: Number,
                default: 5
            },
            rowsPerPageOptions: {
                type: Array,
                default: null
            },
            template: {
                type: [Object, String],
                default: "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown"
            },
            currentPageReportTemplate: {
                type: null,
                default: "({currentPage} of {totalPages})"
            },
            alwaysShow: {
                type: Boolean,
                default: !0
            }
        },
        style: gB,
        provide: function() {
            return {
                $pcPaginator: this,
                $parentInstance: this
            }
        }
    },
    GB = {
        name: "CurrentPageReport",
        hostName: "Paginator",
        extends: nT,
        props: {
            pageCount: {
                type: Number,
                default: 0
            },
            currentPage: {
                type: Number,
                default: 0
            },
            page: {
                type: Number,
                default: 0
            },
            first: {
                type: Number,
                default: 0
            },
            rows: {
                type: Number,
                default: 0
            },
            totalRecords: {
                type: Number,
                default: 0
            },
            template: {
                type: String,
                default: "({currentPage} of {totalPages})"
            }
        },
        computed: {
            text: function() {
                return this.template.replace("{currentPage}", this.currentPage).replace("{totalPages}", this.pageCount).replace("{first}", this.pageCount > 0 ? this.first + 1 : 0).replace("{last}", Math.min(this.first + this.rows, this.totalRecords)).replace("{rows}", this.rows).replace("{totalRecords}", this.totalRecords)
            }
        },
        render: function(e, t, n, r, o, i) {
            return uo(), go("span", Mo({
                class: e.cx("current")
            }, e.ptm("current")), W(i.text), 17)
        }
    },
    jB = {
        name: "FirstPageLink",
        hostName: "Paginator",
        extends: nT,
        props: {
            template: {
                type: Function,
                default: null
            }
        },
        methods: {
            getPTOptions: function(e) {
                return this.ptm(e, {
                    context: {
                        disabled: this.$attrs.disabled
                    }
                })
            }
        },
        components: {
            AngleDoubleLeftIcon: mB
        },
        directives: {
            ripple: ET
        },
        render: function(e, t, n, r, o, i) {
            var a = $n("ripple");
            return Ht((uo(), go("button", Mo({
                class: e.cx("first"),
                type: "button"
            }, i.getPTOptions("first"), {
                "data-pc-group-section": "pagebutton"
            }), [(uo(), mo(Hn(n.template || "AngleDoubleLeftIcon"), Mo({
                class: e.cx("firstIcon")
            }, i.getPTOptions("firstIcon")), null, 16, ["class"]))], 16)), [[a]])
        }
    },
    VB = {
        name: "JumpToPageDropdown",
        hostName: "Paginator",
        extends: nT,
        emits: ["page-change"],
        props: {
            page: Number,
            pageCount: Number,
            disabled: Boolean,
            templates: null
        },
        methods: {
            onChange: function(e) {
                this.$emit("page-change", e)
            }
        },
        computed: {
            pageOptions: function() {
                for (var e = [], t = 0; t < this.pageCount; t++)
                    e.push({
                        label: String(t + 1),
                        value: t
                    });
                return e
            }
        },
        components: {
            JTPSelect: wM
        },
        render: function(e, t, n, r, o, i) {
            var a = jn("JTPSelect");
            return uo(), mo(a, {
                modelValue: n.page,
                options: i.pageOptions,
                optionLabel: "label",
                optionValue: "value",
                "onUpdate:modelValue": t[0] || (t[0] = function(e) {
                    return i.onChange(e)
                }),
                class: G(e.cx("pcJumpToPageDropdown")),
                disabled: n.disabled,
                unstyled: e.unstyled,
                pt: e.ptm("pcJumpToPageDropdown"),
                "data-pc-group-section": "pagedropdown"
            }, Xn({
                _: 2
            }, [n.templates.jumptopagedropdownicon ? {
                name: "dropdownicon",
                fn: Vt(function(e) {
                    return [(uo(), mo(Hn(n.templates.jumptopagedropdownicon), {
                        class: G(e.class)
                    }, null, 8, ["class"]))]
                }),
                key: "0"
            } : void 0]), 1032, ["modelValue", "options", "class", "disabled", "unstyled", "pt"])
        }
    },
    HB = {
        name: "JumpToPageInput",
        hostName: "Paginator",
        extends: nT,
        inheritAttrs: !1,
        emits: ["page-change"],
        props: {
            page: Number,
            pageCount: Number,
            disabled: Boolean
        },
        data: function() {
            return {
                d_page: this.page
            }
        },
        watch: {
            page: function(e) {
                this.d_page = e
            }
        },
        methods: {
            onChange: function(e) {
                e !== this.page && (this.d_page = e, this.$emit("page-change", e - 1))
            }
        },
        computed: {
            inputArialabel: function() {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.jumpToPageInputLabel : void 0
            }
        },
        components: {
            JTPInput: TB
        },
        render: function(e, t, n, r, o, i) {
            var a = jn("JTPInput");
            return uo(), mo(a, {
                ref: "jtpInput",
                modelValue: o.d_page,
                class: G(e.cx("pcJumpToPageInputText")),
                "aria-label": i.inputArialabel,
                disabled: n.disabled,
                "onUpdate:modelValue": i.onChange,
                unstyled: e.unstyled,
                pt: e.ptm("pcJumpToPageInputText")
            }, null, 8, ["modelValue", "class", "aria-label", "disabled", "onUpdate:modelValue", "unstyled", "pt"])
        }
    },
    $B = {
        name: "LastPageLink",
        hostName: "Paginator",
        extends: nT,
        props: {
            template: {
                type: Function,
                default: null
            }
        },
        methods: {
            getPTOptions: function(e) {
                return this.ptm(e, {
                    context: {
                        disabled: this.$attrs.disabled
                    }
                })
            }
        },
        components: {
            AngleDoubleRightIcon: OB
        },
        directives: {
            ripple: ET
        },
        render: function(e, t, n, r, o, i) {
            var a = $n("ripple");
            return Ht((uo(), go("button", Mo({
                class: e.cx("last"),
                type: "button"
            }, i.getPTOptions("last"), {
                "data-pc-group-section": "pagebutton"
            }), [(uo(), mo(Hn(n.template || "AngleDoubleRightIcon"), Mo({
                class: e.cx("lastIcon")
            }, i.getPTOptions("lastIcon")), null, 16, ["class"]))], 16)), [[a]])
        }
    },
    WB = {
        name: "NextPageLink",
        hostName: "Paginator",
        extends: nT,
        props: {
            template: {
                type: Function,
                default: null
            }
        },
        methods: {
            getPTOptions: function(e) {
                return this.ptm(e, {
                    context: {
                        disabled: this.$attrs.disabled
                    }
                })
            }
        },
        components: {
            AngleRightIcon: NB
        },
        directives: {
            ripple: ET
        },
        render: function(e, t, n, r, o, i) {
            var a = $n("ripple");
            return Ht((uo(), go("button", Mo({
                class: e.cx("next"),
                type: "button"
            }, i.getPTOptions("next"), {
                "data-pc-group-section": "pagebutton"
            }), [(uo(), mo(Hn(n.template || "AngleRightIcon"), Mo({
                class: e.cx("nextIcon")
            }, i.getPTOptions("nextIcon")), null, 16, ["class"]))], 16)), [[a]])
        }
    },
    KB = {
        name: "PageLinks",
        hostName: "Paginator",
        extends: nT,
        inheritAttrs: !1,
        emits: ["click"],
        props: {
            value: Array,
            page: Number
        },
        methods: {
            getPTOptions: function(e, t) {
                return this.ptm(t, {
                    context: {
                        active: e === this.page
                    }
                })
            },
            onPageLinkClick: function(e, t) {
                this.$emit("click", {
                    originalEvent: e,
                    value: t
                })
            },
            ariaPageLabel: function(e) {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.pageLabel.replace(/{page}/g, e) : void 0
            }
        },
        directives: {
            ripple: ET
        }
    },
    qB = ["aria-label", "aria-current", "onClick", "data-p-active"];
KB.render = function(e, t, n, r, o, i) {
    var a = $n("ripple");
    return uo(), go("span", Mo({
        class: e.cx("pages")
    }, e.ptm("pages")), [(uo(!0), go(oo, null, qn(n.value, function(t) {
        return Ht((uo(), go("button", Mo({
            key: t,
            class: e.cx("page", {
                pageLink: t
            }),
            type: "button",
            "aria-label": i.ariaPageLabel(t),
            "aria-current": t - 1 === n.page ? "page" : void 0,
            onClick: function(e) {
                return i.onPageLinkClick(e, t)
            }
        }, {
            ref_for: !0
        }, i.getPTOptions(t - 1, "page"), {
            "data-p-active": t - 1 === n.page
        }), [Co(W(t), 1)], 16, qB)), [[a]])
    }), 128))], 16)
};
var XB = {
        name: "PrevPageLink",
        hostName: "Paginator",
        extends: nT,
        props: {
            template: {
                type: Function,
                default: null
            }
        },
        methods: {
            getPTOptions: function(e) {
                return this.ptm(e, {
                    context: {
                        disabled: this.$attrs.disabled
                    }
                })
            }
        },
        components: {
            AngleLeftIcon: UB
        },
        directives: {
            ripple: ET
        },
        render: function(e, t, n, r, o, i) {
            var a = $n("ripple");
            return Ht((uo(), go("button", Mo({
                class: e.cx("prev"),
                type: "button"
            }, i.getPTOptions("prev"), {
                "data-pc-group-section": "pagebutton"
            }), [(uo(), mo(Hn(n.template || "AngleLeftIcon"), Mo({
                class: e.cx("prevIcon")
            }, i.getPTOptions("prevIcon")), null, 16, ["class"]))], 16)), [[a]])
        }
    },
    YB = {
        name: "RowsPerPageDropdown",
        hostName: "Paginator",
        extends: nT,
        emits: ["rows-change"],
        props: {
            options: Array,
            rows: Number,
            disabled: Boolean,
            templates: null
        },
        methods: {
            onChange: function(e) {
                this.$emit("rows-change", e)
            }
        },
        computed: {
            rowsOptions: function() {
                var e = [];
                if (this.options)
                    for (var t = 0; t < this.options.length; t++)
                        e.push({
                            label: String(this.options[t]),
                            value: this.options[t]
                        });
                return e
            }
        },
        components: {
            RPPSelect: wM
        }
    };
function JB(e) {
    return (JB = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function ZB(e, t) {
    return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r,
                    o,
                    i,
                    a,
                    s = [],
                    l = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t) {
                        if (Object(n) !== n)
                            return;
                        l = !1
                    } else
                        for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                            ;
                } catch (u) {
                    c = !0,
                    o = u
                } finally {
                    try {
                        if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                            return
                    } finally {
                        if (c)
                            throw o
                    }
                }
                return s
            }
        }(e, t) || function(e, t) {
            if (e) {
                if ("string" == typeof e)
                    return ek(e, t);
                var n = {}.toString.call(e).slice(8, -1);
                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ek(e, t) : void 0
            }
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function ek(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
YB.render = function(e, t, n, r, o, i) {
    var a = jn("RPPSelect");
    return uo(), mo(a, {
        modelValue: n.rows,
        options: i.rowsOptions,
        optionLabel: "label",
        optionValue: "value",
        "onUpdate:modelValue": t[0] || (t[0] = function(e) {
            return i.onChange(e)
        }),
        class: G(e.cx("pcRowPerPageDropdown")),
        disabled: n.disabled,
        unstyled: e.unstyled,
        pt: e.ptm("pcRowPerPageDropdown"),
        "data-pc-group-section": "pagedropdown"
    }, Xn({
        _: 2
    }, [n.templates.rowsperpagedropdownicon ? {
        name: "dropdownicon",
        fn: Vt(function(e) {
            return [(uo(), mo(Hn(n.templates.rowsperpagedropdownicon), {
                class: G(e.class)
            }, null, 8, ["class"]))]
        }),
        key: "0"
    } : void 0]), 1032, ["modelValue", "options", "class", "disabled", "unstyled", "pt"])
};
var tk = {
        name: "Paginator",
        extends: QB,
        inheritAttrs: !1,
        emits: ["update:first", "update:rows", "page"],
        data: function() {
            return {
                d_first: this.first,
                d_rows: this.rows
            }
        },
        watch: {
            first: function(e) {
                this.d_first = e
            },
            rows: function(e) {
                this.d_rows = e
            },
            totalRecords: function(e) {
                this.page > 0 && e && this.d_first >= e && this.changePage(this.pageCount - 1)
            }
        },
        mounted: function() {
            this.createStyle()
        },
        methods: {
            changePage: function(e) {
                var t = this.pageCount;
                if (e >= 0 && e < t) {
                    this.d_first = this.d_rows * e;
                    var n = {
                        page: e,
                        first: this.d_first,
                        rows: this.d_rows,
                        pageCount: t
                    };
                    this.$emit("update:first", this.d_first),
                    this.$emit("update:rows", this.d_rows),
                    this.$emit("page", n)
                }
            },
            changePageToFirst: function(e) {
                this.isFirstPage || this.changePage(0),
                e.preventDefault()
            },
            changePageToPrev: function(e) {
                this.changePage(this.page - 1),
                e.preventDefault()
            },
            changePageLink: function(e) {
                this.changePage(e.value - 1),
                e.originalEvent.preventDefault()
            },
            changePageToNext: function(e) {
                this.changePage(this.page + 1),
                e.preventDefault()
            },
            changePageToLast: function(e) {
                this.isLastPage || this.changePage(this.pageCount - 1),
                e.preventDefault()
            },
            onRowChange: function(e) {
                this.d_rows = e,
                this.changePage(this.page)
            },
            createStyle: function() {
                var e = this;
                if (this.hasBreakpoints() && !this.isUnstyled) {
                    var t;
                    this.styleElement = document.createElement("style"),
                    this.styleElement.type = "text/css",
                    YE(this.styleElement, "nonce", null === (t = this.$primevue) || void 0 === t || null === (t = t.config) || void 0 === t || null === (t = t.csp) || void 0 === t ? void 0 : t.nonce),
                    document.body.appendChild(this.styleElement);
                    var n = "",
                        r = Object.keys(this.template),
                        o = {};
                    r.sort(function(e, t) {
                        return parseInt(e) - parseInt(t)
                    }).forEach(function(t) {
                        o[t] = e.template[t]
                    });
                    for (var i = 0, a = Object.entries(Object.entries(o)); i < a.length; i++) {
                        var s,
                            l,
                            c = ZB(a[i], 2),
                            u = c[0],
                            d = ZB(c[1], 1)[0];
                        l = "default" !== d && "string" == typeof Object.keys(o)[u - 1] ? Number(Object.keys(o)[u - 1].slice(0, -2)) + 1 + "px" : Object.keys(o)[u - 1],
                        s = Object.entries(o)[u - 1] ? "and (min-width:".concat(l, ")") : "",
                        n += "default" === d ? "\n                            @media screen ".concat(s, " {\n                                .p-paginator[").concat(this.$attrSelector, "],\n                                    display: flex;\n                                }\n                            }\n                        ") : "\n.p-paginator-".concat(d, " {\n    display: none;\n}\n@media screen ").concat(s, " and (max-width: ").concat(d, ") {\n    .p-paginator-").concat(d, " {\n        display: flex;\n    }\n\n    .p-paginator-default{\n        display: none;\n    }\n}\n                    ")
                    }
                    this.styleElement.innerHTML = n
                }
            },
            hasBreakpoints: function() {
                return "object" === JB(this.template)
            },
            getAriaLabel: function(e) {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria[e] : void 0
            }
        },
        computed: {
            templateItems: function() {
                var e = {};
                if (this.hasBreakpoints()) {
                    for (var t in (e = this.template).default || (e.default = "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown"), e)
                        e[t] = this.template[t].split(" ").map(function(e) {
                            return e.trim()
                        });
                    return e
                }
                return e.default = this.template.split(" ").map(function(e) {
                    return e.trim()
                }), e
            },
            page: function() {
                return Math.floor(this.d_first / this.d_rows)
            },
            pageCount: function() {
                return Math.ceil(this.totalRecords / this.d_rows)
            },
            isFirstPage: function() {
                return 0 === this.page
            },
            isLastPage: function() {
                return this.page === this.pageCount - 1
            },
            calculatePageLinkBoundaries: function() {
                var e = this.pageCount,
                    t = Math.min(this.pageLinkSize, e),
                    n = Math.max(0, Math.ceil(this.page - t / 2)),
                    r = Math.min(e - 1, n + t - 1),
                    o = this.pageLinkSize - (r - n + 1);
                return [n = Math.max(0, n - o), r]
            },
            pageLinks: function() {
                for (var e = [], t = this.calculatePageLinkBoundaries, n = t[0], r = t[1], o = n; o <= r; o++)
                    e.push(o + 1);
                return e
            },
            currentState: function() {
                return {
                    page: this.page,
                    first: this.d_first,
                    rows: this.d_rows
                }
            },
            empty: function() {
                return 0 === this.pageCount
            },
            currentPage: function() {
                return this.pageCount > 0 ? this.page + 1 : 0
            },
            last: function() {
                return Math.min(this.d_first + this.rows, this.totalRecords)
            }
        },
        components: {
            CurrentPageReport: GB,
            FirstPageLink: jB,
            LastPageLink: $B,
            NextPageLink: WB,
            PageLinks: KB,
            PrevPageLink: XB,
            RowsPerPageDropdown: YB,
            JumpToPageDropdown: VB,
            JumpToPageInput: HB
        },
        render: function(e, t, n, r, o, i) {
            var a = jn("FirstPageLink"),
                s = jn("PrevPageLink"),
                l = jn("NextPageLink"),
                c = jn("LastPageLink"),
                u = jn("PageLinks"),
                d = jn("CurrentPageReport"),
                p = jn("RowsPerPageDropdown"),
                h = jn("JumpToPageDropdown"),
                f = jn("JumpToPageInput");
            return e.alwaysShow || i.pageLinks && i.pageLinks.length > 1 ? (uo(), go("nav", j(Mo({
                key: 0
            }, e.ptmi("paginatorContainer"))), [(uo(!0), go(oo, null, qn(i.templateItems, function(n, r) {
                return uo(), go("div", Mo({
                    key: r,
                    ref_for: !0,
                    ref: "paginator",
                    class: e.cx("paginator", {
                        key: r
                    })
                }, {
                    ref_for: !0
                }, e.ptm("root")), [e.$slots.container ? Yn(e.$slots, "container", {
                    key: 0,
                    first: o.d_first + 1,
                    last: i.last,
                    rows: o.d_rows,
                    page: i.page,
                    pageCount: i.pageCount,
                    pageLinks: i.pageLinks,
                    totalRecords: e.totalRecords,
                    firstPageCallback: i.changePageToFirst,
                    lastPageCallback: i.changePageToLast,
                    prevPageCallback: i.changePageToPrev,
                    nextPageCallback: i.changePageToNext,
                    rowChangeCallback: i.onRowChange,
                    changePageCallback: i.changePage
                }) : (uo(), go(oo, {
                    key: 1
                }, [e.$slots.start ? (uo(), go("div", Mo({
                    key: 0,
                    class: e.cx("contentStart")
                }, {
                    ref_for: !0
                }, e.ptm("contentStart")), [Yn(e.$slots, "start", {
                    state: i.currentState
                })], 16)) : Eo("", !0), _o("div", Mo({
                    class: e.cx("content")
                }, {
                    ref_for: !0
                }, e.ptm("content")), [(uo(!0), go(oo, null, qn(n, function(n) {
                    return uo(), go(oo, {
                        key: n
                    }, ["FirstPageLink" === n ? (uo(), mo(a, {
                        key: 0,
                        "aria-label": i.getAriaLabel("firstPageLabel"),
                        template: e.$slots.firsticon || e.$slots.firstpagelinkicon,
                        onClick: t[0] || (t[0] = function(e) {
                            return i.changePageToFirst(e)
                        }),
                        disabled: i.isFirstPage || i.empty,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : "PrevPageLink" === n ? (uo(), mo(s, {
                        key: 1,
                        "aria-label": i.getAriaLabel("prevPageLabel"),
                        template: e.$slots.previcon || e.$slots.prevpagelinkicon,
                        onClick: t[1] || (t[1] = function(e) {
                            return i.changePageToPrev(e)
                        }),
                        disabled: i.isFirstPage || i.empty,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : "NextPageLink" === n ? (uo(), mo(l, {
                        key: 2,
                        "aria-label": i.getAriaLabel("nextPageLabel"),
                        template: e.$slots.nexticon || e.$slots.nextpagelinkicon,
                        onClick: t[2] || (t[2] = function(e) {
                            return i.changePageToNext(e)
                        }),
                        disabled: i.isLastPage || i.empty,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : "LastPageLink" === n ? (uo(), mo(c, {
                        key: 3,
                        "aria-label": i.getAriaLabel("lastPageLabel"),
                        template: e.$slots.lasticon || e.$slots.lastpagelinkicon,
                        onClick: t[3] || (t[3] = function(e) {
                            return i.changePageToLast(e)
                        }),
                        disabled: i.isLastPage || i.empty,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "template", "disabled", "unstyled", "pt"])) : "PageLinks" === n ? (uo(), mo(u, {
                        key: 4,
                        "aria-label": i.getAriaLabel("pageLabel"),
                        value: i.pageLinks,
                        page: i.page,
                        onClick: t[4] || (t[4] = function(e) {
                            return i.changePageLink(e)
                        }),
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "value", "page", "unstyled", "pt"])) : "CurrentPageReport" === n ? (uo(), mo(d, {
                        key: 5,
                        "aria-live": "polite",
                        template: e.currentPageReportTemplate,
                        currentPage: i.currentPage,
                        page: i.page,
                        pageCount: i.pageCount,
                        first: o.d_first,
                        rows: o.d_rows,
                        totalRecords: e.totalRecords,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["template", "currentPage", "page", "pageCount", "first", "rows", "totalRecords", "unstyled", "pt"])) : "RowsPerPageDropdown" === n && e.rowsPerPageOptions ? (uo(), mo(p, {
                        key: 6,
                        "aria-label": i.getAriaLabel("rowsPerPageLabel"),
                        rows: o.d_rows,
                        options: e.rowsPerPageOptions,
                        onRowsChange: t[5] || (t[5] = function(e) {
                            return i.onRowChange(e)
                        }),
                        disabled: i.empty,
                        templates: e.$slots,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "rows", "options", "disabled", "templates", "unstyled", "pt"])) : "JumpToPageDropdown" === n ? (uo(), mo(h, {
                        key: 7,
                        "aria-label": i.getAriaLabel("jumpToPageDropdownLabel"),
                        page: i.page,
                        pageCount: i.pageCount,
                        onPageChange: t[6] || (t[6] = function(e) {
                            return i.changePage(e)
                        }),
                        disabled: i.empty,
                        templates: e.$slots,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["aria-label", "page", "pageCount", "disabled", "templates", "unstyled", "pt"])) : "JumpToPageInput" === n ? (uo(), mo(f, {
                        key: 8,
                        page: i.currentPage,
                        onPageChange: t[7] || (t[7] = function(e) {
                            return i.changePage(e)
                        }),
                        disabled: i.empty,
                        unstyled: e.unstyled,
                        pt: e.pt
                    }, null, 8, ["page", "disabled", "unstyled", "pt"])) : Eo("", !0)], 64)
                }), 128))], 16), e.$slots.end ? (uo(), go("div", Mo({
                    key: 1,
                    class: e.cx("contentEnd")
                }, {
                    ref_for: !0
                }, e.ptm("contentEnd")), [Yn(e.$slots, "end", {
                    state: i.currentState
                })], 16)) : Eo("", !0)], 64))], 16)
            }), 128))], 16)) : Eo("", !0)
        }
    },
    nk = kI.extend({
        name: "datatable",
        style: "\n    .p-datatable {\n        position: relative;\n        display: block;\n    }\n\n    .p-datatable-table {\n        border-spacing: 0;\n        border-collapse: separate;\n        width: 100%;\n    }\n\n    .p-datatable-scrollable > .p-datatable-table-container {\n        position: relative;\n    }\n\n    .p-datatable-scrollable-table > .p-datatable-thead {\n        inset-block-start: 0;\n        z-index: 1;\n    }\n\n    .p-datatable-scrollable-table > .p-datatable-frozen-tbody {\n        position: sticky;\n        z-index: 1;\n    }\n\n    .p-datatable-scrollable-table > .p-datatable-tfoot {\n        inset-block-end: 0;\n        z-index: 1;\n    }\n\n    .p-datatable-scrollable .p-datatable-frozen-column {\n        position: sticky;\n    }\n\n    .p-datatable-scrollable th.p-datatable-frozen-column {\n        z-index: 1;\n    }\n\n    .p-datatable-scrollable td.p-datatable-frozen-column {\n        background: inherit;\n    }\n\n    .p-datatable-scrollable > .p-datatable-table-container > .p-datatable-table > .p-datatable-thead,\n    .p-datatable-scrollable > .p-datatable-table-container > .p-virtualscroller > .p-datatable-table > .p-datatable-thead {\n        background: dt('datatable.header.cell.background');\n    }\n\n    .p-datatable-scrollable > .p-datatable-table-container > .p-datatable-table > .p-datatable-tfoot,\n    .p-datatable-scrollable > .p-datatable-table-container > .p-virtualscroller > .p-datatable-table > .p-datatable-tfoot {\n        background: dt('datatable.footer.cell.background');\n    }\n\n    .p-datatable-flex-scrollable {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n    }\n\n    .p-datatable-flex-scrollable > .p-datatable-table-container {\n        display: flex;\n        flex-direction: column;\n        flex: 1;\n        height: 100%;\n    }\n\n    .p-datatable-scrollable-table > .p-datatable-tbody > .p-datatable-row-group-header {\n        position: sticky;\n        z-index: 1;\n    }\n\n    .p-datatable-resizable-table > .p-datatable-thead > tr > th,\n    .p-datatable-resizable-table > .p-datatable-tfoot > tr > td,\n    .p-datatable-resizable-table > .p-datatable-tbody > tr > td {\n        overflow: hidden;\n        white-space: nowrap;\n    }\n\n    .p-datatable-resizable-table > .p-datatable-thead > tr > th.p-datatable-resizable-column:not(.p-datatable-frozen-column) {\n        background-clip: padding-box;\n        position: relative;\n    }\n\n    .p-datatable-resizable-table-fit > .p-datatable-thead > tr > th.p-datatable-resizable-column:last-child .p-datatable-column-resizer {\n        display: none;\n    }\n\n    .p-datatable-column-resizer {\n        display: block;\n        position: absolute;\n        inset-block-start: 0;\n        inset-inline-end: 0;\n        margin: 0;\n        width: dt('datatable.column.resizer.width');\n        height: 100%;\n        padding: 0;\n        cursor: col-resize;\n        border: 1px solid transparent;\n    }\n\n    .p-datatable-column-header-content {\n        display: flex;\n        align-items: center;\n        gap: dt('datatable.header.cell.gap');\n    }\n\n    .p-datatable-column-resize-indicator {\n        width: dt('datatable.resize.indicator.width');\n        position: absolute;\n        z-index: 10;\n        display: none;\n        background: dt('datatable.resize.indicator.color');\n    }\n\n    .p-datatable-row-reorder-indicator-up,\n    .p-datatable-row-reorder-indicator-down {\n        position: absolute;\n        display: none;\n    }\n\n    .p-datatable-reorderable-column,\n    .p-datatable-reorderable-row-handle {\n        cursor: move;\n    }\n\n    .p-datatable-mask {\n        position: absolute;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 2;\n    }\n\n    .p-datatable-inline-filter {\n        display: flex;\n        align-items: center;\n        width: 100%;\n        gap: dt('datatable.filter.inline.gap');\n    }\n\n    .p-datatable-inline-filter .p-datatable-filter-element-container {\n        flex: 1 1 auto;\n        width: 1%;\n    }\n\n    .p-datatable-filter-overlay {\n        background: dt('datatable.filter.overlay.select.background');\n        color: dt('datatable.filter.overlay.select.color');\n        border: 1px solid dt('datatable.filter.overlay.select.border.color');\n        border-radius: dt('datatable.filter.overlay.select.border.radius');\n        box-shadow: dt('datatable.filter.overlay.select.shadow');\n        min-width: 12.5rem;\n    }\n\n    .p-datatable-filter-constraint-list {\n        margin: 0;\n        list-style: none;\n        display: flex;\n        flex-direction: column;\n        padding: dt('datatable.filter.constraint.list.padding');\n        gap: dt('datatable.filter.constraint.list.gap');\n    }\n\n    .p-datatable-filter-constraint {\n        padding: dt('datatable.filter.constraint.padding');\n        color: dt('datatable.filter.constraint.color');\n        border-radius: dt('datatable.filter.constraint.border.radius');\n        cursor: pointer;\n        transition:\n            background dt('datatable.transition.duration'),\n            color dt('datatable.transition.duration'),\n            border-color dt('datatable.transition.duration'),\n            box-shadow dt('datatable.transition.duration');\n    }\n\n    .p-datatable-filter-constraint-selected {\n        background: dt('datatable.filter.constraint.selected.background');\n        color: dt('datatable.filter.constraint.selected.color');\n    }\n\n    .p-datatable-filter-constraint:not(.p-datatable-filter-constraint-selected):not(.p-disabled):hover {\n        background: dt('datatable.filter.constraint.focus.background');\n        color: dt('datatable.filter.constraint.focus.color');\n    }\n\n    .p-datatable-filter-constraint:focus-visible {\n        outline: 0 none;\n        background: dt('datatable.filter.constraint.focus.background');\n        color: dt('datatable.filter.constraint.focus.color');\n    }\n\n    .p-datatable-filter-constraint-selected:focus-visible {\n        outline: 0 none;\n        background: dt('datatable.filter.constraint.selected.focus.background');\n        color: dt('datatable.filter.constraint.selected.focus.color');\n    }\n\n    .p-datatable-filter-constraint-separator {\n        border-block-start: 1px solid dt('datatable.filter.constraint.separator.border.color');\n    }\n\n    .p-datatable-popover-filter {\n        display: inline-flex;\n        margin-inline-start: auto;\n    }\n\n    .p-datatable-filter-overlay-popover {\n        background: dt('datatable.filter.overlay.popover.background');\n        color: dt('datatable.filter.overlay.popover.color');\n        border: 1px solid dt('datatable.filter.overlay.popover.border.color');\n        border-radius: dt('datatable.filter.overlay.popover.border.radius');\n        box-shadow: dt('datatable.filter.overlay.popover.shadow');\n        min-width: 12.5rem;\n        padding: dt('datatable.filter.overlay.popover.padding');\n        display: flex;\n        flex-direction: column;\n        gap: dt('datatable.filter.overlay.popover.gap');\n    }\n\n    .p-datatable-filter-operator-dropdown {\n        width: 100%;\n    }\n\n    .p-datatable-filter-rule-list,\n    .p-datatable-filter-rule {\n        display: flex;\n        flex-direction: column;\n        gap: dt('datatable.filter.overlay.popover.gap');\n    }\n\n    .p-datatable-filter-rule {\n        border-block-end: 1px solid dt('datatable.filter.rule.border.color');\n        padding-bottom: dt('datatable.filter.overlay.popover.gap');\n    }\n\n    .p-datatable-filter-rule:last-child {\n        border-block-end: 0 none;\n        padding-bottom: 0;\n    }\n\n    .p-datatable-filter-add-rule-button {\n        width: 100%;\n    }\n\n    .p-datatable-filter-remove-rule-button {\n        width: 100%;\n    }\n\n    .p-datatable-filter-buttonbar {\n        padding: 0;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n    }\n\n    .p-datatable-virtualscroller-spacer {\n        display: flex;\n    }\n\n    .p-datatable .p-virtualscroller .p-virtualscroller-loading {\n        transform: none !important;\n        min-height: 0;\n        position: sticky;\n        inset-block-start: 0;\n        inset-inline-start: 0;\n    }\n\n    .p-datatable-paginator-top {\n        border-color: dt('datatable.paginator.top.border.color');\n        border-style: solid;\n        border-width: dt('datatable.paginator.top.border.width');\n    }\n\n    .p-datatable-paginator-bottom {\n        border-color: dt('datatable.paginator.bottom.border.color');\n        border-style: solid;\n        border-width: dt('datatable.paginator.bottom.border.width');\n    }\n\n    .p-datatable-header {\n        background: dt('datatable.header.background');\n        color: dt('datatable.header.color');\n        border-color: dt('datatable.header.border.color');\n        border-style: solid;\n        border-width: dt('datatable.header.border.width');\n        padding: dt('datatable.header.padding');\n    }\n\n    .p-datatable-footer {\n        background: dt('datatable.footer.background');\n        color: dt('datatable.footer.color');\n        border-color: dt('datatable.footer.border.color');\n        border-style: solid;\n        border-width: dt('datatable.footer.border.width');\n        padding: dt('datatable.footer.padding');\n    }\n\n    .p-datatable-header-cell {\n        padding: dt('datatable.header.cell.padding');\n        background: dt('datatable.header.cell.background');\n        border-color: dt('datatable.header.cell.border.color');\n        border-style: solid;\n        border-width: 0 0 1px 0;\n        color: dt('datatable.header.cell.color');\n        font-weight: normal;\n        text-align: start;\n        transition:\n            background dt('datatable.transition.duration'),\n            color dt('datatable.transition.duration'),\n            border-color dt('datatable.transition.duration'),\n            outline-color dt('datatable.transition.duration'),\n            box-shadow dt('datatable.transition.duration');\n    }\n\n    .p-datatable-column-title {\n        font-weight: dt('datatable.column.title.font.weight');\n    }\n\n    .p-datatable-tbody > tr {\n        outline-color: transparent;\n        background: dt('datatable.row.background');\n        color: dt('datatable.row.color');\n        transition:\n            background dt('datatable.transition.duration'),\n            color dt('datatable.transition.duration'),\n            border-color dt('datatable.transition.duration'),\n            outline-color dt('datatable.transition.duration'),\n            box-shadow dt('datatable.transition.duration');\n    }\n\n    .p-datatable-tbody > tr > td {\n        text-align: start;\n        border-color: dt('datatable.body.cell.border.color');\n        border-style: solid;\n        border-width: 0 0 1px 0;\n        padding: dt('datatable.body.cell.padding');\n    }\n\n    .p-datatable-hoverable .p-datatable-tbody > tr:not(.p-datatable-row-selected):hover {\n        background: dt('datatable.row.hover.background');\n        color: dt('datatable.row.hover.color');\n    }\n\n    .p-datatable-tbody > tr.p-datatable-row-selected {\n        background: dt('datatable.row.selected.background');\n        color: dt('datatable.row.selected.color');\n    }\n\n    .p-datatable-tbody > tr:has(+ .p-datatable-row-selected) > td {\n        border-block-end-color: dt('datatable.body.cell.selected.border.color');\n    }\n\n    .p-datatable-tbody > tr.p-datatable-row-selected > td {\n        border-block-end-color: dt('datatable.body.cell.selected.border.color');\n    }\n\n    .p-datatable-tbody > tr:focus-visible,\n    .p-datatable-tbody > tr.p-datatable-contextmenu-row-selected {\n        box-shadow: dt('datatable.row.focus.ring.shadow');\n        outline: dt('datatable.row.focus.ring.width') dt('datatable.row.focus.ring.style') dt('datatable.row.focus.ring.color');\n        outline-offset: dt('datatable.row.focus.ring.offset');\n    }\n\n    .p-datatable-tfoot > tr > td {\n        text-align: start;\n        padding: dt('datatable.footer.cell.padding');\n        border-color: dt('datatable.footer.cell.border.color');\n        border-style: solid;\n        border-width: 0 0 1px 0;\n        color: dt('datatable.footer.cell.color');\n        background: dt('datatable.footer.cell.background');\n    }\n\n    .p-datatable-column-footer {\n        font-weight: dt('datatable.column.footer.font.weight');\n    }\n\n    .p-datatable-sortable-column {\n        cursor: pointer;\n        user-select: none;\n        outline-color: transparent;\n    }\n\n    .p-datatable-column-title,\n    .p-datatable-sort-icon,\n    .p-datatable-sort-badge {\n        vertical-align: middle;\n    }\n\n    .p-datatable-sort-icon {\n        color: dt('datatable.sort.icon.color');\n        font-size: dt('datatable.sort.icon.size');\n        width: dt('datatable.sort.icon.size');\n        height: dt('datatable.sort.icon.size');\n        transition: color dt('datatable.transition.duration');\n    }\n\n    .p-datatable-sortable-column:not(.p-datatable-column-sorted):hover {\n        background: dt('datatable.header.cell.hover.background');\n        color: dt('datatable.header.cell.hover.color');\n    }\n\n    .p-datatable-sortable-column:not(.p-datatable-column-sorted):hover .p-datatable-sort-icon {\n        color: dt('datatable.sort.icon.hover.color');\n    }\n\n    .p-datatable-column-sorted {\n        background: dt('datatable.header.cell.selected.background');\n        color: dt('datatable.header.cell.selected.color');\n    }\n\n    .p-datatable-column-sorted .p-datatable-sort-icon {\n        color: dt('datatable.header.cell.selected.color');\n    }\n\n    .p-datatable-sortable-column:focus-visible {\n        box-shadow: dt('datatable.header.cell.focus.ring.shadow');\n        outline: dt('datatable.header.cell.focus.ring.width') dt('datatable.header.cell.focus.ring.style') dt('datatable.header.cell.focus.ring.color');\n        outline-offset: dt('datatable.header.cell.focus.ring.offset');\n    }\n\n    .p-datatable-hoverable .p-datatable-selectable-row {\n        cursor: pointer;\n    }\n\n    .p-datatable-tbody > tr.p-datatable-dragpoint-top > td {\n        box-shadow: inset 0 2px 0 0 dt('datatable.drop.point.color');\n    }\n\n    .p-datatable-tbody > tr.p-datatable-dragpoint-bottom > td {\n        box-shadow: inset 0 -2px 0 0 dt('datatable.drop.point.color');\n    }\n\n    .p-datatable-loading-icon {\n        font-size: dt('datatable.loading.icon.size');\n        width: dt('datatable.loading.icon.size');\n        height: dt('datatable.loading.icon.size');\n    }\n\n    .p-datatable-gridlines .p-datatable-header {\n        border-width: 1px 1px 0 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-footer {\n        border-width: 0 1px 1px 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-paginator-top {\n        border-width: 1px 1px 0 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-paginator-bottom {\n        border-width: 0 1px 1px 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-thead > tr > th {\n        border-width: 1px 0 1px 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-thead > tr > th:last-child {\n        border-width: 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tbody > tr > td {\n        border-width: 1px 0 0 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tbody > tr > td:last-child {\n        border-width: 1px 1px 0 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tbody > tr:last-child > td {\n        border-width: 1px 0 1px 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tbody > tr:last-child > td:last-child {\n        border-width: 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tfoot > tr > td {\n        border-width: 1px 0 1px 1px;\n    }\n\n    .p-datatable-gridlines .p-datatable-tfoot > tr > td:last-child {\n        border-width: 1px 1px 1px 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot > tr > td {\n        border-width: 0 0 1px 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines .p-datatable-thead + .p-datatable-tfoot > tr > td:last-child {\n        border-width: 0 1px 1px 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody > tr > td {\n        border-width: 0 0 1px 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines:has(.p-datatable-thead):has(.p-datatable-tbody) .p-datatable-tbody > tr > td:last-child {\n        border-width: 0 1px 1px 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody > tr:last-child > td {\n        border-width: 0 0 0 1px;\n    }\n\n    .p-datatable.p-datatable-gridlines:has(.p-datatable-tbody):has(.p-datatable-tfoot) .p-datatable-tbody > tr:last-child > td:last-child {\n        border-width: 0 1px 0 1px;\n    }\n\n    .p-datatable.p-datatable-striped .p-datatable-tbody > tr.p-row-odd {\n        background: dt('datatable.row.striped.background');\n    }\n\n    .p-datatable.p-datatable-striped .p-datatable-tbody > tr.p-row-odd.p-datatable-row-selected {\n        background: dt('datatable.row.selected.background');\n        color: dt('datatable.row.selected.color');\n    }\n\n    .p-datatable-striped.p-datatable-hoverable .p-datatable-tbody > tr:not(.p-datatable-row-selected):hover {\n        background: dt('datatable.row.hover.background');\n        color: dt('datatable.row.hover.color');\n    }\n\n    .p-datatable.p-datatable-sm .p-datatable-header {\n        padding: dt('datatable.header.sm.padding');\n    }\n\n    .p-datatable.p-datatable-sm .p-datatable-thead > tr > th {\n        padding: dt('datatable.header.cell.sm.padding');\n    }\n\n    .p-datatable.p-datatable-sm .p-datatable-tbody > tr > td {\n        padding: dt('datatable.body.cell.sm.padding');\n    }\n\n    .p-datatable.p-datatable-sm .p-datatable-tfoot > tr > td {\n        padding: dt('datatable.footer.cell.sm.padding');\n    }\n\n    .p-datatable.p-datatable-sm .p-datatable-footer {\n        padding: dt('datatable.footer.sm.padding');\n    }\n\n    .p-datatable.p-datatable-lg .p-datatable-header {\n        padding: dt('datatable.header.lg.padding');\n    }\n\n    .p-datatable.p-datatable-lg .p-datatable-thead > tr > th {\n        padding: dt('datatable.header.cell.lg.padding');\n    }\n\n    .p-datatable.p-datatable-lg .p-datatable-tbody > tr > td {\n        padding: dt('datatable.body.cell.lg.padding');\n    }\n\n    .p-datatable.p-datatable-lg .p-datatable-tfoot > tr > td {\n        padding: dt('datatable.footer.cell.lg.padding');\n    }\n\n    .p-datatable.p-datatable-lg .p-datatable-footer {\n        padding: dt('datatable.footer.lg.padding');\n    }\n\n    .p-datatable-row-toggle-button {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        overflow: hidden;\n        position: relative;\n        width: dt('datatable.row.toggle.button.size');\n        height: dt('datatable.row.toggle.button.size');\n        color: dt('datatable.row.toggle.button.color');\n        border: 0 none;\n        background: transparent;\n        cursor: pointer;\n        border-radius: dt('datatable.row.toggle.button.border.radius');\n        transition:\n            background dt('datatable.transition.duration'),\n            color dt('datatable.transition.duration'),\n            border-color dt('datatable.transition.duration'),\n            outline-color dt('datatable.transition.duration'),\n            box-shadow dt('datatable.transition.duration');\n        outline-color: transparent;\n        user-select: none;\n    }\n\n    .p-datatable-row-toggle-button:enabled:hover {\n        color: dt('datatable.row.toggle.button.hover.color');\n        background: dt('datatable.row.toggle.button.hover.background');\n    }\n\n    .p-datatable-tbody > tr.p-datatable-row-selected .p-datatable-row-toggle-button:hover {\n        background: dt('datatable.row.toggle.button.selected.hover.background');\n        color: dt('datatable.row.toggle.button.selected.hover.color');\n    }\n\n    .p-datatable-row-toggle-button:focus-visible {\n        box-shadow: dt('datatable.row.toggle.button.focus.ring.shadow');\n        outline: dt('datatable.row.toggle.button.focus.ring.width') dt('datatable.row.toggle.button.focus.ring.style') dt('datatable.row.toggle.button.focus.ring.color');\n        outline-offset: dt('datatable.row.toggle.button.focus.ring.offset');\n    }\n\n    .p-datatable-row-toggle-icon:dir(rtl) {\n        transform: rotate(180deg);\n    }\n",
        classes: {
            root: function(e) {
                var t = e.props;
                return ["p-datatable p-component", {
                    "p-datatable-hoverable": t.rowHover || t.selectionMode,
                    "p-datatable-resizable": t.resizableColumns,
                    "p-datatable-resizable-fit": t.resizableColumns && "fit" === t.columnResizeMode,
                    "p-datatable-scrollable": t.scrollable,
                    "p-datatable-flex-scrollable": t.scrollable && "flex" === t.scrollHeight,
                    "p-datatable-striped": t.stripedRows,
                    "p-datatable-gridlines": t.showGridlines,
                    "p-datatable-sm": "small" === t.size,
                    "p-datatable-lg": "large" === t.size
                }]
            },
            mask: "p-datatable-mask p-overlay-mask",
            loadingIcon: "p-datatable-loading-icon",
            header: "p-datatable-header",
            pcPaginator: function(e) {
                return "p-datatable-paginator-" + e.position
            },
            tableContainer: "p-datatable-table-container",
            table: function(e) {
                var t = e.props;
                return ["p-datatable-table", {
                    "p-datatable-scrollable-table": t.scrollable,
                    "p-datatable-resizable-table": t.resizableColumns,
                    "p-datatable-resizable-table-fit": t.resizableColumns && "fit" === t.columnResizeMode
                }]
            },
            thead: "p-datatable-thead",
            headerCell: function(e) {
                var t = e.instance,
                    n = e.props,
                    r = e.column;
                return !r || t.columnProp("hidden") || "subheader" === n.rowGroupMode && n.groupRowsBy === t.columnProp(r, "field") ? ["p-datatable-header-cell", {
                    "p-datatable-sortable-column": t.columnProp("sortable"),
                    "p-datatable-resizable-column": t.resizableColumns,
                    "p-datatable-column-sorted": t.isColumnSorted(),
                    "p-datatable-frozen-column": t.columnProp("frozen"),
                    "p-datatable-reorderable-column": n.reorderableColumns
                }] : ["p-datatable-header-cell", {
                    "p-datatable-frozen-column": t.columnProp("frozen")
                }]
            },
            columnResizer: "p-datatable-column-resizer",
            columnHeaderContent: "p-datatable-column-header-content",
            columnTitle: "p-datatable-column-title",
            columnFooter: "p-datatable-column-footer",
            sortIcon: "p-datatable-sort-icon",
            pcSortBadge: "p-datatable-sort-badge",
            filter: function(e) {
                var t = e.props;
                return ["p-datatable-filter", {
                    "p-datatable-inline-filter": "row" === t.display,
                    "p-datatable-popover-filter": "menu" === t.display
                }]
            },
            filterElementContainer: "p-datatable-filter-element-container",
            pcColumnFilterButton: "p-datatable-column-filter-button",
            pcColumnFilterClearButton: "p-datatable-column-filter-clear-button",
            filterOverlay: function(e) {
                return ["p-datatable-filter-overlay p-component", {
                    "p-datatable-filter-overlay-popover": "menu" === e.props.display
                }]
            },
            filterConstraintList: "p-datatable-filter-constraint-list",
            filterConstraint: function(e) {
                var t = e.instance,
                    n = e.matchMode;
                return ["p-datatable-filter-constraint", {
                    "p-datatable-filter-constraint-selected": n && t.isRowMatchModeSelected(n.value)
                }]
            },
            filterConstraintSeparator: "p-datatable-filter-constraint-separator",
            filterOperator: "p-datatable-filter-operator",
            pcFilterOperatorDropdown: "p-datatable-filter-operator-dropdown",
            filterRuleList: "p-datatable-filter-rule-list",
            filterRule: "p-datatable-filter-rule",
            pcFilterConstraintDropdown: "p-datatable-filter-constraint-dropdown",
            pcFilterRemoveRuleButton: "p-datatable-filter-remove-rule-button",
            pcFilterAddRuleButton: "p-datatable-filter-add-rule-button",
            filterButtonbar: "p-datatable-filter-buttonbar",
            pcFilterClearButton: "p-datatable-filter-clear-button",
            pcFilterApplyButton: "p-datatable-filter-apply-button",
            tbody: function(e) {
                return e.props.frozenRow ? "p-datatable-tbody p-datatable-frozen-tbody" : "p-datatable-tbody"
            },
            rowGroupHeader: "p-datatable-row-group-header",
            rowToggleButton: "p-datatable-row-toggle-button",
            rowToggleIcon: "p-datatable-row-toggle-icon",
            row: function(e) {
                var t = e.instance,
                    n = e.props,
                    r = e.index,
                    o = e.columnSelectionMode,
                    i = [];
                return n.selectionMode && i.push("p-datatable-selectable-row"), n.selection && i.push({
                    "p-datatable-row-selected": o ? t.isSelected && t.$parentInstance.$parentInstance.highlightOnSelect : t.isSelected
                }), n.contextMenuSelection && i.push({
                    "p-datatable-contextmenu-row-selected": t.isSelectedWithContextMenu
                }), i.push(r % 2 == 0 ? "p-row-even" : "p-row-odd"), i
            },
            rowExpansion: "p-datatable-row-expansion",
            rowGroupFooter: "p-datatable-row-group-footer",
            emptyMessage: "p-datatable-empty-message",
            bodyCell: function(e) {
                return [{
                    "p-datatable-frozen-column": e.instance.columnProp("frozen")
                }]
            },
            reorderableRowHandle: "p-datatable-reorderable-row-handle",
            pcRowEditorInit: "p-datatable-row-editor-init",
            pcRowEditorSave: "p-datatable-row-editor-save",
            pcRowEditorCancel: "p-datatable-row-editor-cancel",
            tfoot: "p-datatable-tfoot",
            footerCell: function(e) {
                return [{
                    "p-datatable-frozen-column": e.instance.columnProp("frozen")
                }]
            },
            virtualScrollerSpacer: "p-datatable-virtualscroller-spacer",
            footer: "p-datatable-footer",
            columnResizeIndicator: "p-datatable-column-resize-indicator",
            rowReorderIndicatorUp: "p-datatable-row-reorder-indicator-up",
            rowReorderIndicatorDown: "p-datatable-row-reorder-indicator-down"
        },
        inlineStyles: {
            tableContainer: {
                overflow: "auto"
            },
            thead: {
                position: "sticky"
            },
            tfoot: {
                position: "sticky"
            }
        }
    }),
    rk = {
        name: "BarsIcon",
        extends: AT
    };
function ok(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
rk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return ok(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M13.3226 3.6129H0.677419C0.497757 3.6129 0.325452 3.54152 0.198411 3.41448C0.0713707 3.28744 0 3.11514 0 2.93548C0 2.75581 0.0713707 2.58351 0.198411 2.45647C0.325452 2.32943 0.497757 2.25806 0.677419 2.25806H13.3226C13.5022 2.25806 13.6745 2.32943 13.8016 2.45647C13.9286 2.58351 14 2.75581 14 2.93548C14 3.11514 13.9286 3.28744 13.8016 3.41448C13.6745 3.54152 13.5022 3.6129 13.3226 3.6129ZM13.3226 7.67741H0.677419C0.497757 7.67741 0.325452 7.60604 0.198411 7.479C0.0713707 7.35196 0 7.17965 0 6.99999C0 6.82033 0.0713707 6.64802 0.198411 6.52098C0.325452 6.39394 0.497757 6.32257 0.677419 6.32257H13.3226C13.5022 6.32257 13.6745 6.39394 13.8016 6.52098C13.9286 6.64802 14 6.82033 14 6.99999C14 7.17965 13.9286 7.35196 13.8016 7.479C13.6745 7.60604 13.5022 7.67741 13.3226 7.67741ZM0.677419 11.7419H13.3226C13.5022 11.7419 13.6745 11.6706 13.8016 11.5435C13.9286 11.4165 14 11.2442 14 11.0645C14 10.8848 13.9286 10.7125 13.8016 10.5855C13.6745 10.4585 13.5022 10.3871 13.3226 10.3871H0.677419C0.497757 10.3871 0.325452 10.4585 0.198411 10.5855C0.0713707 10.7125 0 10.8848 0 11.0645C0 11.2442 0.0713707 11.4165 0.198411 11.5435C0.325452 11.6706 0.497757 11.7419 0.677419 11.7419Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return ok(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ok(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var ik = {
    name: "PencilIcon",
    extends: AT
};
function ak(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
ik.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return ak(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M0.609628 13.959C0.530658 13.9599 0.452305 13.9451 0.379077 13.9156C0.305849 13.8861 0.239191 13.8424 0.18294 13.787C0.118447 13.7234 0.0688234 13.6464 0.0376166 13.5614C0.00640987 13.4765 -0.00560954 13.3857 0.00241768 13.2956L0.25679 10.1501C0.267698 10.0041 0.331934 9.86709 0.437312 9.76516L9.51265 0.705715C10.0183 0.233014 10.6911 -0.0203041 11.3835 0.00127367C12.0714 0.00660201 12.7315 0.27311 13.2298 0.746671C13.7076 1.23651 13.9824 1.88848 13.9992 2.57201C14.0159 3.25554 13.7733 3.92015 13.32 4.4327L4.23648 13.5331C4.13482 13.6342 4.0017 13.6978 3.85903 13.7133L0.667067 14L0.609628 13.959ZM1.43018 10.4696L1.25787 12.714L3.50619 12.5092L12.4502 3.56444C12.6246 3.35841 12.7361 3.10674 12.7714 2.83933C12.8067 2.57193 12.7644 2.30002 12.6495 2.05591C12.5346 1.8118 12.3519 1.60575 12.1231 1.46224C11.8943 1.31873 11.6291 1.2438 11.3589 1.24633C11.1813 1.23508 11.0033 1.25975 10.8355 1.31887C10.6677 1.37798 10.5136 1.47033 10.3824 1.59036L1.43018 10.4696Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return ak(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ak(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var sk = kI.extend({
    name: "radiobutton",
    style: "\n    .p-radiobutton {\n        position: relative;\n        display: inline-flex;\n        user-select: none;\n        vertical-align: bottom;\n        width: dt('radiobutton.width');\n        height: dt('radiobutton.height');\n    }\n\n    .p-radiobutton-input {\n        cursor: pointer;\n        appearance: none;\n        position: absolute;\n        top: 0;\n        inset-inline-start: 0;\n        width: 100%;\n        height: 100%;\n        padding: 0;\n        margin: 0;\n        opacity: 0;\n        z-index: 1;\n        outline: 0 none;\n        border: 1px solid transparent;\n        border-radius: 50%;\n    }\n\n    .p-radiobutton-box {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        border-radius: 50%;\n        border: 1px solid dt('radiobutton.border.color');\n        background: dt('radiobutton.background');\n        width: dt('radiobutton.width');\n        height: dt('radiobutton.height');\n        transition:\n            background dt('radiobutton.transition.duration'),\n            color dt('radiobutton.transition.duration'),\n            border-color dt('radiobutton.transition.duration'),\n            box-shadow dt('radiobutton.transition.duration'),\n            outline-color dt('radiobutton.transition.duration');\n        outline-color: transparent;\n        box-shadow: dt('radiobutton.shadow');\n    }\n\n    .p-radiobutton-icon {\n        transition-duration: dt('radiobutton.transition.duration');\n        background: transparent;\n        font-size: dt('radiobutton.icon.size');\n        width: dt('radiobutton.icon.size');\n        height: dt('radiobutton.icon.size');\n        border-radius: 50%;\n        backface-visibility: hidden;\n        transform: translateZ(0) scale(0.1);\n    }\n\n    .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {\n        border-color: dt('radiobutton.hover.border.color');\n    }\n\n    .p-radiobutton-checked .p-radiobutton-box {\n        border-color: dt('radiobutton.checked.border.color');\n        background: dt('radiobutton.checked.background');\n    }\n\n    .p-radiobutton-checked .p-radiobutton-box .p-radiobutton-icon {\n        background: dt('radiobutton.icon.checked.color');\n        transform: translateZ(0) scale(1, 1);\n        visibility: visible;\n    }\n\n    .p-radiobutton-checked:not(.p-disabled):has(.p-radiobutton-input:hover) .p-radiobutton-box {\n        border-color: dt('radiobutton.checked.hover.border.color');\n        background: dt('radiobutton.checked.hover.background');\n    }\n\n    .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:hover).p-radiobutton-checked .p-radiobutton-box .p-radiobutton-icon {\n        background: dt('radiobutton.icon.checked.hover.color');\n    }\n\n    .p-radiobutton:not(.p-disabled):has(.p-radiobutton-input:focus-visible) .p-radiobutton-box {\n        border-color: dt('radiobutton.focus.border.color');\n        box-shadow: dt('radiobutton.focus.ring.shadow');\n        outline: dt('radiobutton.focus.ring.width') dt('radiobutton.focus.ring.style') dt('radiobutton.focus.ring.color');\n        outline-offset: dt('radiobutton.focus.ring.offset');\n    }\n\n    .p-radiobutton-checked:not(.p-disabled):has(.p-radiobutton-input:focus-visible) .p-radiobutton-box {\n        border-color: dt('radiobutton.checked.focus.border.color');\n    }\n\n    .p-radiobutton.p-invalid > .p-radiobutton-box {\n        border-color: dt('radiobutton.invalid.border.color');\n    }\n\n    .p-radiobutton.p-variant-filled .p-radiobutton-box {\n        background: dt('radiobutton.filled.background');\n    }\n\n    .p-radiobutton.p-variant-filled.p-radiobutton-checked .p-radiobutton-box {\n        background: dt('radiobutton.checked.background');\n    }\n\n    .p-radiobutton.p-variant-filled:not(.p-disabled):has(.p-radiobutton-input:hover).p-radiobutton-checked .p-radiobutton-box {\n        background: dt('radiobutton.checked.hover.background');\n    }\n\n    .p-radiobutton.p-disabled {\n        opacity: 1;\n    }\n\n    .p-radiobutton.p-disabled .p-radiobutton-box {\n        background: dt('radiobutton.disabled.background');\n        border-color: dt('radiobutton.checked.disabled.border.color');\n    }\n\n    .p-radiobutton-checked.p-disabled .p-radiobutton-box .p-radiobutton-icon {\n        background: dt('radiobutton.icon.disabled.color');\n    }\n\n    .p-radiobutton-sm,\n    .p-radiobutton-sm .p-radiobutton-box {\n        width: dt('radiobutton.sm.width');\n        height: dt('radiobutton.sm.height');\n    }\n\n    .p-radiobutton-sm .p-radiobutton-icon {\n        font-size: dt('radiobutton.icon.sm.size');\n        width: dt('radiobutton.icon.sm.size');\n        height: dt('radiobutton.icon.sm.size');\n    }\n\n    .p-radiobutton-lg,\n    .p-radiobutton-lg .p-radiobutton-box {\n        width: dt('radiobutton.lg.width');\n        height: dt('radiobutton.lg.height');\n    }\n\n    .p-radiobutton-lg .p-radiobutton-icon {\n        font-size: dt('radiobutton.icon.lg.size');\n        width: dt('radiobutton.icon.lg.size');\n        height: dt('radiobutton.icon.lg.size');\n    }\n",
    classes: {
        root: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-radiobutton p-component", {
                "p-radiobutton-checked": t.checked,
                "p-disabled": n.disabled,
                "p-invalid": t.$pcRadioButtonGroup ? t.$pcRadioButtonGroup.$invalid : t.$invalid,
                "p-variant-filled": "filled" === t.$variant,
                "p-radiobutton-sm p-inputfield-sm": "small" === n.size,
                "p-radiobutton-lg p-inputfield-lg": "large" === n.size
            }]
        },
        box: "p-radiobutton-box",
        input: "p-radiobutton-input",
        icon: "p-radiobutton-icon"
    }
});
function lk(e) {
    return (lk = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
var ck = {
        name: "RadioButton",
        extends: {
            name: "BaseRadioButton",
            extends: oM,
            props: {
                value: null,
                binary: Boolean,
                readonly: {
                    type: Boolean,
                    default: !1
                },
                tabindex: {
                    type: Number,
                    default: null
                },
                inputId: {
                    type: String,
                    default: null
                },
                inputClass: {
                    type: [String, Object],
                    default: null
                },
                inputStyle: {
                    type: Object,
                    default: null
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                ariaLabel: {
                    type: String,
                    default: null
                }
            },
            style: sk,
            provide: function() {
                return {
                    $pcRadioButton: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change", "focus", "blur"],
        inject: {
            $pcRadioButtonGroup: {
                default: void 0
            }
        },
        methods: {
            getPTOptions: function(e) {
                return ("root" === e ? this.ptmi : this.ptm)(e, {
                    context: {
                        checked: this.checked,
                        disabled: this.disabled
                    }
                })
            },
            onChange: function(e) {
                if (!this.disabled && !this.readonly) {
                    var t = this.binary ? !this.checked : this.value;
                    this.$pcRadioButtonGroup ? this.$pcRadioButtonGroup.writeValue(t, e) : this.writeValue(t, e),
                    this.$emit("change", e)
                }
            },
            onFocus: function(e) {
                this.$emit("focus", e)
            },
            onBlur: function(e) {
                var t,
                    n;
                this.$emit("blur", e),
                null === (t = (n = this.formField).onBlur) || void 0 === t || t.call(n, e)
            }
        },
        computed: {
            groupName: function() {
                return this.$pcRadioButtonGroup ? this.$pcRadioButtonGroup.groupName : this.$formName
            },
            checked: function() {
                var e = this.$pcRadioButtonGroup ? this.$pcRadioButtonGroup.d_value : this.d_value;
                return null != e && (this.binary ? !!e : cS(e, this.value))
            },
            dataP: function() {
                return RS((e = {
                    invalid: this.$invalid,
                    checked: this.checked,
                    disabled: this.disabled,
                    filled: "filled" === this.$variant
                }, t = this.size, n = this.size, (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != lk(e) || !e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t);
                            if ("object" != lk(r))
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(e)
                    }(e, "string");
                    return "symbol" == lk(t) ? t : t + ""
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e));
                var e,
                    t,
                    n
            }
        }
    },
    uk = ["data-p-checked", "data-p-disabled", "data-p"],
    dk = ["id", "value", "name", "checked", "tabindex", "disabled", "readonly", "aria-labelledby", "aria-label", "aria-invalid"],
    pk = ["data-p"],
    hk = ["data-p"];
ck.render = function(e, t, n, r, o, i) {
    return uo(), go("div", Mo({
        class: e.cx("root")
    }, i.getPTOptions("root"), {
        "data-p-checked": i.checked,
        "data-p-disabled": e.disabled,
        "data-p": i.dataP
    }), [_o("input", Mo({
        id: e.inputId,
        type: "radio",
        class: [e.cx("input"), e.inputClass],
        style: e.inputStyle,
        value: e.value,
        name: i.groupName,
        checked: i.checked,
        tabindex: e.tabindex,
        disabled: e.disabled,
        readonly: e.readonly,
        "aria-labelledby": e.ariaLabelledby,
        "aria-label": e.ariaLabel,
        "aria-invalid": e.invalid || void 0,
        onFocus: t[0] || (t[0] = function() {
            return i.onFocus && i.onFocus.apply(i, arguments)
        }),
        onBlur: t[1] || (t[1] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        }),
        onChange: t[2] || (t[2] = function() {
            return i.onChange && i.onChange.apply(i, arguments)
        })
    }, i.getPTOptions("input")), null, 16, dk), _o("div", Mo({
        class: e.cx("box")
    }, i.getPTOptions("box"), {
        "data-p": i.dataP
    }), [_o("div", Mo({
        class: e.cx("icon")
    }, i.getPTOptions("icon"), {
        "data-p": i.dataP
    }), null, 16, hk)], 16, pk)], 16, uk)
};
var fk = {
    name: "FilterIcon",
    extends: AT
};
function gk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
fk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return gk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M8.64708 14H5.35296C5.18981 13.9979 5.03395 13.9321 4.91858 13.8167C4.8032 13.7014 4.73745 13.5455 4.73531 13.3824V7L0.329431 0.98C0.259794 0.889466 0.217389 0.780968 0.20718 0.667208C0.19697 0.553448 0.219379 0.439133 0.271783 0.337647C0.324282 0.236453 0.403423 0.151519 0.500663 0.0920138C0.597903 0.0325088 0.709548 0.000692754 0.823548 0H13.1765C13.2905 0.000692754 13.4021 0.0325088 13.4994 0.0920138C13.5966 0.151519 13.6758 0.236453 13.7283 0.337647C13.7807 0.439133 13.8031 0.553448 13.7929 0.667208C13.7826 0.780968 13.7402 0.889466 13.6706 0.98L9.26472 7V13.3824C9.26259 13.5455 9.19683 13.7014 9.08146 13.8167C8.96609 13.9321 8.81022 13.9979 8.64708 14ZM5.97061 12.7647H8.02943V6.79412C8.02878 6.66289 8.07229 6.53527 8.15296 6.43177L11.9412 1.23529H2.05884L5.86355 6.43177C5.94422 6.53527 5.98773 6.66289 5.98708 6.79412L5.97061 12.7647Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return gk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? gk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var mk = {
    name: "FilterFillIcon",
    extends: AT
};
function bk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
mk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return bk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M13.7274 0.33847C13.6228 0.130941 13.4095 0 13.1764 0H0.82351C0.590451 0 0.377157 0.130941 0.272568 0.33847C0.167157 0.545999 0.187746 0.795529 0.325275 0.98247L4.73527 6.99588V13.3824C4.73527 13.7233 5.01198 14 5.35292 14H8.64704C8.98798 14 9.26469 13.7233 9.26469 13.3824V6.99588L13.6747 0.98247C13.8122 0.795529 13.8328 0.545999 13.7274 0.33847Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return bk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? bk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var Ak = {
    name: "FilterSlashIcon",
    extends: AT
};
function yk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
Ak.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return yk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M13.4994 0.0920138C13.5967 0.151519 13.6758 0.236453 13.7283 0.337647C13.7807 0.439133 13.8031 0.553448 13.7929 0.667208C13.7827 0.780968 13.7403 0.889466 13.6707 0.98L11.406 4.06823C11.3099 4.19928 11.1656 4.28679 11.005 4.3115C10.8444 4.33621 10.6805 4.2961 10.5495 4.2C10.4184 4.1039 10.3309 3.95967 10.3062 3.79905C10.2815 3.63843 10.3216 3.47458 10.4177 3.34353L11.9412 1.23529H7.41184C7.24803 1.23529 7.09093 1.17022 6.97509 1.05439C6.85926 0.938558 6.79419 0.781457 6.79419 0.617647C6.79419 0.453837 6.85926 0.296736 6.97509 0.180905C7.09093 0.0650733 7.24803 0 7.41184 0H13.1765C13.2905 0.000692754 13.4022 0.0325088 13.4994 0.0920138ZM4.20008 0.181168H4.24126L13.2013 9.03411C13.3169 9.14992 13.3819 9.3069 13.3819 9.47058C13.3819 9.63426 13.3169 9.79124 13.2013 9.90705C13.1445 9.96517 13.0766 10.0112 13.0016 10.0423C12.9266 10.0735 12.846 10.0891 12.7648 10.0882C12.6836 10.0886 12.6032 10.0728 12.5283 10.0417C12.4533 10.0106 12.3853 9.96479 12.3283 9.90705L9.3142 6.92587L9.26479 6.99999V13.3823C9.26265 13.5455 9.19689 13.7014 9.08152 13.8167C8.96615 13.9321 8.81029 13.9979 8.64714 14H5.35302C5.18987 13.9979 5.03401 13.9321 4.91864 13.8167C4.80327 13.7014 4.73751 13.5455 4.73537 13.3823V6.99999L0.329492 1.02117C0.259855 0.930634 0.21745 0.822137 0.207241 0.708376C0.197031 0.594616 0.21944 0.480301 0.271844 0.378815C0.324343 0.277621 0.403484 0.192687 0.500724 0.133182C0.597964 0.073677 0.709609 0.041861 0.823609 0.0411682H3.86243C3.92448 0.0461551 3.9855 0.060022 4.04361 0.0823446C4.10037 0.10735 4.15311 0.140655 4.20008 0.181168ZM8.02949 6.79411C8.02884 6.66289 8.07235 6.53526 8.15302 6.43176L8.42478 6.05293L3.55773 1.23529H2.0589L5.84714 6.43176C5.92781 6.53526 5.97132 6.66289 5.97067 6.79411V12.7647H8.02949V6.79411Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return yk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var vk = {
    name: "TrashIcon",
    extends: AT
};
function _k(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
vk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return _k(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M3.44802 13.9955H10.552C10.8056 14.0129 11.06 13.9797 11.3006 13.898C11.5412 13.8163 11.7632 13.6877 11.9537 13.5196C12.1442 13.3515 12.2995 13.1473 12.4104 12.9188C12.5213 12.6903 12.5858 12.442 12.6 12.1884V4.36041H13.4C13.5591 4.36041 13.7117 4.29722 13.8243 4.18476C13.9368 4.07229 14 3.91976 14 3.76071C14 3.60166 13.9368 3.44912 13.8243 3.33666C13.7117 3.22419 13.5591 3.16101 13.4 3.16101H12.0537C12.0203 3.1557 11.9863 3.15299 11.952 3.15299C11.9178 3.15299 11.8838 3.1557 11.8503 3.16101H11.2285C11.2421 3.10893 11.2487 3.05513 11.248 3.00106V1.80966C11.2171 1.30262 10.9871 0.828306 10.608 0.48989C10.229 0.151475 9.73159 -0.0236625 9.22402 0.00257442H4.77602C4.27251 -0.0171866 3.78126 0.160868 3.40746 0.498617C3.03365 0.836366 2.807 1.30697 2.77602 1.80966V3.00106C2.77602 3.0556 2.78346 3.10936 2.79776 3.16101H0.6C0.521207 3.16101 0.443185 3.17652 0.37039 3.20666C0.297595 3.2368 0.231451 3.28097 0.175736 3.33666C0.120021 3.39235 0.0758251 3.45846 0.0456722 3.53121C0.0155194 3.60397 0 3.68196 0 3.76071C0 3.83946 0.0155194 3.91744 0.0456722 3.9902C0.0758251 4.06296 0.120021 4.12907 0.175736 4.18476C0.231451 4.24045 0.297595 4.28462 0.37039 4.31476C0.443185 4.3449 0.521207 4.36041 0.6 4.36041H1.40002V12.1884C1.41426 12.442 1.47871 12.6903 1.58965 12.9188C1.7006 13.1473 1.85582 13.3515 2.04633 13.5196C2.23683 13.6877 2.45882 13.8163 2.69944 13.898C2.94005 13.9797 3.1945 14.0129 3.44802 13.9955ZM2.60002 4.36041H11.304V12.1884C11.304 12.5163 10.952 12.7961 10.504 12.7961H3.40002C2.97602 12.7961 2.60002 12.5163 2.60002 12.1884V4.36041ZM3.95429 3.16101C3.96859 3.10936 3.97602 3.0556 3.97602 3.00106V1.80966C3.97602 1.48183 4.33602 1.20197 4.77602 1.20197H9.24802C9.66403 1.20197 10.048 1.48183 10.048 1.80966V3.00106C10.0473 3.05515 10.054 3.10896 10.0678 3.16101H3.95429ZM5.57571 10.997C5.41731 10.995 5.26597 10.9311 5.15395 10.8191C5.04193 10.7071 4.97808 10.5558 4.97601 10.3973V6.77517C4.97601 6.61612 5.0392 6.46359 5.15166 6.35112C5.26413 6.23866 5.41666 6.17548 5.57571 6.17548C5.73476 6.17548 5.8873 6.23866 5.99976 6.35112C6.11223 6.46359 6.17541 6.61612 6.17541 6.77517V10.3894C6.17647 10.4688 6.16174 10.5476 6.13208 10.6213C6.10241 10.695 6.05841 10.762 6.00261 10.8186C5.94682 10.8751 5.88035 10.92 5.80707 10.9506C5.73378 10.9813 5.65514 10.9971 5.57571 10.997ZM7.99968 10.8214C8.11215 10.9339 8.26468 10.997 8.42373 10.997C8.58351 10.9949 8.73604 10.93 8.84828 10.8163C8.96052 10.7025 9.02345 10.5491 9.02343 10.3894V6.77517C9.02343 6.61612 8.96025 6.46359 8.84778 6.35112C8.73532 6.23866 8.58278 6.17548 8.42373 6.17548C8.26468 6.17548 8.11215 6.23866 7.99968 6.35112C7.88722 6.46359 7.82404 6.61612 7.82404 6.77517V10.3973C7.82404 10.5564 7.88722 10.7089 7.99968 10.8214Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return _k(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _k(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var xk = kI.extend({
    name: "focustrap-directive"
});
function wk(e) {
    return (wk = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function Ck(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function Ek(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? Ck(Object(n), !0).forEach(function(t) {
            Sk(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ck(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function Sk(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != wk(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != wk(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == wk(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var Ik = zI.extend({
        style: xk
    }).extend("focustrap", {
        mounted: function(e, t) {
            (t.value || {}).disabled || (this.createHiddenFocusableElements(e, t), this.bind(e, t), this.autoElementFocus(e, t)),
            e.setAttribute("data-pd-focustrap", !0),
            this.$el = e
        },
        updated: function(e, t) {
            (t.value || {}).disabled && this.unbind(e)
        },
        unmounted: function(e) {
            this.unbind(e)
        },
        methods: {
            getComputedSelector: function(e) {
                return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(null != e ? e : "")
            },
            bind: function(e, t) {
                var n = this,
                    r = t.value || {},
                    o = r.onFocusIn,
                    i = r.onFocusOut;
                e.$_pfocustrap_mutationobserver = new MutationObserver(function(t) {
                    t.forEach(function(t) {
                        if ("childList" === t.type && !e.contains(document.activeElement)) {
                            var r = function(t) {
                                var o = KE(t) ? KE(t, n.getComputedSelector(e.$_pfocustrap_focusableselector)) ? t : DE(e, n.getComputedSelector(e.$_pfocustrap_focusableselector)) : DE(t);
                                return sS(o) ? o : t.nextSibling && r(t.nextSibling)
                            };
                            RE(r(t.nextSibling))
                        }
                    })
                }),
                e.$_pfocustrap_mutationobserver.disconnect(),
                e.$_pfocustrap_mutationobserver.observe(e, {
                    childList: !0
                }),
                e.$_pfocustrap_focusinlistener = function(e) {
                    return o && o(e)
                },
                e.$_pfocustrap_focusoutlistener = function(e) {
                    return i && i(e)
                },
                e.addEventListener("focusin", e.$_pfocustrap_focusinlistener),
                e.addEventListener("focusout", e.$_pfocustrap_focusoutlistener)
            },
            unbind: function(e) {
                e.$_pfocustrap_mutationobserver && e.$_pfocustrap_mutationobserver.disconnect(),
                e.$_pfocustrap_focusinlistener && e.removeEventListener("focusin", e.$_pfocustrap_focusinlistener) && (e.$_pfocustrap_focusinlistener = null),
                e.$_pfocustrap_focusoutlistener && e.removeEventListener("focusout", e.$_pfocustrap_focusoutlistener) && (e.$_pfocustrap_focusoutlistener = null)
            },
            autoFocus: function(e) {
                this.autoElementFocus(this.$el, {
                    value: Ek(Ek({}, e), {}, {
                        autoFocus: !0
                    })
                })
            },
            autoElementFocus: function(e, t) {
                var n = t.value || {},
                    r = n.autoFocusSelector,
                    o = void 0 === r ? "" : r,
                    i = n.firstFocusableSelector,
                    a = void 0 === i ? "" : i,
                    s = n.autoFocus,
                    l = void 0 !== s && s,
                    c = DE(e, "[autofocus]".concat(this.getComputedSelector(o)));
                l && !c && (c = DE(e, this.getComputedSelector(a))),
                RE(c)
            },
            onFirstHiddenElementFocus: function(e) {
                var t,
                    n = e.currentTarget,
                    r = e.relatedTarget;
                RE(r !== n.$_pfocustrap_lasthiddenfocusableelement && null !== (t = this.$el) && void 0 !== t && t.contains(r) ? n.$_pfocustrap_lasthiddenfocusableelement : DE(n.parentElement, this.getComputedSelector(n.$_pfocustrap_focusableselector)))
            },
            onLastHiddenElementFocus: function(e) {
                var t,
                    n = e.currentTarget,
                    r = e.relatedTarget;
                RE(r !== n.$_pfocustrap_firsthiddenfocusableelement && null !== (t = this.$el) && void 0 !== t && t.contains(r) ? n.$_pfocustrap_firsthiddenfocusableelement : LE(n.parentElement, this.getComputedSelector(n.$_pfocustrap_focusableselector)))
            },
            createHiddenFocusableElements: function(e, t) {
                var n = this,
                    r = t.value || {},
                    o = r.tabIndex,
                    i = void 0 === o ? 0 : o,
                    a = r.firstFocusableSelector,
                    s = void 0 === a ? "" : a,
                    l = r.lastFocusableSelector,
                    c = void 0 === l ? "" : l,
                    u = function(e) {
                        return IE("span", {
                            class: "p-hidden-accessible p-hidden-focusable",
                            tabIndex: i,
                            role: "presentation",
                            "aria-hidden": !0,
                            "data-p-hidden-accessible": !0,
                            "data-p-hidden-focusable": !0,
                            onFocus: null == e ? void 0 : e.bind(n)
                        })
                    },
                    d = u(this.onFirstHiddenElementFocus),
                    p = u(this.onLastHiddenElementFocus);
                d.$_pfocustrap_lasthiddenfocusableelement = p,
                d.$_pfocustrap_focusableselector = s,
                d.setAttribute("data-pc-section", "firstfocusableelement"),
                p.$_pfocustrap_firsthiddenfocusableelement = d,
                p.$_pfocustrap_focusableselector = c,
                p.setAttribute("data-pc-section", "lastfocusableelement"),
                e.prepend(d),
                e.append(p)
            }
        }
    }),
    Tk = {
        name: "SortAltIcon",
        extends: AT
    };
function Mk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
Tk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return Mk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M5.64515 3.61291C5.47353 3.61291 5.30192 3.54968 5.16644 3.4142L3.38708 1.63484L1.60773 3.4142C1.34579 3.67613 0.912244 3.67613 0.650309 3.4142C0.388374 3.15226 0.388374 2.71871 0.650309 2.45678L2.90837 0.198712C3.17031 -0.0632236 3.60386 -0.0632236 3.86579 0.198712L6.12386 2.45678C6.38579 2.71871 6.38579 3.15226 6.12386 3.4142C5.98837 3.54968 5.81676 3.61291 5.64515 3.61291Z",
        fill: "currentColor"
    }, null, -1), _o("path", {
        d: "M3.38714 14C3.01681 14 2.70972 13.6929 2.70972 13.3226V0.677419C2.70972 0.307097 3.01681 0 3.38714 0C3.75746 0 4.06456 0.307097 4.06456 0.677419V13.3226C4.06456 13.6929 3.75746 14 3.38714 14Z",
        fill: "currentColor"
    }, null, -1), _o("path", {
        d: "M10.6129 14C10.4413 14 10.2697 13.9368 10.1342 13.8013L7.87611 11.5432C7.61418 11.2813 7.61418 10.8477 7.87611 10.5858C8.13805 10.3239 8.5716 10.3239 8.83353 10.5858L10.6129 12.3652L12.3922 10.5858C12.6542 10.3239 13.0877 10.3239 13.3497 10.5858C13.6116 10.8477 13.6116 11.2813 13.3497 11.5432L11.0916 13.8013C10.9561 13.9368 10.7845 14 10.6129 14Z",
        fill: "currentColor"
    }, null, -1), _o("path", {
        d: "M10.6129 14C10.2426 14 9.93552 13.6929 9.93552 13.3226V0.677419C9.93552 0.307097 10.2426 0 10.6129 0C10.9833 0 11.2904 0.307097 11.2904 0.677419V13.3226C11.2904 13.6929 10.9832 14 10.6129 14Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return Mk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Mk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var Rk = {
    name: "SortAmountDownIcon",
    extends: AT
};
function Bk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
Rk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return Bk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M4.93953 10.5858L3.83759 11.6877V0.677419C3.83759 0.307097 3.53049 0 3.16017 0C2.78985 0 2.48275 0.307097 2.48275 0.677419V11.6877L1.38082 10.5858C1.11888 10.3239 0.685331 10.3239 0.423396 10.5858C0.16146 10.8477 0.16146 11.2813 0.423396 11.5432L2.68146 13.8013C2.74469 13.8645 2.81694 13.9097 2.89823 13.9458C2.97952 13.9819 3.06985 14 3.16017 14C3.25049 14 3.33178 13.9819 3.42211 13.9458C3.5034 13.9097 3.57565 13.8645 3.63888 13.8013L5.89694 11.5432C6.15888 11.2813 6.15888 10.8477 5.89694 10.5858C5.63501 10.3239 5.20146 10.3239 4.93953 10.5858ZM13.0957 0H7.22468C6.85436 0 6.54726 0.307097 6.54726 0.677419C6.54726 1.04774 6.85436 1.35484 7.22468 1.35484H13.0957C13.466 1.35484 13.7731 1.04774 13.7731 0.677419C13.7731 0.307097 13.466 0 13.0957 0ZM7.22468 5.41935H9.48275C9.85307 5.41935 10.1602 5.72645 10.1602 6.09677C10.1602 6.4671 9.85307 6.77419 9.48275 6.77419H7.22468C6.85436 6.77419 6.54726 6.4671 6.54726 6.09677C6.54726 5.72645 6.85436 5.41935 7.22468 5.41935ZM7.6763 8.12903H7.22468C6.85436 8.12903 6.54726 8.43613 6.54726 8.80645C6.54726 9.17677 6.85436 9.48387 7.22468 9.48387H7.6763C8.04662 9.48387 8.35372 9.17677 8.35372 8.80645C8.35372 8.43613 8.04662 8.12903 7.6763 8.12903ZM7.22468 2.70968H11.2892C11.6595 2.70968 11.9666 3.01677 11.9666 3.3871C11.9666 3.75742 11.6595 4.06452 11.2892 4.06452H7.22468C6.85436 4.06452 6.54726 3.75742 6.54726 3.3871C6.54726 3.01677 6.85436 2.70968 7.22468 2.70968Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return Bk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Bk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var kk = {
    name: "SortAmountUpAltIcon",
    extends: AT
};
function Dk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
kk.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return Dk(e)
    }(a = t[0] || (t[0] = [_o("path", {
        d: "M3.63435 0.19871C3.57113 0.135484 3.49887 0.0903226 3.41758 0.0541935C3.255 -0.0180645 3.06532 -0.0180645 2.90274 0.0541935C2.82145 0.0903226 2.74919 0.135484 2.68597 0.19871L0.427901 2.45677C0.165965 2.71871 0.165965 3.15226 0.427901 3.41419C0.689836 3.67613 1.12338 3.67613 1.38532 3.41419L2.48726 2.31226V13.3226C2.48726 13.6929 2.79435 14 3.16467 14C3.535 14 3.84209 13.6929 3.84209 13.3226V2.31226L4.94403 3.41419C5.07951 3.54968 5.25113 3.6129 5.42274 3.6129C5.59435 3.6129 5.76597 3.54968 5.90145 3.41419C6.16338 3.15226 6.16338 2.71871 5.90145 2.45677L3.64338 0.19871H3.63435ZM13.7685 13.3226C13.7685 12.9523 13.4615 12.6452 13.0911 12.6452H7.22016C6.84984 12.6452 6.54274 12.9523 6.54274 13.3226C6.54274 13.6929 6.84984 14 7.22016 14H13.0911C13.4615 14 13.7685 13.6929 13.7685 13.3226ZM7.22016 8.58064C6.84984 8.58064 6.54274 8.27355 6.54274 7.90323C6.54274 7.5329 6.84984 7.22581 7.22016 7.22581H9.47823C9.84855 7.22581 10.1556 7.5329 10.1556 7.90323C10.1556 8.27355 9.84855 8.58064 9.47823 8.58064H7.22016ZM7.22016 5.87097H7.67177C8.0421 5.87097 8.34919 5.56387 8.34919 5.19355C8.34919 4.82323 8.0421 4.51613 7.67177 4.51613H7.22016C6.84984 4.51613 6.54274 4.82323 6.54274 5.19355C6.54274 5.56387 6.84984 5.87097 7.22016 5.87097ZM11.2847 11.2903H7.22016C6.84984 11.2903 6.54274 10.9832 6.54274 10.6129C6.54274 10.2426 6.84984 9.93548 7.22016 9.93548H11.2847C11.655 9.93548 11.9621 10.2426 11.9621 10.6129C11.9621 10.9832 11.655 11.2903 11.2847 11.2903Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return Dk(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Dk(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var Pk = {
        name: "BaseDataTable",
        extends: nT,
        props: {
            value: {
                type: Array,
                default: null
            },
            dataKey: {
                type: [String, Function],
                default: null
            },
            rows: {
                type: Number,
                default: 0
            },
            first: {
                type: Number,
                default: 0
            },
            totalRecords: {
                type: Number,
                default: 0
            },
            paginator: {
                type: Boolean,
                default: !1
            },
            paginatorPosition: {
                type: String,
                default: "bottom"
            },
            alwaysShowPaginator: {
                type: Boolean,
                default: !0
            },
            paginatorTemplate: {
                type: [Object, String],
                default: "FirstPageLink PrevPageLink PageLinks NextPageLink LastPageLink RowsPerPageDropdown"
            },
            pageLinkSize: {
                type: Number,
                default: 5
            },
            rowsPerPageOptions: {
                type: Array,
                default: null
            },
            currentPageReportTemplate: {
                type: String,
                default: "({currentPage} of {totalPages})"
            },
            lazy: {
                type: Boolean,
                default: !1
            },
            loading: {
                type: Boolean,
                default: !1
            },
            loadingIcon: {
                type: String,
                default: void 0
            },
            sortField: {
                type: [String, Function],
                default: null
            },
            sortOrder: {
                type: Number,
                default: null
            },
            defaultSortOrder: {
                type: Number,
                default: 1
            },
            nullSortOrder: {
                type: Number,
                default: 1
            },
            multiSortMeta: {
                type: Array,
                default: null
            },
            sortMode: {
                type: String,
                default: "single"
            },
            removableSort: {
                type: Boolean,
                default: !1
            },
            filters: {
                type: Object,
                default: null
            },
            filterDisplay: {
                type: String,
                default: null
            },
            globalFilterFields: {
                type: Array,
                default: null
            },
            filterLocale: {
                type: String,
                default: void 0
            },
            selection: {
                type: [Array, Object],
                default: null
            },
            selectionMode: {
                type: String,
                default: null
            },
            compareSelectionBy: {
                type: String,
                default: "deepEquals"
            },
            metaKeySelection: {
                type: Boolean,
                default: !1
            },
            contextMenu: {
                type: Boolean,
                default: !1
            },
            contextMenuSelection: {
                type: Object,
                default: null
            },
            selectAll: {
                type: Boolean,
                default: null
            },
            rowHover: {
                type: Boolean,
                default: !1
            },
            csvSeparator: {
                type: String,
                default: ","
            },
            exportFilename: {
                type: String,
                default: "download"
            },
            exportFunction: {
                type: Function,
                default: null
            },
            resizableColumns: {
                type: Boolean,
                default: !1
            },
            columnResizeMode: {
                type: String,
                default: "fit"
            },
            reorderableColumns: {
                type: Boolean,
                default: !1
            },
            expandedRows: {
                type: [Array, Object],
                default: null
            },
            expandedRowIcon: {
                type: String,
                default: void 0
            },
            collapsedRowIcon: {
                type: String,
                default: void 0
            },
            rowGroupMode: {
                type: String,
                default: null
            },
            groupRowsBy: {
                type: [Array, String, Function],
                default: null
            },
            expandableRowGroups: {
                type: Boolean,
                default: !1
            },
            expandedRowGroups: {
                type: Array,
                default: null
            },
            stateStorage: {
                type: String,
                default: "session"
            },
            stateKey: {
                type: String,
                default: null
            },
            editMode: {
                type: String,
                default: null
            },
            editingRows: {
                type: Array,
                default: null
            },
            rowClass: {
                type: Function,
                default: null
            },
            rowStyle: {
                type: Function,
                default: null
            },
            scrollable: {
                type: Boolean,
                default: !1
            },
            virtualScrollerOptions: {
                type: Object,
                default: null
            },
            scrollHeight: {
                type: String,
                default: null
            },
            frozenValue: {
                type: Array,
                default: null
            },
            breakpoint: {
                type: String,
                default: "960px"
            },
            showHeaders: {
                type: Boolean,
                default: !0
            },
            showGridlines: {
                type: Boolean,
                default: !1
            },
            stripedRows: {
                type: Boolean,
                default: !1
            },
            highlightOnSelect: {
                type: Boolean,
                default: !1
            },
            size: {
                type: String,
                default: null
            },
            tableStyle: {
                type: null,
                default: null
            },
            tableClass: {
                type: [String, Object],
                default: null
            },
            tableProps: {
                type: Object,
                default: null
            },
            filterInputProps: {
                type: null,
                default: null
            },
            filterButtonProps: {
                type: Object,
                default: function() {
                    return {
                        filter: {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        },
                        inline: {
                            clear: {
                                severity: "secondary",
                                text: !0,
                                rounded: !0
                            }
                        },
                        popover: {
                            addRule: {
                                severity: "info",
                                text: !0,
                                size: "small"
                            },
                            removeRule: {
                                severity: "danger",
                                text: !0,
                                size: "small"
                            },
                            apply: {
                                size: "small"
                            },
                            clear: {
                                outlined: !0,
                                size: "small"
                            }
                        }
                    }
                }
            },
            editButtonProps: {
                type: Object,
                default: function() {
                    return {
                        init: {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        },
                        save: {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        },
                        cancel: {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        }
                    }
                }
            }
        },
        style: nk,
        provide: function() {
            return {
                $pcDataTable: this,
                $parentInstance: this
            }
        }
    },
    Ok = {
        name: "RowCheckbox",
        hostName: "DataTable",
        extends: nT,
        emits: ["change"],
        props: {
            value: null,
            checked: null,
            column: null,
            rowCheckboxIconTemplate: {
                type: Function,
                default: null
            },
            index: {
                type: Number,
                default: null
            }
        },
        methods: {
            getColumnPT: function(e) {
                var t = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index,
                        checked: this.checked,
                        disabled: this.$attrs.disabled
                    }
                };
                return Mo(this.ptm("column.".concat(e), {
                    column: t
                }), this.ptm("column.".concat(e), t), this.ptmo(this.getColumnProp(), e, t))
            },
            getColumnProp: function() {
                return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
            },
            onChange: function(e) {
                this.$attrs.disabled || this.$emit("change", {
                    originalEvent: e,
                    data: this.value
                })
            }
        },
        computed: {
            checkboxAriaLabel: function() {
                return this.$primevue.config.locale.aria ? this.checked ? this.$primevue.config.locale.aria.selectRow : this.$primevue.config.locale.aria.unselectRow : void 0
            }
        },
        components: {
            CheckIcon: KT,
            Checkbox: IR
        },
        render: function(e, t, n, r, o, i) {
            var a = jn("CheckIcon"),
                s = jn("Checkbox");
            return uo(), mo(s, {
                modelValue: n.checked,
                binary: !0,
                disabled: e.$attrs.disabled,
                "aria-label": i.checkboxAriaLabel,
                onChange: i.onChange,
                unstyled: e.unstyled,
                pt: i.getColumnPT("pcRowCheckbox")
            }, {
                icon: Vt(function(e) {
                    return [n.rowCheckboxIconTemplate ? (uo(), mo(Hn(n.rowCheckboxIconTemplate), {
                        key: 0,
                        checked: e.checked,
                        class: G(e.class)
                    }, null, 8, ["checked", "class"])) : !n.rowCheckboxIconTemplate && e.checked ? (uo(), mo(a, Mo({
                        key: 1,
                        class: e.class
                    }, i.getColumnPT("pcRowCheckbox.icon")), null, 16, ["class"])) : Eo("", !0)]
                }),
                _: 1
            }, 8, ["modelValue", "disabled", "aria-label", "onChange", "unstyled", "pt"])
        }
    },
    Lk = {
        name: "RowRadioButton",
        hostName: "DataTable",
        extends: nT,
        emits: ["change"],
        props: {
            value: null,
            checked: null,
            name: null,
            column: null,
            index: {
                type: Number,
                default: null
            }
        },
        methods: {
            getColumnPT: function(e) {
                var t = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index,
                        checked: this.checked,
                        disabled: this.$attrs.disabled
                    }
                };
                return Mo(this.ptm("column.".concat(e), {
                    column: t
                }), this.ptm("column.".concat(e), t), this.ptmo(this.getColumnProp(), e, t))
            },
            getColumnProp: function() {
                return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
            },
            onChange: function(e) {
                this.$attrs.disabled || this.$emit("change", {
                    originalEvent: e,
                    data: this.value
                })
            }
        },
        components: {
            RadioButton: ck
        }
    };
function Nk() {
    var e,
        t,
        n = "function" == typeof Symbol ? Symbol : {},
        r = n.iterator || "@@iterator",
        o = n.toStringTag || "@@toStringTag";
    function i(n, r, o, i) {
        var l = r && r.prototype instanceof s ? r : s,
            c = Object.create(l.prototype);
        return Fk(c, "_invoke", function(n, r, o) {
            var i,
                s,
                l,
                c = 0,
                u = o || [],
                d = !1,
                p = {
                    p: 0,
                    n: 0,
                    v: e,
                    a: h,
                    f: h.bind(e, 4),
                    d: function(t, n) {
                        return i = t, s = 0, l = e, p.n = n, a
                    }
                };
            function h(n, r) {
                for (s = n, l = r, t = 0; !d && c && !o && t < u.length; t++) {
                    var o,
                        i = u[t],
                        h = p.p,
                        f = i[2];
                    n > 3 ? (o = f === r) && (l = i[(s = i[4]) ? 5 : (s = 3, 3)], i[4] = i[5] = e) : i[0] <= h && ((o = n < 2 && h < i[1]) ? (s = 0, p.v = r, p.n = i[1]) : h < f && (o = n < 3 || i[0] > r || r > f) && (i[4] = n, i[5] = r, p.n = f, s = 0))
                }
                if (o || n > 1)
                    return a;
                throw d = !0, r
            }
            return function(o, u, f) {
                if (c > 1)
                    throw TypeError("Generator is already running");
                for (d && 1 === u && h(u, f), s = u, l = f; (t = s < 2 ? e : l) || !d;) {
                    i || (s ? s < 3 ? (s > 1 && (p.n = -1), h(s, l)) : p.n = l : p.v = l);
                    try {
                        if (c = 2, i) {
                            if (s || (o = "next"), t = i[o]) {
                                if (!(t = t.call(i, l)))
                                    throw TypeError("iterator result is not an object");
                                if (!t.done)
                                    return t;
                                l = t.value,
                                s < 2 && (s = 0)
                            } else
                                1 === s && (t = i.return) && t.call(i),
                                s < 2 && (l = TypeError("The iterator does not provide a '" + o + "' method"), s = 1);
                            i = e
                        } else if ((t = (d = p.n < 0) ? l : n.call(r, p)) !== a)
                            break
                    } catch (g) {
                        i = e,
                        s = 1,
                        l = g
                    } finally {
                        c = 1
                    }
                }
                return {
                    value: t,
                    done: d
                }
            }
        }(n, o, i), !0), c
    }
    var a = {};
    function s() {}
    function l() {}
    function c() {}
    t = Object.getPrototypeOf;
    var u = [][r] ? t(t([][r]())) : (Fk(t = {}, r, function() {
            return this
        }), t),
        d = c.prototype = s.prototype = Object.create(u);
    function p(e) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e, c) : (e.__proto__ = c, Fk(e, o, "GeneratorFunction")), e.prototype = Object.create(d), e
    }
    return l.prototype = c, Fk(d, "constructor", c), Fk(c, "constructor", l), l.displayName = "GeneratorFunction", Fk(c, o, "GeneratorFunction"), Fk(d), Fk(d, o, "Generator"), Fk(d, r, function() {
        return this
    }), Fk(d, "toString", function() {
        return "[object Generator]"
    }), (Nk = function() {
        return {
            w: i,
            m: p
        }
    })()
}
function Fk(e, t, n, r) {
    var o = Object.defineProperty;
    try {
        o({}, "", {})
    } catch (i) {
        o = 0
    }
    (Fk = function(e, t, n, r) {
        function i(t, n) {
            Fk(e, t, function(e) {
                return this._invoke(t, n, e)
            })
        }
        t ? o ? o(e, t, {
            value: n,
            enumerable: !r,
            configurable: !r,
            writable: !r
        }) : e[t] = n : (i("next", 0), i("throw", 1), i("return", 2))
    })(e, t, n, r)
}
function Uk(e, t, n, r, o, i, a) {
    try {
        var s = e[i](a),
            l = s.value
    } catch (c) {
        return void n(c)
    }
    s.done ? t(l) : Promise.resolve(l).then(r, o)
}
function zk(e) {
    return function() {
        var t = this,
            n = arguments;
        return new Promise(function(r, o) {
            var i = e.apply(t, n);
            function a(e) {
                Uk(i, r, o, a, s, "next", e)
            }
            function s(e) {
                Uk(i, r, o, a, s, "throw", e)
            }
            a(void 0)
        })
    }
}
Lk.render = function(e, t, n, r, o, i) {
    var a = jn("RadioButton");
    return uo(), mo(a, {
        modelValue: n.checked,
        binary: !0,
        disabled: e.$attrs.disabled,
        name: n.name,
        onChange: i.onChange,
        unstyled: e.unstyled,
        pt: i.getColumnPT("pcRowRadiobutton")
    }, null, 8, ["modelValue", "disabled", "name", "onChange", "unstyled", "pt"])
};
var Qk = {
    name: "BodyCell",
    hostName: "DataTable",
    extends: nT,
    emits: ["cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "row-toggle", "radio-change", "checkbox-change", "editing-meta-change"],
    props: {
        rowData: {
            type: Object,
            default: null
        },
        column: {
            type: Object,
            default: null
        },
        frozenRow: {
            type: Boolean,
            default: !1
        },
        rowIndex: {
            type: Number,
            default: null
        },
        index: {
            type: Number,
            default: null
        },
        isRowExpanded: {
            type: Boolean,
            default: !1
        },
        selected: {
            type: Boolean,
            default: !1
        },
        editing: {
            type: Boolean,
            default: !1
        },
        editingMeta: {
            type: Object,
            default: null
        },
        editMode: {
            type: String,
            default: null
        },
        virtualScrollerContentProps: {
            type: Object,
            default: null
        },
        ariaControls: {
            type: String,
            default: null
        },
        name: {
            type: String,
            default: null
        },
        expandedRowIcon: {
            type: String,
            default: null
        },
        collapsedRowIcon: {
            type: String,
            default: null
        },
        editButtonProps: {
            type: Object,
            default: null
        }
    },
    documentEditListener: null,
    selfClick: !1,
    overlayEventListener: null,
    editCompleteTimeout: null,
    data: function() {
        return {
            d_editing: this.editing,
            styleObject: {}
        }
    },
    watch: {
        editing: function(e) {
            this.d_editing = e
        },
        "$data.d_editing": function(e) {
            this.$emit("editing-meta-change", {
                data: this.rowData,
                field: this.field || "field_".concat(this.index),
                index: this.rowIndex,
                editing: e
            })
        }
    },
    mounted: function() {
        this.columnProp("frozen") && this.updateStickyPosition()
    },
    updated: function() {
        var e = this;
        this.columnProp("frozen") && this.updateStickyPosition(),
        this.d_editing && ("cell" === this.editMode || "row" === this.editMode && this.columnProp("rowEditor")) && setTimeout(function() {
            var t = DE(e.$el);
            t && t.focus()
        }, 1)
    },
    beforeUnmount: function() {
        this.overlayEventListener && (lM.off("overlay-click", this.overlayEventListener), this.overlayEventListener = null)
    },
    methods: {
        columnProp: function(e) {
            return zS(this.column, e)
        },
        getColumnPT: function(e) {
            var t,
                n,
                r = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index,
                        size: null === (t = this.$parentInstance) || void 0 === t || null === (t = t.$parentInstance) || void 0 === t ? void 0 : t.size,
                        showGridlines: null === (n = this.$parentInstance) || void 0 === n || null === (n = n.$parentInstance) || void 0 === n ? void 0 : n.showGridlines
                    }
                };
            return Mo(this.ptm("column.".concat(e), {
                column: r
            }), this.ptm("column.".concat(e), r), this.ptmo(this.getColumnProp(), e, r))
        },
        getColumnProp: function() {
            return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
        },
        resolveFieldData: function() {
            return lS(this.rowData, this.field)
        },
        toggleRow: function(e) {
            this.$emit("row-toggle", {
                originalEvent: e,
                data: this.rowData
            })
        },
        toggleRowWithRadio: function(e, t) {
            this.$emit("radio-change", {
                originalEvent: e.originalEvent,
                index: t,
                data: e.data
            })
        },
        toggleRowWithCheckbox: function(e, t) {
            this.$emit("checkbox-change", {
                originalEvent: e.originalEvent,
                index: t,
                data: e.data
            })
        },
        isEditable: function() {
            return this.column.children && null != this.column.children.editor
        },
        bindDocumentEditListener: function() {
            var e = this;
            this.documentEditListener || (this.documentEditListener = function(t) {
                e.selfClick = e.$el && e.$el.contains(t.target),
                e.editCompleteTimeout && clearTimeout(e.editCompleteTimeout),
                e.selfClick || (e.editCompleteTimeout = setTimeout(function() {
                    e.completeEdit(t, "outside")
                }, 1))
            }, document.addEventListener("mousedown", this.documentEditListener))
        },
        unbindDocumentEditListener: function() {
            this.documentEditListener && (document.removeEventListener("mousedown", this.documentEditListener), this.documentEditListener = null, this.selfClick = !1, this.editCompleteTimeout && (clearTimeout(this.editCompleteTimeout), this.editCompleteTimeout = null))
        },
        switchCellToViewMode: function() {
            this.d_editing = !1,
            this.unbindDocumentEditListener(),
            lM.off("overlay-click", this.overlayEventListener),
            this.overlayEventListener = null
        },
        onClick: function(e) {
            var t = this;
            "cell" === this.editMode && this.isEditable() && (this.d_editing || (this.d_editing = !0, this.bindDocumentEditListener(), this.$emit("cell-edit-init", {
                originalEvent: e,
                data: this.rowData,
                field: this.field,
                index: this.rowIndex
            }), this.overlayEventListener = function(e) {
                t.selfClick = t.$el && t.$el.contains(e.target)
            }, lM.on("overlay-click", this.overlayEventListener)))
        },
        completeEdit: function(e, t) {
            var n = {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                value: this.rowData[this.field],
                newValue: this.editingRowData[this.field],
                field: this.field,
                index: this.rowIndex,
                type: t,
                defaultPrevented: !1,
                preventDefault: function() {
                    this.defaultPrevented = !0
                }
            };
            this.$emit("cell-edit-complete", n),
            n.defaultPrevented || this.switchCellToViewMode()
        },
        onKeyDown: function(e) {
            if ("cell" === this.editMode)
                switch (e.code) {
                case "Enter":
                case "NumpadEnter":
                    this.completeEdit(e, "enter");
                    break;
                case "Escape":
                    this.switchCellToViewMode(),
                    this.$emit("cell-edit-cancel", {
                        originalEvent: e,
                        data: this.rowData,
                        field: this.field,
                        index: this.rowIndex
                    });
                    break;
                case "Tab":
                    this.completeEdit(e, "tab"),
                    e.shiftKey ? this.moveToPreviousCell(e) : this.moveToNextCell(e)
                }
        },
        moveToPreviousCell: function(e) {
            var t = this;
            return zk(Nk().m(function n() {
                var r,
                    o;
                return Nk().w(function(n) {
                    for (;;)
                        switch (n.n) {
                        case 0:
                            if (r = t.findCell(e.target), !(o = t.findPreviousEditableColumn(r))) {
                                n.n = 2;
                                break
                            }
                            return n.n = 1, t.$nextTick();
                        case 1:
                            HE(o, "click"),
                            e.preventDefault();
                        case 2:
                            return n.a(2)
                        }
                }, n)
            }))()
        },
        moveToNextCell: function(e) {
            var t = this;
            return zk(Nk().m(function n() {
                var r,
                    o;
                return Nk().w(function(n) {
                    for (;;)
                        switch (n.n) {
                        case 0:
                            if (r = t.findCell(e.target), !(o = t.findNextEditableColumn(r))) {
                                n.n = 2;
                                break
                            }
                            return n.n = 1, t.$nextTick();
                        case 1:
                            HE(o, "click"),
                            e.preventDefault();
                        case 2:
                            return n.a(2)
                        }
                }, n)
            }))()
        },
        findCell: function(e) {
            if (e) {
                for (var t = e; t && !BE(t, "data-p-cell-editing");)
                    t = t.parentElement;
                return t
            }
            return null
        },
        findPreviousEditableColumn: function(e) {
            var t = e.previousElementSibling;
            if (!t) {
                var n = e.parentElement.previousElementSibling;
                n && (t = n.lastElementChild)
            }
            return t ? BE(t, "data-p-editable-column") ? t : this.findPreviousEditableColumn(t) : null
        },
        findNextEditableColumn: function(e) {
            var t = e.nextElementSibling;
            if (!t) {
                var n = e.parentElement.nextElementSibling;
                n && (t = n.firstElementChild)
            }
            return t ? BE(t, "data-p-editable-column") ? t : this.findNextEditableColumn(t) : null
        },
        onRowEditInit: function(e) {
            this.$emit("row-edit-init", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            })
        },
        onRowEditSave: function(e) {
            this.$emit("row-edit-save", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            })
        },
        onRowEditCancel: function(e) {
            this.$emit("row-edit-cancel", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            })
        },
        editorInitCallback: function(e) {
            this.$emit("row-edit-init", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            })
        },
        editorSaveCallback: function(e) {
            "row" === this.editMode ? this.$emit("row-edit-save", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            }) : this.completeEdit(e, "enter")
        },
        editorCancelCallback: function(e) {
            "row" === this.editMode ? this.$emit("row-edit-cancel", {
                originalEvent: e,
                data: this.rowData,
                newData: this.editingRowData,
                field: this.field,
                index: this.rowIndex
            }) : (this.switchCellToViewMode(), this.$emit("cell-edit-cancel", {
                originalEvent: e,
                data: this.rowData,
                field: this.field,
                index: this.rowIndex
            }))
        },
        updateStickyPosition: function() {
            if (this.columnProp("frozen"))
                if ("right" === this.columnProp("alignFrozen")) {
                    var e = 0,
                        t = NE(this.$el, '[data-p-frozen-column="true"]');
                    t && (e = _E(t) + parseFloat(t.style["inset-inline-end"] || 0)),
                    this.styleObject.insetInlineEnd = e + "px"
                } else {
                    var n = 0,
                        r = QE(this.$el, '[data-p-frozen-column="true"]');
                    r && (n = _E(r) + parseFloat(r.style["inset-inline-start"] || 0)),
                    this.styleObject.insetInlineStart = n + "px"
                }
        },
        getVirtualScrollerProp: function(e) {
            return this.virtualScrollerContentProps ? this.virtualScrollerContentProps[e] : null
        }
    },
    computed: {
        editingRowData: function() {
            return this.editingMeta[this.rowIndex] ? this.editingMeta[this.rowIndex].data : this.rowData
        },
        field: function() {
            return this.columnProp("field")
        },
        containerClass: function() {
            return [this.columnProp("bodyClass"), this.columnProp("class"), this.cx("bodyCell")]
        },
        containerStyle: function() {
            var e = this.columnProp("bodyStyle"),
                t = this.columnProp("style");
            return this.columnProp("frozen") ? [t, e, this.styleObject] : [t, e]
        },
        loading: function() {
            return this.getVirtualScrollerProp("loading")
        },
        loadingOptions: function() {
            var e = this.getVirtualScrollerProp("getLoaderOptions");
            return e && e(this.rowIndex, {
                    cellIndex: this.index,
                    cellFirst: 0 === this.index,
                    cellLast: this.index === this.getVirtualScrollerProp("columns").length - 1,
                    cellEven: this.index % 2 == 0,
                    cellOdd: this.index % 2 != 0,
                    column: this.column,
                    field: this.field
                })
        },
        expandButtonAriaLabel: function() {
            return this.$primevue.config.locale.aria ? this.isRowExpanded ? this.$primevue.config.locale.aria.expandRow : this.$primevue.config.locale.aria.collapseRow : void 0
        },
        initButtonAriaLabel: function() {
            return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.editRow : void 0
        },
        saveButtonAriaLabel: function() {
            return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.saveEdit : void 0
        },
        cancelButtonAriaLabel: function() {
            return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.cancelEdit : void 0
        }
    },
    components: {
        DTRadioButton: Lk,
        DTCheckbox: Ok,
        Button: _R,
        ChevronDownIcon: XT,
        ChevronRightIcon: OM,
        BarsIcon: rk,
        PencilIcon: ik,
        CheckIcon: KT,
        TimesIcon: yT
    },
    directives: {
        ripple: ET
    }
};
function Gk(e) {
    return (Gk = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function jk(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function Vk(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? jk(Object(n), !0).forEach(function(t) {
            Hk(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jk(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function Hk(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != Gk(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != Gk(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == Gk(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var $k = ["colspan", "rowspan", "data-p-selection-column", "data-p-editable-column", "data-p-cell-editing", "data-p-frozen-column"],
    Wk = ["aria-expanded", "aria-controls", "aria-label"];
function Kk(e) {
    return (Kk = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function qk(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function Xk(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function Yk(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? Xk(Object(n), !0).forEach(function(t) {
            Jk(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xk(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function Jk(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != Kk(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != Kk(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == Kk(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
Qk.render = function(e, t, n, r, o, i) {
    var a = jn("DTRadioButton"),
        s = jn("DTCheckbox"),
        l = jn("BarsIcon"),
        c = jn("ChevronDownIcon"),
        u = jn("ChevronRightIcon"),
        d = jn("Button"),
        p = $n("ripple");
    return i.loading ? (uo(), go("td", Mo({
        key: 0,
        style: i.containerStyle,
        class: i.containerClass,
        role: "cell"
    }, Vk(Vk({}, i.getColumnPT("root")), i.getColumnPT("bodyCell"))), [(uo(), mo(Hn(n.column.children.loading), {
        data: n.rowData,
        column: n.column,
        field: i.field,
        index: n.rowIndex,
        frozenRow: n.frozenRow,
        loadingOptions: i.loadingOptions
    }, null, 8, ["data", "column", "field", "index", "frozenRow", "loadingOptions"]))], 16)) : (uo(), go("td", Mo({
        key: 1,
        style: i.containerStyle,
        class: i.containerClass,
        colspan: i.columnProp("colspan"),
        rowspan: i.columnProp("rowspan"),
        onClick: t[3] || (t[3] = function() {
            return i.onClick && i.onClick.apply(i, arguments)
        }),
        onKeydown: t[4] || (t[4] = function() {
            return i.onKeyDown && i.onKeyDown.apply(i, arguments)
        }),
        role: "cell"
    }, Vk(Vk({}, i.getColumnPT("root")), i.getColumnPT("bodyCell")), {
        "data-p-selection-column": null != i.columnProp("selectionMode"),
        "data-p-editable-column": i.isEditable(),
        "data-p-cell-editing": o.d_editing,
        "data-p-frozen-column": i.columnProp("frozen")
    }), [n.column.children && n.column.children.body && !o.d_editing ? (uo(), mo(Hn(n.column.children.body), {
        key: 0,
        data: n.rowData,
        column: n.column,
        field: i.field,
        index: n.rowIndex,
        frozenRow: n.frozenRow,
        editorInitCallback: i.editorInitCallback,
        rowTogglerCallback: i.toggleRow
    }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorInitCallback", "rowTogglerCallback"])) : n.column.children && n.column.children.editor && o.d_editing ? (uo(), mo(Hn(n.column.children.editor), {
        key: 1,
        data: i.editingRowData,
        column: n.column,
        field: i.field,
        index: n.rowIndex,
        frozenRow: n.frozenRow,
        editorSaveCallback: i.editorSaveCallback,
        editorCancelCallback: i.editorCancelCallback
    }, null, 8, ["data", "column", "field", "index", "frozenRow", "editorSaveCallback", "editorCancelCallback"])) : n.column.children && n.column.children.body && !n.column.children.editor && o.d_editing ? (uo(), mo(Hn(n.column.children.body), {
        key: 2,
        data: i.editingRowData,
        column: n.column,
        field: i.field,
        index: n.rowIndex,
        frozenRow: n.frozenRow
    }, null, 8, ["data", "column", "field", "index", "frozenRow"])) : i.columnProp("selectionMode") ? (uo(), go(oo, {
        key: 3
    }, ["single" === i.columnProp("selectionMode") ? (uo(), mo(a, {
        key: 0,
        value: n.rowData,
        name: n.name,
        checked: n.selected,
        onChange: t[0] || (t[0] = function(e) {
            return i.toggleRowWithRadio(e, n.rowIndex)
        }),
        column: n.column,
        index: n.index,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["value", "name", "checked", "column", "index", "unstyled", "pt"])) : "multiple" === i.columnProp("selectionMode") ? (uo(), mo(s, {
        key: 1,
        value: n.rowData,
        checked: n.selected,
        rowCheckboxIconTemplate: n.column.children && n.column.children.rowcheckboxicon,
        "aria-selected": !!n.selected || void 0,
        onChange: t[1] || (t[1] = function(e) {
            return i.toggleRowWithCheckbox(e, n.rowIndex)
        }),
        column: n.column,
        index: n.index,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["value", "checked", "rowCheckboxIconTemplate", "aria-selected", "column", "index", "unstyled", "pt"])) : Eo("", !0)], 64)) : i.columnProp("rowReorder") ? (uo(), go(oo, {
        key: 4
    }, [n.column.children && n.column.children.rowreordericon ? (uo(), mo(Hn(n.column.children.rowreordericon), Mo({
        key: 0,
        class: e.cx("reorderableRowHandle")
    }, i.getColumnPT("reorderableRowHandle")), null, 16, ["class"])) : i.columnProp("rowReorderIcon") ? (uo(), go("i", Mo({
        key: 1,
        class: [e.cx("reorderableRowHandle"), i.columnProp("rowReorderIcon")]
    }, i.getColumnPT("reorderableRowHandle")), null, 16)) : (uo(), mo(l, Mo({
        key: 2,
        class: e.cx("reorderableRowHandle")
    }, i.getColumnPT("reorderableRowHandle")), null, 16, ["class"]))], 64)) : i.columnProp("expander") ? Ht((uo(), go("button", Mo({
        key: 5,
        class: e.cx("rowToggleButton"),
        type: "button",
        "aria-expanded": n.isRowExpanded,
        "aria-controls": n.ariaControls,
        "aria-label": i.expandButtonAriaLabel,
        onClick: t[2] || (t[2] = Fi(function() {
            return i.toggleRow && i.toggleRow.apply(i, arguments)
        }, ["stop"])),
        "data-p-selected": "selected"
    }, i.getColumnPT("rowToggleButton"), {
        "data-pc-group-section": "rowactionbutton"
    }), [n.column.children && n.column.children.rowtoggleicon ? (uo(), mo(Hn(n.column.children.rowtoggleicon), {
        key: 0,
        class: G(e.cx("rowToggleIcon")),
        rowExpanded: n.isRowExpanded
    }, null, 8, ["class", "rowExpanded"])) : n.column.children && n.column.children.rowtogglericon ? (uo(), mo(Hn(n.column.children.rowtogglericon), {
        key: 1,
        class: G(e.cx("rowToggleIcon")),
        rowExpanded: n.isRowExpanded
    }, null, 8, ["class", "rowExpanded"])) : (uo(), go(oo, {
        key: 2
    }, [n.isRowExpanded && n.expandedRowIcon ? (uo(), go("span", {
        key: 0,
        class: G([e.cx("rowToggleIcon"), n.expandedRowIcon])
    }, null, 2)) : n.isRowExpanded && !n.expandedRowIcon ? (uo(), mo(c, Mo({
        key: 1,
        class: e.cx("rowToggleIcon")
    }, i.getColumnPT("rowToggleIcon")), null, 16, ["class"])) : !n.isRowExpanded && n.collapsedRowIcon ? (uo(), go("span", {
        key: 2,
        class: G([e.cx("rowToggleIcon"), n.collapsedRowIcon])
    }, null, 2)) : n.isRowExpanded || n.collapsedRowIcon ? Eo("", !0) : (uo(), mo(u, Mo({
        key: 3,
        class: e.cx("rowToggleIcon")
    }, i.getColumnPT("rowToggleIcon")), null, 16, ["class"]))], 64))], 16, Wk)), [[p]]) : "row" === n.editMode && i.columnProp("rowEditor") ? (uo(), go(oo, {
        key: 6
    }, [o.d_editing ? Eo("", !0) : (uo(), mo(d, Mo({
        key: 0,
        class: e.cx("pcRowEditorInit"),
        "aria-label": i.initButtonAriaLabel,
        unstyled: e.unstyled,
        onClick: i.onRowEditInit
    }, n.editButtonProps.init, {
        pt: i.getColumnPT("pcRowEditorInit"),
        "data-pc-group-section": "rowactionbutton"
    }), {
        icon: Vt(function(e) {
            return [(uo(), mo(Hn(n.column.children && n.column.children.roweditoriniticon || "PencilIcon"), Mo({
                class: e.class
            }, i.getColumnPT("pcRowEditorInit").icon), null, 16, ["class"]))]
        }),
        _: 1
    }, 16, ["class", "aria-label", "unstyled", "onClick", "pt"])), o.d_editing ? (uo(), mo(d, Mo({
        key: 1,
        class: e.cx("pcRowEditorSave"),
        "aria-label": i.saveButtonAriaLabel,
        unstyled: e.unstyled,
        onClick: i.onRowEditSave
    }, n.editButtonProps.save, {
        pt: i.getColumnPT("pcRowEditorSave"),
        "data-pc-group-section": "rowactionbutton"
    }), {
        icon: Vt(function(e) {
            return [(uo(), mo(Hn(n.column.children && n.column.children.roweditorsaveicon || "CheckIcon"), Mo({
                class: e.class
            }, i.getColumnPT("pcRowEditorSave").icon), null, 16, ["class"]))]
        }),
        _: 1
    }, 16, ["class", "aria-label", "unstyled", "onClick", "pt"])) : Eo("", !0), o.d_editing ? (uo(), mo(d, Mo({
        key: 2,
        class: e.cx("pcRowEditorCancel"),
        "aria-label": i.cancelButtonAriaLabel,
        unstyled: e.unstyled,
        onClick: i.onRowEditCancel
    }, n.editButtonProps.cancel, {
        pt: i.getColumnPT("pcRowEditorCancel"),
        "data-pc-group-section": "rowactionbutton"
    }), {
        icon: Vt(function(e) {
            return [(uo(), mo(Hn(n.column.children && n.column.children.roweditorcancelicon || "TimesIcon"), Mo({
                class: e.class
            }, i.getColumnPT("pcRowEditorCancel").icon), null, 16, ["class"]))]
        }),
        _: 1
    }, 16, ["class", "aria-label", "unstyled", "onClick", "pt"])) : Eo("", !0)], 64)) : (uo(), go(oo, {
        key: 7
    }, [Co(W(i.resolveFieldData()), 1)], 64))], 16, $k))
};
var Zk = {
    name: "BodyRow",
    hostName: "DataTable",
    extends: nT,
    emits: ["rowgroup-toggle", "row-click", "row-dblclick", "row-rightclick", "row-touchend", "row-keydown", "row-mousedown", "row-dragstart", "row-dragover", "row-dragleave", "row-dragend", "row-drop", "row-toggle", "radio-change", "checkbox-change", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "editing-meta-change"],
    props: {
        rowData: {
            type: Object,
            default: null
        },
        index: {
            type: Number,
            default: 0
        },
        value: {
            type: Array,
            default: null
        },
        columns: {
            type: null,
            default: null
        },
        frozenRow: {
            type: Boolean,
            default: !1
        },
        empty: {
            type: Boolean,
            default: !1
        },
        rowGroupMode: {
            type: String,
            default: null
        },
        groupRowsBy: {
            type: [Array, String, Function],
            default: null
        },
        expandableRowGroups: {
            type: Boolean,
            default: !1
        },
        expandedRowGroups: {
            type: Array,
            default: null
        },
        first: {
            type: Number,
            default: 0
        },
        dataKey: {
            type: [String, Function],
            default: null
        },
        expandedRowIcon: {
            type: String,
            default: null
        },
        collapsedRowIcon: {
            type: String,
            default: null
        },
        expandedRows: {
            type: [Array, Object],
            default: null
        },
        selection: {
            type: [Array, Object],
            default: null
        },
        selectionKeys: {
            type: null,
            default: null
        },
        selectionMode: {
            type: String,
            default: null
        },
        contextMenu: {
            type: Boolean,
            default: !1
        },
        contextMenuSelection: {
            type: Object,
            default: null
        },
        rowClass: {
            type: null,
            default: null
        },
        rowStyle: {
            type: null,
            default: null
        },
        rowGroupHeaderStyle: {
            type: null,
            default: null
        },
        editMode: {
            type: String,
            default: null
        },
        compareSelectionBy: {
            type: String,
            default: "deepEquals"
        },
        editingRows: {
            type: Array,
            default: null
        },
        editingRowKeys: {
            type: null,
            default: null
        },
        editingMeta: {
            type: Object,
            default: null
        },
        templates: {
            type: null,
            default: null
        },
        scrollable: {
            type: Boolean,
            default: !1
        },
        editButtonProps: {
            type: Object,
            default: null
        },
        virtualScrollerContentProps: {
            type: Object,
            default: null
        },
        isVirtualScrollerDisabled: {
            type: Boolean,
            default: !1
        },
        expandedRowId: {
            type: String,
            default: null
        },
        nameAttributeSelector: {
            type: String,
            default: null
        }
    },
    data: function() {
        return {
            d_rowExpanded: !1
        }
    },
    watch: {
        expandedRows: {
            deep: !0,
            immediate: !0,
            handler: function(e) {
                var t = this;
                this.d_rowExpanded = this.dataKey ? void 0 !== (null == e ? void 0 : e[lS(this.rowData, this.dataKey)]) : null == e ? void 0 : e.some(function(e) {
                    return t.equals(t.rowData, e)
                })
            }
        }
    },
    methods: {
        columnProp: function(e, t) {
            return zS(e, t)
        },
        getColumnPT: function(e) {
            var t = {
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                }
            };
            return Mo(this.ptm("column.".concat(e), {
                column: t
            }), this.ptm("column.".concat(e), t), this.ptmo(this.columnProp({}, "pt"), e, t))
        },
        getBodyRowPTOptions: function(e) {
            var t,
                n = null === (t = this.$parentInstance) || void 0 === t ? void 0 : t.$parentInstance;
            return this.ptm(e, {
                context: {
                    index: this.rowIndex,
                    selectable: (null == n ? void 0 : n.rowHover) || (null == n ? void 0 : n.selectionMode),
                    selected: this.isSelected,
                    stripedRows: (null == n ? void 0 : n.stripedRows) || !1
                }
            })
        },
        shouldRenderBodyCell: function(e) {
            var t = this.columnProp(e, "hidden");
            if (!this.rowGroupMode || t)
                return !t;
            var n = this.columnProp(e, "field");
            if ("subheader" === this.rowGroupMode)
                return this.groupRowsBy !== n;
            if ("rowspan" === this.rowGroupMode) {
                if (this.isGrouped(e)) {
                    var r = this.value[this.rowIndex - 1];
                    return !r || lS(this.value[this.rowIndex], n) !== lS(r, n)
                }
                return !0
            }
        },
        calculateRowGroupSize: function(e) {
            if (this.isGrouped(e)) {
                var t = this.rowIndex,
                    n = this.columnProp(e, "field"),
                    r = lS(this.value[t], n),
                    o = r,
                    i = 0;
                for (this.d_rowExpanded && i++; r === o;) {
                    i++;
                    var a = this.value[++t];
                    if (!a)
                        break;
                    o = lS(a, n)
                }
                return 1 === i ? null : i
            }
            return null
        },
        isGrouped: function(e) {
            var t = this.columnProp(e, "field");
            return !(!this.groupRowsBy || !t) && (Array.isArray(this.groupRowsBy) ? this.groupRowsBy.indexOf(t) > -1 : this.groupRowsBy === t)
        },
        findIndexInSelection: function(e) {
            return this.findIndex(e, this.selection)
        },
        findIndex: function(e, t) {
            var n = -1;
            if (t && t.length)
                for (var r = 0; r < t.length; r++)
                    if (this.equals(e, t[r])) {
                        n = r;
                        break
                    }
            return n
        },
        equals: function(e, t) {
            return "equals" === this.compareSelectionBy ? e === t : cS(e, t, this.dataKey)
        },
        onRowGroupToggle: function(e) {
            this.$emit("rowgroup-toggle", {
                originalEvent: e,
                data: this.rowData
            })
        },
        onRowClick: function(e) {
            this.$emit("row-click", {
                originalEvent: e,
                data: this.rowData,
                index: this.rowIndex
            })
        },
        onRowDblClick: function(e) {
            this.$emit("row-dblclick", {
                originalEvent: e,
                data: this.rowData,
                index: this.rowIndex
            })
        },
        onRowRightClick: function(e) {
            this.$emit("row-rightclick", {
                originalEvent: e,
                data: this.rowData,
                index: this.rowIndex
            })
        },
        onRowTouchEnd: function(e) {
            this.$emit("row-touchend", e)
        },
        onRowKeyDown: function(e) {
            this.$emit("row-keydown", {
                originalEvent: e,
                data: this.rowData,
                index: this.rowIndex
            })
        },
        onRowMouseDown: function(e) {
            this.$emit("row-mousedown", e)
        },
        onRowDragStart: function(e) {
            this.$emit("row-dragstart", {
                originalEvent: e,
                index: this.rowIndex
            })
        },
        onRowDragOver: function(e) {
            this.$emit("row-dragover", {
                originalEvent: e,
                index: this.rowIndex
            })
        },
        onRowDragLeave: function(e) {
            this.$emit("row-dragleave", e)
        },
        onRowDragEnd: function(e) {
            this.$emit("row-dragend", e)
        },
        onRowDrop: function(e) {
            this.$emit("row-drop", e)
        },
        onRowToggle: function(e) {
            this.d_rowExpanded = !this.d_rowExpanded,
            this.$emit("row-toggle", Yk(Yk({}, e), {}, {
                expanded: this.d_rowExpanded
            }))
        },
        onRadioChange: function(e) {
            this.$emit("radio-change", e)
        },
        onCheckboxChange: function(e) {
            this.$emit("checkbox-change", e)
        },
        onCellEditInit: function(e) {
            this.$emit("cell-edit-init", e)
        },
        onCellEditComplete: function(e) {
            this.$emit("cell-edit-complete", e)
        },
        onCellEditCancel: function(e) {
            this.$emit("cell-edit-cancel", e)
        },
        onRowEditInit: function(e) {
            this.$emit("row-edit-init", e)
        },
        onRowEditSave: function(e) {
            this.$emit("row-edit-save", e)
        },
        onRowEditCancel: function(e) {
            this.$emit("row-edit-cancel", e)
        },
        onEditingMetaChange: function(e) {
            this.$emit("editing-meta-change", e)
        },
        getVirtualScrollerProp: function(e, t) {
            return (t = t || this.virtualScrollerContentProps) ? t[e] : null
        }
    },
    computed: {
        rowIndex: function() {
            var e = this.getVirtualScrollerProp("getItemOptions");
            return e ? e(this.index).index : this.index
        },
        rowStyles: function() {
            var e;
            return null === (e = this.rowStyle) || void 0 === e ? void 0 : e.call(this, this.rowData)
        },
        rowClasses: function() {
            var e = [],
                t = null;
            if (this.rowClass) {
                var n = this.rowClass(this.rowData);
                n && e.push(n)
            }
            if (this.columns) {
                var r,
                    o = function(e, t) {
                        var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (!n) {
                            if (Array.isArray(e) || (n = function(e, t) {
                                if (e) {
                                    if ("string" == typeof e)
                                        return qk(e, t);
                                    var n = {}.toString.call(e).slice(8, -1);
                                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? qk(e, t) : void 0
                                }
                            }(e)) || t) {
                                n && (e = n);
                                var r = 0,
                                    o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return r >= e.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: e[r++]
                                        }
                                    },
                                    e: function(e) {
                                        throw e
                                    },
                                    f: o
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var i,
                            a = !0,
                            s = !1;
                        return {
                            s: function() {
                                n = n.call(e)
                            },
                            n: function() {
                                var e = n.next();
                                return a = e.done, e
                            },
                            e: function(e) {
                                s = !0,
                                i = e
                            },
                            f: function() {
                                try {
                                    a || null == n.return || n.return()
                                } finally {
                                    if (s)
                                        throw i
                                }
                            }
                        }
                    }(this.columns);
                try {
                    for (o.s(); !(r = o.n()).done;) {
                        var i = r.value,
                            a = this.columnProp(i, "selectionMode");
                        if (sS(a)) {
                            t = a;
                            break
                        }
                    }
                } catch (s) {
                    o.e(s)
                } finally {
                    o.f()
                }
            }
            return [this.cx("row", {
                rowData: this.rowData,
                index: this.rowIndex,
                columnSelectionMode: t
            }), e]
        },
        rowTabindex: function() {
            return null !== this.selection || "single" !== this.selectionMode && "multiple" !== this.selectionMode ? -1 : 0 === this.rowIndex ? 0 : -1
        },
        isRowEditing: function() {
            return !(!this.rowData || !this.editingRows) && (this.dataKey ? !!this.editingRowKeys && void 0 !== this.editingRowKeys[lS(this.rowData, this.dataKey)] : this.findIndex(this.rowData, this.editingRows) > -1)
        },
        isRowGroupExpanded: function() {
            if (this.expandableRowGroups && this.expandedRowGroups) {
                var e = lS(this.rowData, this.groupRowsBy);
                return this.expandedRowGroups.indexOf(e) > -1
            }
            return !1
        },
        isSelected: function() {
            return !(!this.rowData || !this.selection) && (this.dataKey ? !!this.selectionKeys && void 0 !== this.selectionKeys[lS(this.rowData, this.dataKey)] : this.selection instanceof Array ? this.findIndexInSelection(this.rowData) > -1 : this.equals(this.rowData, this.selection))
        },
        isSelectedWithContextMenu: function() {
            return !(!this.rowData || !this.contextMenuSelection) && this.equals(this.rowData, this.contextMenuSelection, this.dataKey)
        },
        shouldRenderRowGroupHeader: function() {
            var e = lS(this.rowData, this.groupRowsBy),
                t = this.value[this.rowIndex - 1];
            return !t || e !== lS(t, this.groupRowsBy)
        },
        shouldRenderRowGroupFooter: function() {
            if (this.expandableRowGroups && !this.isRowGroupExpanded)
                return !1;
            var e = lS(this.rowData, this.groupRowsBy),
                t = this.value[this.rowIndex + 1];
            return !t || e !== lS(t, this.groupRowsBy)
        },
        columnsLength: function() {
            var e = this;
            if (this.columns) {
                var t = 0;
                return this.columns.forEach(function(n) {
                    e.columnProp(n, "hidden") && t++
                }), this.columns.length - t
            }
            return 0
        }
    },
    components: {
        DTBodyCell: Qk,
        ChevronDownIcon: XT,
        ChevronRightIcon: OM
    }
};
function eD(e) {
    return (eD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function tD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function nD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? tD(Object(n), !0).forEach(function(t) {
            rD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function rD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != eD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != eD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == eD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var oD = ["colspan"],
    iD = ["tabindex", "aria-selected", "data-p-index", "data-p-selectable-row", "data-p-selected", "data-p-selected-contextmenu"],
    aD = ["id"],
    sD = ["colspan"],
    lD = ["colspan"],
    cD = ["colspan"];
Zk.render = function(e, t, n, r, o, i) {
    var a = jn("ChevronDownIcon"),
        s = jn("ChevronRightIcon"),
        l = jn("DTBodyCell");
    return n.empty ? (uo(), go("tr", Mo({
        key: 1,
        class: e.cx("emptyMessage"),
        role: "row"
    }, e.ptm("emptyMessage")), [_o("td", Mo({
        colspan: i.columnsLength
    }, nD(nD({}, i.getColumnPT("bodycell")), e.ptm("emptyMessageCell"))), [n.templates.empty ? (uo(), mo(Hn(n.templates.empty), {
        key: 0
    })) : Eo("", !0)], 16, cD)], 16)) : (uo(), go(oo, {
        key: 0
    }, [n.templates.groupheader && "subheader" === n.rowGroupMode && i.shouldRenderRowGroupHeader ? (uo(), go("tr", Mo({
        key: 0,
        class: e.cx("rowGroupHeader"),
        style: n.rowGroupHeaderStyle,
        role: "row"
    }, e.ptm("rowGroupHeader")), [_o("td", Mo({
        colspan: i.columnsLength - 1
    }, nD(nD({}, i.getColumnPT("bodycell")), e.ptm("rowGroupHeaderCell"))), [n.expandableRowGroups ? (uo(), go("button", Mo({
        key: 0,
        class: e.cx("rowToggleButton"),
        onClick: t[0] || (t[0] = function() {
            return i.onRowGroupToggle && i.onRowGroupToggle.apply(i, arguments)
        }),
        type: "button"
    }, e.ptm("rowToggleButton")), [n.templates.rowtoggleicon || n.templates.rowgrouptogglericon ? (uo(), mo(Hn(n.templates.rowtoggleicon || n.templates.rowgrouptogglericon), {
        key: 0,
        expanded: i.isRowGroupExpanded
    }, null, 8, ["expanded"])) : (uo(), go(oo, {
        key: 1
    }, [i.isRowGroupExpanded && n.expandedRowIcon ? (uo(), go("span", Mo({
        key: 0,
        class: [e.cx("rowToggleIcon"), n.expandedRowIcon]
    }, e.ptm("rowToggleIcon")), null, 16)) : i.isRowGroupExpanded && !n.expandedRowIcon ? (uo(), mo(a, Mo({
        key: 1,
        class: e.cx("rowToggleIcon")
    }, e.ptm("rowToggleIcon")), null, 16, ["class"])) : !i.isRowGroupExpanded && n.collapsedRowIcon ? (uo(), go("span", Mo({
        key: 2,
        class: [e.cx("rowToggleIcon"), n.collapsedRowIcon]
    }, e.ptm("rowToggleIcon")), null, 16)) : i.isRowGroupExpanded || n.collapsedRowIcon ? Eo("", !0) : (uo(), mo(s, Mo({
        key: 3,
        class: e.cx("rowToggleIcon")
    }, e.ptm("rowToggleIcon")), null, 16, ["class"]))], 64))], 16)) : Eo("", !0), (uo(), mo(Hn(n.templates.groupheader), {
        data: n.rowData,
        index: i.rowIndex
    }, null, 8, ["data", "index"]))], 16, oD)], 16)) : Eo("", !0), !n.expandableRowGroups || i.isRowGroupExpanded ? (uo(), go("tr", Mo({
        key: 1,
        class: i.rowClasses,
        style: i.rowStyles,
        tabindex: i.rowTabindex,
        role: "row",
        "aria-selected": n.selectionMode ? i.isSelected : null,
        onClick: t[1] || (t[1] = function() {
            return i.onRowClick && i.onRowClick.apply(i, arguments)
        }),
        onDblclick: t[2] || (t[2] = function() {
            return i.onRowDblClick && i.onRowDblClick.apply(i, arguments)
        }),
        onContextmenu: t[3] || (t[3] = function() {
            return i.onRowRightClick && i.onRowRightClick.apply(i, arguments)
        }),
        onTouchend: t[4] || (t[4] = function() {
            return i.onRowTouchEnd && i.onRowTouchEnd.apply(i, arguments)
        }),
        onKeydown: t[5] || (t[5] = Fi(function() {
            return i.onRowKeyDown && i.onRowKeyDown.apply(i, arguments)
        }, ["self"])),
        onMousedown: t[6] || (t[6] = function() {
            return i.onRowMouseDown && i.onRowMouseDown.apply(i, arguments)
        }),
        onDragstart: t[7] || (t[7] = function() {
            return i.onRowDragStart && i.onRowDragStart.apply(i, arguments)
        }),
        onDragover: t[8] || (t[8] = function() {
            return i.onRowDragOver && i.onRowDragOver.apply(i, arguments)
        }),
        onDragleave: t[9] || (t[9] = function() {
            return i.onRowDragLeave && i.onRowDragLeave.apply(i, arguments)
        }),
        onDragend: t[10] || (t[10] = function() {
            return i.onRowDragEnd && i.onRowDragEnd.apply(i, arguments)
        }),
        onDrop: t[11] || (t[11] = function() {
            return i.onRowDrop && i.onRowDrop.apply(i, arguments)
        })
    }, i.getBodyRowPTOptions("bodyRow"), {
        "data-p-index": i.rowIndex,
        "data-p-selectable-row": !!n.selectionMode,
        "data-p-selected": n.selection && i.isSelected,
        "data-p-selected-contextmenu": n.contextMenuSelection && i.isSelectedWithContextMenu
    }), [(uo(!0), go(oo, null, qn(n.columns, function(t, r) {
        return uo(), go(oo, null, [i.shouldRenderBodyCell(t) ? (uo(), mo(l, {
            key: i.columnProp(t, "columnKey") || i.columnProp(t, "field") || r,
            rowData: n.rowData,
            column: t,
            rowIndex: i.rowIndex,
            index: r,
            selected: i.isSelected,
            frozenRow: n.frozenRow,
            rowspan: "rowspan" === n.rowGroupMode ? i.calculateRowGroupSize(t) : null,
            editMode: n.editMode,
            editing: "row" === n.editMode && i.isRowEditing,
            editingMeta: n.editingMeta,
            virtualScrollerContentProps: n.virtualScrollerContentProps,
            ariaControls: n.expandedRowId + "_" + i.rowIndex + "_expansion",
            name: n.nameAttributeSelector,
            isRowExpanded: o.d_rowExpanded,
            expandedRowIcon: n.expandedRowIcon,
            collapsedRowIcon: n.collapsedRowIcon,
            editButtonProps: n.editButtonProps,
            onRadioChange: i.onRadioChange,
            onCheckboxChange: i.onCheckboxChange,
            onRowToggle: i.onRowToggle,
            onCellEditInit: i.onCellEditInit,
            onCellEditComplete: i.onCellEditComplete,
            onCellEditCancel: i.onCellEditCancel,
            onRowEditInit: i.onRowEditInit,
            onRowEditSave: i.onRowEditSave,
            onRowEditCancel: i.onRowEditCancel,
            onEditingMetaChange: i.onEditingMetaChange,
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["rowData", "column", "rowIndex", "index", "selected", "frozenRow", "rowspan", "editMode", "editing", "editingMeta", "virtualScrollerContentProps", "ariaControls", "name", "isRowExpanded", "expandedRowIcon", "collapsedRowIcon", "editButtonProps", "onRadioChange", "onCheckboxChange", "onRowToggle", "onCellEditInit", "onCellEditComplete", "onCellEditCancel", "onRowEditInit", "onRowEditSave", "onRowEditCancel", "onEditingMetaChange", "unstyled", "pt"])) : Eo("", !0)], 64)
    }), 256))], 16, iD)) : Eo("", !0), n.templates.expansion && n.expandedRows && o.d_rowExpanded ? (uo(), go("tr", Mo({
        key: 2,
        id: n.expandedRowId + "_" + i.rowIndex + "_expansion",
        class: e.cx("rowExpansion"),
        role: "row"
    }, e.ptm("rowExpansion")), [_o("td", Mo({
        colspan: i.columnsLength
    }, nD(nD({}, i.getColumnPT("bodycell")), e.ptm("rowExpansionCell"))), [(uo(), mo(Hn(n.templates.expansion), {
        data: n.rowData,
        index: i.rowIndex
    }, null, 8, ["data", "index"]))], 16, sD)], 16, aD)) : Eo("", !0), n.templates.groupfooter && "subheader" === n.rowGroupMode && i.shouldRenderRowGroupFooter ? (uo(), go("tr", Mo({
        key: 3,
        class: e.cx("rowGroupFooter"),
        role: "row"
    }, e.ptm("rowGroupFooter")), [_o("td", Mo({
        colspan: i.columnsLength - 1
    }, nD(nD({}, i.getColumnPT("bodycell")), e.ptm("rowGroupFooterCell"))), [(uo(), mo(Hn(n.templates.groupfooter), {
        data: n.rowData,
        index: i.rowIndex
    }, null, 8, ["data", "index"]))], 16, lD)], 16)) : Eo("", !0)], 64))
};
var uD = {
        name: "TableBody",
        hostName: "DataTable",
        extends: nT,
        emits: ["rowgroup-toggle", "row-click", "row-dblclick", "row-rightclick", "row-touchend", "row-keydown", "row-mousedown", "row-dragstart", "row-dragover", "row-dragleave", "row-dragend", "row-drop", "row-toggle", "radio-change", "checkbox-change", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "row-edit-init", "row-edit-save", "row-edit-cancel", "editing-meta-change"],
        props: {
            value: {
                type: Array,
                default: null
            },
            columns: {
                type: null,
                default: null
            },
            frozenRow: {
                type: Boolean,
                default: !1
            },
            empty: {
                type: Boolean,
                default: !1
            },
            rowGroupMode: {
                type: String,
                default: null
            },
            groupRowsBy: {
                type: [Array, String, Function],
                default: null
            },
            expandableRowGroups: {
                type: Boolean,
                default: !1
            },
            expandedRowGroups: {
                type: Array,
                default: null
            },
            first: {
                type: Number,
                default: 0
            },
            dataKey: {
                type: [String, Function],
                default: null
            },
            expandedRowIcon: {
                type: String,
                default: null
            },
            collapsedRowIcon: {
                type: String,
                default: null
            },
            expandedRows: {
                type: [Array, Object],
                default: null
            },
            selection: {
                type: [Array, Object],
                default: null
            },
            selectionKeys: {
                type: null,
                default: null
            },
            selectionMode: {
                type: String,
                default: null
            },
            rowHover: {
                type: Boolean,
                default: !1
            },
            contextMenu: {
                type: Boolean,
                default: !1
            },
            contextMenuSelection: {
                type: Object,
                default: null
            },
            rowClass: {
                type: null,
                default: null
            },
            rowStyle: {
                type: null,
                default: null
            },
            editMode: {
                type: String,
                default: null
            },
            compareSelectionBy: {
                type: String,
                default: "deepEquals"
            },
            editingRows: {
                type: Array,
                default: null
            },
            editingRowKeys: {
                type: null,
                default: null
            },
            editingMeta: {
                type: Object,
                default: null
            },
            templates: {
                type: null,
                default: null
            },
            scrollable: {
                type: Boolean,
                default: !1
            },
            editButtonProps: {
                type: Object,
                default: null
            },
            virtualScrollerContentProps: {
                type: Object,
                default: null
            },
            isVirtualScrollerDisabled: {
                type: Boolean,
                default: !1
            }
        },
        data: function() {
            return {
                rowGroupHeaderStyleObject: {}
            }
        },
        mounted: function() {
            this.frozenRow && this.updateFrozenRowStickyPosition(),
            this.scrollable && "subheader" === this.rowGroupMode && this.updateFrozenRowGroupHeaderStickyPosition()
        },
        updated: function() {
            this.frozenRow && this.updateFrozenRowStickyPosition(),
            this.scrollable && "subheader" === this.rowGroupMode && this.updateFrozenRowGroupHeaderStickyPosition()
        },
        methods: {
            getRowKey: function(e, t) {
                return this.dataKey ? lS(e, this.dataKey) : t
            },
            updateFrozenRowStickyPosition: function() {
                this.$el.style.top = UE(this.$el.previousElementSibling) + "px"
            },
            updateFrozenRowGroupHeaderStickyPosition: function() {
                var e = UE(this.$el.previousElementSibling);
                this.rowGroupHeaderStyleObject.top = e + "px"
            },
            getVirtualScrollerProp: function(e, t) {
                return (t = t || this.virtualScrollerContentProps) ? t[e] : null
            },
            bodyRef: function(e) {
                var t = this.getVirtualScrollerProp("contentRef");
                t && t(e)
            }
        },
        computed: {
            rowGroupHeaderStyle: function() {
                return this.scrollable ? {
                    top: this.rowGroupHeaderStyleObject.top
                } : null
            },
            bodyContentStyle: function() {
                return this.getVirtualScrollerProp("contentStyle")
            },
            ptmTBodyOptions: function() {
                var e;
                return {
                    context: {
                        scrollable: null === (e = this.$parentInstance) || void 0 === e || null === (e = e.$parentInstance) || void 0 === e ? void 0 : e.scrollable
                    }
                }
            },
            dataP: function() {
                return RS({
                    hoverable: this.rowHover || this.selectionMode,
                    frozen: this.frozenRow
                })
            }
        },
        components: {
            DTBodyRow: Zk
        }
    },
    dD = ["data-p"];
uD.render = function(e, t, n, r, o, i) {
    var a = jn("DTBodyRow");
    return uo(), go("tbody", Mo({
        ref: i.bodyRef,
        class: e.cx("tbody"),
        role: "rowgroup",
        style: i.bodyContentStyle,
        "data-p": i.dataP
    }, e.ptm("tbody", i.ptmTBodyOptions)), [n.empty ? (uo(), mo(a, {
        key: 1,
        empty: n.empty,
        columns: n.columns,
        templates: n.templates,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["empty", "columns", "templates", "unstyled", "pt"])) : (uo(!0), go(oo, {
        key: 0
    }, qn(n.value, function(r, o) {
        return uo(), mo(a, {
            key: i.getRowKey(r, o),
            rowData: r,
            index: o,
            value: n.value,
            columns: n.columns,
            frozenRow: n.frozenRow,
            empty: n.empty,
            first: n.first,
            dataKey: n.dataKey,
            selection: n.selection,
            selectionKeys: n.selectionKeys,
            selectionMode: n.selectionMode,
            contextMenu: n.contextMenu,
            contextMenuSelection: n.contextMenuSelection,
            rowGroupMode: n.rowGroupMode,
            groupRowsBy: n.groupRowsBy,
            expandableRowGroups: n.expandableRowGroups,
            rowClass: n.rowClass,
            rowStyle: n.rowStyle,
            editMode: n.editMode,
            compareSelectionBy: n.compareSelectionBy,
            scrollable: n.scrollable,
            expandedRowIcon: n.expandedRowIcon,
            collapsedRowIcon: n.collapsedRowIcon,
            expandedRows: n.expandedRows,
            expandedRowGroups: n.expandedRowGroups,
            editingRows: n.editingRows,
            editingRowKeys: n.editingRowKeys,
            templates: n.templates,
            editButtonProps: n.editButtonProps,
            virtualScrollerContentProps: n.virtualScrollerContentProps,
            isVirtualScrollerDisabled: n.isVirtualScrollerDisabled,
            editingMeta: n.editingMeta,
            rowGroupHeaderStyle: i.rowGroupHeaderStyle,
            expandedRowId: e.$id,
            nameAttributeSelector: e.$attrSelector,
            onRowgroupToggle: t[0] || (t[0] = function(t) {
                return e.$emit("rowgroup-toggle", t)
            }),
            onRowClick: t[1] || (t[1] = function(t) {
                return e.$emit("row-click", t)
            }),
            onRowDblclick: t[2] || (t[2] = function(t) {
                return e.$emit("row-dblclick", t)
            }),
            onRowRightclick: t[3] || (t[3] = function(t) {
                return e.$emit("row-rightclick", t)
            }),
            onRowTouchend: t[4] || (t[4] = function(t) {
                return e.$emit("row-touchend", t)
            }),
            onRowKeydown: t[5] || (t[5] = function(t) {
                return e.$emit("row-keydown", t)
            }),
            onRowMousedown: t[6] || (t[6] = function(t) {
                return e.$emit("row-mousedown", t)
            }),
            onRowDragstart: t[7] || (t[7] = function(t) {
                return e.$emit("row-dragstart", t)
            }),
            onRowDragover: t[8] || (t[8] = function(t) {
                return e.$emit("row-dragover", t)
            }),
            onRowDragleave: t[9] || (t[9] = function(t) {
                return e.$emit("row-dragleave", t)
            }),
            onRowDragend: t[10] || (t[10] = function(t) {
                return e.$emit("row-dragend", t)
            }),
            onRowDrop: t[11] || (t[11] = function(t) {
                return e.$emit("row-drop", t)
            }),
            onRowToggle: t[12] || (t[12] = function(t) {
                return e.$emit("row-toggle", t)
            }),
            onRadioChange: t[13] || (t[13] = function(t) {
                return e.$emit("radio-change", t)
            }),
            onCheckboxChange: t[14] || (t[14] = function(t) {
                return e.$emit("checkbox-change", t)
            }),
            onCellEditInit: t[15] || (t[15] = function(t) {
                return e.$emit("cell-edit-init", t)
            }),
            onCellEditComplete: t[16] || (t[16] = function(t) {
                return e.$emit("cell-edit-complete", t)
            }),
            onCellEditCancel: t[17] || (t[17] = function(t) {
                return e.$emit("cell-edit-cancel", t)
            }),
            onRowEditInit: t[18] || (t[18] = function(t) {
                return e.$emit("row-edit-init", t)
            }),
            onRowEditSave: t[19] || (t[19] = function(t) {
                return e.$emit("row-edit-save", t)
            }),
            onRowEditCancel: t[20] || (t[20] = function(t) {
                return e.$emit("row-edit-cancel", t)
            }),
            onEditingMetaChange: t[21] || (t[21] = function(t) {
                return e.$emit("editing-meta-change", t)
            }),
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["rowData", "index", "value", "columns", "frozenRow", "empty", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "virtualScrollerContentProps", "isVirtualScrollerDisabled", "editingMeta", "rowGroupHeaderStyle", "expandedRowId", "nameAttributeSelector", "unstyled", "pt"])
    }), 128))], 16, dD)
};
var pD = {
    name: "FooterCell",
    hostName: "DataTable",
    extends: nT,
    props: {
        column: {
            type: Object,
            default: null
        },
        index: {
            type: Number,
            default: null
        }
    },
    data: function() {
        return {
            styleObject: {}
        }
    },
    mounted: function() {
        this.columnProp("frozen") && this.updateStickyPosition()
    },
    updated: function() {
        this.columnProp("frozen") && this.updateStickyPosition()
    },
    methods: {
        columnProp: function(e) {
            return zS(this.column, e)
        },
        getColumnPT: function(e) {
            var t,
                n,
                r = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index,
                        size: null === (t = this.$parentInstance) || void 0 === t || null === (t = t.$parentInstance) || void 0 === t ? void 0 : t.size,
                        showGridlines: (null === (n = this.$parentInstance) || void 0 === n || null === (n = n.$parentInstance) || void 0 === n ? void 0 : n.showGridlines) || !1
                    }
                };
            return Mo(this.ptm("column.".concat(e), {
                column: r
            }), this.ptm("column.".concat(e), r), this.ptmo(this.getColumnProp(), e, r))
        },
        getColumnProp: function() {
            return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
        },
        updateStickyPosition: function() {
            if (this.columnProp("frozen"))
                if ("right" === this.columnProp("alignFrozen")) {
                    var e = 0,
                        t = NE(this.$el, '[data-p-frozen-column="true"]');
                    t && (e = _E(t) + parseFloat(t.style["inset-inline-end"] || 0)),
                    this.styleObject.insetInlineEnd = e + "px"
                } else {
                    var n = 0,
                        r = QE(this.$el, '[data-p-frozen-column="true"]');
                    r && (n = _E(r) + parseFloat(r.style["inset-inline-start"] || 0)),
                    this.styleObject.insetInlineStart = n + "px"
                }
        }
    },
    computed: {
        containerClass: function() {
            return [this.columnProp("footerClass"), this.columnProp("class"), this.cx("footerCell")]
        },
        containerStyle: function() {
            var e = this.columnProp("footerStyle"),
                t = this.columnProp("style");
            return this.columnProp("frozen") ? [t, e, this.styleObject] : [t, e]
        }
    }
};
function hD(e) {
    return (hD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function fD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function gD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? fD(Object(n), !0).forEach(function(t) {
            mD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function mD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != hD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != hD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == hD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var bD = ["colspan", "rowspan", "data-p-frozen-column"];
function AD(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
pD.render = function(e, t, n, r, o, i) {
    return uo(), go("td", Mo({
        style: i.containerStyle,
        class: i.containerClass,
        role: "cell",
        colspan: i.columnProp("colspan"),
        rowspan: i.columnProp("rowspan")
    }, gD(gD({}, i.getColumnPT("root")), i.getColumnPT("footerCell")), {
        "data-p-frozen-column": i.columnProp("frozen")
    }), [n.column.children && n.column.children.footer ? (uo(), mo(Hn(n.column.children.footer), {
        key: 0,
        column: n.column
    }, null, 8, ["column"])) : Eo("", !0), i.columnProp("footer") ? (uo(), go("span", Mo({
        key: 1,
        class: e.cx("columnFooter")
    }, i.getColumnPT("columnFooter")), W(i.columnProp("footer")), 17)) : Eo("", !0)], 16, bD)
};
var yD = {
    name: "TableFooter",
    hostName: "DataTable",
    extends: nT,
    props: {
        columnGroup: {
            type: null,
            default: null
        },
        columns: {
            type: Object,
            default: null
        }
    },
    provide: function() {
        return {
            $rows: this.d_footerRows,
            $columns: this.d_footerColumns
        }
    },
    data: function() {
        return {
            d_footerRows: new US({
                type: "Row"
            }),
            d_footerColumns: new US({
                type: "Column"
            })
        }
    },
    beforeUnmount: function() {
        this.d_footerRows.clear(),
        this.d_footerColumns.clear()
    },
    methods: {
        columnProp: function(e, t) {
            return zS(e, t)
        },
        getColumnGroupPT: function(e) {
            var t = {
                props: this.getColumnGroupProps(),
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                },
                context: {
                    type: "footer",
                    scrollable: this.ptmTFootOptions.context.scrollable
                }
            };
            return Mo(this.ptm("columnGroup.".concat(e), {
                columnGroup: t
            }), this.ptm("columnGroup.".concat(e), t), this.ptmo(this.getColumnGroupProps(), e, t))
        },
        getColumnGroupProps: function() {
            return this.columnGroup && this.columnGroup.props && this.columnGroup.props.pt ? this.columnGroup.props.pt : void 0
        },
        getRowPT: function(e, t, n) {
            var r = {
                props: e.props,
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                },
                context: {
                    index: n
                }
            };
            return Mo(this.ptm("row.".concat(t), {
                row: r
            }), this.ptm("row.".concat(t), r), this.ptmo(this.getRowProp(e), t, r))
        },
        getRowProp: function(e) {
            return e.props && e.props.pt ? e.props.pt : void 0
        },
        getFooterRows: function() {
            var e;
            return null === (e = this.d_footerRows) || void 0 === e ? void 0 : e.get(this.columnGroup, this.columnGroup.children)
        },
        getFooterColumns: function(e) {
            var t;
            return null === (t = this.d_footerColumns) || void 0 === t ? void 0 : t.get(e, e.children)
        }
    },
    computed: {
        hasFooter: function() {
            var e = !1;
            if (this.columnGroup)
                e = !0;
            else if (this.columns) {
                var t,
                    n = function(e, t) {
                        var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (!n) {
                            if (Array.isArray(e) || (n = function(e, t) {
                                if (e) {
                                    if ("string" == typeof e)
                                        return AD(e, t);
                                    var n = {}.toString.call(e).slice(8, -1);
                                    return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? AD(e, t) : void 0
                                }
                            }(e)) || t) {
                                n && (e = n);
                                var r = 0,
                                    o = function() {};
                                return {
                                    s: o,
                                    n: function() {
                                        return r >= e.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: e[r++]
                                        }
                                    },
                                    e: function(e) {
                                        throw e
                                    },
                                    f: o
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var i,
                            a = !0,
                            s = !1;
                        return {
                            s: function() {
                                n = n.call(e)
                            },
                            n: function() {
                                var e = n.next();
                                return a = e.done, e
                            },
                            e: function(e) {
                                s = !0,
                                i = e
                            },
                            f: function() {
                                try {
                                    a || null == n.return || n.return()
                                } finally {
                                    if (s)
                                        throw i
                                }
                            }
                        }
                    }(this.columns);
                try {
                    for (n.s(); !(t = n.n()).done;) {
                        var r = t.value;
                        if (this.columnProp(r, "footer") || r.children && r.children.footer) {
                            e = !0;
                            break
                        }
                    }
                } catch (o) {
                    n.e(o)
                } finally {
                    n.f()
                }
            }
            return e
        },
        ptmTFootOptions: function() {
            var e;
            return {
                context: {
                    scrollable: null === (e = this.$parentInstance) || void 0 === e || null === (e = e.$parentInstance) || void 0 === e ? void 0 : e.scrollable
                }
            }
        }
    },
    components: {
        DTFooterCell: pD
    }
};
function vD(e) {
    return (vD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function _D(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function xD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? _D(Object(n), !0).forEach(function(t) {
            wD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _D(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function wD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != vD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != vD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == vD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var CD = ["data-p-scrollable"];
function ED(e) {
    return (ED = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function SD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function ID(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? SD(Object(n), !0).forEach(function(t) {
            TD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function TD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != ED(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != ED(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == ED(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
yD.render = function(e, t, n, r, o, i) {
    var a,
        s = jn("DTFooterCell");
    return i.hasFooter ? (uo(), go("tfoot", Mo({
        key: 0,
        class: e.cx("tfoot"),
        style: e.sx("tfoot"),
        role: "rowgroup"
    }, n.columnGroup ? xD(xD({}, e.ptm("tfoot", i.ptmTFootOptions)), i.getColumnGroupPT("root")) : e.ptm("tfoot", i.ptmTFootOptions), {
        "data-p-scrollable": null === (a = e.$parentInstance) || void 0 === a || null === (a = a.$parentInstance) || void 0 === a ? void 0 : a.scrollable,
        "data-pc-section": "tfoot"
    }), [n.columnGroup ? (uo(!0), go(oo, {
        key: 1
    }, qn(i.getFooterRows(), function(t, n) {
        return uo(), go("tr", Mo({
            key: n,
            role: "row"
        }, {
            ref_for: !0
        }, xD(xD({}, e.ptm("footerRow")), i.getRowPT(t, "root", n))), [(uo(!0), go(oo, null, qn(i.getFooterColumns(t), function(t, r) {
            return uo(), go(oo, {
                key: i.columnProp(t, "columnKey") || i.columnProp(t, "field") || r
            }, [i.columnProp(t, "hidden") ? Eo("", !0) : (uo(), mo(s, {
                key: 0,
                column: t,
                index: n,
                pt: e.pt
            }, null, 8, ["column", "index", "pt"]))], 64)
        }), 128))], 16)
    }), 128)) : (uo(), go("tr", Mo({
        key: 0,
        role: "row"
    }, e.ptm("footerRow")), [(uo(!0), go(oo, null, qn(n.columns, function(t, n) {
        return uo(), go(oo, {
            key: i.columnProp(t, "columnKey") || i.columnProp(t, "field") || n
        }, [i.columnProp(t, "hidden") ? Eo("", !0) : (uo(), mo(s, {
            key: 0,
            column: t,
            pt: e.pt
        }, null, 8, ["column", "pt"]))], 64)
    }), 128))], 16))], 16, CD)) : Eo("", !0)
};
var MD = {
    name: "ColumnFilter",
    hostName: "DataTable",
    extends: nT,
    emits: ["filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
    props: {
        field: {
            type: String,
            default: null
        },
        type: {
            type: String,
            default: "text"
        },
        display: {
            type: String,
            default: null
        },
        showMenu: {
            type: Boolean,
            default: !0
        },
        matchMode: {
            type: String,
            default: null
        },
        showOperator: {
            type: Boolean,
            default: !0
        },
        showClearButton: {
            type: Boolean,
            default: !0
        },
        showApplyButton: {
            type: Boolean,
            default: !0
        },
        showMatchModes: {
            type: Boolean,
            default: !0
        },
        showAddButton: {
            type: Boolean,
            default: !0
        },
        matchModeOptions: {
            type: Array,
            default: null
        },
        maxConstraints: {
            type: Number,
            default: 2
        },
        filterElement: {
            type: Function,
            default: null
        },
        filterHeaderTemplate: {
            type: Function,
            default: null
        },
        filterFooterTemplate: {
            type: Function,
            default: null
        },
        filterClearTemplate: {
            type: Function,
            default: null
        },
        filterApplyTemplate: {
            type: Function,
            default: null
        },
        filterIconTemplate: {
            type: Function,
            default: null
        },
        filterAddIconTemplate: {
            type: Function,
            default: null
        },
        filterRemoveIconTemplate: {
            type: Function,
            default: null
        },
        filterClearIconTemplate: {
            type: Function,
            default: null
        },
        filters: {
            type: Object,
            default: null
        },
        filtersStore: {
            type: Object,
            default: null
        },
        filterMenuClass: {
            type: String,
            default: null
        },
        filterMenuStyle: {
            type: null,
            default: null
        },
        filterInputProps: {
            type: null,
            default: null
        },
        filterButtonProps: {
            type: null,
            default: null
        },
        column: null
    },
    data: function() {
        return {
            overlayVisible: !1,
            defaultMatchMode: null,
            defaultOperator: null
        }
    },
    overlay: null,
    selfClick: !1,
    overlayEventListener: null,
    beforeUnmount: function() {
        this.overlayEventListener && (lM.off("overlay-click", this.overlayEventListener), this.overlayEventListener = null),
        this.overlay && (MS.clear(this.overlay), this.onOverlayHide())
    },
    mounted: function() {
        if (this.filters && this.filters[this.field]) {
            var e = this.filters[this.field];
            e.operator ? (this.defaultMatchMode = e.constraints[0].matchMode, this.defaultOperator = e.operator) : this.defaultMatchMode = this.filters[this.field].matchMode
        }
    },
    methods: {
        getColumnPT: function(e, t) {
            var n = ID({
                props: this.column.props,
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                }
            }, t);
            return Mo(this.ptm("column.".concat(e), {
                column: n
            }), this.ptm("column.".concat(e), n), this.ptmo(this.getColumnProp(), e, n))
        },
        getColumnProp: function() {
            return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
        },
        ptmFilterConstraintOptions: function(e) {
            return {
                context: {
                    highlighted: e && this.isRowMatchModeSelected(e.value)
                }
            }
        },
        clearFilter: function() {
            var e = ID({}, this.filters);
            e[this.field].operator ? (e[this.field].constraints.splice(1), e[this.field].operator = this.defaultOperator, e[this.field].constraints[0] = {
                value: null,
                matchMode: this.defaultMatchMode
            }) : (e[this.field].value = null, e[this.field].matchMode = this.defaultMatchMode),
            this.$emit("filter-clear"),
            this.$emit("filter-change", e),
            this.$emit("filter-apply"),
            this.hide()
        },
        applyFilter: function() {
            this.$emit("apply-click", {
                field: this.field,
                constraints: this.filters[this.field]
            }),
            this.$emit("filter-apply"),
            this.hide()
        },
        hasFilter: function() {
            if (this.filtersStore) {
                var e = this.filtersStore[this.field];
                if (e)
                    return e.operator ? !this.isFilterBlank(e.constraints[0].value) : !this.isFilterBlank(e.value)
            }
            return !1
        },
        hasRowFilter: function() {
            return this.filters[this.field] && !this.isFilterBlank(this.filters[this.field].value)
        },
        isFilterBlank: function(e) {
            return null == e || "string" == typeof e && 0 == e.trim().length || e instanceof Array && 0 == e.length
        },
        toggleMenu: function(e) {
            this.overlayVisible = !this.overlayVisible,
            e.preventDefault()
        },
        onToggleButtonKeyDown: function(e) {
            switch (e.code) {
            case "Enter":
            case "NumpadEnter":
            case "Space":
                this.toggleMenu(e);
                break;
            case "Escape":
                this.overlayVisible = !1
            }
        },
        onRowMatchModeChange: function(e) {
            var t = ID({}, this.filters);
            t[this.field].matchMode = e,
            this.$emit("matchmode-change", {
                field: this.field,
                matchMode: e
            }),
            this.$emit("filter-change", t),
            this.$emit("filter-apply"),
            this.hide()
        },
        onRowMatchModeKeyDown: function(e) {
            var t = e.target;
            switch (e.code) {
            case "ArrowDown":
                var n = this.findNextItem(t);
                n && (t.removeAttribute("tabindex"), n.tabIndex = "0", n.focus()),
                e.preventDefault();
                break;
            case "ArrowUp":
                var r = this.findPrevItem(t);
                r && (t.removeAttribute("tabindex"), r.tabIndex = "0", r.focus()),
                e.preventDefault()
            }
        },
        isRowMatchModeSelected: function(e) {
            return this.filters[this.field].matchMode === e
        },
        onOperatorChange: function(e) {
            var t = ID({}, this.filters);
            t[this.field].operator = e,
            this.$emit("filter-change", t),
            this.$emit("operator-change", {
                field: this.field,
                operator: e
            }),
            this.showApplyButton || this.$emit("filter-apply")
        },
        onMenuMatchModeChange: function(e, t) {
            ID({}, this.filters)[this.field].constraints[t].matchMode = e,
            this.$emit("matchmode-change", {
                field: this.field,
                matchMode: e,
                index: t
            }),
            this.showApplyButton || this.$emit("filter-apply")
        },
        addConstraint: function() {
            var e = ID({}, this.filters),
                t = {
                    value: null,
                    matchMode: this.defaultMatchMode
                };
            e[this.field].constraints.push(t),
            this.$emit("constraint-add", {
                field: this.field,
                constraint: t
            }),
            this.$emit("filter-change", e),
            this.showApplyButton || this.$emit("filter-apply")
        },
        removeConstraint: function(e) {
            var t = ID({}, this.filters),
                n = t[this.field].constraints.splice(e, 1);
            this.$emit("constraint-remove", {
                field: this.field,
                constraint: n
            }),
            this.$emit("filter-change", t),
            this.showApplyButton || this.$emit("filter-apply")
        },
        filterCallback: function() {
            this.$emit("filter-apply")
        },
        findNextItem: function(e) {
            var t = e.nextElementSibling;
            return t ? "filterconstraintseparator" === BE(t, "data-pc-section") ? this.findNextItem(t) : t : e.parentElement.firstElementChild
        },
        findPrevItem: function(e) {
            var t = e.previousElementSibling;
            return t ? "filterconstraintseparator" === BE(t, "data-pc-section") ? this.findPrevItem(t) : t : e.parentElement.lastElementChild
        },
        hide: function() {
            this.overlayVisible = !1,
            this.showMenuButton && RE(this.$refs.icon.$el)
        },
        onContentClick: function(e) {
            this.selfClick = !0,
            lM.emit("overlay-click", {
                originalEvent: e,
                target: this.overlay
            })
        },
        onContentMouseDown: function() {
            this.selfClick = !0
        },
        onOverlayEnter: function(e) {
            var t = this;
            this.filterMenuStyle && vE(this.overlay, this.filterMenuStyle),
            MS.set("overlay", e, this.$primevue.config.zIndex.overlay),
            vE(e, {
                position: "absolute",
                top: "0"
            }),
            yE(this.overlay, this.$refs.icon.$el),
            this.bindOutsideClickListener(),
            this.bindScrollListener(),
            this.bindResizeListener(),
            this.overlayEventListener = function(e) {
                t.isOutsideClicked(e.target) || (t.selfClick = !0)
            },
            lM.on("overlay-click", this.overlayEventListener)
        },
        onOverlayAfterEnter: function() {
            var e;
            null === (e = this.overlay) || void 0 === e || null === (e = e.$focustrap) || void 0 === e || e.autoFocus()
        },
        onOverlayLeave: function() {
            this.onOverlayHide()
        },
        onOverlayAfterLeave: function(e) {
            MS.clear(e)
        },
        onOverlayHide: function() {
            this.unbindOutsideClickListener(),
            this.unbindResizeListener(),
            this.unbindScrollListener(),
            this.overlay = null,
            lM.off("overlay-click", this.overlayEventListener),
            this.overlayEventListener = null
        },
        overlayRef: function(e) {
            this.overlay = e
        },
        isOutsideClicked: function(e) {
            return !this.isTargetClicked(e) && this.overlay && !(this.overlay.isSameNode(e) || this.overlay.contains(e))
        },
        isTargetClicked: function(e) {
            return this.$refs.icon && (this.$refs.icon.$el.isSameNode(e) || this.$refs.icon.$el.contains(e))
        },
        bindOutsideClickListener: function() {
            var e = this;
            this.outsideClickListener || (this.outsideClickListener = function(t) {
                e.overlayVisible && !e.selfClick && e.isOutsideClicked(t.target) && (e.overlayVisible = !1),
                e.selfClick = !1
            }, document.addEventListener("click", this.outsideClickListener, !0))
        },
        unbindOutsideClickListener: function() {
            this.outsideClickListener && (document.removeEventListener("click", this.outsideClickListener, !0), this.outsideClickListener = null, this.selfClick = !1)
        },
        bindScrollListener: function() {
            var e = this;
            this.scrollHandler || (this.scrollHandler = new PS(this.$refs.icon.$el, function() {
                e.overlayVisible && e.hide()
            })),
            this.scrollHandler.bindScrollListener()
        },
        unbindScrollListener: function() {
            this.scrollHandler && this.scrollHandler.unbindScrollListener()
        },
        bindResizeListener: function() {
            var e = this;
            this.resizeListener || (this.resizeListener = function() {
                e.overlayVisible && !XE() && e.hide()
            }, window.addEventListener("resize", this.resizeListener))
        },
        unbindResizeListener: function() {
            this.resizeListener && (window.removeEventListener("resize", this.resizeListener), this.resizeListener = null)
        }
    },
    computed: {
        showMenuButton: function() {
            return this.showMenu && ("row" !== this.display || "boolean" !== this.type)
        },
        overlayId: function() {
            return this.$id + "_overlay"
        },
        matchModes: function() {
            var e = this;
            return this.matchModeOptions || this.$primevue.config.filterMatchModeOptions[this.type].map(function(t) {
                    return {
                        label: e.$primevue.config.locale[t],
                        value: t
                    }
                })
        },
        isShowMatchModes: function() {
            return "boolean" !== this.type && this.showMatchModes && this.matchModes
        },
        operatorOptions: function() {
            return [{
                label: this.$primevue.config.locale.matchAll,
                value: "and"
            }, {
                label: this.$primevue.config.locale.matchAny,
                value: "or"
            }]
        },
        noFilterLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.noFilter : void 0
        },
        isShowOperator: function() {
            return this.showOperator && this.filters[this.field].operator
        },
        operator: function() {
            return this.filters[this.field].operator
        },
        fieldConstraints: function() {
            return this.filters[this.field].constraints || [this.filters[this.field]]
        },
        showRemoveIcon: function() {
            return this.fieldConstraints.length > 1
        },
        removeRuleButtonLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.removeRule : void 0
        },
        addRuleButtonLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.addRule : void 0
        },
        isShowAddConstraint: function() {
            return this.showAddButton && this.filters[this.field].operator && this.fieldConstraints && this.fieldConstraints.length < this.maxConstraints
        },
        clearButtonLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.clear : void 0
        },
        applyButtonLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.apply : void 0
        },
        columnFilterButtonAriaLabel: function() {
            var e;
            return null !== (e = this.$primevue.config.locale) && void 0 !== e && e.aria ? this.overlayVisible ? this.$primevue.config.locale.aria.hideFilterMenu : this.$primevue.config.locale.aria.showFilterMenu : void 0
        },
        filterOperatorAriaLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.filterOperator : void 0
        },
        filterRuleAriaLabel: function() {
            return this.$primevue.config.locale ? this.$primevue.config.locale.filterConstraint : void 0
        },
        ptmHeaderFilterClearParams: function() {
            return {
                context: {
                    hidden: this.hasRowFilter()
                }
            }
        },
        ptmFilterMenuParams: function() {
            return {
                context: {
                    overlayVisible: this.overlayVisible,
                    active: this.hasFilter()
                }
            }
        }
    },
    components: {
        Select: wM,
        Button: _R,
        Portal: cM,
        FilterSlashIcon: Ak,
        FilterFillIcon: mk,
        FilterIcon: fk,
        TrashIcon: vk,
        PlusIcon: XM
    },
    directives: {
        focustrap: Ik
    }
};
function RD(e) {
    return (RD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function BD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function kD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? BD(Object(n), !0).forEach(function(t) {
            DD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function DD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != RD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != RD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == RD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var PD = ["id", "aria-modal"],
    OD = ["onClick", "onKeydown", "tabindex"];
MD.render = function(e, t, n, r, o, i) {
    var a = jn("Button"),
        s = jn("Select"),
        l = jn("Portal"),
        c = $n("focustrap");
    return uo(), go("div", Mo({
        class: e.cx("filter")
    }, i.getColumnPT("filter")), ["row" === n.display ? (uo(), go("div", Mo({
        key: 0,
        class: e.cx("filterElementContainer")
    }, kD(kD({}, n.filterInputProps), i.getColumnPT("filterElementContainer"))), [(uo(), mo(Hn(n.filterElement), {
        field: n.field,
        filterModel: n.filters[n.field],
        filterCallback: i.filterCallback
    }, null, 8, ["field", "filterModel", "filterCallback"]))], 16)) : Eo("", !0), i.showMenuButton ? (uo(), mo(a, Mo({
        key: 1,
        ref: "icon",
        "aria-label": i.columnFilterButtonAriaLabel,
        "aria-haspopup": "true",
        "aria-expanded": o.overlayVisible,
        "aria-controls": o.overlayVisible ? i.overlayId : void 0,
        class: e.cx("pcColumnFilterButton"),
        unstyled: e.unstyled,
        onClick: t[0] || (t[0] = function(e) {
            return i.toggleMenu(e)
        }),
        onKeydown: t[1] || (t[1] = function(e) {
            return i.onToggleButtonKeyDown(e)
        })
    }, kD(kD({}, i.getColumnPT("pcColumnFilterButton", i.ptmFilterMenuParams)), n.filterButtonProps.filter)), {
        icon: Vt(function(e) {
            return [(uo(), mo(Hn(n.filterIconTemplate || (i.hasFilter() ? "FilterFillIcon" : "FilterIcon")), Mo({
                class: e.class
            }, i.getColumnPT("filterMenuIcon")), null, 16, ["class"]))]
        }),
        _: 1
    }, 16, ["aria-label", "aria-expanded", "aria-controls", "class", "unstyled"])) : Eo("", !0), xo(l, null, {
        default: Vt(function() {
            return [xo(ii, Mo({
                name: "p-connected-overlay",
                onEnter: i.onOverlayEnter,
                onAfterEnter: i.onOverlayAfterEnter,
                onLeave: i.onOverlayLeave,
                onAfterLeave: i.onOverlayAfterLeave
            }, i.getColumnPT("transition")), {
                default: Vt(function() {
                    return [o.overlayVisible ? Ht((uo(), go("div", Mo({
                        key: 0,
                        ref: i.overlayRef,
                        id: i.overlayId,
                        "aria-modal": o.overlayVisible,
                        role: "dialog",
                        class: [e.cx("filterOverlay"), n.filterMenuClass],
                        onKeydown: t[10] || (t[10] = zi(function() {
                            return i.hide && i.hide.apply(i, arguments)
                        }, ["escape"])),
                        onClick: t[11] || (t[11] = function() {
                            return i.onContentClick && i.onContentClick.apply(i, arguments)
                        }),
                        onMousedown: t[12] || (t[12] = function() {
                            return i.onContentMouseDown && i.onContentMouseDown.apply(i, arguments)
                        })
                    }, i.getColumnPT("filterOverlay")), [(uo(), mo(Hn(n.filterHeaderTemplate), {
                        field: n.field,
                        filterModel: n.filters[n.field],
                        filterCallback: i.filterCallback
                    }, null, 8, ["field", "filterModel", "filterCallback"])), "row" === n.display ? (uo(), go("ul", Mo({
                        key: 0,
                        class: e.cx("filterConstraintList")
                    }, i.getColumnPT("filterConstraintList")), [(uo(!0), go(oo, null, qn(i.matchModes, function(n, r) {
                        return uo(), go("li", Mo({
                            key: n.label,
                            class: e.cx("filterConstraint", {
                                matchMode: n
                            }),
                            onClick: function(e) {
                                return i.onRowMatchModeChange(n.value)
                            },
                            onKeydown: [t[2] || (t[2] = function(e) {
                                return i.onRowMatchModeKeyDown(e)
                            }), zi(Fi(function(e) {
                                return i.onRowMatchModeChange(n.value)
                            }, ["prevent"]), ["enter"])],
                            tabindex: 0 === r ? "0" : null
                        }, {
                            ref_for: !0
                        }, i.getColumnPT("filterConstraint", i.ptmFilterConstraintOptions(n))), W(n.label), 17, OD)
                    }), 128)), _o("li", Mo({
                        class: e.cx("filterConstraintSeparator")
                    }, i.getColumnPT("filterConstraintSeparator")), null, 16), _o("li", Mo({
                        class: e.cx("filterConstraint"),
                        onClick: t[3] || (t[3] = function(e) {
                            return i.clearFilter()
                        }),
                        onKeydown: [t[4] || (t[4] = function(e) {
                            return i.onRowMatchModeKeyDown(e)
                        }), t[5] || (t[5] = zi(function(t) {
                            return e.onRowClearItemClick()
                        }, ["enter"]))]
                    }, i.getColumnPT("filterConstraint")), W(i.noFilterLabel), 17)], 16)) : (uo(), go(oo, {
                        key: 1
                    }, [i.isShowOperator ? (uo(), go("div", Mo({
                        key: 0,
                        class: e.cx("filterOperator")
                    }, i.getColumnPT("filterOperator")), [xo(s, {
                        options: i.operatorOptions,
                        modelValue: i.operator,
                        "aria-label": i.filterOperatorAriaLabel,
                        class: G(e.cx("pcFilterOperatorDropdown")),
                        optionLabel: "label",
                        optionValue: "value",
                        "onUpdate:modelValue": t[6] || (t[6] = function(e) {
                            return i.onOperatorChange(e)
                        }),
                        unstyled: e.unstyled,
                        pt: i.getColumnPT("pcFilterOperatorDropdown")
                    }, null, 8, ["options", "modelValue", "aria-label", "class", "unstyled", "pt"])], 16)) : Eo("", !0), _o("div", Mo({
                        class: e.cx("filterRuleList")
                    }, i.getColumnPT("filterRuleList")), [(uo(!0), go(oo, null, qn(i.fieldConstraints, function(t, r) {
                        return uo(), go("div", Mo({
                            key: r,
                            class: e.cx("filterRule")
                        }, {
                            ref_for: !0
                        }, i.getColumnPT("filterRule")), [i.isShowMatchModes ? (uo(), mo(s, {
                            key: 0,
                            options: i.matchModes,
                            modelValue: t.matchMode,
                            class: G(e.cx("pcFilterConstraintDropdown")),
                            optionLabel: "label",
                            optionValue: "value",
                            "aria-label": i.filterRuleAriaLabel,
                            "onUpdate:modelValue": function(e) {
                                return i.onMenuMatchModeChange(e, r)
                            },
                            unstyled: e.unstyled,
                            pt: i.getColumnPT("pcFilterConstraintDropdown")
                        }, null, 8, ["options", "modelValue", "class", "aria-label", "onUpdate:modelValue", "unstyled", "pt"])) : Eo("", !0), "menu" === n.display ? (uo(), mo(Hn(n.filterElement), {
                            key: 1,
                            field: n.field,
                            filterModel: t,
                            filterCallback: i.filterCallback,
                            applyFilter: i.applyFilter
                        }, null, 8, ["field", "filterModel", "filterCallback", "applyFilter"])) : Eo("", !0), i.showRemoveIcon ? (uo(), go("div", Mo({
                            key: 2,
                            ref_for: !0
                        }, i.getColumnPT("filterRemove")), [xo(a, Mo({
                            type: "button",
                            class: e.cx("pcFilterRemoveRuleButton"),
                            onClick: function(e) {
                                return i.removeConstraint(r)
                            },
                            label: i.removeRuleButtonLabel,
                            unstyled: e.unstyled
                        }, {
                            ref_for: !0
                        }, n.filterButtonProps.popover.removeRule, {
                            pt: i.getColumnPT("pcFilterRemoveRuleButton")
                        }), {
                            icon: Vt(function(e) {
                                return [(uo(), mo(Hn(n.filterRemoveIconTemplate || "TrashIcon"), Mo({
                                    class: e.class
                                }, {
                                    ref_for: !0
                                }, i.getColumnPT("pcFilterRemoveRuleButton").icon), null, 16, ["class"]))]
                            }),
                            _: 1
                        }, 16, ["class", "onClick", "label", "unstyled", "pt"])], 16)) : Eo("", !0)], 16)
                    }), 128))], 16), i.isShowAddConstraint ? (uo(), go("div", j(Mo({
                        key: 1
                    }, i.getColumnPT("filterAddButtonContainer"))), [xo(a, Mo({
                        type: "button",
                        label: i.addRuleButtonLabel,
                        iconPos: "left",
                        class: e.cx("pcFilterAddRuleButton"),
                        onClick: t[7] || (t[7] = function(e) {
                            return i.addConstraint()
                        }),
                        unstyled: e.unstyled
                    }, n.filterButtonProps.popover.addRule, {
                        pt: i.getColumnPT("pcFilterAddRuleButton")
                    }), {
                        icon: Vt(function(e) {
                            return [(uo(), mo(Hn(n.filterAddIconTemplate || "PlusIcon"), Mo({
                                class: e.class
                            }, i.getColumnPT("pcFilterAddRuleButton").icon), null, 16, ["class"]))]
                        }),
                        _: 1
                    }, 16, ["label", "class", "unstyled", "pt"])], 16)) : Eo("", !0), _o("div", Mo({
                        class: e.cx("filterButtonbar")
                    }, i.getColumnPT("filterButtonbar")), [!n.filterClearTemplate && n.showClearButton ? (uo(), mo(a, Mo({
                        key: 0,
                        type: "button",
                        class: e.cx("pcFilterClearButton"),
                        label: i.clearButtonLabel,
                        onClick: t[8] || (t[8] = function(e) {
                            return i.clearFilter()
                        }),
                        unstyled: e.unstyled
                    }, n.filterButtonProps.popover.clear, {
                        pt: i.getColumnPT("pcFilterClearButton")
                    }), null, 16, ["class", "label", "unstyled", "pt"])) : (uo(), mo(Hn(n.filterClearTemplate), {
                        key: 1,
                        field: n.field,
                        filterModel: n.filters[n.field],
                        filterCallback: i.clearFilter
                    }, null, 8, ["field", "filterModel", "filterCallback"])), n.showApplyButton ? (uo(), go(oo, {
                        key: 2
                    }, [n.filterApplyTemplate ? (uo(), mo(Hn(n.filterApplyTemplate), {
                        key: 1,
                        field: n.field,
                        filterModel: n.filters[n.field],
                        filterCallback: i.applyFilter
                    }, null, 8, ["field", "filterModel", "filterCallback"])) : (uo(), mo(a, Mo({
                        key: 0,
                        type: "button",
                        class: e.cx("pcFilterApplyButton"),
                        label: i.applyButtonLabel,
                        onClick: t[9] || (t[9] = function(e) {
                            return i.applyFilter()
                        }),
                        unstyled: e.unstyled
                    }, n.filterButtonProps.popover.apply, {
                        pt: i.getColumnPT("pcFilterApplyButton")
                    }), null, 16, ["class", "label", "unstyled", "pt"]))], 64)) : Eo("", !0)], 16)], 64)), (uo(), mo(Hn(n.filterFooterTemplate), {
                        field: n.field,
                        filterModel: n.filters[n.field],
                        filterCallback: i.filterCallback
                    }, null, 8, ["field", "filterModel", "filterCallback"]))], 16, PD)), [[c]]) : Eo("", !0)]
                }),
                _: 1
            }, 16, ["onEnter", "onAfterEnter", "onLeave", "onAfterLeave"])]
        }),
        _: 1
    })], 16)
};
var LD = {
        name: "HeaderCheckbox",
        hostName: "DataTable",
        extends: nT,
        emits: ["change"],
        props: {
            checked: null,
            disabled: null,
            column: null,
            headerCheckboxIconTemplate: {
                type: Function,
                default: null
            }
        },
        methods: {
            getColumnPT: function(e) {
                var t = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        checked: this.checked,
                        disabled: this.disabled
                    }
                };
                return Mo(this.ptm("column.".concat(e), {
                    column: t
                }), this.ptm("column.".concat(e), t), this.ptmo(this.getColumnProp(), e, t))
            },
            getColumnProp: function() {
                return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
            },
            onChange: function(e) {
                this.$emit("change", {
                    originalEvent: e,
                    checked: !this.checked
                })
            }
        },
        computed: {
            headerCheckboxAriaLabel: function() {
                return this.$primevue.config.locale.aria ? this.checked ? this.$primevue.config.locale.aria.selectAll : this.$primevue.config.locale.aria.unselectAll : void 0
            }
        },
        components: {
            CheckIcon: KT,
            Checkbox: IR
        },
        render: function(e, t, n, r, o, i) {
            var a = jn("Checkbox");
            return uo(), mo(a, {
                modelValue: n.checked,
                binary: !0,
                disabled: n.disabled,
                "aria-label": i.headerCheckboxAriaLabel,
                onChange: i.onChange,
                unstyled: e.unstyled,
                pt: i.getColumnPT("pcHeaderCheckbox")
            }, {
                icon: Vt(function(e) {
                    return [n.headerCheckboxIconTemplate ? (uo(), mo(Hn(n.headerCheckboxIconTemplate), {
                        key: 0,
                        checked: e.checked,
                        class: G(e.class)
                    }, null, 8, ["checked", "class"])) : Eo("", !0)]
                }),
                _: 1
            }, 8, ["modelValue", "disabled", "aria-label", "onChange", "unstyled", "pt"])
        }
    },
    ND = {
        name: "FilterHeaderCell",
        hostName: "DataTable",
        extends: nT,
        emits: ["checkbox-change", "filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "apply-click"],
        props: {
            column: {
                type: Object,
                default: null
            },
            index: {
                type: Number,
                default: null
            },
            allRowsSelected: {
                type: Boolean,
                default: !1
            },
            empty: {
                type: Boolean,
                default: !1
            },
            display: {
                type: String,
                default: "row"
            },
            filters: {
                type: Object,
                default: null
            },
            filtersStore: {
                type: Object,
                default: null
            },
            rowGroupMode: {
                type: String,
                default: null
            },
            groupRowsBy: {
                type: [Array, String, Function],
                default: null
            },
            filterInputProps: {
                type: null,
                default: null
            },
            filterButtonProps: {
                type: null,
                default: null
            }
        },
        data: function() {
            return {
                styleObject: {}
            }
        },
        mounted: function() {
            this.columnProp("frozen") && this.updateStickyPosition()
        },
        updated: function() {
            this.columnProp("frozen") && this.updateStickyPosition()
        },
        methods: {
            columnProp: function(e) {
                return zS(this.column, e)
            },
            getColumnPT: function(e) {
                if (!this.column)
                    return null;
                var t = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index
                    }
                };
                return Mo(this.ptm("column.".concat(e), {
                    column: t
                }), this.ptm("column.".concat(e), t), this.ptmo(this.getColumnProp(), e, t))
            },
            getColumnProp: function() {
                return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
            },
            updateStickyPosition: function() {
                if (this.columnProp("frozen"))
                    if ("right" === this.columnProp("alignFrozen")) {
                        var e = 0,
                            t = NE(this.$el, '[data-p-frozen-column="true"]');
                        t && (e = _E(t) + parseFloat(t.style["inset-inline-end"] || 0)),
                        this.styleObject.insetInlineEnd = e + "px"
                    } else {
                        var n = 0,
                            r = QE(this.$el, '[data-p-frozen-column="true"]');
                        r && (n = _E(r) + parseFloat(r.style["inset-inline-start"] || 0)),
                        this.styleObject.insetInlineStart = n + "px"
                    }
            }
        },
        computed: {
            getFilterColumnHeaderClass: function() {
                return [this.cx("headerCell", {
                    column: this.column
                }), this.columnProp("filterHeaderClass"), this.columnProp("class")]
            },
            getFilterColumnHeaderStyle: function() {
                return this.columnProp("frozen") ? [this.columnProp("filterHeaderStyle"), this.columnProp("style"), this.styleObject] : [this.columnProp("filterHeaderStyle"), this.columnProp("style")]
            }
        },
        components: {
            DTHeaderCheckbox: LD,
            DTColumnFilter: MD
        }
    };
function FD(e) {
    return (FD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function UD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function zD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? UD(Object(n), !0).forEach(function(t) {
            QD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function QD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != FD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != FD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == FD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var GD = ["data-p-frozen-column"];
ND.render = function(e, t, n, r, o, i) {
    var a = jn("DTHeaderCheckbox"),
        s = jn("DTColumnFilter");
    return i.columnProp("hidden") || "subheader" === n.rowGroupMode && n.groupRowsBy === i.columnProp("field") ? Eo("", !0) : (uo(), go("th", Mo({
        key: 0,
        style: i.getFilterColumnHeaderStyle,
        class: i.getFilterColumnHeaderClass
    }, zD(zD({}, i.getColumnPT("root")), i.getColumnPT("headerCell")), {
        "data-p-frozen-column": i.columnProp("frozen")
    }), ["multiple" === i.columnProp("selectionMode") ? (uo(), mo(a, {
        key: 0,
        checked: n.allRowsSelected,
        disabled: n.empty,
        onChange: t[0] || (t[0] = function(t) {
            return e.$emit("checkbox-change", t)
        }),
        column: n.column,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["checked", "disabled", "column", "unstyled", "pt"])) : Eo("", !0), n.column.children && n.column.children.filter ? (uo(), mo(s, {
        key: 1,
        field: i.columnProp("filterField") || i.columnProp("field"),
        type: i.columnProp("dataType"),
        display: "row",
        showMenu: i.columnProp("showFilterMenu"),
        filterElement: n.column.children && n.column.children.filter,
        filterHeaderTemplate: n.column.children && n.column.children.filterheader,
        filterFooterTemplate: n.column.children && n.column.children.filterfooter,
        filterClearTemplate: n.column.children && n.column.children.filterclear,
        filterApplyTemplate: n.column.children && n.column.children.filterapply,
        filterIconTemplate: n.column.children && n.column.children.filtericon,
        filterAddIconTemplate: n.column.children && n.column.children.filteraddicon,
        filterRemoveIconTemplate: n.column.children && n.column.children.filterremoveicon,
        filterClearIconTemplate: n.column.children && n.column.children.filterclearicon,
        filters: n.filters,
        filtersStore: n.filtersStore,
        filterInputProps: n.filterInputProps,
        filterButtonProps: n.filterButtonProps,
        onFilterChange: t[1] || (t[1] = function(t) {
            return e.$emit("filter-change", t)
        }),
        onFilterApply: t[2] || (t[2] = function(t) {
            return e.$emit("filter-apply")
        }),
        filterMenuStyle: i.columnProp("filterMenuStyle"),
        filterMenuClass: i.columnProp("filterMenuClass"),
        showOperator: i.columnProp("showFilterOperator"),
        showClearButton: i.columnProp("showClearButton"),
        showApplyButton: i.columnProp("showApplyButton"),
        showMatchModes: i.columnProp("showFilterMatchModes"),
        showAddButton: i.columnProp("showAddButton"),
        matchModeOptions: i.columnProp("filterMatchModeOptions"),
        maxConstraints: i.columnProp("maxConstraints"),
        onOperatorChange: t[3] || (t[3] = function(t) {
            return e.$emit("operator-change", t)
        }),
        onMatchmodeChange: t[4] || (t[4] = function(t) {
            return e.$emit("matchmode-change", t)
        }),
        onConstraintAdd: t[5] || (t[5] = function(t) {
            return e.$emit("constraint-add", t)
        }),
        onConstraintRemove: t[6] || (t[6] = function(t) {
            return e.$emit("constraint-remove", t)
        }),
        onApplyClick: t[7] || (t[7] = function(t) {
            return e.$emit("apply-click", t)
        }),
        column: n.column,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filterIconTemplate", "filterAddIconTemplate", "filterRemoveIconTemplate", "filterClearIconTemplate", "filters", "filtersStore", "filterInputProps", "filterButtonProps", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints", "column", "unstyled", "pt"])) : Eo("", !0)], 16, GD))
};
var jD = {
    name: "HeaderCell",
    hostName: "DataTable",
    extends: nT,
    emits: ["column-click", "column-mousedown", "column-dragstart", "column-dragover", "column-dragleave", "column-drop", "column-resizestart", "checkbox-change", "filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
    props: {
        column: {
            type: Object,
            default: null
        },
        index: {
            type: Number,
            default: null
        },
        resizableColumns: {
            type: Boolean,
            default: !1
        },
        groupRowsBy: {
            type: [Array, String, Function],
            default: null
        },
        sortMode: {
            type: String,
            default: "single"
        },
        groupRowSortField: {
            type: [String, Function],
            default: null
        },
        sortField: {
            type: [String, Function],
            default: null
        },
        sortOrder: {
            type: Number,
            default: null
        },
        multiSortMeta: {
            type: Array,
            default: null
        },
        allRowsSelected: {
            type: Boolean,
            default: !1
        },
        empty: {
            type: Boolean,
            default: !1
        },
        filterDisplay: {
            type: String,
            default: null
        },
        filters: {
            type: Object,
            default: null
        },
        filtersStore: {
            type: Object,
            default: null
        },
        filterColumn: {
            type: Boolean,
            default: !1
        },
        reorderableColumns: {
            type: Boolean,
            default: !1
        },
        filterInputProps: {
            type: null,
            default: null
        },
        filterButtonProps: {
            type: null,
            default: null
        }
    },
    data: function() {
        return {
            styleObject: {}
        }
    },
    mounted: function() {
        this.columnProp("frozen") && this.updateStickyPosition()
    },
    updated: function() {
        this.columnProp("frozen") && this.updateStickyPosition()
    },
    methods: {
        columnProp: function(e) {
            return zS(this.column, e)
        },
        getColumnPT: function(e) {
            var t,
                n,
                r = {
                    props: this.column.props,
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        index: this.index,
                        sortable: "" === this.columnProp("sortable") || this.columnProp("sortable"),
                        sorted: this.isColumnSorted(),
                        resizable: this.resizableColumns,
                        size: null === (t = this.$parentInstance) || void 0 === t || null === (t = t.$parentInstance) || void 0 === t ? void 0 : t.size,
                        showGridlines: (null === (n = this.$parentInstance) || void 0 === n || null === (n = n.$parentInstance) || void 0 === n ? void 0 : n.showGridlines) || !1
                    }
                };
            return Mo(this.ptm("column.".concat(e), {
                column: r
            }), this.ptm("column.".concat(e), r), this.ptmo(this.getColumnProp(), e, r))
        },
        getColumnProp: function() {
            return this.column.props && this.column.props.pt ? this.column.props.pt : void 0
        },
        onClick: function(e) {
            this.$emit("column-click", {
                originalEvent: e,
                column: this.column
            })
        },
        onKeyDown: function(e) {
            "Enter" !== e.code && "NumpadEnter" !== e.code && "Space" !== e.code || "TH" !== e.currentTarget.nodeName || !BE(e.currentTarget, "data-p-sortable-column") || (this.$emit("column-click", {
                originalEvent: e,
                column: this.column
            }), e.preventDefault())
        },
        onMouseDown: function(e) {
            this.$emit("column-mousedown", {
                originalEvent: e,
                column: this.column
            })
        },
        onDragStart: function(e) {
            this.$emit("column-dragstart", {
                originalEvent: e,
                column: this.column
            })
        },
        onDragOver: function(e) {
            this.$emit("column-dragover", {
                originalEvent: e,
                column: this.column
            })
        },
        onDragLeave: function(e) {
            this.$emit("column-dragleave", {
                originalEvent: e,
                column: this.column
            })
        },
        onDrop: function(e) {
            this.$emit("column-drop", {
                originalEvent: e,
                column: this.column
            })
        },
        onResizeStart: function(e) {
            this.$emit("column-resizestart", e)
        },
        getMultiSortMetaIndex: function() {
            var e = this;
            return this.multiSortMeta.findIndex(function(t) {
                return t.field === e.columnProp("field") || t.field === e.columnProp("sortField")
            })
        },
        getBadgeValue: function() {
            var e = this.getMultiSortMetaIndex();
            return this.groupRowsBy && this.groupRowsBy === this.groupRowSortField && e > -1 ? e : e + 1
        },
        isMultiSorted: function() {
            return "multiple" === this.sortMode && this.columnProp("sortable") && this.getMultiSortMetaIndex() > -1
        },
        isColumnSorted: function() {
            return "single" === this.sortMode ? this.sortField && (this.sortField === this.columnProp("field") || this.sortField === this.columnProp("sortField")) : this.isMultiSorted()
        },
        updateStickyPosition: function() {
            if (this.columnProp("frozen")) {
                if ("right" === this.columnProp("alignFrozen")) {
                    var e = 0,
                        t = NE(this.$el, '[data-p-frozen-column="true"]');
                    t && (e = _E(t) + parseFloat(t.style["inset-inline-end"] || 0)),
                    this.styleObject.insetInlineEnd = e + "px"
                } else {
                    var n = 0,
                        r = QE(this.$el, '[data-p-frozen-column="true"]');
                    r && (n = _E(r) + parseFloat(r.style["inset-inline-start"] || 0)),
                    this.styleObject.insetInlineStart = n + "px"
                }
                var o = this.$el.parentElement.nextElementSibling;
                if (o) {
                    var i = OE(this.$el);
                    o.children[i] && (o.children[i].style["inset-inline-start"] = this.styleObject["inset-inline-start"], o.children[i].style["inset-inline-end"] = this.styleObject["inset-inline-end"])
                }
            }
        },
        onHeaderCheckboxChange: function(e) {
            this.$emit("checkbox-change", e)
        }
    },
    computed: {
        containerClass: function() {
            return [this.cx("headerCell"), this.filterColumn ? this.columnProp("filterHeaderClass") : this.columnProp("headerClass"), this.columnProp("class")]
        },
        containerStyle: function() {
            var e = this.filterColumn ? this.columnProp("filterHeaderStyle") : this.columnProp("headerStyle"),
                t = this.columnProp("style");
            return this.columnProp("frozen") ? [t, e, this.styleObject] : [t, e]
        },
        sortState: function() {
            var e = !1,
                t = null;
            if ("single" === this.sortMode)
                t = (e = this.sortField && (this.sortField === this.columnProp("field") || this.sortField === this.columnProp("sortField"))) ? this.sortOrder : 0;
            else if ("multiple" === this.sortMode) {
                var n = this.getMultiSortMetaIndex();
                n > -1 && (e = !0, t = this.multiSortMeta[n].order)
            }
            return {
                sorted: e,
                sortOrder: t
            }
        },
        sortableColumnIcon: function() {
            var e = this.sortState,
                t = e.sorted,
                n = e.sortOrder;
            return t ? t && n > 0 ? kk : t && n < 0 ? Rk : null : Tk
        },
        ariaSort: function() {
            if (this.columnProp("sortable")) {
                var e = this.sortState,
                    t = e.sorted,
                    n = e.sortOrder;
                return t && n < 0 ? "descending" : t && n > 0 ? "ascending" : "none"
            }
            return null
        }
    },
    components: {
        Badge: hR,
        DTHeaderCheckbox: LD,
        DTColumnFilter: MD,
        SortAltIcon: Tk,
        SortAmountUpAltIcon: kk,
        SortAmountDownIcon: Rk
    }
};
function VD(e) {
    return (VD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function HD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function $D(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? HD(Object(n), !0).forEach(function(t) {
            WD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function WD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != VD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != VD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == VD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var KD = ["tabindex", "colspan", "rowspan", "aria-sort", "data-p-sortable-column", "data-p-resizable-column", "data-p-sorted", "data-p-filter-column", "data-p-frozen-column", "data-p-reorderable-column"];
jD.render = function(e, t, n, r, o, i) {
    var a = jn("Badge"),
        s = jn("DTHeaderCheckbox"),
        l = jn("DTColumnFilter");
    return uo(), go("th", Mo({
        style: i.containerStyle,
        class: i.containerClass,
        tabindex: i.columnProp("sortable") ? "0" : null,
        role: "columnheader",
        colspan: i.columnProp("colspan"),
        rowspan: i.columnProp("rowspan"),
        "aria-sort": i.ariaSort,
        onClick: t[8] || (t[8] = function() {
            return i.onClick && i.onClick.apply(i, arguments)
        }),
        onKeydown: t[9] || (t[9] = function() {
            return i.onKeyDown && i.onKeyDown.apply(i, arguments)
        }),
        onMousedown: t[10] || (t[10] = function() {
            return i.onMouseDown && i.onMouseDown.apply(i, arguments)
        }),
        onDragstart: t[11] || (t[11] = function() {
            return i.onDragStart && i.onDragStart.apply(i, arguments)
        }),
        onDragover: t[12] || (t[12] = function() {
            return i.onDragOver && i.onDragOver.apply(i, arguments)
        }),
        onDragleave: t[13] || (t[13] = function() {
            return i.onDragLeave && i.onDragLeave.apply(i, arguments)
        }),
        onDrop: t[14] || (t[14] = function() {
            return i.onDrop && i.onDrop.apply(i, arguments)
        })
    }, $D($D({}, i.getColumnPT("root")), i.getColumnPT("headerCell")), {
        "data-p-sortable-column": i.columnProp("sortable"),
        "data-p-resizable-column": n.resizableColumns,
        "data-p-sorted": i.isColumnSorted(),
        "data-p-filter-column": n.filterColumn,
        "data-p-frozen-column": i.columnProp("frozen"),
        "data-p-reorderable-column": n.reorderableColumns
    }), [n.resizableColumns && !i.columnProp("frozen") ? (uo(), go("span", Mo({
        key: 0,
        class: e.cx("columnResizer"),
        onMousedown: t[0] || (t[0] = function() {
            return i.onResizeStart && i.onResizeStart.apply(i, arguments)
        })
    }, i.getColumnPT("columnResizer")), null, 16)) : Eo("", !0), _o("div", Mo({
        class: e.cx("columnHeaderContent")
    }, i.getColumnPT("columnHeaderContent")), [n.column.children && n.column.children.header ? (uo(), mo(Hn(n.column.children.header), {
        key: 0,
        column: n.column
    }, null, 8, ["column"])) : Eo("", !0), i.columnProp("header") ? (uo(), go("span", Mo({
        key: 1,
        class: e.cx("columnTitle")
    }, i.getColumnPT("columnTitle")), W(i.columnProp("header")), 17)) : Eo("", !0), i.columnProp("sortable") ? (uo(), go("span", j(Mo({
        key: 2
    }, i.getColumnPT("sort"))), [(uo(), mo(Hn(n.column.children && n.column.children.sorticon || i.sortableColumnIcon), Mo({
        sorted: i.sortState.sorted,
        sortOrder: i.sortState.sortOrder,
        class: e.cx("sortIcon")
    }, i.getColumnPT("sorticon")), null, 16, ["sorted", "sortOrder", "class"]))], 16)) : Eo("", !0), i.isMultiSorted() ? (uo(), mo(a, {
        key: 3,
        class: G(e.cx("pcSortBadge")),
        pt: i.getColumnPT("pcSortBadge"),
        value: i.getBadgeValue(),
        size: "small"
    }, null, 8, ["class", "pt", "value"])) : Eo("", !0), "multiple" === i.columnProp("selectionMode") && "row" !== n.filterDisplay ? (uo(), mo(s, {
        key: 4,
        checked: n.allRowsSelected,
        onChange: i.onHeaderCheckboxChange,
        disabled: n.empty,
        headerCheckboxIconTemplate: n.column.children && n.column.children.headercheckboxicon,
        column: n.column,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["checked", "onChange", "disabled", "headerCheckboxIconTemplate", "column", "unstyled", "pt"])) : Eo("", !0), "menu" === n.filterDisplay && n.column.children && n.column.children.filter ? (uo(), mo(l, {
        key: 5,
        field: i.columnProp("filterField") || i.columnProp("field"),
        type: i.columnProp("dataType"),
        display: "menu",
        showMenu: i.columnProp("showFilterMenu"),
        filterElement: n.column.children && n.column.children.filter,
        filterHeaderTemplate: n.column.children && n.column.children.filterheader,
        filterFooterTemplate: n.column.children && n.column.children.filterfooter,
        filterClearTemplate: n.column.children && n.column.children.filterclear,
        filterApplyTemplate: n.column.children && n.column.children.filterapply,
        filterIconTemplate: n.column.children && n.column.children.filtericon,
        filterAddIconTemplate: n.column.children && n.column.children.filteraddicon,
        filterRemoveIconTemplate: n.column.children && n.column.children.filterremoveicon,
        filterClearIconTemplate: n.column.children && n.column.children.filterclearicon,
        filters: n.filters,
        filtersStore: n.filtersStore,
        filterInputProps: n.filterInputProps,
        filterButtonProps: n.filterButtonProps,
        onFilterChange: t[1] || (t[1] = function(t) {
            return e.$emit("filter-change", t)
        }),
        onFilterApply: t[2] || (t[2] = function(t) {
            return e.$emit("filter-apply")
        }),
        filterMenuStyle: i.columnProp("filterMenuStyle"),
        filterMenuClass: i.columnProp("filterMenuClass"),
        showOperator: i.columnProp("showFilterOperator"),
        showClearButton: i.columnProp("showClearButton"),
        showApplyButton: i.columnProp("showApplyButton"),
        showMatchModes: i.columnProp("showFilterMatchModes"),
        showAddButton: i.columnProp("showAddButton"),
        matchModeOptions: i.columnProp("filterMatchModeOptions"),
        maxConstraints: i.columnProp("maxConstraints"),
        onOperatorChange: t[3] || (t[3] = function(t) {
            return e.$emit("operator-change", t)
        }),
        onMatchmodeChange: t[4] || (t[4] = function(t) {
            return e.$emit("matchmode-change", t)
        }),
        onConstraintAdd: t[5] || (t[5] = function(t) {
            return e.$emit("constraint-add", t)
        }),
        onConstraintRemove: t[6] || (t[6] = function(t) {
            return e.$emit("constraint-remove", t)
        }),
        onApplyClick: t[7] || (t[7] = function(t) {
            return e.$emit("apply-click", t)
        }),
        column: n.column,
        unstyled: e.unstyled,
        pt: e.pt
    }, null, 8, ["field", "type", "showMenu", "filterElement", "filterHeaderTemplate", "filterFooterTemplate", "filterClearTemplate", "filterApplyTemplate", "filterIconTemplate", "filterAddIconTemplate", "filterRemoveIconTemplate", "filterClearIconTemplate", "filters", "filtersStore", "filterInputProps", "filterButtonProps", "filterMenuStyle", "filterMenuClass", "showOperator", "showClearButton", "showApplyButton", "showMatchModes", "showAddButton", "matchModeOptions", "maxConstraints", "column", "unstyled", "pt"])) : Eo("", !0)], 16)], 16, KD)
};
var qD = {
    name: "TableHeader",
    hostName: "DataTable",
    extends: nT,
    emits: ["column-click", "column-mousedown", "column-dragstart", "column-dragover", "column-dragleave", "column-drop", "column-resizestart", "checkbox-change", "filter-change", "filter-apply", "operator-change", "matchmode-change", "constraint-add", "constraint-remove", "filter-clear", "apply-click"],
    props: {
        columnGroup: {
            type: null,
            default: null
        },
        columns: {
            type: null,
            default: null
        },
        rowGroupMode: {
            type: String,
            default: null
        },
        groupRowsBy: {
            type: [Array, String, Function],
            default: null
        },
        resizableColumns: {
            type: Boolean,
            default: !1
        },
        allRowsSelected: {
            type: Boolean,
            default: !1
        },
        empty: {
            type: Boolean,
            default: !1
        },
        sortMode: {
            type: String,
            default: "single"
        },
        groupRowSortField: {
            type: [String, Function],
            default: null
        },
        sortField: {
            type: [String, Function],
            default: null
        },
        sortOrder: {
            type: Number,
            default: null
        },
        multiSortMeta: {
            type: Array,
            default: null
        },
        filterDisplay: {
            type: String,
            default: null
        },
        filters: {
            type: Object,
            default: null
        },
        filtersStore: {
            type: Object,
            default: null
        },
        reorderableColumns: {
            type: Boolean,
            default: !1
        },
        first: {
            type: Number,
            default: 0
        },
        filterInputProps: {
            type: null,
            default: null
        },
        filterButtonProps: {
            type: null,
            default: null
        }
    },
    provide: function() {
        return {
            $rows: this.d_headerRows,
            $columns: this.d_headerColumns
        }
    },
    data: function() {
        return {
            d_headerRows: new US({
                type: "Row"
            }),
            d_headerColumns: new US({
                type: "Column"
            })
        }
    },
    beforeUnmount: function() {
        this.d_headerRows.clear(),
        this.d_headerColumns.clear()
    },
    methods: {
        columnProp: function(e, t) {
            return zS(e, t)
        },
        getColumnGroupPT: function(e) {
            var t,
                n = {
                    props: this.getColumnGroupProps(),
                    parent: {
                        instance: this,
                        props: this.$props,
                        state: this.$data
                    },
                    context: {
                        type: "header",
                        scrollable: null === (t = this.$parentInstance) || void 0 === t || null === (t = t.$parentInstance) || void 0 === t ? void 0 : t.scrollable
                    }
                };
            return Mo(this.ptm("columnGroup.".concat(e), {
                columnGroup: n
            }), this.ptm("columnGroup.".concat(e), n), this.ptmo(this.getColumnGroupProps(), e, n))
        },
        getColumnGroupProps: function() {
            return this.columnGroup && this.columnGroup.props && this.columnGroup.props.pt ? this.columnGroup.props.pt : void 0
        },
        getRowPT: function(e, t, n) {
            var r = {
                props: e.props,
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                },
                context: {
                    index: n
                }
            };
            return Mo(this.ptm("row.".concat(t), {
                row: r
            }), this.ptm("row.".concat(t), r), this.ptmo(this.getRowProp(e), t, r))
        },
        getRowProp: function(e) {
            return e.props && e.props.pt ? e.props.pt : void 0
        },
        getColumnPT: function(e, t, n) {
            var r = {
                props: e.props,
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                },
                context: {
                    index: n
                }
            };
            return Mo(this.ptm("column.".concat(t), {
                column: r
            }), this.ptm("column.".concat(t), r), this.ptmo(this.getColumnProp(e), t, r))
        },
        getColumnProp: function(e) {
            return e.props && e.props.pt ? e.props.pt : void 0
        },
        getFilterColumnHeaderClass: function(e) {
            return [this.cx("headerCell", {
                column: e
            }), this.columnProp(e, "filterHeaderClass"), this.columnProp(e, "class")]
        },
        getFilterColumnHeaderStyle: function(e) {
            return [this.columnProp(e, "filterHeaderStyle"), this.columnProp(e, "style")]
        },
        getHeaderRows: function() {
            var e;
            return null === (e = this.d_headerRows) || void 0 === e ? void 0 : e.get(this.columnGroup, this.columnGroup.children)
        },
        getHeaderColumns: function(e) {
            var t;
            return null === (t = this.d_headerColumns) || void 0 === t ? void 0 : t.get(e, e.children)
        }
    },
    computed: {
        ptmTHeadOptions: function() {
            var e;
            return {
                context: {
                    scrollable: null === (e = this.$parentInstance) || void 0 === e || null === (e = e.$parentInstance) || void 0 === e ? void 0 : e.scrollable
                }
            }
        }
    },
    components: {
        DTHeaderCell: jD,
        DTFilterHeaderCell: ND
    }
};
function XD(e) {
    return (XD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function YD(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function JD(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? YD(Object(n), !0).forEach(function(t) {
            ZD(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YD(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function ZD(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != XD(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != XD(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == XD(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var eP = ["data-p-scrollable"];
qD.render = function(e, t, n, r, o, i) {
    var a,
        s = jn("DTHeaderCell"),
        l = jn("DTFilterHeaderCell");
    return uo(), go("thead", Mo({
        class: e.cx("thead"),
        style: e.sx("thead"),
        role: "rowgroup"
    }, n.columnGroup ? JD(JD({}, e.ptm("thead", i.ptmTHeadOptions)), i.getColumnGroupPT("root")) : e.ptm("thead", i.ptmTHeadOptions), {
        "data-p-scrollable": null === (a = e.$parentInstance) || void 0 === a || null === (a = a.$parentInstance) || void 0 === a ? void 0 : a.scrollable,
        "data-pc-section": "thead"
    }), [n.columnGroup ? (uo(!0), go(oo, {
        key: 1
    }, qn(i.getHeaderRows(), function(r, o) {
        return uo(), go("tr", Mo({
            key: o,
            role: "row"
        }, {
            ref_for: !0
        }, JD(JD({}, e.ptm("headerRow")), i.getRowPT(r, "root", o))), [(uo(!0), go(oo, null, qn(i.getHeaderColumns(r), function(r, o) {
            return uo(), go(oo, {
                key: i.columnProp(r, "columnKey") || i.columnProp(r, "field") || o
            }, [i.columnProp(r, "hidden") || "subheader" === n.rowGroupMode && n.groupRowsBy === i.columnProp(r, "field") || "string" == typeof r.children ? Eo("", !0) : (uo(), mo(s, {
                key: 0,
                column: r,
                onColumnClick: t[15] || (t[15] = function(t) {
                    return e.$emit("column-click", t)
                }),
                onColumnMousedown: t[16] || (t[16] = function(t) {
                    return e.$emit("column-mousedown", t)
                }),
                groupRowsBy: n.groupRowsBy,
                groupRowSortField: n.groupRowSortField,
                sortMode: n.sortMode,
                sortField: n.sortField,
                sortOrder: n.sortOrder,
                multiSortMeta: n.multiSortMeta,
                allRowsSelected: n.allRowsSelected,
                empty: n.empty,
                onCheckboxChange: t[17] || (t[17] = function(t) {
                    return e.$emit("checkbox-change", t)
                }),
                filters: n.filters,
                filterDisplay: n.filterDisplay,
                filtersStore: n.filtersStore,
                filterInputProps: n.filterInputProps,
                filterButtonProps: n.filterButtonProps,
                onFilterChange: t[18] || (t[18] = function(t) {
                    return e.$emit("filter-change", t)
                }),
                onFilterApply: t[19] || (t[19] = function(t) {
                    return e.$emit("filter-apply")
                }),
                onOperatorChange: t[20] || (t[20] = function(t) {
                    return e.$emit("operator-change", t)
                }),
                onMatchmodeChange: t[21] || (t[21] = function(t) {
                    return e.$emit("matchmode-change", t)
                }),
                onConstraintAdd: t[22] || (t[22] = function(t) {
                    return e.$emit("constraint-add", t)
                }),
                onConstraintRemove: t[23] || (t[23] = function(t) {
                    return e.$emit("constraint-remove", t)
                }),
                onApplyClick: t[24] || (t[24] = function(t) {
                    return e.$emit("apply-click", t)
                }),
                unstyled: e.unstyled,
                pt: e.pt
            }, null, 8, ["column", "groupRowsBy", "groupRowSortField", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore", "filterInputProps", "filterButtonProps", "unstyled", "pt"]))], 64)
        }), 128))], 16)
    }), 128)) : (uo(), go("tr", Mo({
        key: 0,
        role: "row"
    }, e.ptm("headerRow")), [(uo(!0), go(oo, null, qn(n.columns, function(r, o) {
        return uo(), go(oo, {
            key: i.columnProp(r, "columnKey") || i.columnProp(r, "field") || o
        }, [i.columnProp(r, "hidden") || "subheader" === n.rowGroupMode && n.groupRowsBy === i.columnProp(r, "field") ? Eo("", !0) : (uo(), mo(s, {
            key: 0,
            column: r,
            index: o,
            onColumnClick: t[0] || (t[0] = function(t) {
                return e.$emit("column-click", t)
            }),
            onColumnMousedown: t[1] || (t[1] = function(t) {
                return e.$emit("column-mousedown", t)
            }),
            onColumnDragstart: t[2] || (t[2] = function(t) {
                return e.$emit("column-dragstart", t)
            }),
            onColumnDragover: t[3] || (t[3] = function(t) {
                return e.$emit("column-dragover", t)
            }),
            onColumnDragleave: t[4] || (t[4] = function(t) {
                return e.$emit("column-dragleave", t)
            }),
            onColumnDrop: t[5] || (t[5] = function(t) {
                return e.$emit("column-drop", t)
            }),
            groupRowsBy: n.groupRowsBy,
            groupRowSortField: n.groupRowSortField,
            reorderableColumns: n.reorderableColumns,
            resizableColumns: n.resizableColumns,
            onColumnResizestart: t[6] || (t[6] = function(t) {
                return e.$emit("column-resizestart", t)
            }),
            sortMode: n.sortMode,
            sortField: n.sortField,
            sortOrder: n.sortOrder,
            multiSortMeta: n.multiSortMeta,
            allRowsSelected: n.allRowsSelected,
            empty: n.empty,
            onCheckboxChange: t[7] || (t[7] = function(t) {
                return e.$emit("checkbox-change", t)
            }),
            filters: n.filters,
            filterDisplay: n.filterDisplay,
            filtersStore: n.filtersStore,
            filterInputProps: n.filterInputProps,
            filterButtonProps: n.filterButtonProps,
            first: n.first,
            onFilterChange: t[8] || (t[8] = function(t) {
                return e.$emit("filter-change", t)
            }),
            onFilterApply: t[9] || (t[9] = function(t) {
                return e.$emit("filter-apply")
            }),
            onOperatorChange: t[10] || (t[10] = function(t) {
                return e.$emit("operator-change", t)
            }),
            onMatchmodeChange: t[11] || (t[11] = function(t) {
                return e.$emit("matchmode-change", t)
            }),
            onConstraintAdd: t[12] || (t[12] = function(t) {
                return e.$emit("constraint-add", t)
            }),
            onConstraintRemove: t[13] || (t[13] = function(t) {
                return e.$emit("constraint-remove", t)
            }),
            onApplyClick: t[14] || (t[14] = function(t) {
                return e.$emit("apply-click", t)
            }),
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["column", "index", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "sortMode", "sortField", "sortOrder", "multiSortMeta", "allRowsSelected", "empty", "filters", "filterDisplay", "filtersStore", "filterInputProps", "filterButtonProps", "first", "unstyled", "pt"]))], 64)
    }), 128))], 16)), "row" === n.filterDisplay ? (uo(), go("tr", Mo({
        key: 2,
        role: "row"
    }, e.ptm("headerRow")), [(uo(!0), go(oo, null, qn(n.columns, function(r, o) {
        return uo(), go(oo, {
            key: i.columnProp(r, "columnKey") || i.columnProp(r, "field") || o
        }, [i.columnProp(r, "hidden") || "subheader" === n.rowGroupMode && n.groupRowsBy === i.columnProp(r, "field") ? Eo("", !0) : (uo(), mo(l, {
            key: 0,
            column: r,
            index: o,
            allRowsSelected: n.allRowsSelected,
            empty: n.empty,
            display: "row",
            filters: n.filters,
            filtersStore: n.filtersStore,
            filterInputProps: n.filterInputProps,
            filterButtonProps: n.filterButtonProps,
            onFilterChange: t[25] || (t[25] = function(t) {
                return e.$emit("filter-change", t)
            }),
            onFilterApply: t[26] || (t[26] = function(t) {
                return e.$emit("filter-apply")
            }),
            onOperatorChange: t[27] || (t[27] = function(t) {
                return e.$emit("operator-change", t)
            }),
            onMatchmodeChange: t[28] || (t[28] = function(t) {
                return e.$emit("matchmode-change", t)
            }),
            onConstraintAdd: t[29] || (t[29] = function(t) {
                return e.$emit("constraint-add", t)
            }),
            onConstraintRemove: t[30] || (t[30] = function(t) {
                return e.$emit("constraint-remove", t)
            }),
            onApplyClick: t[31] || (t[31] = function(t) {
                return e.$emit("apply-click", t)
            }),
            onCheckboxChange: t[32] || (t[32] = function(t) {
                return e.$emit("checkbox-change", t)
            }),
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["column", "index", "allRowsSelected", "empty", "filters", "filtersStore", "filterInputProps", "filterButtonProps", "unstyled", "pt"]))], 64)
    }), 128))], 16)) : Eo("", !0)], 16, eP)
};
var tP = ["expanded"];
function nP(e) {
    return (nP = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function rP(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function oP(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? rP(Object(n), !0).forEach(function(t) {
            iP(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rP(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function iP(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != nP(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != nP(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == nP(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
function aP(e, t) {
    return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r,
                    o,
                    i,
                    a,
                    s = [],
                    l = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t)
                        ;
                    else
                        for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0)
                            ;
                } catch (u) {
                    c = !0,
                    o = u
                } finally {
                    try {
                        if (!l && null != n.return && (a = n.return(), Object(a) !== a))
                            return
                    } finally {
                        if (c)
                            throw o
                    }
                }
                return s
            }
        }(e, t) || cP(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function sP(e, t) {
    var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
        if (Array.isArray(e) || (n = cP(e)) || t) {
            n && (e = n);
            var r = 0,
                o = function() {};
            return {
                s: o,
                n: function() {
                    return r >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[r++]
                    }
                },
                e: function(e) {
                    throw e
                },
                f: o
            }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
    var i,
        a = !0,
        s = !1;
    return {
        s: function() {
            n = n.call(e)
        },
        n: function() {
            var e = n.next();
            return a = e.done, e
        },
        e: function(e) {
            s = !0,
            i = e
        },
        f: function() {
            try {
                a || null == n.return || n.return()
            } finally {
                if (s)
                    throw i
            }
        }
    }
}
function lP(e) {
    return function(e) {
            if (Array.isArray(e))
                return uP(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(e) || cP(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function cP(e, t) {
    if (e) {
        if ("string" == typeof e)
            return uP(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? uP(e, t) : void 0
    }
}
function uP(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var dP = {
    name: "DataTable",
    extends: Pk,
    inheritAttrs: !1,
    emits: ["value-change", "update:first", "update:rows", "page", "update:sortField", "update:sortOrder", "update:multiSortMeta", "sort", "filter", "row-click", "row-dblclick", "update:selection", "row-select", "row-unselect", "update:contextMenuSelection", "row-contextmenu", "row-unselect-all", "row-select-all", "select-all-change", "column-resize-end", "column-reorder", "row-reorder", "update:expandedRows", "row-collapse", "row-expand", "update:expandedRowGroups", "rowgroup-collapse", "rowgroup-expand", "update:filters", "state-restore", "state-save", "cell-edit-init", "cell-edit-complete", "cell-edit-cancel", "update:editingRows", "row-edit-init", "row-edit-save", "row-edit-cancel"],
    provide: function() {
        return {
            $columns: this.d_columns,
            $columnGroups: this.d_columnGroups
        }
    },
    data: function() {
        return {
            d_first: this.first,
            d_rows: this.rows,
            d_sortField: this.sortField,
            d_sortOrder: this.sortOrder,
            d_nullSortOrder: this.nullSortOrder,
            d_multiSortMeta: this.multiSortMeta ? lP(this.multiSortMeta) : [],
            d_groupRowsSortMeta: null,
            d_selectionKeys: null,
            d_columnOrder: null,
            d_editingRowKeys: null,
            d_editingMeta: {},
            d_filters: this.cloneFilters(this.filters),
            d_columns: new US({
                type: "Column"
            }),
            d_columnGroups: new US({
                type: "ColumnGroup"
            })
        }
    },
    rowTouched: !1,
    anchorRowIndex: null,
    rangeRowIndex: null,
    documentColumnResizeListener: null,
    documentColumnResizeEndListener: null,
    lastResizeHelperX: null,
    resizeColumnElement: null,
    columnResizing: !1,
    colReorderIconWidth: null,
    colReorderIconHeight: null,
    draggedColumn: null,
    draggedColumnElement: null,
    draggedRowIndex: null,
    droppedRowIndex: null,
    rowDragging: null,
    columnWidthsState: null,
    tableWidthState: null,
    columnWidthsRestored: !1,
    watch: {
        first: function(e) {
            this.d_first = e
        },
        rows: function(e) {
            this.d_rows = e
        },
        sortField: function(e) {
            this.d_sortField = e
        },
        sortOrder: function(e) {
            this.d_sortOrder = e
        },
        nullSortOrder: function(e) {
            this.d_nullSortOrder = e
        },
        multiSortMeta: function(e) {
            this.d_multiSortMeta = e
        },
        selection: {
            immediate: !0,
            handler: function(e) {
                this.dataKey && this.updateSelectionKeys(e)
            }
        },
        editingRows: {
            immediate: !0,
            handler: function(e) {
                this.dataKey && this.updateEditingRowKeys(e)
            }
        },
        filters: {
            deep: !0,
            handler: function(e) {
                this.d_filters = this.cloneFilters(e)
            }
        }
    },
    mounted: function() {
        this.isStateful() && (this.restoreState(), this.resizableColumns && this.restoreColumnWidths()),
        "row" === this.editMode && this.dataKey && !this.d_editingRowKeys && this.updateEditingRowKeys(this.editingRows)
    },
    beforeUnmount: function() {
        this.unbindColumnResizeEvents(),
        this.destroyStyleElement(),
        this.d_columns.clear(),
        this.d_columnGroups.clear()
    },
    updated: function() {
        this.isStateful() && this.saveState(),
        "row" === this.editMode && this.dataKey && !this.d_editingRowKeys && this.updateEditingRowKeys(this.editingRows)
    },
    methods: {
        columnProp: function(e, t) {
            return zS(e, t)
        },
        onPage: function(e) {
            var t = this;
            this.clearEditingMetaData(),
            this.d_first = e.first,
            this.d_rows = e.rows;
            var n = this.createLazyLoadEvent(e);
            n.pageCount = e.pageCount,
            n.page = e.page,
            this.$emit("update:first", this.d_first),
            this.$emit("update:rows", this.d_rows),
            this.$emit("page", n),
            this.$nextTick(function() {
                t.$emit("value-change", t.processedData)
            })
        },
        onColumnHeaderClick: function(e) {
            var t = this,
                n = e.originalEvent,
                r = e.column;
            if (this.columnProp(r, "sortable")) {
                var o = n.target,
                    i = this.columnProp(r, "sortField") || this.columnProp(r, "field");
                (!0 === BE(o, "data-p-sortable-column") || "columntitle" === BE(o, "data-pc-section") || "columnheadercontent" === BE(o, "data-pc-section") || "sorticon" === BE(o, "data-pc-section") || "sorticon" === BE(o.parentElement, "data-pc-section") || "sorticon" === BE(o.parentElement.parentElement, "data-pc-section") || o.closest('[data-p-sortable-column="true"]') && !o.closest('[data-pc-section="columnfilterbutton"]') && !$E(n.target)) && (EE(), "single" === this.sortMode ? (this.d_sortField === i ? this.removableSort && -1 * this.d_sortOrder === this.defaultSortOrder ? (this.d_sortOrder = null, this.d_sortField = null) : this.d_sortOrder = -1 * this.d_sortOrder : (this.d_sortOrder = this.defaultSortOrder, this.d_sortField = i), this.$emit("update:sortField", this.d_sortField), this.$emit("update:sortOrder", this.d_sortOrder), this.resetPage()) : "multiple" === this.sortMode && (n.metaKey || n.ctrlKey || (this.d_multiSortMeta = this.d_multiSortMeta.filter(function(e) {
                    return e.field === i
                })), this.addMultiSortField(i), this.$emit("update:multiSortMeta", this.d_multiSortMeta)), this.$emit("sort", this.createLazyLoadEvent(n)), this.$nextTick(function() {
                    t.$emit("value-change", t.processedData)
                }))
            }
        },
        sortSingle: function(e) {
            var t = this;
            if (this.clearEditingMetaData(), this.groupRowsBy && this.groupRowsBy === this.sortField)
                return this.d_multiSortMeta = [{
                    field: this.sortField,
                    order: this.sortOrder || this.defaultSortOrder
                }, {
                    field: this.d_sortField,
                    order: this.d_sortOrder
                }], this.sortMultiple(e);
            var n,
                r = lP(e),
                o = new Map,
                i = sP(r);
            try {
                for (i.s(); !(n = i.n()).done;) {
                    var a = n.value;
                    o.set(a, lS(a, this.d_sortField))
                }
            } catch (l) {
                i.e(l)
            } finally {
                i.f()
            }
            var s = vS();
            return r.sort(function(e, n) {
                return ES(o.get(e), o.get(n), t.d_sortOrder, s, t.d_nullSortOrder)
            }), r
        },
        sortMultiple: function(e) {
            var t = this;
            if (this.clearEditingMetaData(), this.groupRowsBy && (this.d_groupRowsSortMeta || this.d_multiSortMeta.length && this.groupRowsBy === this.d_multiSortMeta[0].field)) {
                var n = this.d_multiSortMeta[0];
                !this.d_groupRowsSortMeta && (this.d_groupRowsSortMeta = n),
                n.field !== this.d_groupRowsSortMeta.field && (this.d_multiSortMeta = [this.d_groupRowsSortMeta].concat(lP(this.d_multiSortMeta)))
            }
            var r = lP(e);
            return r.sort(function(e, n) {
                return t.multisortField(e, n, 0)
            }), r
        },
        multisortField: function(e, t, n) {
            var r = lS(e, this.d_multiSortMeta[n].field),
                o = lS(t, this.d_multiSortMeta[n].field),
                i = vS();
            return r === o ? this.d_multiSortMeta.length - 1 > n ? this.multisortField(e, t, n + 1) : 0 : ES(r, o, this.d_multiSortMeta[n].order, i, this.d_nullSortOrder)
        },
        addMultiSortField: function(e) {
            var t = this.d_multiSortMeta.findIndex(function(t) {
                return t.field === e
            });
            t >= 0 ? this.removableSort && -1 * this.d_multiSortMeta[t].order === this.defaultSortOrder ? this.d_multiSortMeta.splice(t, 1) : this.d_multiSortMeta[t] = {
                field: e,
                order: -1 * this.d_multiSortMeta[t].order
            } : this.d_multiSortMeta.push({
                field: e,
                order: this.defaultSortOrder
            }),
            this.d_multiSortMeta = lP(this.d_multiSortMeta)
        },
        getActiveFilters: function(e) {
            var t = Object.entries(e).map(function(e) {
                var t = aP(e, 2),
                    n = t[0],
                    r = t[1];
                if (r.constraints) {
                    var o = r.constraints.filter(function(e) {
                        return null !== e.value
                    });
                    if (o.length > 0)
                        return [n, oP(oP({}, r), {}, {
                            constraints: o
                        })]
                } else if (null !== r.value)
                    return [n, r]
            }).filter(function(e) {
                return void 0 !== e
            });
            return Object.fromEntries(t)
        },
        filter: function(e) {
            var t = this;
            if (e) {
                this.clearEditingMetaData();
                var n,
                    r = this.getActiveFilters(this.filters);
                r.global && (n = this.globalFilterFields || this.columns.map(function(e) {
                    return t.columnProp(e, "filterField") || t.columnProp(e, "field")
                }));
                for (var o = [], i = 0; i < e.length; i++) {
                    var a = !0,
                        s = !1,
                        l = !1;
                    for (var c in r)
                        if (Object.prototype.hasOwnProperty.call(r, c) && "global" !== c) {
                            l = !0;
                            var u = c,
                                d = r[u];
                            if (d.operator) {
                                var p,
                                    h = sP(d.constraints);
                                try {
                                    for (h.s(); !(p = h.n()).done;) {
                                        var f = p.value;
                                        if (a = this.executeLocalFilter(u, e[i], f), "or" === d.operator && a || "and" === d.operator && !a)
                                            break
                                    }
                                } catch (A) {
                                    h.e(A)
                                } finally {
                                    h.f()
                                }
                            } else
                                a = this.executeLocalFilter(u, e[i], d);
                            if (!a)
                                break
                        }
                    if (a && r.global && !s && n)
                        for (var g = 0; g < n.length; g++) {
                            var m = n[g];
                            if (s = HT.filters[r.global.matchMode || zT](lS(e[i], m), r.global.value, this.filterLocale))
                                break
                        }
                    (r.global ? l ? l && a && s : s : l && a) && o.push(e[i])
                }
                o.length !== this.value.length && 0 != Object.keys(r).length || (o = e);
                var b = this.createLazyLoadEvent();
                return b.filteredValue = o, this.$emit("filter", b), this.$emit("value-change", o), o
            }
        },
        executeLocalFilter: function(e, t, n) {
            var r = n.value,
                o = n.matchMode || UT,
                i = lS(t, e);
            return (0, HT.filters[o])(i, r, this.filterLocale)
        },
        onRowClick: function(e) {
            var t = e.originalEvent,
                n = ME(this.$refs.bodyRef && this.$refs.bodyRef.$el, 'tr[data-p-selectable-row="true"][tabindex="0"]');
            if (!$E(t.target)) {
                if (this.$emit("row-click", e), this.selectionMode) {
                    var r = e.data,
                        o = this.d_first + e.index;
                    if (this.isMultipleSelectionMode() && t.shiftKey && null != this.anchorRowIndex)
                        EE(),
                        this.rangeRowIndex = o,
                        this.selectRange(t);
                    else {
                        var i = this.isSelected(r),
                            a = !this.rowTouched && this.metaKeySelection;
                        if (this.anchorRowIndex = o, this.rangeRowIndex = o, a) {
                            var s = t.metaKey || t.ctrlKey;
                            if (i && s) {
                                if (this.isSingleSelectionMode())
                                    this.$emit("update:selection", null);
                                else {
                                    var l = this.findIndexInSelection(r),
                                        c = this.selection.filter(function(e, t) {
                                            return t != l
                                        });
                                    this.$emit("update:selection", c)
                                }
                                this.$emit("row-unselect", {
                                    originalEvent: t,
                                    data: r,
                                    index: o,
                                    type: "row"
                                })
                            } else {
                                if (this.isSingleSelectionMode())
                                    this.$emit("update:selection", r);
                                else if (this.isMultipleSelectionMode()) {
                                    var u = s && this.selection || [];
                                    u = [].concat(lP(u), [r]),
                                    this.$emit("update:selection", u)
                                }
                                this.$emit("row-select", {
                                    originalEvent: t,
                                    data: r,
                                    index: o,
                                    type: "row"
                                })
                            }
                        } else if ("single" === this.selectionMode)
                            i ? (this.$emit("update:selection", null), this.$emit("row-unselect", {
                                originalEvent: t,
                                data: r,
                                index: o,
                                type: "row"
                            })) : (this.$emit("update:selection", r), this.$emit("row-select", {
                                originalEvent: t,
                                data: r,
                                index: o,
                                type: "row"
                            }));
                        else if ("multiple" === this.selectionMode)
                            if (i) {
                                var d = this.findIndexInSelection(r),
                                    p = this.selection.filter(function(e, t) {
                                        return t != d
                                    });
                                this.$emit("update:selection", p),
                                this.$emit("row-unselect", {
                                    originalEvent: t,
                                    data: r,
                                    index: o,
                                    type: "row"
                                })
                            } else {
                                var h = this.selection ? [].concat(lP(this.selection), [r]) : [r];
                                this.$emit("update:selection", h),
                                this.$emit("row-select", {
                                    originalEvent: t,
                                    data: r,
                                    index: o,
                                    type: "row"
                                })
                            }
                    }
                }
                if (this.rowTouched = !1, n) {
                    var f,
                        g;
                    if ("rowtoggleicon" === (null === (f = t.target) || void 0 === f ? void 0 : f.getAttribute("data-pc-section")))
                        return;
                    var m = null === (g = t.currentTarget) || void 0 === g ? void 0 : g.closest('tr[data-p-selectable-row="true"]');
                    n.tabIndex = "-1",
                    m && (m.tabIndex = "0")
                }
            }
        },
        onRowDblClick: function(e) {
            $E(e.originalEvent.target) || this.$emit("row-dblclick", e)
        },
        onRowRightClick: function(e) {
            this.contextMenu && (EE(), e.originalEvent.target.focus()),
            this.$emit("update:contextMenuSelection", e.data),
            this.$emit("row-contextmenu", e)
        },
        onRowTouchEnd: function() {
            this.rowTouched = !0
        },
        onRowKeyDown: function(e, t) {
            var n = e.originalEvent,
                r = e.data,
                o = e.index,
                i = n.metaKey || n.ctrlKey;
            if (this.selectionMode) {
                var a = n.target;
                switch (n.code) {
                case "ArrowDown":
                    this.onArrowDownKey(n, a, o, t);
                    break;
                case "ArrowUp":
                    this.onArrowUpKey(n, a, o, t);
                    break;
                case "Home":
                    this.onHomeKey(n, a, o, t);
                    break;
                case "End":
                    this.onEndKey(n, a, o, t);
                    break;
                case "Enter":
                case "NumpadEnter":
                    this.onEnterKey(n, r, o);
                    break;
                case "Space":
                    this.onSpaceKey(n, r, o, t);
                    break;
                case "Tab":
                    this.onTabKey(n, o);
                    break;
                default:
                    if ("KeyA" === n.code && i && this.isMultipleSelectionMode()) {
                        var s = this.dataToRender(t.rows);
                        this.$emit("update:selection", s)
                    }
                    "KeyC" === n.code && i || n.preventDefault()
                }
            }
        },
        onArrowDownKey: function(e, t, n, r) {
            var o = this.findNextSelectableRow(t);
            if (o && this.focusRowChange(t, o), e.shiftKey) {
                var i = this.dataToRender(r.rows),
                    a = n + 1 >= i.length ? i.length - 1 : n + 1;
                this.onRowClick({
                    originalEvent: e,
                    data: i[a],
                    index: a
                })
            }
            e.preventDefault()
        },
        onArrowUpKey: function(e, t, n, r) {
            var o = this.findPrevSelectableRow(t);
            if (o && this.focusRowChange(t, o), e.shiftKey) {
                var i = this.dataToRender(r.rows),
                    a = n - 1 <= 0 ? 0 : n - 1;
                this.onRowClick({
                    originalEvent: e,
                    data: i[a],
                    index: a
                })
            }
            e.preventDefault()
        },
        onHomeKey: function(e, t, n, r) {
            var o = this.findFirstSelectableRow();
            if (o && this.focusRowChange(t, o), e.ctrlKey && e.shiftKey) {
                var i = this.dataToRender(r.rows);
                this.$emit("update:selection", i.slice(0, n + 1))
            }
            e.preventDefault()
        },
        onEndKey: function(e, t, n, r) {
            var o = this.findLastSelectableRow();
            if (o && this.focusRowChange(t, o), e.ctrlKey && e.shiftKey) {
                var i = this.dataToRender(r.rows);
                this.$emit("update:selection", i.slice(n, i.length))
            }
            e.preventDefault()
        },
        onEnterKey: function(e, t, n) {
            this.onRowClick({
                originalEvent: e,
                data: t,
                index: n
            }),
            e.preventDefault()
        },
        onSpaceKey: function(e, t, n, r) {
            if (this.onEnterKey(e, t, n), e.shiftKey && null !== this.selection) {
                var o,
                    i,
                    a,
                    s = this.dataToRender(r.rows);
                this.selection.length > 0 ? (i = hS(this.selection[0], s), a = hS(this.selection[this.selection.length - 1], s), o = n <= i ? a : i) : o = hS(this.selection, s);
                var l = o !== n ? s.slice(Math.min(o, n), Math.max(o, n) + 1) : t;
                this.$emit("update:selection", l)
            }
        },
        onTabKey: function(e, t) {
            var n = this.$refs.bodyRef && this.$refs.bodyRef.$el,
                r = TE(n, 'tr[data-p-selectable-row="true"]');
            if ("Tab" === e.code && r && r.length > 0) {
                var o = ME(n, 'tr[data-p-selected="true"]'),
                    i = ME(n, 'tr[data-p-selectable-row="true"][tabindex="0"]');
                o ? (o.tabIndex = "0", i && i !== o && (i.tabIndex = "-1")) : (r[0].tabIndex = "0", i !== r[0] && r[t] && (r[t].tabIndex = "-1"))
            }
        },
        findNextSelectableRow: function(e) {
            var t = e.nextElementSibling;
            return t ? !0 === BE(t, "data-p-selectable-row") ? t : this.findNextSelectableRow(t) : null
        },
        findPrevSelectableRow: function(e) {
            var t = e.previousElementSibling;
            return t ? !0 === BE(t, "data-p-selectable-row") ? t : this.findPrevSelectableRow(t) : null
        },
        findFirstSelectableRow: function() {
            return ME(this.$refs.table, 'tr[data-p-selectable-row="true"]')
        },
        findLastSelectableRow: function() {
            var e = TE(this.$refs.table, 'tr[data-p-selectable-row="true"]');
            return e ? e[e.length - 1] : null
        },
        focusRowChange: function(e, t) {
            e.tabIndex = "-1",
            t.tabIndex = "0",
            RE(t)
        },
        toggleRowWithRadio: function(e) {
            var t = e.data;
            this.isSelected(t) ? (this.$emit("update:selection", null), this.$emit("row-unselect", {
                originalEvent: e.originalEvent,
                data: t,
                index: e.index,
                type: "radiobutton"
            })) : (this.$emit("update:selection", t), this.$emit("row-select", {
                originalEvent: e.originalEvent,
                data: t,
                index: e.index,
                type: "radiobutton"
            }))
        },
        toggleRowWithCheckbox: function(e) {
            var t = e.data;
            if (this.isSelected(t)) {
                var n = this.findIndexInSelection(t),
                    r = this.selection.filter(function(e, t) {
                        return t != n
                    });
                this.$emit("update:selection", r),
                this.$emit("row-unselect", {
                    originalEvent: e.originalEvent,
                    data: t,
                    index: e.index,
                    type: "checkbox"
                })
            } else {
                var o = this.selection ? lP(this.selection) : [];
                o = [].concat(lP(o), [t]),
                this.$emit("update:selection", o),
                this.$emit("row-select", {
                    originalEvent: e.originalEvent,
                    data: t,
                    index: e.index,
                    type: "checkbox"
                })
            }
        },
        toggleRowsWithCheckbox: function(e) {
            if (null !== this.selectAll)
                this.$emit("select-all-change", e);
            else {
                var t = e.originalEvent,
                    n = [];
                e.checked ? (n = this.frozenValue ? [].concat(lP(this.frozenValue), lP(this.processedData)) : this.processedData, this.$emit("row-select-all", {
                    originalEvent: t,
                    data: n
                })) : this.$emit("row-unselect-all", {
                    originalEvent: t
                }),
                this.$emit("update:selection", n)
            }
        },
        isSingleSelectionMode: function() {
            return "single" === this.selectionMode
        },
        isMultipleSelectionMode: function() {
            return "multiple" === this.selectionMode
        },
        isSelected: function(e) {
            return !(!e || !this.selection) && (this.dataKey ? !!this.d_selectionKeys && void 0 !== this.d_selectionKeys[lS(e, this.dataKey)] : this.selection instanceof Array ? this.findIndexInSelection(e) > -1 : this.equals(e, this.selection))
        },
        findIndexInSelection: function(e) {
            return this.findIndex(e, this.selection)
        },
        findIndex: function(e, t) {
            var n = -1;
            if (t && t.length)
                for (var r = 0; r < t.length; r++)
                    if (this.equals(e, t[r])) {
                        n = r;
                        break
                    }
            return n
        },
        updateSelectionKeys: function(e) {
            if (this.d_selectionKeys = {}, Array.isArray(e)) {
                var t,
                    n = sP(e);
                try {
                    for (n.s(); !(t = n.n()).done;) {
                        var r = t.value;
                        this.d_selectionKeys[String(lS(r, this.dataKey))] = 1
                    }
                } catch (o) {
                    n.e(o)
                } finally {
                    n.f()
                }
            } else
                this.d_selectionKeys[String(lS(e, this.dataKey))] = 1
        },
        updateEditingRowKeys: function(e) {
            if (e && e.length) {
                this.d_editingRowKeys = {};
                var t,
                    n = sP(e);
                try {
                    for (n.s(); !(t = n.n()).done;) {
                        var r = t.value;
                        this.d_editingRowKeys[String(lS(r, this.dataKey))] = 1
                    }
                } catch (o) {
                    n.e(o)
                } finally {
                    n.f()
                }
            } else
                this.d_editingRowKeys = null
        },
        equals: function(e, t) {
            return "equals" === this.compareSelectionBy ? e === t : cS(e, t, this.dataKey)
        },
        selectRange: function(e) {
            var t,
                n;
            this.rangeRowIndex > this.anchorRowIndex ? (t = this.anchorRowIndex, n = this.rangeRowIndex) : this.rangeRowIndex < this.anchorRowIndex ? (t = this.rangeRowIndex, n = this.anchorRowIndex) : (t = this.rangeRowIndex, n = this.rangeRowIndex),
            this.lazy && this.paginator && (t -= this.d_first, n -= this.d_first);
            for (var r = this.processedData, o = [], i = t; i <= n; i++) {
                var a = r[i];
                o.push(a),
                this.$emit("row-select", {
                    originalEvent: e,
                    data: a,
                    type: "row"
                })
            }
            this.$emit("update:selection", o)
        },
        generateCSV: function(e, t) {
            var n = this,
                r = "\ufeff";
            t || (t = this.processedData, e && e.selectionOnly ? t = this.selection || [] : this.frozenValue && (t = t ? [].concat(lP(this.frozenValue), lP(t)) : this.frozenValue));
            for (var o = !1, i = 0; i < this.columns.length; i++) {
                var a = this.columns[i];
                !1 !== this.columnProp(a, "exportable") && this.columnProp(a, "field") && (o ? r += this.csvSeparator : o = !0, r += '"' + (this.columnProp(a, "exportHeader") || this.columnProp(a, "header") || this.columnProp(a, "field")) + '"')
            }
            t && t.forEach(function(e) {
                r += "\n";
                for (var t = !1, o = 0; o < n.columns.length; o++) {
                    var i = n.columns[o];
                    if (!1 !== n.columnProp(i, "exportable") && n.columnProp(i, "field")) {
                        t ? r += n.csvSeparator : t = !0;
                        var a = lS(e, n.columnProp(i, "field"));
                        a = null != a ? n.exportFunction ? n.exportFunction({
                            data: a,
                            field: n.columnProp(i, "field")
                        }) : String(a).replace(/"/g, '""') : "",
                        r += '"' + a + '"'
                    }
                }
            });
            for (var s = !1, l = 0; l < this.columns.length; l++) {
                var c = this.columns[l];
                0 === l && (r += "\n"),
                !1 !== this.columnProp(c, "exportable") && this.columnProp(c, "exportFooter") && (s ? r += this.csvSeparator : s = !0, r += '"' + (this.columnProp(c, "exportFooter") || this.columnProp(c, "footer") || this.columnProp(c, "field")) + '"')
            }
            return r
        },
        exportCSV: function(e, t) {
            !function(e, t) {
                let n = new Blob([e], {
                    type: "application/csv;charset=utf-8;"
                });
                window.navigator.msSaveOrOpenBlob ? navigator.msSaveOrOpenBlob(n, t + ".csv") : function(e) {
                    if (e) {
                        let t = document.createElement("a");
                        if (void 0 !== t.download) {
                            let {name: n, src: r} = e;
                            return t.setAttribute("href", r), t.setAttribute("download", n), t.style.display = "none", document.body.appendChild(t), t.click(), document.body.removeChild(t), !0
                        }
                    }
                    return !1
                }({
                    name: t + ".csv",
                    src: URL.createObjectURL(n)
                }) || (e = "data:text/csv;charset=utf-8," + e, window.open(encodeURI(e)))
            }(this.generateCSV(e, t), this.exportFilename)
        },
        resetPage: function() {
            this.d_first = 0,
            this.$emit("update:first", this.d_first)
        },
        onColumnResizeStart: function(e) {
            var t = FE(this.$el).left;
            this.resizeColumnElement = e.target.parentElement,
            this.columnResizing = !0,
            this.lastResizeHelperX = e.pageX - t + this.$el.scrollLeft,
            this.bindColumnResizeEvents()
        },
        onColumnResize: function(e) {
            var t = FE(this.$el).left;
            this.$el.setAttribute("data-p-unselectable-text", "true"),
            !this.isUnstyled && vE(this.$el, {
                "user-select": "none"
            }),
            this.$refs.resizeHelper.style.height = this.$el.offsetHeight + "px",
            this.$refs.resizeHelper.style.top = "0px",
            this.$refs.resizeHelper.style.left = e.pageX - t + this.$el.scrollLeft + "px",
            this.$refs.resizeHelper.style.display = "block"
        },
        onColumnResizeEnd: function() {
            var e = AE(this.$el) ? this.lastResizeHelperX - this.$refs.resizeHelper.offsetLeft : this.$refs.resizeHelper.offsetLeft - this.lastResizeHelperX,
                t = this.resizeColumnElement.offsetWidth,
                n = t + e,
                r = this.resizeColumnElement.style.minWidth || 15;
            if (t + e > parseInt(r, 10)) {
                if ("fit" === this.columnResizeMode) {
                    var o = this.resizeColumnElement.nextElementSibling.offsetWidth - e;
                    n > 15 && o > 15 && this.resizeTableCells(n, o)
                } else if ("expand" === this.columnResizeMode) {
                    var i = this.$refs.table.offsetWidth + e + "px",
                        a = function(e) {
                            e && (e.style.width = e.style.minWidth = i)
                        };
                    if (this.resizeTableCells(n), a(this.$refs.table), !this.virtualScrollerDisabled) {
                        var s = this.$refs.bodyRef && this.$refs.bodyRef.$el,
                            l = this.$refs.frozenBodyRef && this.$refs.frozenBodyRef.$el;
                        a(s),
                        a(l)
                    }
                }
                this.$emit("column-resize-end", {
                    element: this.resizeColumnElement,
                    delta: e
                })
            }
            this.$refs.resizeHelper.style.display = "none",
            this.resizeColumn = null,
            this.$el.removeAttribute("data-p-unselectable-text"),
            !this.isUnstyled && (this.$el.style["user-select"] = ""),
            this.unbindColumnResizeEvents(),
            this.isStateful() && this.saveState()
        },
        resizeTableCells: function(e, t) {
            var n = OE(this.resizeColumnElement),
                r = [];
            TE(this.$refs.table, 'thead[data-pc-section="thead"] > tr > th').forEach(function(e) {
                return r.push(_E(e))
            }),
            this.destroyStyleElement(),
            this.createStyleElement();
            var o = "",
                i = '[data-pc-name="datatable"]['.concat(this.$attrSelector, '] > [data-pc-section="tablecontainer"] ').concat(this.virtualScrollerDisabled ? "" : '> [data-pc-name="virtualscroller"]', ' > table[data-pc-section="table"]');
            r.forEach(function(r, a) {
                var s = a === n ? e : t && a === n + 1 ? t : r,
                    l = "width: ".concat(s, "px !important; max-width: ").concat(s, "px !important");
                o += "\n                    ".concat(i, ' > thead[data-pc-section="thead"] > tr > th:nth-child(').concat(a + 1, "),\n                    ").concat(i, ' > tbody[data-pc-section="tbody"] > tr > td:nth-child(').concat(a + 1, "),\n                    ").concat(i, ' > tfoot[data-pc-section="tfoot"] > tr > td:nth-child(').concat(a + 1, ") {\n                        ").concat(l, "\n                    }\n                ")
            }),
            this.styleElement.innerHTML = o
        },
        bindColumnResizeEvents: function() {
            var e = this;
            this.documentColumnResizeListener || (this.documentColumnResizeListener = function(t) {
                e.columnResizing && e.onColumnResize(t)
            }, document.addEventListener("mousemove", this.documentColumnResizeListener)),
            this.documentColumnResizeEndListener || (this.documentColumnResizeEndListener = function() {
                e.columnResizing && (e.columnResizing = !1, e.onColumnResizeEnd())
            }, document.addEventListener("mouseup", this.documentColumnResizeEndListener))
        },
        unbindColumnResizeEvents: function() {
            this.documentColumnResizeListener && (document.removeEventListener("document", this.documentColumnResizeListener), this.documentColumnResizeListener = null),
            this.documentColumnResizeEndListener && (document.removeEventListener("document", this.documentColumnResizeEndListener), this.documentColumnResizeEndListener = null)
        },
        onColumnHeaderMouseDown: function(e) {
            var t = e.originalEvent,
                n = e.column;
            this.reorderableColumns && !1 !== this.columnProp(n, "reorderableColumn") && ("INPUT" === t.target.nodeName || "TEXTAREA" === t.target.nodeName || BE(t.target, '[data-pc-section="columnresizer"]') ? t.currentTarget.draggable = !1 : t.currentTarget.draggable = !0)
        },
        onColumnHeaderDragStart: function(e) {
            var t = e.originalEvent,
                n = e.column;
            this.columnResizing ? t.preventDefault() : (this.colReorderIconWidth = function(e) {
                if (e) {
                    let [t, n] = [e.style.visibility, e.style.display];
                    e.style.visibility = "hidden",
                    e.style.display = "block";
                    let r = e.offsetWidth;
                    return e.style.display = n, e.style.visibility = t, r
                }
                return 0
            }(this.$refs.reorderIndicatorUp), this.colReorderIconHeight = function(e) {
                if (e) {
                    let [t, n] = [e.style.visibility, e.style.display];
                    e.style.visibility = "hidden",
                    e.style.display = "block";
                    let r = e.offsetHeight;
                    return e.style.display = n, e.style.visibility = t, r
                }
                return 0
            }(this.$refs.reorderIndicatorUp), this.draggedColumn = n, this.draggedColumnElement = this.findParentHeader(t.target), t.dataTransfer.setData("text", "b"))
        },
        onColumnHeaderDragOver: function(e) {
            var t = e.originalEvent,
                n = e.column,
                r = this.findParentHeader(t.target);
            if (this.reorderableColumns && this.draggedColumnElement && r && !this.columnProp(n, "frozen")) {
                t.preventDefault();
                var o = FE(this.$el),
                    i = FE(r);
                if (this.draggedColumnElement !== r) {
                    var a = i.left - o.left,
                        s = i.left + r.offsetWidth / 2;
                    this.$refs.reorderIndicatorUp.style.top = i.top - o.top - (this.colReorderIconHeight - 1) + "px",
                    this.$refs.reorderIndicatorDown.style.top = i.top - o.top + r.offsetHeight + "px",
                    t.pageX > s ? (this.$refs.reorderIndicatorUp.style.left = a + r.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + "px", this.$refs.reorderIndicatorDown.style.left = a + r.offsetWidth - Math.ceil(this.colReorderIconWidth / 2) + "px", this.dropPosition = 1) : (this.$refs.reorderIndicatorUp.style.left = a - Math.ceil(this.colReorderIconWidth / 2) + "px", this.$refs.reorderIndicatorDown.style.left = a - Math.ceil(this.colReorderIconWidth / 2) + "px", this.dropPosition = -1),
                    this.$refs.reorderIndicatorUp.style.display = "block",
                    this.$refs.reorderIndicatorDown.style.display = "block"
                }
            }
        },
        onColumnHeaderDragLeave: function(e) {
            var t = e.originalEvent;
            this.reorderableColumns && this.draggedColumnElement && (t.preventDefault(), this.$refs.reorderIndicatorUp.style.display = "none", this.$refs.reorderIndicatorDown.style.display = "none")
        },
        onColumnHeaderDrop: function(e) {
            var t = this,
                n = e.originalEvent,
                r = e.column;
            if (n.preventDefault(), this.draggedColumnElement) {
                var o = OE(this.draggedColumnElement),
                    i = OE(this.findParentHeader(n.target)),
                    a = o !== i;
                if (a && (i - o === 1 && -1 === this.dropPosition || i - o === -1 && 1 === this.dropPosition) && (a = !1), a) {
                    var s = function(e, n) {
                            return t.columnProp(e, "columnKey") || t.columnProp(n, "columnKey") ? t.columnProp(e, "columnKey") === t.columnProp(n, "columnKey") : t.columnProp(e, "field") === t.columnProp(n, "field")
                        },
                        l = this.columns.findIndex(function(e) {
                            return s(e, t.draggedColumn)
                        }),
                        c = this.columns.findIndex(function(e) {
                            return s(e, r)
                        }),
                        u = [];
                    TE(this.$el, 'thead[data-pc-section="thead"] > tr > th').forEach(function(e) {
                        return u.push(_E(e))
                    });
                    var d = u.find(function(e, t) {
                            return t === l
                        }),
                        p = u.filter(function(e, t) {
                            return t !== l
                        }),
                        h = [].concat(lP(p.slice(0, c)), [d], lP(p.slice(c)));
                    this.addColumnWidthStyles(h),
                    c < l && 1 === this.dropPosition && c++,
                    c > l && -1 === this.dropPosition && c--,
                    CS(this.columns, l, c),
                    this.updateReorderableColumns(),
                    this.$emit("column-reorder", {
                        originalEvent: n,
                        dragIndex: l,
                        dropIndex: c
                    })
                }
                this.$refs.reorderIndicatorUp.style.display = "none",
                this.$refs.reorderIndicatorDown.style.display = "none",
                this.draggedColumnElement.draggable = !1,
                this.draggedColumnElement = null,
                this.draggedColumn = null,
                this.dropPosition = null
            }
        },
        findParentHeader: function(e) {
            if ("TH" === e.nodeName)
                return e;
            for (var t = e.parentElement; "TH" !== t.nodeName && (t = t.parentElement);)
                ;
            return t
        },
        findColumnByKey: function(e, t) {
            if (e && e.length)
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    if (this.columnProp(r, "columnKey") === t || this.columnProp(r, "field") === t)
                        return r
                }
            return null
        },
        onRowMouseDown: function(e) {
            "reorderablerowhandle" === BE(e.target, "data-pc-section") || "reorderablerowhandle" === BE(e.target.parentElement, "data-pc-section") ? e.currentTarget.draggable = !0 : e.currentTarget.draggable = !1
        },
        onRowDragStart: function(e) {
            var t = e.originalEvent,
                n = e.index;
            this.rowDragging = !0,
            this.draggedRowIndex = n,
            t.dataTransfer.setData("text", "b")
        },
        onRowDragOver: function(e) {
            var t = e.originalEvent,
                n = e.index;
            if (this.rowDragging && this.draggedRowIndex !== n) {
                var r = t.currentTarget,
                    o = FE(r).top,
                    i = t.pageY,
                    a = o + UE(r) / 2,
                    s = r.previousElementSibling;
                i < a ? (r.setAttribute("data-p-datatable-dragpoint-bottom", "false"), !this.isUnstyled && dE(r, "p-datatable-dragpoint-bottom"), this.droppedRowIndex = n, s ? (s.setAttribute("data-p-datatable-dragpoint-bottom", "true"), !this.isUnstyled && uE(s, "p-datatable-dragpoint-bottom")) : (r.setAttribute("data-p-datatable-dragpoint-top", "true"), !this.isUnstyled && uE(r, "p-datatable-dragpoint-top"))) : (s ? (s.setAttribute("data-p-datatable-dragpoint-bottom", "false"), !this.isUnstyled && dE(s, "p-datatable-dragpoint-bottom")) : (r.setAttribute("data-p-datatable-dragpoint-top", "true"), !this.isUnstyled && uE(r, "p-datatable-dragpoint-top")), this.droppedRowIndex = n + 1, r.setAttribute("data-p-datatable-dragpoint-bottom", "true"), !this.isUnstyled && uE(r, "p-datatable-dragpoint-bottom")),
                t.preventDefault()
            }
        },
        onRowDragLeave: function(e) {
            var t = e.currentTarget,
                n = t.previousElementSibling;
            n && (n.setAttribute("data-p-datatable-dragpoint-bottom", "false"), !this.isUnstyled && dE(n, "p-datatable-dragpoint-bottom")),
            t.setAttribute("data-p-datatable-dragpoint-bottom", "false"),
            !this.isUnstyled && dE(t, "p-datatable-dragpoint-bottom"),
            t.setAttribute("data-p-datatable-dragpoint-top", "false"),
            !this.isUnstyled && dE(t, "p-datatable-dragpoint-top")
        },
        onRowDragEnd: function(e) {
            this.rowDragging = !1,
            this.draggedRowIndex = null,
            this.droppedRowIndex = null,
            e.currentTarget.draggable = !1
        },
        onRowDrop: function(e) {
            if (null != this.droppedRowIndex) {
                var t = this.draggedRowIndex > this.droppedRowIndex ? this.droppedRowIndex : 0 === this.droppedRowIndex ? 0 : this.droppedRowIndex - 1,
                    n = lP(this.processedData);
                CS(n, this.draggedRowIndex + this.d_first, t + this.d_first),
                this.$emit("row-reorder", {
                    originalEvent: e,
                    dragIndex: this.draggedRowIndex,
                    dropIndex: t,
                    value: n
                })
            }
            this.onRowDragLeave(e),
            this.onRowDragEnd(e),
            e.preventDefault()
        },
        toggleRow: function(e) {
            var t,
                n = this,
                r = e.expanded,
                o = function(e, t) {
                    if (null == e)
                        return {};
                    var n,
                        r,
                        o = function(e, t) {
                            if (null == e)
                                return {};
                            var n = {};
                            for (var r in e)
                                if ({}.hasOwnProperty.call(e, r)) {
                                    if (-1 !== t.indexOf(r))
                                        continue;
                                    n[r] = e[r]
                                }
                            return n
                        }(e, t);
                    if (Object.getOwnPropertySymbols) {
                        var i = Object.getOwnPropertySymbols(e);
                        for (r = 0; r < i.length; r++)
                            n = i[r],
                            -1 === t.indexOf(n) && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n])
                    }
                    return o
                }(e, tP),
                i = e.data;
            if (this.dataKey) {
                var a = lS(i, this.dataKey);
                t = this.expandedRows ? oP({}, this.expandedRows) : {},
                r ? t[a] = !0 : delete t[a]
            } else
                t = this.expandedRows ? lP(this.expandedRows) : [],
                r ? t.push(i) : t = t.filter(function(e) {
                    return !n.equals(i, e)
                });
            this.$emit("update:expandedRows", t),
            r ? this.$emit("row-expand", o) : this.$emit("row-collapse", o)
        },
        toggleRowGroup: function(e) {
            var t = e.originalEvent,
                n = e.data,
                r = lS(n, this.groupRowsBy),
                o = this.expandedRowGroups ? lP(this.expandedRowGroups) : [];
            this.isRowGroupExpanded(n) ? (o = o.filter(function(e) {
                return e !== r
            }), this.$emit("update:expandedRowGroups", o), this.$emit("rowgroup-collapse", {
                originalEvent: t,
                data: r
            })) : (o.push(r), this.$emit("update:expandedRowGroups", o), this.$emit("rowgroup-expand", {
                originalEvent: t,
                data: r
            }))
        },
        isRowGroupExpanded: function(e) {
            if (this.expandableRowGroups && this.expandedRowGroups) {
                var t = lS(e, this.groupRowsBy);
                return this.expandedRowGroups.indexOf(t) > -1
            }
            return !1
        },
        isStateful: function() {
            return null != this.stateKey
        },
        getStorage: function() {
            switch (this.stateStorage) {
            case "local":
                return window.localStorage;
            case "session":
                return window.sessionStorage;
            default:
                throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are "local" and "session".')
            }
        },
        saveState: function() {
            var e = this.getStorage(),
                t = {};
            this.paginator && (t.first = this.d_first, t.rows = this.d_rows),
            this.d_sortField && ("function" != typeof this.d_sortField && (t.sortField = this.d_sortField), t.sortOrder = this.d_sortOrder),
            this.d_multiSortMeta && (t.multiSortMeta = this.d_multiSortMeta),
            this.hasFilters && (t.filters = this.filters),
            this.resizableColumns && this.saveColumnWidths(t),
            this.reorderableColumns && (t.columnOrder = this.d_columnOrder),
            this.expandedRows && (t.expandedRows = this.expandedRows),
            this.expandedRowGroups && (t.expandedRowGroups = this.expandedRowGroups),
            this.selection && (t.selection = this.selection, t.selectionKeys = this.d_selectionKeys),
            Object.keys(t).length && e.setItem(this.stateKey, JSON.stringify(t)),
            this.$emit("state-save", t)
        },
        restoreState: function() {
            var e,
                t = this.getStorage(),
                n = t.getItem(this.stateKey),
                r = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
            try {
                e = JSON.parse(n, function(e, t) {
                    return "string" == typeof t && r.test(t) ? new Date(t) : t
                })
            } catch (i) {}
            if (e && "object" === nP(e)) {
                var o = {};
                this.paginator && ("number" == typeof e.first && (this.d_first = e.first, this.$emit("update:first", this.d_first), o.first = this.d_first), "number" == typeof e.rows && (this.d_rows = e.rows, this.$emit("update:rows", this.d_rows), o.rows = this.d_rows)),
                "string" == typeof e.sortField && (this.d_sortField = e.sortField, this.$emit("update:sortField", this.d_sortField), o.sortField = this.d_sortField),
                "number" == typeof e.sortOrder && (this.d_sortOrder = e.sortOrder, this.$emit("update:sortOrder", this.d_sortOrder), o.sortOrder = this.d_sortOrder),
                Array.isArray(e.multiSortMeta) && (this.d_multiSortMeta = e.multiSortMeta, this.$emit("update:multiSortMeta", this.d_multiSortMeta), o.multiSortMeta = this.d_multiSortMeta),
                this.hasFilters && "object" === nP(e.filters) && null !== e.filters && (this.d_filters = this.cloneFilters(e.filters), this.$emit("update:filters", this.d_filters), o.filters = this.d_filters),
                this.resizableColumns && ("string" == typeof e.columnWidths && (this.columnWidthsState = e.columnWidths, o.columnWidths = this.columnWidthsState), "string" == typeof e.tableWidth && (this.tableWidthState = e.tableWidth, o.tableWidth = this.tableWidthState)),
                this.reorderableColumns && Array.isArray(e.columnOrder) && (this.d_columnOrder = e.columnOrder, o.columnOrder = this.d_columnOrder),
                "object" === nP(e.expandedRows) && null !== e.expandedRows && (this.$emit("update:expandedRows", e.expandedRows), o.expandedRows = e.expandedRows),
                Array.isArray(e.expandedRowGroups) && (this.$emit("update:expandedRowGroups", e.expandedRowGroups), o.expandedRowGroups = e.expandedRowGroups),
                "object" === nP(e.selection) && null !== e.selection && ("object" === nP(e.selectionKeys) && null !== e.selectionKeys && (this.d_selectionKeys = e.selectionKeys, o.selectionKeys = this.d_selectionKeys), this.$emit("update:selection", e.selection), o.selection = e.selection),
                this.$emit("state-restore", o)
            } else
                t.removeItem(this.stateKey)
        },
        saveColumnWidths: function(e) {
            var t = [];
            TE(this.$el, 'thead[data-pc-section="thead"] > tr > th').forEach(function(e) {
                return t.push(_E(e))
            }),
            e.columnWidths = t.join(","),
            "expand" === this.columnResizeMode && (e.tableWidth = _E(this.$refs.table) + "px")
        },
        addColumnWidthStyles: function(e) {
            this.createStyleElement();
            var t = "",
                n = '[data-pc-name="datatable"]['.concat(this.$attrSelector, '] > [data-pc-section="tablecontainer"] ').concat(this.virtualScrollerDisabled ? "" : '> [data-pc-name="virtualscroller"]', ' > table[data-pc-section="table"]');
            e.forEach(function(e, r) {
                var o = "width: ".concat(e, "px !important; max-width: ").concat(e, "px !important");
                t += "\n        ".concat(n, ' > thead[data-pc-section="thead"] > tr > th:nth-child(').concat(r + 1, "),\n        ").concat(n, ' > tbody[data-pc-section="tbody"] > tr > td:nth-child(').concat(r + 1, "),\n        ").concat(n, ' > tfoot[data-pc-section="tfoot"] > tr > td:nth-child(').concat(r + 1, ") {\n            ").concat(o, "\n        }\n    ")
            }),
            this.styleElement.innerHTML = t
        },
        restoreColumnWidths: function() {
            if (this.columnWidthsState) {
                var e = this.columnWidthsState.split(",");
                "expand" === this.columnResizeMode && this.tableWidthState && (this.$refs.table.style.width = this.tableWidthState, this.$refs.table.style.minWidth = this.tableWidthState),
                sS(e) && this.addColumnWidthStyles(e)
            }
        },
        onCellEditInit: function(e) {
            this.$emit("cell-edit-init", e)
        },
        onCellEditComplete: function(e) {
            this.$emit("cell-edit-complete", e)
        },
        onCellEditCancel: function(e) {
            this.$emit("cell-edit-cancel", e)
        },
        onRowEditInit: function(e) {
            var t = this.editingRows ? lP(this.editingRows) : [];
            t.push(e.data),
            this.$emit("update:editingRows", t),
            this.$emit("row-edit-init", e)
        },
        onRowEditSave: function(e) {
            var t = lP(this.editingRows);
            t.splice(this.findIndex(e.data, t), 1),
            this.$emit("update:editingRows", t),
            this.$emit("row-edit-save", e)
        },
        onRowEditCancel: function(e) {
            var t = lP(this.editingRows);
            t.splice(this.findIndex(e.data, t), 1),
            this.$emit("update:editingRows", t),
            this.$emit("row-edit-cancel", e)
        },
        onEditingMetaChange: function(e) {
            var t = e.data,
                n = e.field,
                r = e.index,
                o = e.editing,
                i = oP({}, this.d_editingMeta),
                a = i[r];
            if (o)
                !a && (a = i[r] = {
                    data: oP({}, t),
                    fields: []
                }),
                a.fields.push(n);
            else if (a) {
                var s = a.fields.filter(function(e) {
                    return e !== n
                });
                s.length ? a.fields = s : delete i[r]
            }
            this.d_editingMeta = i
        },
        clearEditingMetaData: function() {
            this.editMode && (this.d_editingMeta = {})
        },
        createLazyLoadEvent: function(e) {
            return {
                originalEvent: e,
                first: this.d_first,
                rows: this.d_rows,
                sortField: this.d_sortField,
                sortOrder: this.d_sortOrder,
                multiSortMeta: this.d_multiSortMeta,
                filters: this.d_filters
            }
        },
        hasGlobalFilter: function() {
            return this.filters && Object.prototype.hasOwnProperty.call(this.filters, "global")
        },
        onFilterChange: function(e) {
            this.d_filters = e
        },
        onFilterApply: function() {
            this.d_first = 0,
            this.$emit("update:first", this.d_first),
            this.$emit("update:filters", this.d_filters),
            this.lazy && this.$emit("filter", this.createLazyLoadEvent())
        },
        cloneFilters: function(e) {
            var t = {};
            return e && Object.entries(e).forEach(function(e) {
                var n = aP(e, 2),
                    r = n[0],
                    o = n[1];
                t[r] = o.operator ? {
                    operator: o.operator,
                    constraints: o.constraints.map(function(e) {
                        return oP({}, e)
                    })
                } : oP({}, o)
            }), t
        },
        updateReorderableColumns: function() {
            var e = this,
                t = [];
            this.columns.forEach(function(n) {
                return t.push(e.columnProp(n, "columnKey") || e.columnProp(n, "field"))
            }),
            this.d_columnOrder = t
        },
        createStyleElement: function() {
            var e;
            this.styleElement = document.createElement("style"),
            this.styleElement.type = "text/css",
            YE(this.styleElement, "nonce", null === (e = this.$primevue) || void 0 === e || null === (e = e.config) || void 0 === e || null === (e = e.csp) || void 0 === e ? void 0 : e.nonce),
            document.head.appendChild(this.styleElement)
        },
        destroyStyleElement: function() {
            this.styleElement && (document.head.removeChild(this.styleElement), this.styleElement = null)
        },
        dataToRender: function(e) {
            var t = e || this.processedData;
            if (t && this.paginator) {
                var n = this.lazy ? 0 : this.d_first;
                return t.slice(n, n + this.d_rows)
            }
            return t
        },
        getVirtualScrollerRef: function() {
            return this.$refs.virtualScroller
        },
        hasSpacerStyle: function(e) {
            return sS(e)
        }
    },
    computed: {
        columns: function() {
            var e = this.d_columns.get(this);
            if (e && this.reorderableColumns && this.d_columnOrder) {
                var t,
                    n = [],
                    r = sP(this.d_columnOrder);
                try {
                    for (r.s(); !(t = r.n()).done;) {
                        var o = t.value,
                            i = this.findColumnByKey(e, o);
                        i && !this.columnProp(i, "hidden") && n.push(i)
                    }
                } catch (a) {
                    r.e(a)
                } finally {
                    r.f()
                }
                return [].concat(n, lP(e.filter(function(e) {
                    return n.indexOf(e) < 0
                })))
            }
            return e
        },
        columnGroups: function() {
            return this.d_columnGroups.get(this)
        },
        headerColumnGroup: function() {
            var e,
                t = this;
            return null === (e = this.columnGroups) || void 0 === e ? void 0 : e.find(function(e) {
                return "header" === t.columnProp(e, "type")
            })
        },
        footerColumnGroup: function() {
            var e,
                t = this;
            return null === (e = this.columnGroups) || void 0 === e ? void 0 : e.find(function(e) {
                return "footer" === t.columnProp(e, "type")
            })
        },
        hasFilters: function() {
            return this.filters && Object.keys(this.filters).length > 0 && this.filters.constructor === Object
        },
        processedData: function() {
            var e,
                t = this.value || [];
            return this.lazy || null !== (e = this.virtualScrollerOptions) && void 0 !== e && e.lazy || t && t.length && (this.hasFilters && (t = this.filter(t)), this.sorted && ("single" === this.sortMode ? t = this.sortSingle(t) : "multiple" === this.sortMode && (t = this.sortMultiple(t)))), t
        },
        totalRecordsLength: function() {
            if (this.lazy)
                return this.totalRecords;
            var e = this.processedData;
            return e ? e.length : 0
        },
        empty: function() {
            var e = this.processedData;
            return !e || 0 === e.length
        },
        paginatorTop: function() {
            return this.paginator && ("bottom" !== this.paginatorPosition || "both" === this.paginatorPosition)
        },
        paginatorBottom: function() {
            return this.paginator && ("top" !== this.paginatorPosition || "both" === this.paginatorPosition)
        },
        sorted: function() {
            return this.d_sortField || this.d_multiSortMeta && this.d_multiSortMeta.length > 0
        },
        allRowsSelected: function() {
            var e = this;
            if (null !== this.selectAll)
                return this.selectAll;
            var t = this.frozenValue ? [].concat(lP(this.frozenValue), lP(this.processedData)) : this.processedData;
            return sS(t) && this.selection && Array.isArray(this.selection) && t.every(function(t) {
                    return e.selection.some(function(n) {
                        return e.equals(n, t)
                    })
                })
        },
        groupRowSortField: function() {
            return "single" === this.sortMode ? this.sortField : this.d_groupRowsSortMeta ? this.d_groupRowsSortMeta.field : null
        },
        headerFilterButtonProps: function() {
            return oP(oP({
                filter: {
                    severity: "secondary",
                    text: !0,
                    rounded: !0
                }
            }, this.filterButtonProps), {}, {
                inline: oP({
                    clear: {
                        severity: "secondary",
                        text: !0,
                        rounded: !0
                    }
                }, this.filterButtonProps.inline),
                popover: oP({
                    addRule: {
                        severity: "info",
                        text: !0,
                        size: "small"
                    },
                    removeRule: {
                        severity: "danger",
                        text: !0,
                        size: "small"
                    },
                    apply: {
                        size: "small"
                    },
                    clear: {
                        outlined: !0,
                        size: "small"
                    }
                }, this.filterButtonProps.popover)
            })
        },
        rowEditButtonProps: function() {
            return oP(oP({}, {
                init: {
                    severity: "secondary",
                    text: !0,
                    rounded: !0
                },
                save: {
                    severity: "secondary",
                    text: !0,
                    rounded: !0
                },
                cancel: {
                    severity: "secondary",
                    text: !0,
                    rounded: !0
                }
            }), this.editButtonProps)
        },
        virtualScrollerDisabled: function() {
            return rS(this.virtualScrollerOptions) || !this.scrollable
        },
        dataP: function() {
            return RS(iP(iP(iP({
                scrollable: this.scrollable,
                "flex-scrollable": this.scrollable && "flex" === this.scrollHeight
            }, this.size, this.size), "loading", this.loading), "empty", this.empty))
        }
    },
    components: {
        DTPaginator: tk,
        DTTableHeader: qD,
        DTTableBody: uD,
        DTTableFooter: yD,
        DTVirtualScroller: gM,
        ArrowDownIcon: cB,
        ArrowUpIcon: dB,
        SpinnerIcon: eM
    }
};
function pP(e) {
    return (pP = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function hP(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function fP(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? hP(Object(n), !0).forEach(function(t) {
            gP(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hP(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function gP(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != pP(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != pP(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == pP(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var mP = ["data-p"],
    bP = ["data-p"];
dP.render = function(e, t, n, r, o, i) {
    var a = jn("SpinnerIcon"),
        s = jn("DTPaginator"),
        l = jn("DTTableHeader"),
        c = jn("DTTableBody"),
        u = jn("DTTableFooter"),
        d = jn("DTVirtualScroller");
    return uo(), go("div", Mo({
        class: e.cx("root"),
        "data-scrollselectors": ".p-datatable-wrapper",
        "data-p": i.dataP
    }, e.ptmi("root")), [Yn(e.$slots, "default"), e.loading ? (uo(), go("div", Mo({
        key: 0,
        class: e.cx("mask")
    }, e.ptm("mask")), [e.$slots.loading ? Yn(e.$slots, "loading", {
        key: 0
    }) : (uo(), go(oo, {
        key: 1
    }, [e.$slots.loadingicon ? (uo(), mo(Hn(e.$slots.loadingicon), {
        key: 0,
        class: G(e.cx("loadingIcon"))
    }, null, 8, ["class"])) : e.loadingIcon ? (uo(), go("i", Mo({
        key: 1,
        class: [e.cx("loadingIcon"), "pi-spin", e.loadingIcon]
    }, e.ptm("loadingIcon")), null, 16)) : (uo(), mo(a, Mo({
        key: 2,
        spin: "",
        class: e.cx("loadingIcon")
    }, e.ptm("loadingIcon")), null, 16, ["class"]))], 64))], 16)) : Eo("", !0), e.$slots.header ? (uo(), go("div", Mo({
        key: 1,
        class: e.cx("header")
    }, e.ptm("header")), [Yn(e.$slots, "header")], 16)) : Eo("", !0), i.paginatorTop ? (uo(), mo(s, {
        key: 2,
        rows: o.d_rows,
        first: o.d_first,
        totalRecords: i.totalRecordsLength,
        pageLinkSize: e.pageLinkSize,
        template: e.paginatorTemplate,
        rowsPerPageOptions: e.rowsPerPageOptions,
        currentPageReportTemplate: e.currentPageReportTemplate,
        class: G(e.cx("pcPaginator", {
            position: "top"
        })),
        onPage: t[0] || (t[0] = function(e) {
            return i.onPage(e)
        }),
        alwaysShow: e.alwaysShowPaginator,
        unstyled: e.unstyled,
        "data-p-top": !0,
        pt: e.ptm("pcPaginator")
    }, Xn({
        _: 2
    }, [e.$slots.paginatorcontainer ? {
        name: "container",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorcontainer", {
                first: t.first,
                last: t.last,
                rows: t.rows,
                page: t.page,
                pageCount: t.pageCount,
                pageLinks: t.pageLinks,
                totalRecords: t.totalRecords,
                firstPageCallback: t.firstPageCallback,
                lastPageCallback: t.lastPageCallback,
                prevPageCallback: t.prevPageCallback,
                nextPageCallback: t.nextPageCallback,
                rowChangeCallback: t.rowChangeCallback,
                changePageCallback: t.changePageCallback
            })]
        }),
        key: "0"
    } : void 0, e.$slots.paginatorstart ? {
        name: "start",
        fn: Vt(function() {
            return [Yn(e.$slots, "paginatorstart")]
        }),
        key: "1"
    } : void 0, e.$slots.paginatorend ? {
        name: "end",
        fn: Vt(function() {
            return [Yn(e.$slots, "paginatorend")]
        }),
        key: "2"
    } : void 0, e.$slots.paginatorfirstpagelinkicon ? {
        name: "firstpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorfirstpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "3"
    } : void 0, e.$slots.paginatorprevpagelinkicon ? {
        name: "prevpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorprevpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "4"
    } : void 0, e.$slots.paginatornextpagelinkicon ? {
        name: "nextpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatornextpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "5"
    } : void 0, e.$slots.paginatorlastpagelinkicon ? {
        name: "lastpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorlastpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "6"
    } : void 0, e.$slots.paginatorjumptopagedropdownicon ? {
        name: "jumptopagedropdownicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorjumptopagedropdownicon", {
                class: G(t.class)
            })]
        }),
        key: "7"
    } : void 0, e.$slots.paginatorrowsperpagedropdownicon ? {
        name: "rowsperpagedropdownicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorrowsperpagedropdownicon", {
                class: G(t.class)
            })]
        }),
        key: "8"
    } : void 0]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "class", "alwaysShow", "unstyled", "pt"])) : Eo("", !0), _o("div", Mo({
        class: e.cx("tableContainer"),
        style: [e.sx("tableContainer"), {
            maxHeight: i.virtualScrollerDisabled ? e.scrollHeight : ""
        }],
        "data-p": i.dataP
    }, e.ptm("tableContainer")), [xo(d, Mo({
        ref: "virtualScroller"
    }, e.virtualScrollerOptions, {
        items: i.processedData,
        columns: i.columns,
        style: "flex" !== e.scrollHeight ? {
            height: e.scrollHeight
        } : void 0,
        scrollHeight: "flex" !== e.scrollHeight ? void 0 : "100%",
        disabled: i.virtualScrollerDisabled,
        loaderDisabled: "",
        inline: "",
        autoSize: "",
        showSpacer: !1,
        pt: e.ptm("virtualScroller")
    }), {
        content: Vt(function(n) {
            return [_o("table", Mo({
                ref: "table",
                role: "table",
                class: [e.cx("table"), e.tableClass],
                style: [e.tableStyle, n.spacerStyle]
            }, fP(fP({}, e.tableProps), e.ptm("table"))), [e.showHeaders ? (uo(), mo(l, {
                key: 0,
                columnGroup: i.headerColumnGroup,
                columns: n.columns,
                rowGroupMode: e.rowGroupMode,
                groupRowsBy: e.groupRowsBy,
                groupRowSortField: i.groupRowSortField,
                reorderableColumns: e.reorderableColumns,
                resizableColumns: e.resizableColumns,
                allRowsSelected: i.allRowsSelected,
                empty: i.empty,
                sortMode: e.sortMode,
                sortField: o.d_sortField,
                sortOrder: o.d_sortOrder,
                multiSortMeta: o.d_multiSortMeta,
                filters: o.d_filters,
                filtersStore: e.filters,
                filterDisplay: e.filterDisplay,
                filterButtonProps: i.headerFilterButtonProps,
                filterInputProps: e.filterInputProps,
                first: o.d_first,
                onColumnClick: t[1] || (t[1] = function(e) {
                    return i.onColumnHeaderClick(e)
                }),
                onColumnMousedown: t[2] || (t[2] = function(e) {
                    return i.onColumnHeaderMouseDown(e)
                }),
                onFilterChange: i.onFilterChange,
                onFilterApply: i.onFilterApply,
                onColumnDragstart: t[3] || (t[3] = function(e) {
                    return i.onColumnHeaderDragStart(e)
                }),
                onColumnDragover: t[4] || (t[4] = function(e) {
                    return i.onColumnHeaderDragOver(e)
                }),
                onColumnDragleave: t[5] || (t[5] = function(e) {
                    return i.onColumnHeaderDragLeave(e)
                }),
                onColumnDrop: t[6] || (t[6] = function(e) {
                    return i.onColumnHeaderDrop(e)
                }),
                onColumnResizestart: t[7] || (t[7] = function(e) {
                    return i.onColumnResizeStart(e)
                }),
                onCheckboxChange: t[8] || (t[8] = function(e) {
                    return i.toggleRowsWithCheckbox(e)
                }),
                unstyled: e.unstyled,
                pt: e.pt
            }, null, 8, ["columnGroup", "columns", "rowGroupMode", "groupRowsBy", "groupRowSortField", "reorderableColumns", "resizableColumns", "allRowsSelected", "empty", "sortMode", "sortField", "sortOrder", "multiSortMeta", "filters", "filtersStore", "filterDisplay", "filterButtonProps", "filterInputProps", "first", "onFilterChange", "onFilterApply", "unstyled", "pt"])) : Eo("", !0), e.frozenValue ? (uo(), mo(c, {
                key: 1,
                ref: "frozenBodyRef",
                value: e.frozenValue,
                frozenRow: !0,
                columns: n.columns,
                first: o.d_first,
                dataKey: e.dataKey,
                selection: e.selection,
                selectionKeys: o.d_selectionKeys,
                selectionMode: e.selectionMode,
                rowHover: e.rowHover,
                contextMenu: e.contextMenu,
                contextMenuSelection: e.contextMenuSelection,
                rowGroupMode: e.rowGroupMode,
                groupRowsBy: e.groupRowsBy,
                expandableRowGroups: e.expandableRowGroups,
                rowClass: e.rowClass,
                rowStyle: e.rowStyle,
                editMode: e.editMode,
                compareSelectionBy: e.compareSelectionBy,
                scrollable: e.scrollable,
                expandedRowIcon: e.expandedRowIcon,
                collapsedRowIcon: e.collapsedRowIcon,
                expandedRows: e.expandedRows,
                expandedRowGroups: e.expandedRowGroups,
                editingRows: e.editingRows,
                editingRowKeys: o.d_editingRowKeys,
                templates: e.$slots,
                editButtonProps: i.rowEditButtonProps,
                isVirtualScrollerDisabled: !0,
                onRowgroupToggle: i.toggleRowGroup,
                onRowClick: t[9] || (t[9] = function(e) {
                    return i.onRowClick(e)
                }),
                onRowDblclick: t[10] || (t[10] = function(e) {
                    return i.onRowDblClick(e)
                }),
                onRowRightclick: t[11] || (t[11] = function(e) {
                    return i.onRowRightClick(e)
                }),
                onRowTouchend: i.onRowTouchEnd,
                onRowKeydown: i.onRowKeyDown,
                onRowMousedown: i.onRowMouseDown,
                onRowDragstart: t[12] || (t[12] = function(e) {
                    return i.onRowDragStart(e)
                }),
                onRowDragover: t[13] || (t[13] = function(e) {
                    return i.onRowDragOver(e)
                }),
                onRowDragleave: t[14] || (t[14] = function(e) {
                    return i.onRowDragLeave(e)
                }),
                onRowDragend: t[15] || (t[15] = function(e) {
                    return i.onRowDragEnd(e)
                }),
                onRowDrop: t[16] || (t[16] = function(e) {
                    return i.onRowDrop(e)
                }),
                onRowToggle: t[17] || (t[17] = function(e) {
                    return i.toggleRow(e)
                }),
                onRadioChange: t[18] || (t[18] = function(e) {
                    return i.toggleRowWithRadio(e)
                }),
                onCheckboxChange: t[19] || (t[19] = function(e) {
                    return i.toggleRowWithCheckbox(e)
                }),
                onCellEditInit: t[20] || (t[20] = function(e) {
                    return i.onCellEditInit(e)
                }),
                onCellEditComplete: t[21] || (t[21] = function(e) {
                    return i.onCellEditComplete(e)
                }),
                onCellEditCancel: t[22] || (t[22] = function(e) {
                    return i.onCellEditCancel(e)
                }),
                onRowEditInit: t[23] || (t[23] = function(e) {
                    return i.onRowEditInit(e)
                }),
                onRowEditSave: t[24] || (t[24] = function(e) {
                    return i.onRowEditSave(e)
                }),
                onRowEditCancel: t[25] || (t[25] = function(e) {
                    return i.onRowEditCancel(e)
                }),
                editingMeta: o.d_editingMeta,
                onEditingMetaChange: i.onEditingMetaChange,
                unstyled: e.unstyled,
                pt: e.pt
            }, null, 8, ["value", "columns", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "rowHover", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange", "unstyled", "pt"])) : Eo("", !0), xo(c, {
                ref: "bodyRef",
                value: i.dataToRender(n.rows),
                class: G(n.styleClass),
                columns: n.columns,
                empty: i.empty,
                first: o.d_first,
                dataKey: e.dataKey,
                selection: e.selection,
                selectionKeys: o.d_selectionKeys,
                selectionMode: e.selectionMode,
                rowHover: e.rowHover,
                contextMenu: e.contextMenu,
                contextMenuSelection: e.contextMenuSelection,
                rowGroupMode: e.rowGroupMode,
                groupRowsBy: e.groupRowsBy,
                expandableRowGroups: e.expandableRowGroups,
                rowClass: e.rowClass,
                rowStyle: e.rowStyle,
                editMode: e.editMode,
                compareSelectionBy: e.compareSelectionBy,
                scrollable: e.scrollable,
                expandedRowIcon: e.expandedRowIcon,
                collapsedRowIcon: e.collapsedRowIcon,
                expandedRows: e.expandedRows,
                expandedRowGroups: e.expandedRowGroups,
                editingRows: e.editingRows,
                editingRowKeys: o.d_editingRowKeys,
                templates: e.$slots,
                editButtonProps: i.rowEditButtonProps,
                virtualScrollerContentProps: n,
                isVirtualScrollerDisabled: i.virtualScrollerDisabled,
                onRowgroupToggle: i.toggleRowGroup,
                onRowClick: t[26] || (t[26] = function(e) {
                    return i.onRowClick(e)
                }),
                onRowDblclick: t[27] || (t[27] = function(e) {
                    return i.onRowDblClick(e)
                }),
                onRowRightclick: t[28] || (t[28] = function(e) {
                    return i.onRowRightClick(e)
                }),
                onRowTouchend: i.onRowTouchEnd,
                onRowKeydown: function(e) {
                    return i.onRowKeyDown(e, n)
                },
                onRowMousedown: i.onRowMouseDown,
                onRowDragstart: t[29] || (t[29] = function(e) {
                    return i.onRowDragStart(e)
                }),
                onRowDragover: t[30] || (t[30] = function(e) {
                    return i.onRowDragOver(e)
                }),
                onRowDragleave: t[31] || (t[31] = function(e) {
                    return i.onRowDragLeave(e)
                }),
                onRowDragend: t[32] || (t[32] = function(e) {
                    return i.onRowDragEnd(e)
                }),
                onRowDrop: t[33] || (t[33] = function(e) {
                    return i.onRowDrop(e)
                }),
                onRowToggle: t[34] || (t[34] = function(e) {
                    return i.toggleRow(e)
                }),
                onRadioChange: t[35] || (t[35] = function(e) {
                    return i.toggleRowWithRadio(e)
                }),
                onCheckboxChange: t[36] || (t[36] = function(e) {
                    return i.toggleRowWithCheckbox(e)
                }),
                onCellEditInit: t[37] || (t[37] = function(e) {
                    return i.onCellEditInit(e)
                }),
                onCellEditComplete: t[38] || (t[38] = function(e) {
                    return i.onCellEditComplete(e)
                }),
                onCellEditCancel: t[39] || (t[39] = function(e) {
                    return i.onCellEditCancel(e)
                }),
                onRowEditInit: t[40] || (t[40] = function(e) {
                    return i.onRowEditInit(e)
                }),
                onRowEditSave: t[41] || (t[41] = function(e) {
                    return i.onRowEditSave(e)
                }),
                onRowEditCancel: t[42] || (t[42] = function(e) {
                    return i.onRowEditCancel(e)
                }),
                editingMeta: o.d_editingMeta,
                onEditingMetaChange: i.onEditingMetaChange,
                unstyled: e.unstyled,
                pt: e.pt
            }, null, 8, ["value", "class", "columns", "empty", "first", "dataKey", "selection", "selectionKeys", "selectionMode", "rowHover", "contextMenu", "contextMenuSelection", "rowGroupMode", "groupRowsBy", "expandableRowGroups", "rowClass", "rowStyle", "editMode", "compareSelectionBy", "scrollable", "expandedRowIcon", "collapsedRowIcon", "expandedRows", "expandedRowGroups", "editingRows", "editingRowKeys", "templates", "editButtonProps", "virtualScrollerContentProps", "isVirtualScrollerDisabled", "onRowgroupToggle", "onRowTouchend", "onRowKeydown", "onRowMousedown", "editingMeta", "onEditingMetaChange", "unstyled", "pt"]), i.hasSpacerStyle(n.spacerStyle) ? (uo(), go("tbody", Mo({
                key: 2,
                class: e.cx("virtualScrollerSpacer"),
                style: {
                    height: "calc(".concat(n.spacerStyle.height, " - ").concat(n.rows.length * n.itemSize, "px)")
                }
            }, e.ptm("virtualScrollerSpacer")), null, 16)) : Eo("", !0), xo(u, {
                columnGroup: i.footerColumnGroup,
                columns: n.columns,
                pt: e.pt
            }, null, 8, ["columnGroup", "columns", "pt"])], 16)]
        }),
        _: 1
    }, 16, ["items", "columns", "style", "scrollHeight", "disabled", "pt"])], 16, bP), i.paginatorBottom ? (uo(), mo(s, {
        key: 3,
        rows: o.d_rows,
        first: o.d_first,
        totalRecords: i.totalRecordsLength,
        pageLinkSize: e.pageLinkSize,
        template: e.paginatorTemplate,
        rowsPerPageOptions: e.rowsPerPageOptions,
        currentPageReportTemplate: e.currentPageReportTemplate,
        class: G(e.cx("pcPaginator", {
            position: "bottom"
        })),
        onPage: t[43] || (t[43] = function(e) {
            return i.onPage(e)
        }),
        alwaysShow: e.alwaysShowPaginator,
        unstyled: e.unstyled,
        "data-p-bottom": !0,
        pt: e.ptm("pcPaginator")
    }, Xn({
        _: 2
    }, [e.$slots.paginatorcontainer ? {
        name: "container",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorcontainer", {
                first: t.first,
                last: t.last,
                rows: t.rows,
                page: t.page,
                pageCount: t.pageCount,
                pageLinks: t.pageLinks,
                totalRecords: t.totalRecords,
                firstPageCallback: t.firstPageCallback,
                lastPageCallback: t.lastPageCallback,
                prevPageCallback: t.prevPageCallback,
                nextPageCallback: t.nextPageCallback,
                rowChangeCallback: t.rowChangeCallback,
                changePageCallback: t.changePageCallback
            })]
        }),
        key: "0"
    } : void 0, e.$slots.paginatorstart ? {
        name: "start",
        fn: Vt(function() {
            return [Yn(e.$slots, "paginatorstart")]
        }),
        key: "1"
    } : void 0, e.$slots.paginatorend ? {
        name: "end",
        fn: Vt(function() {
            return [Yn(e.$slots, "paginatorend")]
        }),
        key: "2"
    } : void 0, e.$slots.paginatorfirstpagelinkicon ? {
        name: "firstpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorfirstpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "3"
    } : void 0, e.$slots.paginatorprevpagelinkicon ? {
        name: "prevpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorprevpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "4"
    } : void 0, e.$slots.paginatornextpagelinkicon ? {
        name: "nextpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatornextpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "5"
    } : void 0, e.$slots.paginatorlastpagelinkicon ? {
        name: "lastpagelinkicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorlastpagelinkicon", {
                class: G(t.class)
            })]
        }),
        key: "6"
    } : void 0, e.$slots.paginatorjumptopagedropdownicon ? {
        name: "jumptopagedropdownicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorjumptopagedropdownicon", {
                class: G(t.class)
            })]
        }),
        key: "7"
    } : void 0, e.$slots.paginatorrowsperpagedropdownicon ? {
        name: "rowsperpagedropdownicon",
        fn: Vt(function(t) {
            return [Yn(e.$slots, "paginatorrowsperpagedropdownicon", {
                class: G(t.class)
            })]
        }),
        key: "8"
    } : void 0]), 1032, ["rows", "first", "totalRecords", "pageLinkSize", "template", "rowsPerPageOptions", "currentPageReportTemplate", "class", "alwaysShow", "unstyled", "pt"])) : Eo("", !0), e.$slots.footer ? (uo(), go("div", Mo({
        key: 4,
        class: e.cx("footer")
    }, e.ptm("footer")), [Yn(e.$slots, "footer")], 16)) : Eo("", !0), _o("div", Mo({
        ref: "resizeHelper",
        class: e.cx("columnResizeIndicator"),
        style: {
            display: "none"
        }
    }, e.ptm("columnResizeIndicator")), null, 16), e.reorderableColumns ? (uo(), go("span", Mo({
        key: 5,
        ref: "reorderIndicatorUp",
        class: e.cx("rowReorderIndicatorUp"),
        style: {
            position: "absolute",
            display: "none"
        }
    }, e.ptm("rowReorderIndicatorUp")), [(uo(), mo(Hn(e.$slots.rowreorderindicatorupicon || e.$slots.reorderindicatorupicon || "ArrowDownIcon")))], 16)) : Eo("", !0), e.reorderableColumns ? (uo(), go("span", Mo({
        key: 6,
        ref: "reorderIndicatorDown",
        class: e.cx("rowReorderIndicatorDown"),
        style: {
            position: "absolute",
            display: "none"
        }
    }, e.ptm("rowReorderIndicatorDown")), [(uo(), mo(Hn(e.$slots.rowreorderindicatordownicon || e.$slots.reorderindicatordownicon || "ArrowUpIcon")))], 16)) : Eo("", !0)], 16, mP)
};
var AP = kI.extend({
        name: "column"
    }),
    yP = {
        name: "Column",
        extends: {
            name: "BaseColumn",
            extends: nT,
            props: {
                columnKey: {
                    type: null,
                    default: null
                },
                field: {
                    type: [String, Function],
                    default: null
                },
                sortField: {
                    type: [String, Function],
                    default: null
                },
                filterField: {
                    type: [String, Function],
                    default: null
                },
                dataType: {
                    type: String,
                    default: "text"
                },
                sortable: {
                    type: Boolean,
                    default: !1
                },
                header: {
                    type: null,
                    default: null
                },
                footer: {
                    type: null,
                    default: null
                },
                style: {
                    type: null,
                    default: null
                },
                class: {
                    type: String,
                    default: null
                },
                headerStyle: {
                    type: null,
                    default: null
                },
                headerClass: {
                    type: String,
                    default: null
                },
                bodyStyle: {
                    type: null,
                    default: null
                },
                bodyClass: {
                    type: String,
                    default: null
                },
                footerStyle: {
                    type: null,
                    default: null
                },
                footerClass: {
                    type: String,
                    default: null
                },
                showFilterMenu: {
                    type: Boolean,
                    default: !0
                },
                showFilterOperator: {
                    type: Boolean,
                    default: !0
                },
                showClearButton: {
                    type: Boolean,
                    default: !1
                },
                showApplyButton: {
                    type: Boolean,
                    default: !0
                },
                showFilterMatchModes: {
                    type: Boolean,
                    default: !0
                },
                showAddButton: {
                    type: Boolean,
                    default: !0
                },
                filterMatchModeOptions: {
                    type: Array,
                    default: null
                },
                maxConstraints: {
                    type: Number,
                    default: 2
                },
                excludeGlobalFilter: {
                    type: Boolean,
                    default: !1
                },
                filterHeaderClass: {
                    type: String,
                    default: null
                },
                filterHeaderStyle: {
                    type: null,
                    default: null
                },
                filterMenuClass: {
                    type: String,
                    default: null
                },
                filterMenuStyle: {
                    type: null,
                    default: null
                },
                selectionMode: {
                    type: String,
                    default: null
                },
                expander: {
                    type: Boolean,
                    default: !1
                },
                colspan: {
                    type: Number,
                    default: null
                },
                rowspan: {
                    type: Number,
                    default: null
                },
                rowReorder: {
                    type: Boolean,
                    default: !1
                },
                rowReorderIcon: {
                    type: String,
                    default: void 0
                },
                reorderableColumn: {
                    type: Boolean,
                    default: !0
                },
                rowEditor: {
                    type: Boolean,
                    default: !1
                },
                frozen: {
                    type: Boolean,
                    default: !1
                },
                alignFrozen: {
                    type: String,
                    default: "left"
                },
                exportable: {
                    type: Boolean,
                    default: !0
                },
                exportHeader: {
                    type: String,
                    default: null
                },
                exportFooter: {
                    type: String,
                    default: null
                },
                filterMatchMode: {
                    type: String,
                    default: null
                },
                hidden: {
                    type: Boolean,
                    default: !1
                }
            },
            style: AP,
            provide: function() {
                return {
                    $pcColumn: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        inject: ["$columns"],
        mounted: function() {
            var e;
            null === (e = this.$columns) || void 0 === e || e.add(this.$)
        },
        unmounted: function() {
            var e;
            null === (e = this.$columns) || void 0 === e || e.delete(this.$)
        },
        render: function() {
            return null
        }
    };
const vP = {
        key: 0,
        style: {
            height: "30px"
        }
    },
    _P = {
        key: 1
    },
    xP = {
        class: "flex-row justify-center mt-2"
    },
    wP = sE(yn({
        __name: "compression-results",
        setup(e) {
            const t = ft([]),
                n = ft(null),
                r = ft("default"),
                o = ft([{
                    field: "target",
                    header: "Target"
                }, {
                    field: "vertices",
                    header: "Vertices"
                }, {
                    field: "primitives",
                    header: "Primitives"
                }, {
                    field: "vertexDataSize",
                    header: "Meshes Size"
                }, {
                    field: "textureDataSize",
                    header: "Textures Size"
                }, {
                    field: "empty",
                    header: ""
                }, {
                    field: "fileSize",
                    header: "File Size"
                }, {
                    field: "memorySize",
                    header: "Memory Size"
                }]),
                i = Ho(() => {
                    const e = [];
                    return o.value.forEach(n => {
                        if ("target" === n.field)
                            return;
                        const r = {
                            key: n.header
                        };
                        t.value.forEach((e, t) => {
                            const o = n.field;
                            r[`col_${t}`] = void 0 !== e[o] ? e[o] : "N/A"
                        }),
                        e.push(r)
                    }), e
                }),
                a = Ho(() => t.value && 0 !== t.value.length ? t.value.map((e, n) => ({
                    field: `col_${n}`,
                    header:t.value[n]?.target
                })) : []);
            function s(e, t) {
                const n = e[t];
                if ("number" != typeof n || !Number.isFinite(n) || n <= 0)
                    return "0 B";
                if ("Vertices" === e.key || "Primitives" === e.key)
                    return n.toString();
                const r = ["B", "KB", "MB", "GB", "TB", "PB"],
                    o = Math.min(Math.floor(Math.log(n) / Math.log(1024)), r.length - 1);
                return `${(n / Math.pow(1024, o)).toFixed(2)} ${r[o]}`
            }
            function l(e, t) {
                return Number.isFinite(e) && 0 !== e && Number.isFinite(t) ? (t - e) / e * 100 : NaN
            }
            function c(e) {
                const t = e.col_2;
                if ("number" == typeof t) {
                    if (t < -1)
                        return t < -10 ? "much-better" : "better";
                    if (t > 1)
                        return t > 10 ? "much-worse" : "worse"
                }
                return ""
            }
            function u(e) {
                const t = e.col_2;
                if ("number" == typeof t) {
                    if (t < -1)
                        return "pi-arrow-down";
                    if (t > 1)
                        return "pi-arrow-up"
                }
                return ""
            }
            function d() {
                if (!n.value)
                    return;
                const e = new Uint8Array(n.value.compressedBytes.byteLength);
                e.set(n.value.compressedBytes);
                const t = new Blob([e], {
                        type: "model/gltf-binary"
                    }),
                    o = document.createElement("a");
                o.href = URL.createObjectURL(t),
                o.download = `${r.value.replace(/\.[^/.]+$/, "")}_compressed.glb`,
                o.click()
            }
            return oE("loadModel", ({files: e}) => {
                t.value = [],
                n.value = null;
                const o = e.find(e => e.name.toLowerCase().endsWith(".glb") || e.name.toLowerCase().endsWith(".gltf"));
                o && (r.value = o.name)
            }), oE("compressionCompleted", e => {
                n.value = e.result;
                const r = {
                    target: "Delta (%)",
                    vertices: l(e.result.original.vertices, e.result.compressed.vertices),
                    primitives: l(e.result.original.primitives, e.result.compressed.primitives),
                    vertexDataSize: l(e.result.original.vertexDataSize, e.result.compressed.vertexDataSize),
                    textureDataSize: l(e.result.original.textureDataSize, e.result.compressed.textureDataSize),
                    fileSize: l(e.result.original.fileSize, e.result.compressed.fileSize),
                    memorySize: l(e.result.original.memorySize, e.result.compressed.memorySize)
                };
                t.value = [e.result.original, e.result.compressed, r]
            }), (e, n) => t.value.length > 0 ? (uo(), mo(mt(lB), {
                key: 0,
                style: {
                    height: "fit-content"
                }
            }, {
                title: Vt(() => [...n[0] || (n[0] = [_o("h3", null, "Compression Results", -1)])]),
                content: Vt(() => [xo(mt(dP), {
                    size: "small",
                    value: i.value
                }, {
                    default: Vt(() => [xo(mt(yP), {
                        field: "key",
                        header: "Attribute"
                    }), (uo(!0), go(oo, null, qn(a.value, e => (uo(), mo(mt(yP), {
                        key: e.header,
                        field: e.field,
                        header: e.header
                    }, {
                        body: Vt(t => {
                            return ["" === t.data.key ? (uo(), go("div", vP)) : (uo(), go(oo, {
                                key: 1
                            }, ["col_2" === e.field ? (uo(), go("span", {
                                key: 0,
                                class: G([c(t.data)])
                            }, [Co(W((n = t.data[e.field], Number.isFinite(n) ? n.toFixed(2) : "N/A")) + "% ", 1), _o("i", {
                                class: G(["pi", [u(t.data)]])
                            }, null, 2)], 2)) : (uo(), go(oo, {
                                key: 1
                            }, ["col_1" === e.field ? (uo(), go("span", {
                                key: 0,
                                class: G([c(t.data)])
                            }, W(s(t.data, e.field)), 3)) : (uo(), go("span", _P, W(s(t.data, e.field)), 1))], 64))], 64))];
                            var n
                        }),
                        _: 2
                    }, 1032, ["field", "header"]))), 128))]),
                    _: 1
                }, 8, ["value"]), _o("div", xP, [xo(mt(_R), {
                    icon: "pi pi-download",
                    label: "Download Model",
                    onClick: d
                })])]),
                _: 1
            })) : Eo("", !0)
        }
    }), [["__scopeId", "data-v-bd09f4b3"]]);
var CP = {
    name: "WindowMaximizeIcon",
    extends: AT
};
function EP(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
CP.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return EP(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return EP(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? EP(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var SP = {
    name: "WindowMinimizeIcon",
    extends: AT
};
function IP(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
function TP() {
    var e;
    "string" == typeof (e = {
        variableName: cI("scrollbar.width").name
    }) ? uE(document.body, e || "p-overflow-hidden") : (null != e && e.variableName && document.body.style.setProperty(e.variableName, window.innerWidth - document.documentElement.offsetWidth + "px"), uE(document.body, (null == e ? void 0 : e.className) || "p-overflow-hidden"))
}
function MP() {
    var e;
    "string" == typeof (e = {
        variableName: cI("scrollbar.width").name
    }) ? dE(document.body, e || "p-overflow-hidden") : (null != e && e.variableName && document.body.style.removeProperty(e.variableName), dE(document.body, (null == e ? void 0 : e.className) || "p-overflow-hidden"))
}
SP.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return IP(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return IP(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? IP(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var RP = kI.extend({
        name: "dialog",
        style: "\n    .p-dialog {\n        max-height: 90%;\n        transform: scale(1);\n        border-radius: dt('dialog.border.radius');\n        box-shadow: dt('dialog.shadow');\n        background: dt('dialog.background');\n        border: 1px solid dt('dialog.border.color');\n        color: dt('dialog.color');\n    }\n\n    .p-dialog-content {\n        overflow-y: auto;\n        padding: dt('dialog.content.padding');\n    }\n\n    .p-dialog-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        flex-shrink: 0;\n        padding: dt('dialog.header.padding');\n    }\n\n    .p-dialog-title {\n        font-weight: dt('dialog.title.font.weight');\n        font-size: dt('dialog.title.font.size');\n    }\n\n    .p-dialog-footer {\n        flex-shrink: 0;\n        padding: dt('dialog.footer.padding');\n        display: flex;\n        justify-content: flex-end;\n        gap: dt('dialog.footer.gap');\n    }\n\n    .p-dialog-header-actions {\n        display: flex;\n        align-items: center;\n        gap: dt('dialog.header.gap');\n    }\n\n    .p-dialog-enter-active {\n        transition: all 150ms cubic-bezier(0, 0, 0.2, 1);\n    }\n\n    .p-dialog-leave-active {\n        transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);\n    }\n\n    .p-dialog-enter-from,\n    .p-dialog-leave-to {\n        opacity: 0;\n        transform: scale(0.7);\n    }\n\n    .p-dialog-top .p-dialog,\n    .p-dialog-bottom .p-dialog,\n    .p-dialog-left .p-dialog,\n    .p-dialog-right .p-dialog,\n    .p-dialog-topleft .p-dialog,\n    .p-dialog-topright .p-dialog,\n    .p-dialog-bottomleft .p-dialog,\n    .p-dialog-bottomright .p-dialog {\n        margin: 0.75rem;\n        transform: translate3d(0px, 0px, 0px);\n    }\n\n    .p-dialog-top .p-dialog-enter-active,\n    .p-dialog-top .p-dialog-leave-active,\n    .p-dialog-bottom .p-dialog-enter-active,\n    .p-dialog-bottom .p-dialog-leave-active,\n    .p-dialog-left .p-dialog-enter-active,\n    .p-dialog-left .p-dialog-leave-active,\n    .p-dialog-right .p-dialog-enter-active,\n    .p-dialog-right .p-dialog-leave-active,\n    .p-dialog-topleft .p-dialog-enter-active,\n    .p-dialog-topleft .p-dialog-leave-active,\n    .p-dialog-topright .p-dialog-enter-active,\n    .p-dialog-topright .p-dialog-leave-active,\n    .p-dialog-bottomleft .p-dialog-enter-active,\n    .p-dialog-bottomleft .p-dialog-leave-active,\n    .p-dialog-bottomright .p-dialog-enter-active,\n    .p-dialog-bottomright .p-dialog-leave-active {\n        transition: all 0.3s ease-out;\n    }\n\n    .p-dialog-top .p-dialog-enter-from,\n    .p-dialog-top .p-dialog-leave-to {\n        transform: translate3d(0px, -100%, 0px);\n    }\n\n    .p-dialog-bottom .p-dialog-enter-from,\n    .p-dialog-bottom .p-dialog-leave-to {\n        transform: translate3d(0px, 100%, 0px);\n    }\n\n    .p-dialog-left .p-dialog-enter-from,\n    .p-dialog-left .p-dialog-leave-to,\n    .p-dialog-topleft .p-dialog-enter-from,\n    .p-dialog-topleft .p-dialog-leave-to,\n    .p-dialog-bottomleft .p-dialog-enter-from,\n    .p-dialog-bottomleft .p-dialog-leave-to {\n        transform: translate3d(-100%, 0px, 0px);\n    }\n\n    .p-dialog-right .p-dialog-enter-from,\n    .p-dialog-right .p-dialog-leave-to,\n    .p-dialog-topright .p-dialog-enter-from,\n    .p-dialog-topright .p-dialog-leave-to,\n    .p-dialog-bottomright .p-dialog-enter-from,\n    .p-dialog-bottomright .p-dialog-leave-to {\n        transform: translate3d(100%, 0px, 0px);\n    }\n\n    .p-dialog-left:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-left:dir(rtl) .p-dialog-leave-to,\n    .p-dialog-topleft:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-topleft:dir(rtl) .p-dialog-leave-to,\n    .p-dialog-bottomleft:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-bottomleft:dir(rtl) .p-dialog-leave-to {\n        transform: translate3d(100%, 0px, 0px);\n    }\n\n    .p-dialog-right:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-right:dir(rtl) .p-dialog-leave-to,\n    .p-dialog-topright:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-topright:dir(rtl) .p-dialog-leave-to,\n    .p-dialog-bottomright:dir(rtl) .p-dialog-enter-from,\n    .p-dialog-bottomright:dir(rtl) .p-dialog-leave-to {\n        transform: translate3d(-100%, 0px, 0px);\n    }\n\n    .p-dialog-maximized {\n        width: 100vw !important;\n        height: 100vh !important;\n        top: 0px !important;\n        left: 0px !important;\n        max-height: 100%;\n        height: 100%;\n        border-radius: 0;\n    }\n\n    .p-dialog-maximized .p-dialog-content {\n        flex-grow: 1;\n    }\n\n    .p-dialog .p-resizable-handle {\n        position: absolute;\n        font-size: 0.1px;\n        display: block;\n        cursor: se-resize;\n        width: 12px;\n        height: 12px;\n        right: 1px;\n        bottom: 1px;\n    }\n",
        classes: {
            mask: function(e) {
                var t = e.props,
                    n = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"].find(function(e) {
                        return e === t.position
                    });
                return ["p-dialog-mask", {
                    "p-overlay-mask p-overlay-mask-enter": t.modal
                }, n ? "p-dialog-".concat(n) : ""]
            },
            root: function(e) {
                var t = e.props,
                    n = e.instance;
                return ["p-dialog p-component", {
                    "p-dialog-maximized": t.maximizable && n.maximized
                }]
            },
            header: "p-dialog-header",
            title: "p-dialog-title",
            headerActions: "p-dialog-header-actions",
            pcMaximizeButton: "p-dialog-maximize-button",
            pcCloseButton: "p-dialog-close-button",
            content: "p-dialog-content",
            footer: "p-dialog-footer"
        },
        inlineStyles: {
            mask: function(e) {
                var t = e.position;
                return {
                    position: "fixed",
                    height: "100%",
                    width: "100%",
                    left: 0,
                    top: 0,
                    display: "flex",
                    justifyContent: "left" === t || "topleft" === t || "bottomleft" === t ? "flex-start" : "right" === t || "topright" === t || "bottomright" === t ? "flex-end" : "center",
                    alignItems: "top" === t || "topleft" === t || "topright" === t ? "flex-start" : "bottom" === t || "bottomleft" === t || "bottomright" === t ? "flex-end" : "center",
                    pointerEvents: e.modal ? "auto" : "none"
                }
            },
            root: {
                display: "flex",
                flexDirection: "column",
                pointerEvents: "auto"
            }
        }
    }),
    BP = {
        name: "Dialog",
        extends: {
            name: "BaseDialog",
            extends: nT,
            props: {
                header: {
                    type: null,
                    default: null
                },
                footer: {
                    type: null,
                    default: null
                },
                visible: {
                    type: Boolean,
                    default: !1
                },
                modal: {
                    type: Boolean,
                    default: null
                },
                contentStyle: {
                    type: null,
                    default: null
                },
                contentClass: {
                    type: String,
                    default: null
                },
                contentProps: {
                    type: null,
                    default: null
                },
                maximizable: {
                    type: Boolean,
                    default: !1
                },
                dismissableMask: {
                    type: Boolean,
                    default: !1
                },
                closable: {
                    type: Boolean,
                    default: !0
                },
                closeOnEscape: {
                    type: Boolean,
                    default: !0
                },
                showHeader: {
                    type: Boolean,
                    default: !0
                },
                blockScroll: {
                    type: Boolean,
                    default: !1
                },
                baseZIndex: {
                    type: Number,
                    default: 0
                },
                autoZIndex: {
                    type: Boolean,
                    default: !0
                },
                position: {
                    type: String,
                    default: "center"
                },
                breakpoints: {
                    type: Object,
                    default: null
                },
                draggable: {
                    type: Boolean,
                    default: !0
                },
                keepInViewport: {
                    type: Boolean,
                    default: !0
                },
                minX: {
                    type: Number,
                    default: 0
                },
                minY: {
                    type: Number,
                    default: 0
                },
                appendTo: {
                    type: [String, Object],
                    default: "body"
                },
                closeIcon: {
                    type: String,
                    default: void 0
                },
                maximizeIcon: {
                    type: String,
                    default: void 0
                },
                minimizeIcon: {
                    type: String,
                    default: void 0
                },
                closeButtonProps: {
                    type: Object,
                    default: function() {
                        return {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        }
                    }
                },
                maximizeButtonProps: {
                    type: Object,
                    default: function() {
                        return {
                            severity: "secondary",
                            text: !0,
                            rounded: !0
                        }
                    }
                },
                _instance: null
            },
            style: RP,
            provide: function() {
                return {
                    $pcDialog: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragstart", "dragend"],
        provide: function() {
            var e = this;
            return {
                dialogRef: Ho(function() {
                    return e._instance
                })
            }
        },
        data: function() {
            return {
                containerVisible: this.visible,
                maximized: !1,
                focusableMax: null,
                focusableClose: null,
                target: null
            }
        },
        documentKeydownListener: null,
        container: null,
        mask: null,
        content: null,
        headerContainer: null,
        footerContainer: null,
        maximizableButton: null,
        closeButton: null,
        styleElement: null,
        dragging: null,
        documentDragListener: null,
        documentDragEndListener: null,
        lastPageX: null,
        lastPageY: null,
        maskMouseDownTarget: null,
        updated: function() {
            this.visible && (this.containerVisible = this.visible)
        },
        beforeUnmount: function() {
            this.unbindDocumentState(),
            this.unbindGlobalListeners(),
            this.destroyStyle(),
            this.mask && this.autoZIndex && MS.clear(this.mask),
            this.container = null,
            this.mask = null
        },
        mounted: function() {
            this.breakpoints && this.createStyle()
        },
        methods: {
            close: function() {
                this.$emit("update:visible", !1)
            },
            onEnter: function() {
                this.$emit("show"),
                this.target = document.activeElement,
                this.enableDocumentSettings(),
                this.bindGlobalListeners(),
                this.autoZIndex && MS.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal)
            },
            onAfterEnter: function() {
                this.focus()
            },
            onBeforeLeave: function() {
                this.modal && !this.isUnstyled && uE(this.mask, "p-overlay-mask-leave"),
                this.dragging && this.documentDragEndListener && this.documentDragEndListener()
            },
            onLeave: function() {
                this.$emit("hide"),
                RE(this.target),
                this.target = null,
                this.focusableClose = null,
                this.focusableMax = null
            },
            onAfterLeave: function() {
                this.autoZIndex && MS.clear(this.mask),
                this.containerVisible = !1,
                this.unbindDocumentState(),
                this.unbindGlobalListeners(),
                this.$emit("after-hide")
            },
            onMaskMouseDown: function(e) {
                this.maskMouseDownTarget = e.target
            },
            onMaskMouseUp: function() {
                this.dismissableMask && this.modal && this.mask === this.maskMouseDownTarget && this.close()
            },
            focus: function() {
                var e = function(e) {
                        return e && e.querySelector("[autofocus]")
                    },
                    t = this.$slots.footer && e(this.footerContainer);
                t || (t = this.$slots.header && e(this.headerContainer)) || (t = this.$slots.default && e(this.content)) || (this.maximizable ? (this.focusableMax = !0, t = this.maximizableButton) : (this.focusableClose = !0, t = this.closeButton)),
                t && RE(t, {
                    focusVisible: !0
                })
            },
            maximize: function(e) {
                this.maximized ? (this.maximized = !1, this.$emit("unmaximize", e)) : (this.maximized = !0, this.$emit("maximize", e)),
                this.modal || (this.maximized ? TP() : MP())
            },
            enableDocumentSettings: function() {
                (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) && TP()
            },
            unbindDocumentState: function() {
                (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) && MP()
            },
            onKeyDown: function(e) {
                "Escape" === e.code && this.closeOnEscape && this.close()
            },
            bindDocumentKeyDownListener: function() {
                this.documentKeydownListener || (this.documentKeydownListener = this.onKeyDown.bind(this), window.document.addEventListener("keydown", this.documentKeydownListener))
            },
            unbindDocumentKeyDownListener: function() {
                this.documentKeydownListener && (window.document.removeEventListener("keydown", this.documentKeydownListener), this.documentKeydownListener = null)
            },
            containerRef: function(e) {
                this.container = e
            },
            maskRef: function(e) {
                this.mask = e
            },
            contentRef: function(e) {
                this.content = e
            },
            headerContainerRef: function(e) {
                this.headerContainer = e
            },
            footerContainerRef: function(e) {
                this.footerContainer = e
            },
            maximizableRef: function(e) {
                this.maximizableButton = e ? e.$el : void 0
            },
            closeButtonRef: function(e) {
                this.closeButton = e ? e.$el : void 0
            },
            createStyle: function() {
                if (!this.styleElement && !this.isUnstyled) {
                    var e;
                    this.styleElement = document.createElement("style"),
                    this.styleElement.type = "text/css",
                    YE(this.styleElement, "nonce", null === (e = this.$primevue) || void 0 === e || null === (e = e.config) || void 0 === e || null === (e = e.csp) || void 0 === e ? void 0 : e.nonce),
                    document.head.appendChild(this.styleElement);
                    var t = "";
                    for (var n in this.breakpoints)
                        t += "\n                        @media screen and (max-width: ".concat(n, ") {\n                            .p-dialog[").concat(this.$attrSelector, "] {\n                                width: ").concat(this.breakpoints[n], " !important;\n                            }\n                        }\n                    ");
                    this.styleElement.innerHTML = t
                }
            },
            destroyStyle: function() {
                this.styleElement && (document.head.removeChild(this.styleElement), this.styleElement = null)
            },
            initDrag: function(e) {
                "headeractions" !== e.target.closest("div").getAttribute("data-pc-section") && this.draggable && (this.dragging = !0, this.lastPageX = e.pageX, this.lastPageY = e.pageY, this.container.style.margin = "0", document.body.setAttribute("data-p-unselectable-text", "true"), !this.isUnstyled && vE(document.body, {
                    "user-select": "none"
                }), this.$emit("dragstart", e))
            },
            bindGlobalListeners: function() {
                this.draggable && (this.bindDocumentDragListener(), this.bindDocumentDragEndListener()),
                this.closeOnEscape && this.bindDocumentKeyDownListener()
            },
            unbindGlobalListeners: function() {
                this.unbindDocumentDragListener(),
                this.unbindDocumentDragEndListener(),
                this.unbindDocumentKeyDownListener()
            },
            bindDocumentDragListener: function() {
                var e = this;
                this.documentDragListener = function(t) {
                    if (e.dragging) {
                        var n = _E(e.container),
                            r = UE(e.container),
                            o = t.pageX - e.lastPageX,
                            i = t.pageY - e.lastPageY,
                            a = e.container.getBoundingClientRect(),
                            s = a.left + o,
                            l = a.top + i,
                            c = fE(),
                            u = getComputedStyle(e.container),
                            d = parseFloat(u.marginLeft),
                            p = parseFloat(u.marginTop);
                        e.container.style.position = "fixed",
                        e.keepInViewport ? (s >= e.minX && s + n < c.width && (e.lastPageX = t.pageX, e.container.style.left = s - d + "px"), l >= e.minY && l + r < c.height && (e.lastPageY = t.pageY, e.container.style.top = l - p + "px")) : (e.lastPageX = t.pageX, e.container.style.left = s - d + "px", e.lastPageY = t.pageY, e.container.style.top = l - p + "px")
                    }
                },
                window.document.addEventListener("mousemove", this.documentDragListener)
            },
            unbindDocumentDragListener: function() {
                this.documentDragListener && (window.document.removeEventListener("mousemove", this.documentDragListener), this.documentDragListener = null)
            },
            bindDocumentDragEndListener: function() {
                var e = this;
                this.documentDragEndListener = function(t) {
                    e.dragging && (e.dragging = !1, document.body.removeAttribute("data-p-unselectable-text"), !e.isUnstyled && (document.body.style["user-select"] = ""), e.$emit("dragend", t))
                },
                window.document.addEventListener("mouseup", this.documentDragEndListener)
            },
            unbindDocumentDragEndListener: function() {
                this.documentDragEndListener && (window.document.removeEventListener("mouseup", this.documentDragEndListener), this.documentDragEndListener = null)
            }
        },
        computed: {
            maximizeIconComponent: function() {
                return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon"
            },
            ariaLabelledById: function() {
                return null != this.header || null !== this.$attrs["aria-labelledby"] ? this.$id + "_header" : null
            },
            closeAriaLabel: function() {
                return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0
            },
            dataP: function() {
                return RS({
                    maximized: this.maximized,
                    modal: this.modal
                })
            }
        },
        directives: {
            ripple: ET,
            focustrap: Ik
        },
        components: {
            Button: _R,
            Portal: cM,
            WindowMinimizeIcon: SP,
            WindowMaximizeIcon: CP,
            TimesIcon: yT
        }
    };
function kP(e) {
    return (kP = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function DP(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function PP(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? DP(Object(n), !0).forEach(function(t) {
            OP(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DP(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function OP(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != kP(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != kP(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == kP(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var LP,
    NP,
    FP = ["data-p"],
    UP = ["aria-labelledby", "aria-modal", "data-p"],
    zP = ["id"],
    QP = ["data-p"];
function GP() {
    if (NP)
        return LP;
    function e(t) {
        return t instanceof Map ? t.clear = t.delete = t.set = function() {
            throw new Error("map is read-only")
        } : t instanceof Set && (t.add = t.clear = t.delete = function() {
            throw new Error("set is read-only")
        }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach(n => {
            const r = t[n],
                o = typeof r;
            "object" !== o && "function" !== o || Object.isFrozen(r) || e(r)
        }), t
    }
    NP = 1;
    class t {
        constructor(e)
        {
            void 0 === e.data && (e.data = {}),
            this.data = e.data,
            this.isMatchIgnored = !1
        }
        ignoreMatch()
        {
            this.isMatchIgnored = !0
        }
    }
    function n(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
    }
    function r(e, ...t) {
        const n = Object.create(null);
        for (const r in e)
            n[r] = e[r];
        return t.forEach(function(e) {
            for (const t in e)
                n[t] = e[t]
        }), n
    }
    const o = e => !!e.scope;
    class i {
        constructor(e, t)
        {
            this.buffer = "",
            this.classPrefix = t.classPrefix,
            e.walk(this)
        }
        addText(e)
        {
            this.buffer += n(e)
        }
        openNode(e)
        {
            if (!o(e))
                return;
            const t = ((e, {prefix: t}) => {
                if (e.startsWith("language:"))
                    return e.replace("language:", "language-");
                if (e.includes(".")) {
                    const n = e.split(".");
                    return [`${t}${n.shift()}`, ...n.map((e, t) => `${e}${"_".repeat(t + 1)}`)].join(" ")
                }
                return `${t}${e}`
            })(e.scope, {
                prefix: this.classPrefix
            });
            this.span(t)
        }
        closeNode(e)
        {
            o(e) && (this.buffer += "</span>")
        }
        value()
        {
            return this.buffer
        }
        span(e)
        {
            this.buffer += `<span class="${e}">`
        }
    }
    const a = (e={}) => {
        const t = {
            children: []
        };
        return Object.assign(t, e), t
    };
    class s {
        constructor()
        {
            this.rootNode = a(),
            this.stack = [this.rootNode]
        }
        get top()
        {
            return this.stack[this.stack.length - 1]
        }
        get root()
        {
            return this.rootNode
        }
        add(e)
        {
            this.top.children.push(e)
        }
        openNode(e)
        {
            const t = a({
                scope: e
            });
            this.add(t),
            this.stack.push(t)
        }
        closeNode()
        {
            if (this.stack.length > 1)
                return this.stack.pop()
        }
        closeAllNodes()
        {
            for (; this.closeNode();)
                ;
        }
        toJSON()
        {
            return JSON.stringify(this.rootNode, null, 4)
        }
        walk(e)
        {
            return this.constructor._walk(e, this.rootNode)
        }
        static _walk(e, t)
        {
            return "string" == typeof t ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach(t => this._walk(e, t)), e.closeNode(t)), e
        }
        static _collapse(e)
        {
            "string" != typeof e && e.children && (e.children.every(e => "string" == typeof e) ? e.children = [e.children.join("")] : e.children.forEach(e => {
                s._collapse(e)
            }))
        }
    }
    class l extends s {
        constructor(e)
        {
            super(),
            this.options = e
        }
        addText(e)
        {
            "" !== e && this.add(e)
        }
        startScope(e)
        {
            this.openNode(e)
        }
        endScope()
        {
            this.closeNode()
        }
        __addSublanguage(e, t)
        {
            const n = e.root;
            t && (n.scope = `language:${t}`),
            this.add(n)
        }
        toHTML()
        {
            return new i(this, this.options).value()
        }
        finalize()
        {
            return this.closeAllNodes(), !0
        }
    }
    function c(e) {
        return e ? "string" == typeof e ? e : e.source : null
    }
    function u(e) {
        return h("(?=", e, ")")
    }
    function d(e) {
        return h("(?:", e, ")*")
    }
    function p(e) {
        return h("(?:", e, ")?")
    }
    function h(...e) {
        return e.map(e => c(e)).join("")
    }
    function f(...e) {
        const t = function(e) {
            const t = e[e.length - 1];
            return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {}
        }(e);
        return "(" + (t.capture ? "" : "?:") + e.map(e => c(e)).join("|") + ")"
    }
    function g(e) {
        return new RegExp(e.toString() + "|").exec("").length - 1
    }
    const m = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function b(e, {joinWith: t}) {
        let n = 0;
        return e.map(e => {
            n += 1;
            const t = n;
            let r = c(e),
                o = "";
            for (; r.length > 0;) {
                const e = m.exec(r);
                if (!e) {
                    o += r;
                    break
                }
                o += r.substring(0, e.index),
                r = r.substring(e.index + e[0].length),
                "\\" === e[0][0] && e[1] ? o += "\\" + String(Number(e[1]) + t) : (o += e[0], "(" === e[0] && n++)
            }
            return o
        }).map(e => `(${e})`).join(t)
    }
    const A = "[a-zA-Z]\\w*",
        y = "[a-zA-Z_]\\w*",
        v = "\\b\\d+(\\.\\d+)?",
        _ = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",
        x = "\\b(0b[01]+)",
        w = {
            begin: "\\\\[\\s\\S]",
            relevance: 0
        },
        C = {
            scope: "string",
            begin: "'",
            end: "'",
            illegal: "\\n",
            contains: [w]
        },
        E = {
            scope: "string",
            begin: '"',
            end: '"',
            illegal: "\\n",
            contains: [w]
        },
        S = function(e, t, n={}) {
            const o = r({
                scope: "comment",
                begin: e,
                end: t,
                contains: []
            }, n);
            o.contains.push({
                scope: "doctag",
                begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
                end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
                excludeBegin: !0,
                relevance: 0
            });
            const i = f("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
            return o.contains.push({
                begin: h(/[ ]+/, "(", i, /[.]?[:]?([.][ ]|[ ])/, "){3}")
            }), o
        },
        I = S("//", "$"),
        T = S("/\\*", "\\*/"),
        M = S("#", "$"),
        R = {
            scope: "number",
            begin: v,
            relevance: 0
        },
        B = {
            scope: "number",
            begin: _,
            relevance: 0
        },
        k = {
            scope: "number",
            begin: x,
            relevance: 0
        },
        D = {
            scope: "regexp",
            begin: /\/(?=[^/\n]*\/)/,
            end: /\/[gimuy]*/,
            contains: [w, {
                begin: /\[/,
                end: /\]/,
                relevance: 0,
                contains: [w]
            }]
        },
        P = {
            scope: "title",
            begin: A,
            relevance: 0
        },
        O = {
            scope: "title",
            begin: y,
            relevance: 0
        },
        L = {
            begin: "\\.\\s*" + y,
            relevance: 0
        };
    var N = Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: C,
        BACKSLASH_ESCAPE: w,
        BINARY_NUMBER_MODE: k,
        BINARY_NUMBER_RE: x,
        COMMENT: S,
        C_BLOCK_COMMENT_MODE: T,
        C_LINE_COMMENT_MODE: I,
        C_NUMBER_MODE: B,
        C_NUMBER_RE: _,
        END_SAME_AS_BEGIN: function(e) {
            return Object.assign(e, {
                "on:begin": (e, t) => {
                    t.data._beginMatch = e[1]
                },
                "on:end": (e, t) => {
                    t.data._beginMatch !== e[1] && t.ignoreMatch()
                }
            })
        },
        HASH_COMMENT_MODE: M,
        IDENT_RE: A,
        MATCH_NOTHING_RE: /\b\B/,
        METHOD_GUARD: L,
        NUMBER_MODE: R,
        NUMBER_RE: v,
        PHRASAL_WORDS_MODE: {
            begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
        },
        QUOTE_STRING_MODE: E,
        REGEXP_MODE: D,
        RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
        SHEBANG: (e={}) => {
            const t = /^#![ ]*\//;
            return e.binary && (e.begin = h(t, /.*\b/, e.binary, /\b.*/)), r({
                scope: "meta",
                begin: t,
                end: /$/,
                relevance: 0,
                "on:begin": (e, t) => {
                    0 !== e.index && t.ignoreMatch()
                }
            }, e)
        },
        TITLE_MODE: P,
        UNDERSCORE_IDENT_RE: y,
        UNDERSCORE_TITLE_MODE: O
    });
    function F(e, t) {
        "." === e.input[e.index - 1] && t.ignoreMatch()
    }
    function U(e, t) {
        void 0 !== e.className && (e.scope = e.className, delete e.className)
    }
    function z(e, t) {
        t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e.__beforeBegin = F, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords, void 0 === e.relevance && (e.relevance = 0))
    }
    function Q(e, t) {
        Array.isArray(e.illegal) && (e.illegal = f(...e.illegal))
    }
    function G(e, t) {
        if (e.match) {
            if (e.begin || e.end)
                throw new Error("begin & end are not supported with match");
            e.begin = e.match,
            delete e.match
        }
    }
    function j(e, t) {
        void 0 === e.relevance && (e.relevance = 1)
    }
    const V = (e, t) => {
            if (!e.beforeMatch)
                return;
            if (e.starts)
                throw new Error("beforeMatch cannot be used with starts");
            const n = Object.assign({}, e);
            Object.keys(e).forEach(t => {
                delete e[t]
            }),
            e.keywords = n.keywords,
            e.begin = h(n.beforeMatch, u(n.begin)),
            e.starts = {
                relevance: 0,
                contains: [Object.assign(n, {
                    endsParent: !0
                })]
            },
            e.relevance = 0,
            delete n.beforeMatch
        },
        H = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"];
    function $(e, t, n="keyword") {
        const r = Object.create(null);
        return "string" == typeof e ? o(n, e.split(" ")) : Array.isArray(e) ? o(n, e) : Object.keys(e).forEach(function(n) {
            Object.assign(r, $(e[n], t, n))
        }), r;
        function o(e, n) {
            t && (n = n.map(e => e.toLowerCase())),
            n.forEach(function(t) {
                const n = t.split("|");
                r[n[0]] = [e, W(n[0], n[1])]
            })
        }
    }
    function W(e, t) {
        return t ? Number(t) : function(e) {
            return H.includes(e.toLowerCase())
        }(e) ? 0 : 1
    }
    const K = {},
        q = (e, t) => {
            K[`${e}/${t}`] || (K[`${e}/${t}`] = !0)
        },
        X = new Error;
    function Y(e, t, {key: n}) {
        let r = 0;
        const o = e[n],
            i = {},
            a = {};
        for (let s = 1; s <= t.length; s++)
            a[s + r] = o[s],
            i[s + r] = !0,
            r += g(t[s - 1]);
        e[n] = a,
        e[n]._emit = i,
        e[n]._multi = !0
    }
    function J(e) {
        !function(e) {
            e.scope && "object" == typeof e.scope && null !== e.scope && (e.beginScope = e.scope, delete e.scope)
        }(e),
        "string" == typeof e.beginScope && (e.beginScope = {
            _wrap: e.beginScope
        }),
        "string" == typeof e.endScope && (e.endScope = {
            _wrap: e.endScope
        }),
        function(e) {
            if (Array.isArray(e.begin)) {
                if (e.skip || e.excludeBegin || e.returnBegin)
                    throw X;
                if ("object" != typeof e.beginScope || null === e.beginScope)
                    throw X;
                Y(e, e.begin, {
                    key: "beginScope"
                }),
                e.begin = b(e.begin, {
                    joinWith: ""
                })
            }
        }(e),
        function(e) {
            if (Array.isArray(e.end)) {
                if (e.skip || e.excludeEnd || e.returnEnd)
                    throw X;
                if ("object" != typeof e.endScope || null === e.endScope)
                    throw X;
                Y(e, e.end, {
                    key: "endScope"
                }),
                e.end = b(e.end, {
                    joinWith: ""
                })
            }
        }(e)
    }
    function Z(e) {
        function t(t, n) {
            return new RegExp(c(t), "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (n ? "g" : ""))
        }
        class n {
            constructor()
            {
                this.matchIndexes = {},
                this.regexes = [],
                this.matchAt = 1,
                this.position = 0
            }
            addRule(e, t)
            {
                t.position = this.position++,
                this.matchIndexes[this.matchAt] = t,
                this.regexes.push([t, e]),
                this.matchAt += g(e) + 1
            }
            compile()
            {
                0 === this.regexes.length && (this.exec = () => null);
                const e = this.regexes.map(e => e[1]);
                this.matcherRe = t(b(e, {
                    joinWith: "|"
                }), !0),
                this.lastIndex = 0
            }
            exec(e)
            {
                this.matcherRe.lastIndex = this.lastIndex;
                const t = this.matcherRe.exec(e);
                if (!t)
                    return null;
                const n = t.findIndex((e, t) => t > 0 && void 0 !== e),
                    r = this.matchIndexes[n];
                return t.splice(0, n), Object.assign(t, r)
            }
        }
        class o {
            constructor()
            {
                this.rules = [],
                this.multiRegexes = [],
                this.count = 0,
                this.lastIndex = 0,
                this.regexIndex = 0
            }
            getMatcher(e)
            {
                if (this.multiRegexes[e])
                    return this.multiRegexes[e];
                const t = new n;
                return this.rules.slice(e).forEach(([e, n]) => t.addRule(e, n)), t.compile(), this.multiRegexes[e] = t, t
            }
            resumingScanAtSamePosition()
            {
                return 0 !== this.regexIndex
            }
            considerAll()
            {
                this.regexIndex = 0
            }
            addRule(e, t)
            {
                this.rules.push([e, t]),
                "begin" === t.type && this.count++
            }
            exec(e)
            {
                const t = this.getMatcher(this.regexIndex);
                t.lastIndex = this.lastIndex;
                let n = t.exec(e);
                if (this.resumingScanAtSamePosition())
                    if (n && n.index === this.lastIndex)
                        ;
                    else {
                        const t = this.getMatcher(0);
                        t.lastIndex = this.lastIndex + 1,
                        n = t.exec(e)
                    }
                return n && (this.regexIndex += n.position + 1, this.regexIndex === this.count && this.considerAll()), n
            }
        }
        if (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes("self"))
            throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return e.classNameAliases = r(e.classNameAliases || {}), function n(i, a) {
            const s = i;
            if (i.isCompiled)
                return s;
            [U, G, J, V].forEach(e => e(i, a)),
            e.compilerExtensions.forEach(e => e(i, a)),
            i.__beforeBegin = null,
            [z, Q, j].forEach(e => e(i, a)),
            i.isCompiled = !0;
            let l = null;
            return "object" == typeof i.keywords && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = $(i.keywords, e.case_insensitive)), s.keywordPatternRe = t(l, !0), a && (i.begin || (i.begin = /\B|\b/), s.beginRe = t(s.begin), i.end || i.endsWithParent || (i.end = /\B|\b/), i.end && (s.endRe = t(s.end)), s.terminatorEnd = c(s.end) || "", i.endsWithParent && a.terminatorEnd && (s.terminatorEnd += (i.end ? "|" : "") + a.terminatorEnd)), i.illegal && (s.illegalRe = t(i.illegal)), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(e) {
                return function(e) {
                    return e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map(function(t) {
                        return r(e, {
                            variants: null
                        }, t)
                    })), e.cachedVariants ? e.cachedVariants : ee(e) ? r(e, {
                        starts: e.starts ? r(e.starts) : null
                    }) : Object.isFrozen(e) ? r(e) : e
                }("self" === e ? i : e)
            })), i.contains.forEach(function(e) {
                n(e, s)
            }), i.starts && n(i.starts, a), s.matcher = function(e) {
                const t = new o;
                return e.contains.forEach(e => t.addRule(e.begin, {
                    rule: e,
                    type: "begin"
                })), e.terminatorEnd && t.addRule(e.terminatorEnd, {
                    type: "end"
                }), e.illegal && t.addRule(e.illegal, {
                    type: "illegal"
                }), t
            }(s), s
        }(e)
    }
    function ee(e) {
        return !!e && (e.endsWithParent || ee(e.starts))
    }
    class te extends Error {
        constructor(e, t)
        {
            super(e),
            this.name = "HTMLInjectionError",
            this.html = t
        }
    }
    const ne = n,
        re = r,
        oe = Symbol("nomatch"),
        ie = function(n) {
            const r = Object.create(null),
                o = Object.create(null),
                i = [];
            let a = !0;
            const s = "Could not find the language '{}', did you forget to load/include a language module?",
                c = {
                    disableAutodetect: !0,
                    name: "Plain text",
                    contains: []
                };
            let g = {
                ignoreUnescapedHTML: !1,
                throwUnescapedHTML: !1,
                noHighlightRe: /^(no-?highlight)$/i,
                languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
                classPrefix: "hljs-",
                cssSelector: "pre code",
                languages: null,
                __emitter: l
            };
            function m(e) {
                return g.noHighlightRe.test(e)
            }
            function b(e, t, n) {
                let r = "",
                    o = "";
                "object" == typeof t ? (r = e, n = t.ignoreIllegals, o = t.language) : (q("10.7.0", "highlight(lang, code, ...args) has been deprecated."), q("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), o = e, r = t),
                void 0 === n && (n = !0);
                const i = {
                    code: r,
                    language: o
                };
                S("before:highlight", i);
                const a = i.result ? i.result : A(i.language, i.code, n);
                return a.code = i.code, S("after:highlight", a), a
            }
            function A(e, n, o, i) {
                const l = Object.create(null);
                function c(e, t) {
                    return e.keywords[t]
                }
                function u() {
                    if (!I.keywords)
                        return void M.addText(R);
                    let e = 0;
                    I.keywordPatternRe.lastIndex = 0;
                    let t = I.keywordPatternRe.exec(R),
                        n = "";
                    for (; t;) {
                        n += R.substring(e, t.index);
                        const r = C.case_insensitive ? t[0].toLowerCase() : t[0],
                            o = c(I, r);
                        if (o) {
                            const [e, i] = o;
                            if (M.addText(n), n = "", l[r] = (l[r] || 0) + 1, l[r] <= 7 && (B += i), e.startsWith("_"))
                                n += t[0];
                            else {
                                const n = C.classNameAliases[e] || e;
                                p(t[0], n)
                            }
                        } else
                            n += t[0];
                        e = I.keywordPatternRe.lastIndex,
                        t = I.keywordPatternRe.exec(R)
                    }
                    n += R.substring(e),
                    M.addText(n)
                }
                function d() {
                    null != I.subLanguage ? function() {
                        if ("" === R)
                            return;
                        let e = null;
                        if ("string" == typeof I.subLanguage) {
                            if (!r[I.subLanguage])
                                return void M.addText(R);
                            e = A(I.subLanguage, R, !0, T[I.subLanguage]),
                            T[I.subLanguage] = e._top
                        } else
                            e = y(R, I.subLanguage.length ? I.subLanguage : null);
                        I.relevance > 0 && (B += e.relevance),
                        M.__addSublanguage(e._emitter, e.language)
                    }() : u(),
                    R = ""
                }
                function p(e, t) {
                    "" !== e && (M.startScope(t), M.addText(e), M.endScope())
                }
                function h(e, t) {
                    let n = 1;
                    const r = t.length - 1;
                    for (; n <= r;) {
                        if (!e._emit[n]) {
                            n++;
                            continue
                        }
                        const r = C.classNameAliases[e[n]] || e[n],
                            o = t[n];
                        r ? p(o, r) : (R = o, u(), R = ""),
                        n++
                    }
                }
                function f(e, t) {
                    return e.scope && "string" == typeof e.scope && M.openNode(C.classNameAliases[e.scope] || e.scope), e.beginScope && (e.beginScope._wrap ? (p(R, C.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap), R = "") : e.beginScope._multi && (h(e.beginScope, t), R = "")), I = Object.create(e, {
                        parent: {
                            value: I
                        }
                    }), I
                }
                function m(e, n, r) {
                    let o = function(e, t) {
                        const n = e && e.exec(t);
                        return n && 0 === n.index
                    }(e.endRe, r);
                    if (o) {
                        if (e["on:end"]) {
                            const r = new t(e);
                            e["on:end"](n, r),
                            r.isMatchIgnored && (o = !1)
                        }
                        if (o) {
                            for (; e.endsParent && e.parent;)
                                e = e.parent;
                            return e
                        }
                    }
                    if (e.endsWithParent)
                        return m(e.parent, n, r)
                }
                function b(e) {
                    return 0 === I.matcher.regexIndex ? (R += e[0], 1) : (P = !0, 0)
                }
                function v(e) {
                    const t = e[0],
                        r = n.substring(e.index),
                        o = m(I, e, r);
                    if (!o)
                        return oe;
                    const i = I;
                    I.endScope && I.endScope._wrap ? (d(), p(t, I.endScope._wrap)) : I.endScope && I.endScope._multi ? (d(), h(I.endScope, e)) : i.skip ? R += t : (i.returnEnd || i.excludeEnd || (R += t), d(), i.excludeEnd && (R = t));
                    do {
                        I.scope && M.closeNode(),
                        I.skip || I.subLanguage || (B += I.relevance),
                        I = I.parent
                    } while (I !== o.parent);
                    return o.starts && f(o.starts, e), i.returnEnd ? 0 : t.length
                }
                let _ = {};
                function x(r, i) {
                    const s = i && i[0];
                    if (R += r, null == s)
                        return d(), 0;
                    if ("begin" === _.type && "end" === i.type && _.index === i.index && "" === s) {
                        if (R += n.slice(i.index, i.index + 1), !a) {
                            const t = new Error(`0 width match regex (${e})`);
                            throw t.languageName = e, t.badRule = _.rule, t
                        }
                        return 1
                    }
                    if (_ = i, "begin" === i.type)
                        return function(e) {
                            const n = e[0],
                                r = e.rule,
                                o = new t(r),
                                i = [r.__beforeBegin, r["on:begin"]];
                            for (const t of i)
                                if (t && (t(e, o), o.isMatchIgnored))
                                    return b(n);
                            return r.skip ? R += n : (r.excludeBegin && (R += n), d(), r.returnBegin || r.excludeBegin || (R = n)), f(r, e), r.returnBegin ? 0 : n.length
                        }(i);
                    if ("illegal" === i.type && !o) {
                        const e = new Error('Illegal lexeme "' + s + '" for mode "' + (I.scope || "<unnamed>") + '"');
                        throw e.mode = I, e
                    }
                    if ("end" === i.type) {
                        const e = v(i);
                        if (e !== oe)
                            return e
                    }
                    if ("illegal" === i.type && "" === s)
                        return R += "\n", 1;
                    if (D > 1e5 && D > 3 * i.index)
                        throw new Error("potential infinite loop, way more iterations than matches");
                    return R += s, s.length
                }
                const C = w(e);
                if (!C)
                    throw s.replace("{}", e), new Error('Unknown language: "' + e + '"');
                const E = Z(C);
                let S = "",
                    I = i || E;
                const T = {},
                    M = new g.__emitter(g);
                !function() {
                    const e = [];
                    for (let t = I; t !== C; t = t.parent)
                        t.scope && e.unshift(t.scope);
                    e.forEach(e => M.openNode(e))
                }();
                let R = "",
                    B = 0,
                    k = 0,
                    D = 0,
                    P = !1;
                try {
                    if (C.__emitTokens)
                        C.__emitTokens(n, M);
                    else {
                        for (I.matcher.considerAll();;) {
                            D++,
                            P ? P = !1 : I.matcher.considerAll(),
                            I.matcher.lastIndex = k;
                            const e = I.matcher.exec(n);
                            if (!e)
                                break;
                            const t = x(n.substring(k, e.index), e);
                            k = e.index + t
                        }
                        x(n.substring(k))
                    }
                    return M.finalize(), S = M.toHTML(), {
                        language: e,
                        value: S,
                        relevance: B,
                        illegal: !1,
                        _emitter: M,
                        _top: I
                    }
                } catch (O) {
                    if (O.message && O.message.includes("Illegal"))
                        return {
                            language: e,
                            value: ne(n),
                            illegal: !0,
                            relevance: 0,
                            _illegalBy: {
                                message: O.message,
                                index: k,
                                context: n.slice(k - 100, k + 100),
                                mode: O.mode,
                                resultSoFar: S
                            },
                            _emitter: M
                        };
                    if (a)
                        return {
                            language: e,
                            value: ne(n),
                            illegal: !1,
                            relevance: 0,
                            errorRaised: O,
                            _emitter: M,
                            _top: I
                        };
                    throw O
                }
            }
            function y(e, t) {
                t = t || g.languages || Object.keys(r);
                const n = function(e) {
                        const t = {
                            value: ne(e),
                            illegal: !1,
                            relevance: 0,
                            _top: c,
                            _emitter: new g.__emitter(g)
                        };
                        return t._emitter.addText(e), t
                    }(e),
                    o = t.filter(w).filter(E).map(t => A(t, e, !1));
                o.unshift(n);
                const i = o.sort((e, t) => {
                        if (e.relevance !== t.relevance)
                            return t.relevance - e.relevance;
                        if (e.language && t.language) {
                            if (w(e.language).supersetOf === t.language)
                                return 1;
                            if (w(t.language).supersetOf === e.language)
                                return -1
                        }
                        return 0
                    }),
                    [a, s] = i,
                    l = a;
                return l.secondBest = s, l
            }
            function v(e) {
                let t = null;
                const n = function(e) {
                    let t = e.className + " ";
                    t += e.parentNode ? e.parentNode.className : "";
                    const n = g.languageDetectRe.exec(t);
                    if (n) {
                        const e = w(n[1]);
                        return e || s.replace("{}", n[1]), e ? n[1] : "no-highlight"
                    }
                    return t.split(/\s+/).find(e => m(e) || w(e))
                }(e);
                if (m(n))
                    return;
                if (S("before:highlightElement", {
                    el: e,
                    language: n
                }), e.dataset.highlighted)
                    return;
                if (e.children.length > 0 && (g.ignoreUnescapedHTML, g.throwUnescapedHTML))
                    throw new te("One of your code blocks includes unescaped HTML.", e.innerHTML);
                t = e;
                const r = t.textContent,
                    i = n ? b(r, {
                        language: n,
                        ignoreIllegals: !0
                    }) : y(r);
                e.innerHTML = i.value,
                e.dataset.highlighted = "yes",
                function(e, t, n) {
                    const r = t && o[t] || n;
                    e.classList.add("hljs"),
                    e.classList.add(`language-${r}`)
                }(e, n, i.language),
                e.result = {
                    language: i.language,
                    re: i.relevance,
                    relevance: i.relevance
                },
                i.secondBest && (e.secondBest = {
                    language: i.secondBest.language,
                    relevance: i.secondBest.relevance
                }),
                S("after:highlightElement", {
                    el: e,
                    result: i,
                    text: r
                })
            }
            let _ = !1;
            function x() {
                if ("loading" === document.readyState)
                    return _ || window.addEventListener("DOMContentLoaded", function() {
                        x()
                    }, !1), void (_ = !0);
                document.querySelectorAll(g.cssSelector).forEach(v)
            }
            function w(e) {
                return e = (e || "").toLowerCase(), r[e] || r[o[e]]
            }
            function C(e, {languageName: t}) {
                "string" == typeof e && (e = [e]),
                e.forEach(e => {
                    o[e.toLowerCase()] = t
                })
            }
            function E(e) {
                const t = w(e);
                return t && !t.disableAutodetect
            }
            function S(e, t) {
                const n = e;
                i.forEach(function(e) {
                    e[n] && e[n](t)
                })
            }
            Object.assign(n, {
                highlight: b,
                highlightAuto: y,
                highlightAll: x,
                highlightElement: v,
                highlightBlock: function(e) {
                    return q("10.7.0", "highlightBlock will be removed entirely in v12.0"), q("10.7.0", "Please use highlightElement now."), v(e)
                },
                configure: function(e) {
                    g = re(g, e)
                },
                initHighlighting: () => {
                    x(),
                    q("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
                },
                initHighlightingOnLoad: function() {
                    x(),
                    q("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
                },
                registerLanguage: function(e, t) {
                    let o = null;
                    try {
                        o = t(n)
                    } catch (i) {
                        if ("Language definition for '{}' could not be registered.".replace("{}", e), !a)
                            throw i;
                        o = c
                    }
                    o.name || (o.name = e),
                    r[e] = o,
                    o.rawDefinition = t.bind(null, n),
                    o.aliases && C(o.aliases, {
                        languageName: e
                    })
                },
                unregisterLanguage: function(e) {
                    delete r[e];
                    for (const t of Object.keys(o))
                        o[t] === e && delete o[t]
                },
                listLanguages: function() {
                    return Object.keys(r)
                },
                getLanguage: w,
                registerAliases: C,
                autoDetection: E,
                inherit: re,
                addPlugin: function(e) {
                    !function(e) {
                        e["before:highlightBlock"] && !e["before:highlightElement"] && (e["before:highlightElement"] = t => {
                            e["before:highlightBlock"](Object.assign({
                                block: t.el
                            }, t))
                        }),
                        e["after:highlightBlock"] && !e["after:highlightElement"] && (e["after:highlightElement"] = t => {
                            e["after:highlightBlock"](Object.assign({
                                block: t.el
                            }, t))
                        })
                    }(e),
                    i.push(e)
                },
                removePlugin: function(e) {
                    const t = i.indexOf(e);
                    -1 !== t && i.splice(t, 1)
                }
            }),
            n.debugMode = function() {
                a = !1
            },
            n.safeMode = function() {
                a = !0
            },
            n.versionString = "11.11.1",
            n.regex = {
                concat: h,
                lookahead: u,
                either: f,
                optional: p,
                anyNumberOfTimes: d
            };
            for (const t in N)
                "object" == typeof N[t] && e(N[t]);
            return Object.assign(n, N), n
        },
        ae = ie({});
    return ae.newInstance = () => ie({}), LP = ae, ae.HighlightJS = ae, ae.default = ae, LP
}
BP.render = function(e, t, n, r, o, i) {
    var a = jn("Button"),
        s = jn("Portal"),
        l = $n("focustrap");
    return uo(), mo(s, {
        appendTo: e.appendTo
    }, {
        default: Vt(function() {
            return [o.containerVisible ? (uo(), go("div", Mo({
                key: 0,
                ref: i.maskRef,
                class: e.cx("mask"),
                style: e.sx("mask", !0, {
                    position: e.position,
                    modal: e.modal
                }),
                onMousedown: t[1] || (t[1] = function() {
                    return i.onMaskMouseDown && i.onMaskMouseDown.apply(i, arguments)
                }),
                onMouseup: t[2] || (t[2] = function() {
                    return i.onMaskMouseUp && i.onMaskMouseUp.apply(i, arguments)
                }),
                "data-p": i.dataP
            }, e.ptm("mask")), [xo(ii, Mo({
                name: "p-dialog",
                onEnter: i.onEnter,
                onAfterEnter: i.onAfterEnter,
                onBeforeLeave: i.onBeforeLeave,
                onLeave: i.onLeave,
                onAfterLeave: i.onAfterLeave,
                appear: ""
            }, e.ptm("transition")), {
                default: Vt(function() {
                    return [e.visible ? Ht((uo(), go("div", Mo({
                        key: 0,
                        ref: i.containerRef,
                        class: e.cx("root"),
                        style: e.sx("root"),
                        role: "dialog",
                        "aria-labelledby": i.ariaLabelledById,
                        "aria-modal": e.modal,
                        "data-p": i.dataP
                    }, e.ptmi("root")), [e.$slots.container ? Yn(e.$slots, "container", {
                        key: 0,
                        closeCallback: i.close,
                        maximizeCallback: function(e) {
                            return i.maximize(e)
                        },
                        initDragCallback: i.initDrag
                    }) : (uo(), go(oo, {
                        key: 1
                    }, [e.showHeader ? (uo(), go("div", Mo({
                        key: 0,
                        ref: i.headerContainerRef,
                        class: e.cx("header"),
                        onMousedown: t[0] || (t[0] = function() {
                            return i.initDrag && i.initDrag.apply(i, arguments)
                        })
                    }, e.ptm("header")), [Yn(e.$slots, "header", {
                        class: G(e.cx("title"))
                    }, function() {
                        return [e.header ? (uo(), go("span", Mo({
                            key: 0,
                            id: i.ariaLabelledById,
                            class: e.cx("title")
                        }, e.ptm("title")), W(e.header), 17, zP)) : Eo("", !0)]
                    }), _o("div", Mo({
                        class: e.cx("headerActions")
                    }, e.ptm("headerActions")), [e.maximizable ? Yn(e.$slots, "maximizebutton", {
                        key: 0,
                        maximized: o.maximized,
                        maximizeCallback: function(e) {
                            return i.maximize(e)
                        }
                    }, function() {
                        return [xo(a, Mo({
                            ref: i.maximizableRef,
                            autofocus: o.focusableMax,
                            class: e.cx("pcMaximizeButton"),
                            onClick: i.maximize,
                            tabindex: e.maximizable ? "0" : "-1",
                            unstyled: e.unstyled
                        }, e.maximizeButtonProps, {
                            pt: e.ptm("pcMaximizeButton"),
                            "data-pc-group-section": "headericon"
                        }), {
                            icon: Vt(function(t) {
                                return [Yn(e.$slots, "maximizeicon", {
                                    maximized: o.maximized
                                }, function() {
                                    return [(uo(), mo(Hn(i.maximizeIconComponent), Mo({
                                        class: [t.class, o.maximized ? e.minimizeIcon : e.maximizeIcon]
                                    }, e.ptm("pcMaximizeButton").icon), null, 16, ["class"]))]
                                })]
                            }),
                            _: 3
                        }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])]
                    }) : Eo("", !0), e.closable ? Yn(e.$slots, "closebutton", {
                        key: 1,
                        closeCallback: i.close
                    }, function() {
                        return [xo(a, Mo({
                            ref: i.closeButtonRef,
                            autofocus: o.focusableClose,
                            class: e.cx("pcCloseButton"),
                            onClick: i.close,
                            "aria-label": i.closeAriaLabel,
                            unstyled: e.unstyled
                        }, e.closeButtonProps, {
                            pt: e.ptm("pcCloseButton"),
                            "data-pc-group-section": "headericon"
                        }), {
                            icon: Vt(function(t) {
                                return [Yn(e.$slots, "closeicon", {}, function() {
                                    return [(uo(), mo(Hn(e.closeIcon ? "span" : "TimesIcon"), Mo({
                                        class: [e.closeIcon, t.class]
                                    }, e.ptm("pcCloseButton").icon), null, 16, ["class"]))]
                                })]
                            }),
                            _: 3
                        }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])]
                    }) : Eo("", !0)], 16)], 16)) : Eo("", !0), _o("div", Mo({
                        ref: i.contentRef,
                        class: [e.cx("content"), e.contentClass],
                        style: e.contentStyle,
                        "data-p": i.dataP
                    }, PP(PP({}, e.contentProps), e.ptm("content"))), [Yn(e.$slots, "default")], 16, QP), e.footer || e.$slots.footer ? (uo(), go("div", Mo({
                        key: 1,
                        ref: i.footerContainerRef,
                        class: e.cx("footer")
                    }, e.ptm("footer")), [Yn(e.$slots, "footer", {}, function() {
                        return [Co(W(e.footer), 1)]
                    })], 16)) : Eo("", !0)], 64))], 16, UP)), [[l, {
                        disabled: !e.modal
                    }]]) : Eo("", !0)]
                }),
                _: 3
            }, 16, ["onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16, FP)) : Eo("", !0)]
        }),
        _: 3
    }, 8, ["appendTo"])
};
const jP = fy(GP());
var VP = {
    name: "UploadIcon",
    extends: AT
};
function HP(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
VP.render = function(e, t, n, r, o, i) {
    return uo(), go("svg", Mo({
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e.pti()), function(e) {
        if (Array.isArray(e))
            return HP(e)
    }(a = t[0] || (t[0] = [_o("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M6.58942 9.82197C6.70165 9.93405 6.85328 9.99793 7.012 10C7.17071 9.99793 7.32234 9.93405 7.43458 9.82197C7.54681 9.7099 7.61079 9.55849 7.61286 9.4V2.04798L9.79204 4.22402C9.84752 4.28011 9.91365 4.32457 9.98657 4.35479C10.0595 4.38502 10.1377 4.40039 10.2167 4.40002C10.2956 4.40039 10.3738 4.38502 10.4467 4.35479C10.5197 4.32457 10.5858 4.28011 10.6413 4.22402C10.7538 4.11152 10.817 3.95902 10.817 3.80002C10.817 3.64102 10.7538 3.48852 10.6413 3.37602L7.45127 0.190618C7.44656 0.185584 7.44176 0.180622 7.43687 0.175736C7.32419 0.063214 7.17136 0 7.012 0C6.85264 0 6.69981 0.063214 6.58712 0.175736C6.58181 0.181045 6.5766 0.186443 6.5715 0.191927L3.38282 3.37602C3.27669 3.48976 3.2189 3.6402 3.22165 3.79564C3.2244 3.95108 3.28746 4.09939 3.39755 4.20932C3.50764 4.31925 3.65616 4.38222 3.81182 4.38496C3.96749 4.3877 4.11814 4.33001 4.23204 4.22402L6.41113 2.04807V9.4C6.41321 9.55849 6.47718 9.7099 6.58942 9.82197ZM11.9952 14H2.02883C1.751 13.9887 1.47813 13.9228 1.22584 13.8061C0.973545 13.6894 0.746779 13.5241 0.558517 13.3197C0.370254 13.1154 0.22419 12.876 0.128681 12.6152C0.0331723 12.3545 -0.00990605 12.0775 0.0019109 11.8V9.40005C0.0019109 9.24092 0.065216 9.08831 0.1779 8.97579C0.290584 8.86326 0.443416 8.80005 0.602775 8.80005C0.762134 8.80005 0.914966 8.86326 1.02765 8.97579C1.14033 9.08831 1.20364 9.24092 1.20364 9.40005V11.8C1.18295 12.0376 1.25463 12.274 1.40379 12.4602C1.55296 12.6463 1.76817 12.7681 2.00479 12.8H11.9952C12.2318 12.7681 12.447 12.6463 12.5962 12.4602C12.7453 12.274 12.817 12.0376 12.7963 11.8V9.40005C12.7963 9.24092 12.8596 9.08831 12.9723 8.97579C13.085 8.86326 13.2378 8.80005 13.3972 8.80005C13.5565 8.80005 13.7094 8.86326 13.8221 8.97579C13.9347 9.08831 13.998 9.24092 13.998 9.40005V11.8C14.022 12.3563 13.8251 12.8996 13.45 13.3116C13.0749 13.7236 12.552 13.971 11.9952 14Z",
        fill: "currentColor"
    }, null, -1)])) || function(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
            return Array.from(e)
    }(a) || function(e, t) {
        if (e) {
            if ("string" == typeof e)
                return HP(e, t);
            var n = {}.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? HP(e, t) : void 0
        }
    }(a) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }(), 16);
    var a
};
var $P = kI.extend({
        name: "progressbar",
        style: "\n    .p-progressbar {\n        display: block;\n        position: relative;\n        overflow: hidden;\n        height: dt('progressbar.height');\n        background: dt('progressbar.background');\n        border-radius: dt('progressbar.border.radius');\n    }\n\n    .p-progressbar-value {\n        margin: 0;\n        background: dt('progressbar.value.background');\n    }\n\n    .p-progressbar-label {\n        color: dt('progressbar.label.color');\n        font-size: dt('progressbar.label.font.size');\n        font-weight: dt('progressbar.label.font.weight');\n    }\n\n    .p-progressbar-determinate .p-progressbar-value {\n        height: 100%;\n        width: 0%;\n        position: absolute;\n        display: none;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        overflow: hidden;\n        transition: width 1s ease-in-out;\n    }\n\n    .p-progressbar-determinate .p-progressbar-label {\n        display: inline-flex;\n    }\n\n    .p-progressbar-indeterminate .p-progressbar-value::before {\n        content: '';\n        position: absolute;\n        background: inherit;\n        inset-block-start: 0;\n        inset-inline-start: 0;\n        inset-block-end: 0;\n        will-change: inset-inline-start, inset-inline-end;\n        animation: p-progressbar-indeterminate-anim 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n    }\n\n    .p-progressbar-indeterminate .p-progressbar-value::after {\n        content: '';\n        position: absolute;\n        background: inherit;\n        inset-block-start: 0;\n        inset-inline-start: 0;\n        inset-block-end: 0;\n        will-change: inset-inline-start, inset-inline-end;\n        animation: p-progressbar-indeterminate-anim-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n        animation-delay: 1.15s;\n    }\n\n    @keyframes p-progressbar-indeterminate-anim {\n        0% {\n            inset-inline-start: -35%;\n            inset-inline-end: 100%;\n        }\n        60% {\n            inset-inline-start: 100%;\n            inset-inline-end: -90%;\n        }\n        100% {\n            inset-inline-start: 100%;\n            inset-inline-end: -90%;\n        }\n    }\n    @-webkit-keyframes p-progressbar-indeterminate-anim {\n        0% {\n            inset-inline-start: -35%;\n            inset-inline-end: 100%;\n        }\n        60% {\n            inset-inline-start: 100%;\n            inset-inline-end: -90%;\n        }\n        100% {\n            inset-inline-start: 100%;\n            inset-inline-end: -90%;\n        }\n    }\n\n    @keyframes p-progressbar-indeterminate-anim-short {\n        0% {\n            inset-inline-start: -200%;\n            inset-inline-end: 100%;\n        }\n        60% {\n            inset-inline-start: 107%;\n            inset-inline-end: -8%;\n        }\n        100% {\n            inset-inline-start: 107%;\n            inset-inline-end: -8%;\n        }\n    }\n    @-webkit-keyframes p-progressbar-indeterminate-anim-short {\n        0% {\n            inset-inline-start: -200%;\n            inset-inline-end: 100%;\n        }\n        60% {\n            inset-inline-start: 107%;\n            inset-inline-end: -8%;\n        }\n        100% {\n            inset-inline-start: 107%;\n            inset-inline-end: -8%;\n        }\n    }\n",
        classes: {
            root: function(e) {
                var t = e.instance;
                return ["p-progressbar p-component", {
                    "p-progressbar-determinate": t.determinate,
                    "p-progressbar-indeterminate": t.indeterminate
                }]
            },
            value: "p-progressbar-value",
            label: "p-progressbar-label"
        }
    }),
    WP = {
        name: "ProgressBar",
        extends: {
            name: "BaseProgressBar",
            extends: nT,
            props: {
                value: {
                    type: Number,
                    default: null
                },
                mode: {
                    type: String,
                    default: "determinate"
                },
                showValue: {
                    type: Boolean,
                    default: !0
                }
            },
            style: $P,
            provide: function() {
                return {
                    $pcProgressBar: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        computed: {
            progressStyle: function() {
                return {
                    width: this.value + "%",
                    display: "flex"
                }
            },
            indeterminate: function() {
                return "indeterminate" === this.mode
            },
            determinate: function() {
                return "determinate" === this.mode
            },
            dataP: function() {
                return RS({
                    determinate: this.determinate,
                    indeterminate: this.indeterminate
                })
            }
        }
    },
    KP = ["aria-valuenow", "data-p"],
    qP = ["data-p"],
    XP = ["data-p"],
    YP = ["data-p"];
WP.render = function(e, t, n, r, o, i) {
    return uo(), go("div", Mo({
        role: "progressbar",
        class: e.cx("root"),
        "aria-valuemin": "0",
        "aria-valuenow": e.value,
        "aria-valuemax": "100",
        "data-p": i.dataP
    }, e.ptmi("root")), [i.determinate ? (uo(), go("div", Mo({
        key: 0,
        class: e.cx("value"),
        style: i.progressStyle,
        "data-p": i.dataP
    }, e.ptm("value")), [null != e.value && 0 !== e.value && e.showValue ? (uo(), go("div", Mo({
        key: 0,
        class: e.cx("label"),
        "data-p": i.dataP
    }, e.ptm("label")), [Yn(e.$slots, "default", {}, function() {
        return [Co(W(e.value + "%"), 1)]
    })], 16, XP)) : Eo("", !0)], 16, qP)) : i.indeterminate ? (uo(), go("div", Mo({
        key: 1,
        class: e.cx("value"),
        "data-p": i.dataP
    }, e.ptm("value")), null, 16, YP)) : Eo("", !0)], 16, KP)
};
var JP = kI.extend({
        name: "fileupload",
        style: "\n    .p-fileupload input[type='file'] {\n        display: none;\n    }\n\n    .p-fileupload-advanced {\n        border: 1px solid dt('fileupload.border.color');\n        border-radius: dt('fileupload.border.radius');\n        background: dt('fileupload.background');\n        color: dt('fileupload.color');\n    }\n\n    .p-fileupload-header {\n        display: flex;\n        align-items: center;\n        padding: dt('fileupload.header.padding');\n        background: dt('fileupload.header.background');\n        color: dt('fileupload.header.color');\n        border-style: solid;\n        border-width: dt('fileupload.header.border.width');\n        border-color: dt('fileupload.header.border.color');\n        border-radius: dt('fileupload.header.border.radius');\n        gap: dt('fileupload.header.gap');\n    }\n\n    .p-fileupload-content {\n        border: 1px solid transparent;\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.content.gap');\n        transition: border-color dt('fileupload.transition.duration');\n        padding: dt('fileupload.content.padding');\n    }\n\n    .p-fileupload-content .p-progressbar {\n        width: 100%;\n        height: dt('fileupload.progressbar.height');\n    }\n\n    .p-fileupload-file-list {\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.filelist.gap');\n    }\n\n    .p-fileupload-file {\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        padding: dt('fileupload.file.padding');\n        border-block-end: 1px solid dt('fileupload.file.border.color');\n        gap: dt('fileupload.file.gap');\n    }\n\n    .p-fileupload-file:last-child {\n        border-block-end: 0;\n    }\n\n    .p-fileupload-file-info {\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.file.info.gap');\n    }\n\n    .p-fileupload-file-thumbnail {\n        flex-shrink: 0;\n    }\n\n    .p-fileupload-file-actions {\n        margin-inline-start: auto;\n    }\n\n    .p-fileupload-highlight {\n        border: 1px dashed dt('fileupload.content.highlight.border.color');\n    }\n\n    .p-fileupload-basic .p-message {\n        margin-block-end: dt('fileupload.basic.gap');\n    }\n\n    .p-fileupload-basic-content {\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: dt('fileupload.basic.gap');\n    }\n",
        classes: {
            root: function(e) {
                var t = e.props;
                return ["p-fileupload p-fileupload-".concat(t.mode, " p-component")]
            },
            header: "p-fileupload-header",
            pcChooseButton: "p-fileupload-choose-button",
            pcUploadButton: "p-fileupload-upload-button",
            pcCancelButton: "p-fileupload-cancel-button",
            content: "p-fileupload-content",
            fileList: "p-fileupload-file-list",
            file: "p-fileupload-file",
            fileThumbnail: "p-fileupload-file-thumbnail",
            fileInfo: "p-fileupload-file-info",
            fileName: "p-fileupload-file-name",
            fileSize: "p-fileupload-file-size",
            pcFileBadge: "p-fileupload-file-badge",
            fileActions: "p-fileupload-file-actions",
            pcFileRemoveButton: "p-fileupload-file-remove-button",
            basicContent: "p-fileupload-basic-content"
        }
    }),
    ZP = {
        name: "BaseFileUpload",
        extends: nT,
        props: {
            name: {
                type: String,
                default: null
            },
            url: {
                type: String,
                default: null
            },
            mode: {
                type: String,
                default: "advanced"
            },
            multiple: {
                type: Boolean,
                default: !1
            },
            accept: {
                type: String,
                default: null
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            auto: {
                type: Boolean,
                default: !1
            },
            maxFileSize: {
                type: Number,
                default: null
            },
            invalidFileSizeMessage: {
                type: String,
                default: "{0}: Invalid file size, file size should be smaller than {1}."
            },
            invalidFileTypeMessage: {
                type: String,
                default: "{0}: Invalid file type, allowed file types: {1}."
            },
            fileLimit: {
                type: Number,
                default: null
            },
            invalidFileLimitMessage: {
                type: String,
                default: "Maximum number of files exceeded, limit is {0} at most."
            },
            withCredentials: {
                type: Boolean,
                default: !1
            },
            previewWidth: {
                type: Number,
                default: 50
            },
            chooseLabel: {
                type: String,
                default: null
            },
            uploadLabel: {
                type: String,
                default: null
            },
            cancelLabel: {
                type: String,
                default: null
            },
            customUpload: {
                type: Boolean,
                default: !1
            },
            showUploadButton: {
                type: Boolean,
                default: !0
            },
            showCancelButton: {
                type: Boolean,
                default: !0
            },
            chooseIcon: {
                type: String,
                default: void 0
            },
            uploadIcon: {
                type: String,
                default: void 0
            },
            cancelIcon: {
                type: String,
                default: void 0
            },
            style: null,
            class: null,
            chooseButtonProps: {
                type: null,
                default: null
            },
            uploadButtonProps: {
                type: Object,
                default: function() {
                    return {
                        severity: "secondary"
                    }
                }
            },
            cancelButtonProps: {
                type: Object,
                default: function() {
                    return {
                        severity: "secondary"
                    }
                }
            }
        },
        style: JP,
        provide: function() {
            return {
                $pcFileUpload: this,
                $parentInstance: this
            }
        }
    },
    eO = {
        name: "FileContent",
        hostName: "FileUpload",
        extends: nT,
        emits: ["remove"],
        props: {
            files: {
                type: Array,
                default: function() {
                    return []
                }
            },
            badgeSeverity: {
                type: String,
                default: "warn"
            },
            badgeValue: {
                type: String,
                default: null
            },
            previewWidth: {
                type: Number,
                default: 50
            },
            templates: {
                type: null,
                default: null
            }
        },
        methods: {
            formatSize: function(e) {
                var t,
                    n = (null === (t = this.$primevue.config.locale) || void 0 === t ? void 0 : t.fileSizeTypes) || ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
                if (0 === e)
                    return "0 ".concat(n[0]);
                var r = Math.floor(Math.log(e) / Math.log(1024)),
                    o = parseFloat((e / Math.pow(1024, r)).toFixed(3));
                return "".concat(o, " ").concat(n[r])
            }
        },
        components: {
            Button: _R,
            Badge: hR,
            TimesIcon: yT
        }
    },
    tO = ["alt", "src", "width"];
function nO(e) {
    return function(e) {
            if (Array.isArray(e))
                return iO(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(e) || oO(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
}
function rO(e, t) {
    var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
        if (Array.isArray(e) || (n = oO(e)) || t) {
            n && (e = n);
            var r = 0,
                o = function() {};
            return {
                s: o,
                n: function() {
                    return r >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[r++]
                    }
                },
                e: function(e) {
                    throw e
                },
                f: o
            }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
    var i,
        a = !0,
        s = !1;
    return {
        s: function() {
            n = n.call(e)
        },
        n: function() {
            var e = n.next();
            return a = e.done, e
        },
        e: function(e) {
            s = !0,
            i = e
        },
        f: function() {
            try {
                a || null == n.return || n.return()
            } finally {
                if (s)
                    throw i
            }
        }
    }
}
function oO(e, t) {
    if (e) {
        if ("string" == typeof e)
            return iO(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? iO(e, t) : void 0
    }
}
function iO(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
eO.render = function(e, t, n, r, o, i) {
    var a = jn("Badge"),
        s = jn("TimesIcon"),
        l = jn("Button");
    return uo(!0), go(oo, null, qn(n.files, function(t, r) {
        return uo(), go("div", Mo({
            key: t.name + t.type + t.size,
            class: e.cx("file")
        }, {
            ref_for: !0
        }, e.ptm("file")), [_o("img", Mo({
            role: "presentation",
            class: e.cx("fileThumbnail"),
            alt: t.name,
            src: t.objectURL,
            width: n.previewWidth
        }, {
            ref_for: !0
        }, e.ptm("fileThumbnail")), null, 16, tO), _o("div", Mo({
            class: e.cx("fileInfo")
        }, {
            ref_for: !0
        }, e.ptm("fileInfo")), [_o("div", Mo({
            class: e.cx("fileName")
        }, {
            ref_for: !0
        }, e.ptm("fileName")), W(t.name), 17), _o("span", Mo({
            class: e.cx("fileSize")
        }, {
            ref_for: !0
        }, e.ptm("fileSize")), W(i.formatSize(t.size)), 17)], 16), xo(a, {
            value: n.badgeValue,
            class: G(e.cx("pcFileBadge")),
            severity: n.badgeSeverity,
            unstyled: e.unstyled,
            pt: e.ptm("pcFileBadge")
        }, null, 8, ["value", "class", "severity", "unstyled", "pt"]), _o("div", Mo({
            class: e.cx("fileActions")
        }, {
            ref_for: !0
        }, e.ptm("fileActions")), [xo(l, {
            onClick: function(t) {
                return e.$emit("remove", r)
            },
            text: "",
            rounded: "",
            severity: "danger",
            class: G(e.cx("pcFileRemoveButton")),
            unstyled: e.unstyled,
            pt: e.ptm("pcFileRemoveButton")
        }, {
            icon: Vt(function(o) {
                return [n.templates.fileremoveicon ? (uo(), mo(Hn(n.templates.fileremoveicon), {
                    key: 0,
                    class: G(o.class),
                    file: t,
                    index: r
                }, null, 8, ["class", "file", "index"])) : (uo(), mo(s, Mo({
                    key: 1,
                    class: o.class,
                    "aria-hidden": "true"
                }, {
                    ref_for: !0
                }, e.ptm("pcFileRemoveButton").icon), null, 16, ["class"]))]
            }),
            _: 2
        }, 1032, ["onClick", "class", "unstyled", "pt"])], 16)], 16)
    }), 128)
};
var aO = {
        name: "FileUpload",
        extends: ZP,
        inheritAttrs: !1,
        emits: ["select", "uploader", "before-upload", "progress", "upload", "error", "before-send", "clear", "remove", "remove-uploaded-file"],
        duplicateIEEvent: !1,
        data: function() {
            return {
                uploadedFileCount: 0,
                files: [],
                messages: [],
                focused: !1,
                progress: null,
                uploadedFiles: []
            }
        },
        methods: {
            upload: function() {
                this.hasFiles && this.uploader()
            },
            onBasicUploaderClick: function(e) {
                0 === e.button && this.$refs.fileInput.click()
            },
            onFileSelect: function(e) {
                if ("drop" !== e.type && this.isIE11() && this.duplicateIEEvent)
                    this.duplicateIEEvent = !1;
                else {
                    this.isBasic && this.hasFiles && (this.files = []),
                    this.messages = [],
                    this.files = this.files || [];
                    var t,
                        n = rO(e.dataTransfer ? e.dataTransfer.files : e.target.files);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            var r = t.value;
                            this.isFileSelected(r) || this.isFileLimitExceeded() || this.validate(r) && (this.isImage(r) && (r.objectURL = window.URL.createObjectURL(r)), this.files.push(r))
                        }
                    } catch (o) {
                        n.e(o)
                    } finally {
                        n.f()
                    }
                    this.$emit("select", {
                        originalEvent: e,
                        files: this.files
                    }),
                    this.fileLimit && this.checkFileLimit(),
                    this.auto && this.hasFiles && !this.isFileLimitExceeded() && this.uploader(),
                    "drop" !== e.type && this.isIE11() ? this.clearIEInput() : this.clearInputElement()
                }
            },
            choose: function() {
                this.$refs.fileInput.click()
            },
            uploader: function() {
                var e = this;
                if (this.customUpload)
                    this.fileLimit && (this.uploadedFileCount += this.files.length),
                    this.$emit("uploader", {
                        files: this.files
                    });
                else {
                    var t = new XMLHttpRequest,
                        n = new FormData;
                    this.$emit("before-upload", {
                        xhr: t,
                        formData: n
                    });
                    var r,
                        o = rO(this.files);
                    try {
                        for (o.s(); !(r = o.n()).done;) {
                            var i = r.value;
                            n.append(this.name, i, i.name)
                        }
                    } catch (a) {
                        o.e(a)
                    } finally {
                        o.f()
                    }
                    t.upload.addEventListener("progress", function(t) {
                        t.lengthComputable && (e.progress = Math.round(100 * t.loaded / t.total)),
                        e.$emit("progress", {
                            originalEvent: t,
                            progress: e.progress
                        })
                    }),
                    t.onreadystatechange = function() {
                        var n;
                        4 === t.readyState && (e.progress = 0, t.status >= 200 && t.status < 300 ? (e.fileLimit && (e.uploadedFileCount += e.files.length), e.$emit("upload", {
                            xhr: t,
                            files: e.files
                        }), (n = e.uploadedFiles).push.apply(n, nO(e.files))) : e.$emit("error", {
                            xhr: t,
                            files: e.files
                        }), e.clear())
                    },
                    this.url && (t.open("POST", this.url, !0), this.$emit("before-send", {
                        xhr: t,
                        formData: n
                    }), t.withCredentials = this.withCredentials, t.send(n))
                }
            },
            clear: function() {
                this.files = [],
                this.messages = null,
                this.$emit("clear"),
                this.isAdvanced && this.clearInputElement()
            },
            onFocus: function() {
                this.focused = !0
            },
            onBlur: function() {
                this.focused = !1
            },
            isFileSelected: function(e) {
                if (this.files && this.files.length) {
                    var t,
                        n = rO(this.files);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            var r = t.value;
                            if (r.name + r.type + r.size === e.name + e.type + e.size)
                                return !0
                        }
                    } catch (o) {
                        n.e(o)
                    } finally {
                        n.f()
                    }
                }
                return !1
            },
            isIE11: function() {
                return !!window.MSInputMethodContext && !!document.documentMode
            },
            validate: function(e) {
                return this.accept && !this.isFileTypeValid(e) ? (this.messages.push(this.invalidFileTypeMessage.replace("{0}", e.name).replace("{1}", this.accept)), !1) : !(this.maxFileSize && e.size > this.maxFileSize && (this.messages.push(this.invalidFileSizeMessage.replace("{0}", e.name).replace("{1}", this.formatSize(this.maxFileSize))), 1))
            },
            isFileTypeValid: function(e) {
                var t,
                    n = rO(this.accept.split(",").map(function(e) {
                        return e.trim()
                    }));
                try {
                    for (n.s(); !(t = n.n()).done;) {
                        var r = t.value;
                        if (this.isWildcard(r) ? this.getTypeClass(e.type) === this.getTypeClass(r) : e.type == r || this.getFileExtension(e).toLowerCase() === r.toLowerCase())
                            return !0
                    }
                } catch (o) {
                    n.e(o)
                } finally {
                    n.f()
                }
                return !1
            },
            getTypeClass: function(e) {
                return e.substring(0, e.indexOf("/"))
            },
            isWildcard: function(e) {
                return -1 !== e.indexOf("*")
            },
            getFileExtension: function(e) {
                return "." + e.name.split(".").pop()
            },
            isImage: function(e) {
                return /^image\//.test(e.type)
            },
            onDragEnter: function(e) {
                this.disabled || this.hasFiles && !this.multiple || (e.stopPropagation(), e.preventDefault())
            },
            onDragOver: function(e) {
                this.disabled || this.hasFiles && !this.multiple || (!this.isUnstyled && uE(this.$refs.content, "p-fileupload-highlight"), this.$refs.content.setAttribute("data-p-highlight", !0), e.stopPropagation(), e.preventDefault())
            },
            onDragLeave: function() {
                this.disabled || (!this.isUnstyled && dE(this.$refs.content, "p-fileupload-highlight"), this.$refs.content.setAttribute("data-p-highlight", !1))
            },
            onDrop: function(e) {
                if (!this.disabled) {
                    !this.isUnstyled && dE(this.$refs.content, "p-fileupload-highlight"),
                    this.$refs.content.setAttribute("data-p-highlight", !1),
                    e.stopPropagation(),
                    e.preventDefault();
                    var t = e.dataTransfer ? e.dataTransfer.files : e.target.files;
                    (this.multiple || t && 1 === t.length) && this.onFileSelect(e)
                }
            },
            remove: function(e) {
                this.clearInputElement();
                var t = this.files.splice(e, 1)[0];
                this.files = nO(this.files),
                this.$emit("remove", {
                    file: t,
                    files: this.files
                })
            },
            removeUploadedFile: function(e) {
                var t = this.uploadedFiles.splice(e, 1)[0];
                this.uploadedFiles = nO(this.uploadedFiles),
                this.$emit("remove-uploaded-file", {
                    file: t,
                    files: this.uploadedFiles
                })
            },
            clearInputElement: function() {
                this.$refs.fileInput.value = ""
            },
            clearIEInput: function() {
                this.$refs.fileInput && (this.duplicateIEEvent = !0, this.$refs.fileInput.value = "")
            },
            formatSize: function(e) {
                var t,
                    n = (null === (t = this.$primevue.config.locale) || void 0 === t ? void 0 : t.fileSizeTypes) || ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
                if (0 === e)
                    return "0 ".concat(n[0]);
                var r = Math.floor(Math.log(e) / Math.log(1024)),
                    o = parseFloat((e / Math.pow(1024, r)).toFixed(3));
                return "".concat(o, " ").concat(n[r])
            },
            isFileLimitExceeded: function() {
                return this.fileLimit && this.fileLimit <= this.files.length + this.uploadedFileCount && this.focused && (this.focused = !1), this.fileLimit && this.fileLimit < this.files.length + this.uploadedFileCount
            },
            checkFileLimit: function() {
                this.isFileLimitExceeded() && this.messages.push(this.invalidFileLimitMessage.replace("{0}", this.fileLimit.toString()))
            },
            onMessageClose: function() {
                this.messages = null
            }
        },
        computed: {
            isAdvanced: function() {
                return "advanced" === this.mode
            },
            isBasic: function() {
                return "basic" === this.mode
            },
            chooseButtonClass: function() {
                return [this.cx("pcChooseButton"), this.class]
            },
            basicFileChosenLabel: function() {
                var e,
                    t;
                return this.auto ? this.chooseButtonLabel : this.hasFiles ? this.files && 1 === this.files.length ? this.files[0].name : null === (t = this.$primevue.config.locale) || void 0 === t || null === (t = t.fileChosenMessage) || void 0 === t ? void 0 : t.replace("{0}", this.files.length) : (null === (e = this.$primevue.config.locale) || void 0 === e ? void 0 : e.noFileChosenMessage) || ""
            },
            hasFiles: function() {
                return this.files && this.files.length > 0
            },
            hasUploadedFiles: function() {
                return this.uploadedFiles && this.uploadedFiles.length > 0
            },
            chooseDisabled: function() {
                return this.disabled || this.fileLimit && this.fileLimit <= this.files.length + this.uploadedFileCount
            },
            uploadDisabled: function() {
                return this.disabled || !this.hasFiles || this.fileLimit && this.fileLimit < this.files.length
            },
            cancelDisabled: function() {
                return this.disabled || !this.hasFiles
            },
            chooseButtonLabel: function() {
                return this.chooseLabel || this.$primevue.config.locale.choose
            },
            uploadButtonLabel: function() {
                return this.uploadLabel || this.$primevue.config.locale.upload
            },
            cancelButtonLabel: function() {
                return this.cancelLabel || this.$primevue.config.locale.cancel
            },
            completedLabel: function() {
                return this.$primevue.config.locale.completed
            },
            pendingLabel: function() {
                return this.$primevue.config.locale.pending
            }
        },
        components: {
            Button: _R,
            ProgressBar: WP,
            Message: MT,
            FileContent: eO,
            PlusIcon: XM,
            UploadIcon: VP,
            TimesIcon: yT
        },
        directives: {
            ripple: ET
        }
    },
    sO = ["multiple", "accept", "disabled"],
    lO = ["accept", "disabled", "multiple"];
aO.render = function(e, t, n, r, o, i) {
    var a = jn("Button"),
        s = jn("ProgressBar"),
        l = jn("Message"),
        c = jn("FileContent");
    return i.isAdvanced ? (uo(), go("div", Mo({
        key: 0,
        class: e.cx("root")
    }, e.ptmi("root")), [_o("input", Mo({
        ref: "fileInput",
        type: "file",
        onChange: t[0] || (t[0] = function() {
            return i.onFileSelect && i.onFileSelect.apply(i, arguments)
        }),
        multiple: e.multiple,
        accept: e.accept,
        disabled: i.chooseDisabled
    }, e.ptm("input")), null, 16, sO), _o("div", Mo({
        class: e.cx("header")
    }, e.ptm("header")), [Yn(e.$slots, "header", {
        files: o.files,
        uploadedFiles: o.uploadedFiles,
        chooseCallback: i.choose,
        uploadCallback: i.uploader,
        clearCallback: i.clear
    }, function() {
        return [xo(a, Mo({
            label: i.chooseButtonLabel,
            class: i.chooseButtonClass,
            style: e.style,
            disabled: e.disabled,
            unstyled: e.unstyled,
            onClick: i.choose,
            onKeydown: zi(i.choose, ["enter"]),
            onFocus: i.onFocus,
            onBlur: i.onBlur
        }, e.chooseButtonProps, {
            pt: e.ptm("pcChooseButton")
        }), {
            icon: Vt(function(t) {
                return [Yn(e.$slots, "chooseicon", {}, function() {
                    return [(uo(), mo(Hn(e.chooseIcon ? "span" : "PlusIcon"), Mo({
                        class: [t.class, e.chooseIcon],
                        "aria-hidden": "true"
                    }, e.ptm("pcChooseButton").icon), null, 16, ["class"]))]
                })]
            }),
            _: 3
        }, 16, ["label", "class", "style", "disabled", "unstyled", "onClick", "onKeydown", "onFocus", "onBlur", "pt"]), e.showUploadButton ? (uo(), mo(a, Mo({
            key: 0,
            class: e.cx("pcUploadButton"),
            label: i.uploadButtonLabel,
            onClick: i.uploader,
            disabled: i.uploadDisabled,
            unstyled: e.unstyled
        }, e.uploadButtonProps, {
            pt: e.ptm("pcUploadButton")
        }), {
            icon: Vt(function(t) {
                return [Yn(e.$slots, "uploadicon", {}, function() {
                    return [(uo(), mo(Hn(e.uploadIcon ? "span" : "UploadIcon"), Mo({
                        class: [t.class, e.uploadIcon],
                        "aria-hidden": "true"
                    }, e.ptm("pcUploadButton").icon, {
                        "data-pc-section": "uploadbuttonicon"
                    }), null, 16, ["class"]))]
                })]
            }),
            _: 3
        }, 16, ["class", "label", "onClick", "disabled", "unstyled", "pt"])) : Eo("", !0), e.showCancelButton ? (uo(), mo(a, Mo({
            key: 1,
            class: e.cx("pcCancelButton"),
            label: i.cancelButtonLabel,
            onClick: i.clear,
            disabled: i.cancelDisabled,
            unstyled: e.unstyled
        }, e.cancelButtonProps, {
            pt: e.ptm("pcCancelButton")
        }), {
            icon: Vt(function(t) {
                return [Yn(e.$slots, "cancelicon", {}, function() {
                    return [(uo(), mo(Hn(e.cancelIcon ? "span" : "TimesIcon"), Mo({
                        class: [t.class, e.cancelIcon],
                        "aria-hidden": "true"
                    }, e.ptm("pcCancelButton").icon, {
                        "data-pc-section": "cancelbuttonicon"
                    }), null, 16, ["class"]))]
                })]
            }),
            _: 3
        }, 16, ["class", "label", "onClick", "disabled", "unstyled", "pt"])) : Eo("", !0)]
    })], 16), _o("div", Mo({
        ref: "content",
        class: e.cx("content"),
        onDragenter: t[1] || (t[1] = function() {
            return i.onDragEnter && i.onDragEnter.apply(i, arguments)
        }),
        onDragover: t[2] || (t[2] = function() {
            return i.onDragOver && i.onDragOver.apply(i, arguments)
        }),
        onDragleave: t[3] || (t[3] = function() {
            return i.onDragLeave && i.onDragLeave.apply(i, arguments)
        }),
        onDrop: t[4] || (t[4] = function() {
            return i.onDrop && i.onDrop.apply(i, arguments)
        })
    }, e.ptm("content"), {
        "data-p-highlight": !1
    }), [Yn(e.$slots, "content", {
        files: o.files,
        uploadedFiles: o.uploadedFiles,
        removeUploadedFileCallback: i.removeUploadedFile,
        removeFileCallback: i.remove,
        progress: o.progress,
        messages: o.messages
    }, function() {
        return [i.hasFiles ? (uo(), mo(s, {
            key: 0,
            value: o.progress,
            showValue: !1,
            unstyled: e.unstyled,
            pt: e.ptm("pcProgressbar")
        }, null, 8, ["value", "unstyled", "pt"])) : Eo("", !0), (uo(!0), go(oo, null, qn(o.messages, function(t) {
            return uo(), mo(l, {
                key: t,
                severity: "error",
                onClose: i.onMessageClose,
                unstyled: e.unstyled,
                pt: e.ptm("pcMessage")
            }, {
                default: Vt(function() {
                    return [Co(W(t), 1)]
                }),
                _: 2
            }, 1032, ["onClose", "unstyled", "pt"])
        }), 128)), i.hasFiles ? (uo(), go("div", {
            key: 1,
            class: G(e.cx("fileList"))
        }, [xo(c, {
            files: o.files,
            onRemove: i.remove,
            badgeValue: i.pendingLabel,
            previewWidth: e.previewWidth,
            templates: e.$slots,
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["files", "onRemove", "badgeValue", "previewWidth", "templates", "unstyled", "pt"])], 2)) : Eo("", !0), i.hasUploadedFiles ? (uo(), go("div", {
            key: 2,
            class: G(e.cx("fileList"))
        }, [xo(c, {
            files: o.uploadedFiles,
            onRemove: i.removeUploadedFile,
            badgeValue: i.completedLabel,
            badgeSeverity: "success",
            previewWidth: e.previewWidth,
            templates: e.$slots,
            unstyled: e.unstyled,
            pt: e.pt
        }, null, 8, ["files", "onRemove", "badgeValue", "previewWidth", "templates", "unstyled", "pt"])], 2)) : Eo("", !0)]
    }), !e.$slots.empty || i.hasFiles || i.hasUploadedFiles ? Eo("", !0) : (uo(), go("div", j(Mo({
        key: 0
    }, e.ptm("empty"))), [Yn(e.$slots, "empty")], 16))], 16)], 16)) : i.isBasic ? (uo(), go("div", Mo({
        key: 1,
        class: e.cx("root")
    }, e.ptmi("root")), [(uo(!0), go(oo, null, qn(o.messages, function(t) {
        return uo(), mo(l, {
            key: t,
            severity: "error",
            onClose: i.onMessageClose,
            unstyled: e.unstyled,
            pt: e.ptm("pcMessage")
        }, {
            default: Vt(function() {
                return [Co(W(t), 1)]
            }),
            _: 2
        }, 1032, ["onClose", "unstyled", "pt"])
    }), 128)), _o("div", Mo({
        class: e.cx("basicContent")
    }, e.ptm("basicContent")), [xo(a, Mo({
        label: i.chooseButtonLabel,
        class: i.chooseButtonClass,
        style: e.style,
        disabled: e.disabled,
        unstyled: e.unstyled,
        onMouseup: i.onBasicUploaderClick,
        onKeydown: zi(i.choose, ["enter"]),
        onFocus: i.onFocus,
        onBlur: i.onBlur
    }, e.chooseButtonProps, {
        pt: e.ptm("pcChooseButton")
    }), {
        icon: Vt(function(t) {
            return [Yn(e.$slots, "chooseicon", {}, function() {
                return [(uo(), mo(Hn(e.chooseIcon ? "span" : "PlusIcon"), Mo({
                    class: [t.class, e.chooseIcon],
                    "aria-hidden": "true"
                }, e.ptm("pcChooseButton").icon), null, 16, ["class"]))]
            })]
        }),
        _: 3
    }, 16, ["label", "class", "style", "disabled", "unstyled", "onMouseup", "onKeydown", "onFocus", "onBlur", "pt"]), e.auto ? Eo("", !0) : Yn(e.$slots, "filelabel", {
        key: 0,
        class: G(e.cx("filelabel")),
        files: o.files
    }, function() {
        return [_o("span", {
            class: G(e.cx("filelabel"))
        }, W(i.basicFileChosenLabel), 3)]
    }), _o("input", Mo({
        ref: "fileInput",
        type: "file",
        accept: e.accept,
        disabled: e.disabled,
        multiple: e.multiple,
        onChange: t[5] || (t[5] = function() {
            return i.onFileSelect && i.onFileSelect.apply(i, arguments)
        }),
        onFocus: t[6] || (t[6] = function() {
            return i.onFocus && i.onFocus.apply(i, arguments)
        }),
        onBlur: t[7] || (t[7] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        })
    }, e.ptm("input")), null, 16, lO)], 16)], 16)) : Eo("", !0)
};
const cO = {
        key: 0,
        class: "background flex-column justify-center align-center"
    },
    uO = {
        class: "flex-column justify-center align-center p-2 gap-1"
    },
    dO = {
        class: "code-dialog"
    },
    pO = {
        class: "terminal-wrapper"
    },
    hO = {
        class: "code-block"
    },
    fO = ["innerHTML"],
    gO = sE(yn({
        __name: "compression-uploader",
        setup(e) {
            const t = ft(!0),
                n = ft(!1),
                r = ft("");
            function o(e) {
                const n = e.files;
                n instanceof Array != 0 && (t.value = !1, iE("loadModel", {
                    files: n
                }))
            }
            return oE("loaded", ({error: e}) => {
                e && (r.value = e, t.value = !0)
            }), (e, i) => {
                const a = BP;
                return t.value ? (uo(), go("div", cO, [xo(mt(aO), {
                    name: "files",
                    mode: "advanced",
                    multiple: !0,
                    auto: !0,
                    customUpload: !0,
                    showUploadButton: !1,
                    showCancelButton: !1,
                    accept: ".glb,.gltf,model/gltf-binary,model/gltf+json,.bin,.png,.jpg,.jpeg,.webp,.ktx2,.avif,.basis",
                    onUploader: o
                }, {
                    header: Vt(({chooseCallback: e}) => [xo(mt(_R), {
                        icon: "pi pi-file-import",
                        label: "Select GLB/GLTF File",
                        onClick: e
                    }, null, 8, ["onClick"])]),
                    empty: Vt(() => [_o("div", uO, [i[3] || (i[3] = _o("i", {
                        class: "pi pi-cloud-upload upload mt-3"
                    }, null, -1)), i[4] || (i[4] = _o("span", {
                        class: "mt-2"
                    }, "Drag and drop a GLB/GLTF here, or click to choose one.", -1)), xo(mt(_R), {
                        label: "How do I load these files after?",
                        severity: "info",
                        variant: "text",
                        onClick: i[0] || (i[0] = e => n.value = !0)
                    }), xo(mt(MT), {
                        severity: "info"
                    }, {
                        default: Vt(() => [...i[2] || (i[2] = [Co("Only .glb files are supported at this time.", -1)])]),
                        _: 1
                    }), r.value.length > 0 ? (uo(), mo(mt(MT), {
                        key: 0,
                        severity: "error",
                        class: "mt-2"
                    }, {
                        default: Vt(() => [Co(W(r.value), 1)]),
                        _: 1
                    })) : Eo("", !0)])]),
                    _: 1
                }), xo(a, {
                    visible: n.value,
                    "onUpdate:visible": i[1] || (i[1] = e => n.value = e),
                    "close-on-escape": "",
                    "dismissable-mask": "",
                    modal: "",
                    header: "Loading Compressed Data"
                }, {
                    default: Vt(() => [_o("div", dO, [i[6] || (i[6] = _o("p", null, "In order to load KTX2 compressed textures, and DRACO compressed vertex data, you must create additional loaders and set them on the GLTF loader instance.", -1)), _o("div", pO, [i[5] || (i[5] = _o("div", {
                        class: "terminal-header"
                    }, [_o("span", {
                        class: "terminal-dot dot-red"
                    }), _o("span", {
                        class: "terminal-dot dot-yellow"
                    }), _o("span", {
                        class: "terminal-dot dot-green"
                    })], -1)), _o("div", hO, [_o("pre", null, [_o("code", {
                        innerHTML: jP.highlight("\n// Import these loaders from three.js\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';\nimport { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';\n\nconst dracoLoader = new DRACOLoader();\ndracoLoader.setDecoderPath('./libs/draco/');\n\nconst ktx2Loader = new KTX2Loader();\nktx2Loader.setTranscoderPath('./libs/basis/');\nktx2Loader.detectSupport(renderer);\n\nconst loader = new GLTFLoader();\nloader.setDRACOLoader(dracoLoader);\nloader.setKTX2Loader(ktx2Loader);\n\nloader.load('path/to/model.glb', (gltf) => {\n  scene.add(gltf.scene);\n});\n", {
                            language: "javascript"
                        }).value
                    }, null, 8, fO)])])])])]),
                    _: 1
                }, 8, ["visible"])])) : Eo("", !0)
            }
        }
    }), [["__scopeId", "data-v-792778e3"]]);
var mO = kI.extend({
        name: "progressspinner",
        style: "\n    .p-progressspinner {\n        position: relative;\n        margin: 0 auto;\n        width: 100px;\n        height: 100px;\n        display: inline-block;\n    }\n\n    .p-progressspinner::before {\n        content: '';\n        display: block;\n        padding-top: 100%;\n    }\n\n    .p-progressspinner-spin {\n        height: 100%;\n        transform-origin: center center;\n        width: 100%;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        margin: auto;\n        animation: p-progressspinner-rotate 2s linear infinite;\n    }\n\n    .p-progressspinner-circle {\n        stroke-dasharray: 89, 200;\n        stroke-dashoffset: 0;\n        stroke: dt('progressspinner.colorOne');\n        animation:\n            p-progressspinner-dash 1.5s ease-in-out infinite,\n            p-progressspinner-color 6s ease-in-out infinite;\n        stroke-linecap: round;\n    }\n\n    @keyframes p-progressspinner-rotate {\n        100% {\n            transform: rotate(360deg);\n        }\n    }\n    @keyframes p-progressspinner-dash {\n        0% {\n            stroke-dasharray: 1, 200;\n            stroke-dashoffset: 0;\n        }\n        50% {\n            stroke-dasharray: 89, 200;\n            stroke-dashoffset: -35px;\n        }\n        100% {\n            stroke-dasharray: 89, 200;\n            stroke-dashoffset: -124px;\n        }\n    }\n    @keyframes p-progressspinner-color {\n        100%,\n        0% {\n            stroke: dt('progressspinner.color.one');\n        }\n        40% {\n            stroke: dt('progressspinner.color.two');\n        }\n        66% {\n            stroke: dt('progressspinner.color.three');\n        }\n        80%,\n        90% {\n            stroke: dt('progressspinner.color.four');\n        }\n    }\n",
        classes: {
            root: "p-progressspinner",
            spin: "p-progressspinner-spin",
            circle: "p-progressspinner-circle"
        }
    }),
    bO = {
        name: "ProgressSpinner",
        extends: {
            name: "BaseProgressSpinner",
            extends: nT,
            props: {
                strokeWidth: {
                    type: String,
                    default: "2"
                },
                fill: {
                    type: String,
                    default: "none"
                },
                animationDuration: {
                    type: String,
                    default: "2s"
                }
            },
            style: mO,
            provide: function() {
                return {
                    $pcProgressSpinner: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        computed: {
            svgStyle: function() {
                return {
                    "animation-duration": this.animationDuration
                }
            }
        }
    },
    AO = ["fill", "stroke-width"];
bO.render = function(e, t, n, r, o, i) {
    return uo(), go("div", Mo({
        class: e.cx("root"),
        role: "progressbar"
    }, e.ptmi("root")), [(uo(), go("svg", Mo({
        class: e.cx("spin"),
        viewBox: "25 25 50 50",
        style: i.svgStyle
    }, e.ptm("spin")), [_o("circle", Mo({
        class: e.cx("circle"),
        cx: "50",
        cy: "50",
        r: "20",
        fill: e.fill,
        "stroke-width": e.strokeWidth,
        strokeMiterlimit: "10"
    }, e.ptm("circle")), null, 16, AO)], 16))], 16)
};
const yO = {
        key: 0,
        class: "compression-progress-background flex-column justify-start align-center"
    },
    vO = {
        class: "flex-column justify-center align-center gap-2"
    },
    _O = sE(yn({
        __name: "compression-progress",
        setup(e) {
            const t = ft(!1);
            return oE("applyChanges", () => {
                t.value = !0
            }), oE("compressionCompleted", () => {
                t.value = !1
            }), (e, n) => t.value ? (uo(), go("div", yO, [xo(mt(lB), {
                class: "compression-progress-card p-2 mt-2"
            }, {
                header: Vt(() => [...n[0] || (n[0] = [_o("h2", null, "Applying Modifications...", -1)])]),
                content: Vt(() => [_o("div", vO, [n[1] || (n[1] = _o("span", null, "This may take a minute, depending on which options you chose, and how powerful your computer is.", -1)), xo(mt(bO), {
                    style: {
                        width: "50px",
                        height: "50px"
                    }
                })])]),
                _: 1
            })])) : Eo("", !0)
        }
    }), [["__scopeId", "data-v-2ad68899"]]);
var xO = kI.extend({
    name: "togglebutton",
    style: "\n    .p-togglebutton {\n        display: inline-flex;\n        cursor: pointer;\n        user-select: none;\n        overflow: hidden;\n        position: relative;\n        color: dt('togglebutton.color');\n        background: dt('togglebutton.background');\n        border: 1px solid dt('togglebutton.border.color');\n        padding: dt('togglebutton.padding');\n        font-size: 1rem;\n        font-family: inherit;\n        font-feature-settings: inherit;\n        transition:\n            background dt('togglebutton.transition.duration'),\n            color dt('togglebutton.transition.duration'),\n            border-color dt('togglebutton.transition.duration'),\n            outline-color dt('togglebutton.transition.duration'),\n            box-shadow dt('togglebutton.transition.duration');\n        border-radius: dt('togglebutton.border.radius');\n        outline-color: transparent;\n        font-weight: dt('togglebutton.font.weight');\n    }\n\n    .p-togglebutton-content {\n        display: inline-flex;\n        flex: 1 1 auto;\n        align-items: center;\n        justify-content: center;\n        gap: dt('togglebutton.gap');\n        padding: dt('togglebutton.content.padding');\n        background: transparent;\n        border-radius: dt('togglebutton.content.border.radius');\n        transition:\n            background dt('togglebutton.transition.duration'),\n            color dt('togglebutton.transition.duration'),\n            border-color dt('togglebutton.transition.duration'),\n            outline-color dt('togglebutton.transition.duration'),\n            box-shadow dt('togglebutton.transition.duration');\n    }\n\n    .p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover {\n        background: dt('togglebutton.hover.background');\n        color: dt('togglebutton.hover.color');\n    }\n\n    .p-togglebutton.p-togglebutton-checked {\n        background: dt('togglebutton.checked.background');\n        border-color: dt('togglebutton.checked.border.color');\n        color: dt('togglebutton.checked.color');\n    }\n\n    .p-togglebutton-checked .p-togglebutton-content {\n        background: dt('togglebutton.content.checked.background');\n        box-shadow: dt('togglebutton.content.checked.shadow');\n    }\n\n    .p-togglebutton:focus-visible {\n        box-shadow: dt('togglebutton.focus.ring.shadow');\n        outline: dt('togglebutton.focus.ring.width') dt('togglebutton.focus.ring.style') dt('togglebutton.focus.ring.color');\n        outline-offset: dt('togglebutton.focus.ring.offset');\n    }\n\n    .p-togglebutton.p-invalid {\n        border-color: dt('togglebutton.invalid.border.color');\n    }\n\n    .p-togglebutton:disabled {\n        opacity: 1;\n        cursor: default;\n        background: dt('togglebutton.disabled.background');\n        border-color: dt('togglebutton.disabled.border.color');\n        color: dt('togglebutton.disabled.color');\n    }\n\n    .p-togglebutton-label,\n    .p-togglebutton-icon {\n        position: relative;\n        transition: none;\n    }\n\n    .p-togglebutton-icon {\n        color: dt('togglebutton.icon.color');\n    }\n\n    .p-togglebutton:not(:disabled):not(.p-togglebutton-checked):hover .p-togglebutton-icon {\n        color: dt('togglebutton.icon.hover.color');\n    }\n\n    .p-togglebutton.p-togglebutton-checked .p-togglebutton-icon {\n        color: dt('togglebutton.icon.checked.color');\n    }\n\n    .p-togglebutton:disabled .p-togglebutton-icon {\n        color: dt('togglebutton.icon.disabled.color');\n    }\n\n    .p-togglebutton-sm {\n        padding: dt('togglebutton.sm.padding');\n        font-size: dt('togglebutton.sm.font.size');\n    }\n\n    .p-togglebutton-sm .p-togglebutton-content {\n        padding: dt('togglebutton.content.sm.padding');\n    }\n\n    .p-togglebutton-lg {\n        padding: dt('togglebutton.lg.padding');\n        font-size: dt('togglebutton.lg.font.size');\n    }\n\n    .p-togglebutton-lg .p-togglebutton-content {\n        padding: dt('togglebutton.content.lg.padding');\n    }\n\n    .p-togglebutton-fluid {\n        width: 100%;\n    }\n",
    classes: {
        root: function(e) {
            var t = e.instance,
                n = e.props;
            return ["p-togglebutton p-component", {
                "p-togglebutton-checked": t.active,
                "p-invalid": t.$invalid,
                "p-togglebutton-fluid": n.fluid,
                "p-togglebutton-sm p-inputfield-sm": "small" === n.size,
                "p-togglebutton-lg p-inputfield-lg": "large" === n.size
            }]
        },
        content: "p-togglebutton-content",
        icon: "p-togglebutton-icon",
        label: "p-togglebutton-label"
    }
});
function wO(e) {
    return (wO = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
var CO = {
        name: "ToggleButton",
        extends: {
            name: "BaseToggleButton",
            extends: rT,
            props: {
                onIcon: String,
                offIcon: String,
                onLabel: {
                    type: String,
                    default: "Yes"
                },
                offLabel: {
                    type: String,
                    default: "No"
                },
                readonly: {
                    type: Boolean,
                    default: !1
                },
                tabindex: {
                    type: Number,
                    default: null
                },
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                ariaLabel: {
                    type: String,
                    default: null
                },
                size: {
                    type: String,
                    default: null
                },
                fluid: {
                    type: Boolean,
                    default: null
                }
            },
            style: xO,
            provide: function() {
                return {
                    $pcToggleButton: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change"],
        methods: {
            getPTOptions: function(e) {
                return ("root" === e ? this.ptmi : this.ptm)(e, {
                    context: {
                        active: this.active,
                        disabled: this.disabled
                    }
                })
            },
            onChange: function(e) {
                this.disabled || this.readonly || (this.writeValue(!this.d_value, e), this.$emit("change", e))
            },
            onBlur: function(e) {
                var t,
                    n;
                null === (t = (n = this.formField).onBlur) || void 0 === t || t.call(n, e)
            }
        },
        computed: {
            active: function() {
                return !0 === this.d_value
            },
            hasLabel: function() {
                return sS(this.onLabel) && sS(this.offLabel)
            },
            label: function() {
                return this.hasLabel ? this.d_value ? this.onLabel : this.offLabel : ""
            },
            dataP: function() {
                return RS((e = {
                    checked: this.active,
                    invalid: this.$invalid
                }, t = this.size, n = this.size, (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != wO(e) || !e)
                            return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t);
                            if ("object" != wO(r))
                                return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return String(e)
                    }(e, "string");
                    return "symbol" == wO(t) ? t : t + ""
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e));
                var e,
                    t,
                    n
            }
        },
        directives: {
            ripple: ET
        }
    },
    EO = ["tabindex", "disabled", "aria-pressed", "aria-label", "aria-labelledby", "data-p-checked", "data-p-disabled", "data-p"],
    SO = ["data-p"];
CO.render = function(e, t, n, r, o, i) {
    var a = $n("ripple");
    return Ht((uo(), go("button", Mo({
        type: "button",
        class: e.cx("root"),
        tabindex: e.tabindex,
        disabled: e.disabled,
        "aria-pressed": e.d_value,
        onClick: t[0] || (t[0] = function() {
            return i.onChange && i.onChange.apply(i, arguments)
        }),
        onBlur: t[1] || (t[1] = function() {
            return i.onBlur && i.onBlur.apply(i, arguments)
        })
    }, i.getPTOptions("root"), {
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledby,
        "data-p-checked": i.active,
        "data-p-disabled": e.disabled,
        "data-p": i.dataP
    }), [_o("span", Mo({
        class: e.cx("content")
    }, i.getPTOptions("content"), {
        "data-p": i.dataP
    }), [Yn(e.$slots, "default", {}, function() {
        return [Yn(e.$slots, "icon", {
            value: e.d_value,
            class: G(e.cx("icon"))
        }, function() {
            return [e.onIcon || e.offIcon ? (uo(), go("span", Mo({
                key: 0,
                class: [e.cx("icon"), e.d_value ? e.onIcon : e.offIcon]
            }, i.getPTOptions("icon")), null, 16)) : Eo("", !0)]
        }), _o("span", Mo({
            class: e.cx("label")
        }, i.getPTOptions("label")), W(i.label), 17)]
    })], 16, SO)], 16, EO)), [[a]])
};
var IO = kI.extend({
    name: "selectbutton",
    style: "\n    .p-selectbutton {\n        display: inline-flex;\n        user-select: none;\n        vertical-align: bottom;\n        outline-color: transparent;\n        border-radius: dt('selectbutton.border.radius');\n    }\n\n    .p-selectbutton .p-togglebutton {\n        border-radius: 0;\n        border-width: 1px 1px 1px 0;\n    }\n\n    .p-selectbutton .p-togglebutton:focus-visible {\n        position: relative;\n        z-index: 1;\n    }\n\n    .p-selectbutton .p-togglebutton:first-child {\n        border-inline-start-width: 1px;\n        border-start-start-radius: dt('selectbutton.border.radius');\n        border-end-start-radius: dt('selectbutton.border.radius');\n    }\n\n    .p-selectbutton .p-togglebutton:last-child {\n        border-start-end-radius: dt('selectbutton.border.radius');\n        border-end-end-radius: dt('selectbutton.border.radius');\n    }\n\n    .p-selectbutton.p-invalid {\n        outline: 1px solid dt('selectbutton.invalid.border.color');\n        outline-offset: 0;\n    }\n\n    .p-selectbutton-fluid {\n        width: 100%;\n    }\n    \n    .p-selectbutton-fluid .p-togglebutton {\n        flex: 1 1 0;\n    }\n",
    classes: {
        root: function(e) {
            var t = e.props;
            return ["p-selectbutton p-component", {
                "p-invalid": e.instance.$invalid,
                "p-selectbutton-fluid": t.fluid
            }]
        }
    }
});
function TO(e, t) {
    if (e) {
        if ("string" == typeof e)
            return MO(e, t);
        var n = {}.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? MO(e, t) : void 0
    }
}
function MO(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++)
        r[n] = e[n];
    return r
}
var RO = {
        name: "SelectButton",
        extends: {
            name: "BaseSelectButton",
            extends: rT,
            props: {
                options: Array,
                optionLabel: null,
                optionValue: null,
                optionDisabled: null,
                multiple: Boolean,
                allowEmpty: {
                    type: Boolean,
                    default: !0
                },
                dataKey: null,
                ariaLabelledby: {
                    type: String,
                    default: null
                },
                size: {
                    type: String,
                    default: null
                },
                fluid: {
                    type: Boolean,
                    default: null
                }
            },
            style: IO,
            provide: function() {
                return {
                    $pcSelectButton: this,
                    $parentInstance: this
                }
            }
        },
        inheritAttrs: !1,
        emits: ["change"],
        methods: {
            getOptionLabel: function(e) {
                return this.optionLabel ? lS(e, this.optionLabel) : e
            },
            getOptionValue: function(e) {
                return this.optionValue ? lS(e, this.optionValue) : e
            },
            getOptionRenderKey: function(e) {
                return this.dataKey ? lS(e, this.dataKey) : this.getOptionLabel(e)
            },
            isOptionDisabled: function(e) {
                return !!this.optionDisabled && lS(e, this.optionDisabled)
            },
            isOptionReadonly: function(e) {
                if (this.allowEmpty)
                    return !1;
                var t = this.isSelected(e);
                return this.multiple ? t && 1 === this.d_value.length : t
            },
            onOptionSelect: function(e, t, n) {
                var r,
                    o = this;
                if (!(this.disabled || this.isOptionDisabled(t) || this.isOptionReadonly(t))) {
                    var i,
                        a = this.isSelected(t),
                        s = this.getOptionValue(t);
                    if (this.multiple)
                        if (a) {
                            if (i = this.d_value.filter(function(e) {
                                return !cS(e, s, o.equalityKey)
                            }), !this.allowEmpty && 0 === i.length)
                                return
                        } else
                            i = this.d_value ? [].concat(function(e) {
                                if (Array.isArray(e))
                                    return MO(e)
                            }(r = this.d_value) || function(e) {
                                if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
                                    return Array.from(e)
                            }(r) || TO(r) || function() {
                                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }(), [s]) : [s];
                    else {
                        if (a && !this.allowEmpty)
                            return;
                        i = a ? null : s
                    }
                    this.writeValue(i, e),
                    this.$emit("change", {
                        event: e,
                        value: i
                    })
                }
            },
            isSelected: function(e) {
                var t = !1,
                    n = this.getOptionValue(e);
                if (this.multiple) {
                    if (this.d_value) {
                        var r,
                            o = function(e) {
                                var t = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                if (!t) {
                                    if (Array.isArray(e) || (t = TO(e))) {
                                        t && (e = t);
                                        var n = 0,
                                            r = function() {};
                                        return {
                                            s: r,
                                            n: function() {
                                                return n >= e.length ? {
                                                    done: !0
                                                } : {
                                                    done: !1,
                                                    value: e[n++]
                                                }
                                            },
                                            e: function(e) {
                                                throw e
                                            },
                                            f: r
                                        }
                                    }
                                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                }
                                var o,
                                    i = !0,
                                    a = !1;
                                return {
                                    s: function() {
                                        t = t.call(e)
                                    },
                                    n: function() {
                                        var e = t.next();
                                        return i = e.done, e
                                    },
                                    e: function(e) {
                                        a = !0,
                                        o = e
                                    },
                                    f: function() {
                                        try {
                                            i || null == t.return || t.return()
                                        } finally {
                                            if (a)
                                                throw o
                                        }
                                    }
                                }
                            }(this.d_value);
                        try {
                            for (o.s(); !(r = o.n()).done;)
                                if (cS(r.value, n, this.equalityKey)) {
                                    t = !0;
                                    break
                                }
                        } catch (i) {
                            o.e(i)
                        } finally {
                            o.f()
                        }
                    }
                } else
                    t = cS(this.d_value, n, this.equalityKey);
                return t
            }
        },
        computed: {
            equalityKey: function() {
                return this.optionValue ? null : this.dataKey
            },
            dataP: function() {
                return RS({
                    invalid: this.$invalid
                })
            }
        },
        directives: {
            ripple: ET
        },
        components: {
            ToggleButton: CO
        }
    },
    BO = ["aria-labelledby", "data-p"];
RO.render = function(e, t, n, r, o, i) {
    var a = jn("ToggleButton");
    return uo(), go("div", Mo({
        class: e.cx("root"),
        role: "group",
        "aria-labelledby": e.ariaLabelledby
    }, e.ptmi("root"), {
        "data-p": i.dataP
    }), [(uo(!0), go(oo, null, qn(e.options, function(t, n) {
        return uo(), mo(a, {
            key: i.getOptionRenderKey(t),
            modelValue: i.isSelected(t),
            onLabel: i.getOptionLabel(t),
            offLabel: i.getOptionLabel(t),
            disabled: e.disabled || i.isOptionDisabled(t),
            unstyled: e.unstyled,
            size: e.size,
            readonly: i.isOptionReadonly(t),
            onChange: function(e) {
                return i.onOptionSelect(e, t, n)
            },
            pt: e.ptm("pcToggleButton")
        }, Xn({
            _: 2
        }, [e.$slots.option ? {
            name: "default",
            fn: Vt(function() {
                return [Yn(e.$slots, "option", {
                    option: t,
                    index: n
                }, function() {
                    return [_o("span", Mo({
                        ref_for: !0
                    }, e.ptm("pcToggleButton").label), W(i.getOptionLabel(t)), 17)]
                })]
            }),
            key: "0"
        } : void 0]), 1032, ["modelValue", "onLabel", "offLabel", "disabled", "unstyled", "size", "readonly", "onChange", "pt"])
    }), 128))], 16, BO)
};
const kO = {
        key: 0,
        class: "flex-column justify-center align-center mt-2"
    },
    DO = {
        class: "flex-column model-switcher-text align-center"
    },
    PO = sE(yn({
        __name: "model-switcher",
        setup(e) {
            const t = ft(!1),
                n = ft("Original"),
                r = ft(["Original", "Compressed"]),
                o = () => {
                    iE("selectionChanged", {
                        name: n.value.toLowerCase()
                    })
                };
            return oE("loaded", ({error: e}) => {
                e || (t.value = !0)
            }), (e, i) => {
                return t.value ? (uo(), go("div", kO, [_o("div", DO, [_o("span", {
                    class: G([(a = n.value, "Original" === a ? "text-blue-600" : "text-green-600")])
                }, W(n.value.toUpperCase()), 3)]), xo(mt(RO), {
                    modelValue: n.value,
                    "onUpdate:modelValue": i[0] || (i[0] = e => n.value = e),
                    options: r.value,
                    "allow-empty": !1,
                    onClick: o
                }, null, 8, ["modelValue", "options"])])) : Eo("", !0);
                var a
            }
        }
    }), [["__scopeId", "data-v-1bc2f952"]]),
    OO = {
        class: "flex flex-1"
    },
    LO = {
        class: "child flex-column align-stretch"
    },
    NO = {
        class: "child flex-row justify-space-between p-2"
    },
    FO = {
        class: "child flex-column justify-center align-center"
    },
    UO = {
        class: "progress flex-column justify-center align-center"
    },
    zO = sE(yn({
        __name: "App",
        setup: e => (e, t) => (uo(), go("div", OO, [xo(lE, {
            class: "parent"
        }), _o("div", LO, [xo(PO)]), _o("div", NO, [xo(sB), xo(wP)]), _o("div", FO, [xo(gO)]), _o("div", UO, [xo(_O)])]))
    }), [["__scopeId", "data-v-df993c14"]]);
function QO(e) {
    return (QO = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
}
function GO(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        })),
        n.push.apply(n, r)
    }
    return n
}
function jO(e) {
    for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? GO(Object(n), !0).forEach(function(t) {
            VO(e, t, n[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GO(Object(n)).forEach(function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
        })
    }
    return e
}
function VO(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != QO(e) || !e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t);
                if ("object" != QO(r))
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return String(e)
        }(e, "string");
        return "symbol" == QO(t) ? t : t + ""
    }(t)) in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e
}
var HO = {
        ripple: !1,
        inputStyle: null,
        inputVariant: null,
        locale: {
            startsWith: "Starts with",
            contains: "Contains",
            notContains: "Not contains",
            endsWith: "Ends with",
            equals: "Equals",
            notEquals: "Not equals",
            noFilter: "No Filter",
            lt: "Less than",
            lte: "Less than or equal to",
            gt: "Greater than",
            gte: "Greater than or equal to",
            dateIs: "Date is",
            dateIsNot: "Date is not",
            dateBefore: "Date is before",
            dateAfter: "Date is after",
            clear: "Clear",
            apply: "Apply",
            matchAll: "Match All",
            matchAny: "Match Any",
            addRule: "Add Rule",
            removeRule: "Remove Rule",
            accept: "Yes",
            reject: "No",
            choose: "Choose",
            upload: "Upload",
            cancel: "Cancel",
            completed: "Completed",
            pending: "Pending",
            fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            chooseYear: "Choose Year",
            chooseMonth: "Choose Month",
            chooseDate: "Choose Date",
            prevDecade: "Previous Decade",
            nextDecade: "Next Decade",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            prevHour: "Previous Hour",
            nextHour: "Next Hour",
            prevMinute: "Previous Minute",
            nextMinute: "Next Minute",
            prevSecond: "Previous Second",
            nextSecond: "Next Second",
            am: "am",
            pm: "pm",
            today: "Today",
            weekHeader: "Wk",
            firstDayOfWeek: 0,
            showMonthAfterYear: !1,
            dateFormat: "mm/dd/yy",
            weak: "Weak",
            medium: "Medium",
            strong: "Strong",
            passwordPrompt: "Enter a password",
            emptyFilterMessage: "No results found",
            searchMessage: "{0} results are available",
            selectionMessage: "{0} items selected",
            emptySelectionMessage: "No selected item",
            emptySearchMessage: "No results found",
            fileChosenMessage: "{0} files",
            noFileChosenMessage: "No file chosen",
            emptyMessage: "No available options",
            aria: {
                trueLabel: "True",
                falseLabel: "False",
                nullLabel: "Not Selected",
                star: "1 star",
                stars: "{star} stars",
                selectAll: "All items selected",
                unselectAll: "All items unselected",
                close: "Close",
                previous: "Previous",
                next: "Next",
                navigation: "Navigation",
                scrollTop: "Scroll Top",
                moveTop: "Move Top",
                moveUp: "Move Up",
                moveDown: "Move Down",
                moveBottom: "Move Bottom",
                moveToTarget: "Move to Target",
                moveToSource: "Move to Source",
                moveAllToTarget: "Move All to Target",
                moveAllToSource: "Move All to Source",
                pageLabel: "Page {page}",
                firstPageLabel: "First Page",
                lastPageLabel: "Last Page",
                nextPageLabel: "Next Page",
                prevPageLabel: "Previous Page",
                rowsPerPageLabel: "Rows per page",
                jumpToPageDropdownLabel: "Jump to Page Dropdown",
                jumpToPageInputLabel: "Jump to Page Input",
                selectRow: "Row Selected",
                unselectRow: "Row Unselected",
                expandRow: "Row Expanded",
                collapseRow: "Row Collapsed",
                showFilterMenu: "Show Filter Menu",
                hideFilterMenu: "Hide Filter Menu",
                filterOperator: "Filter Operator",
                filterConstraint: "Filter Constraint",
                editRow: "Row Edit",
                saveEdit: "Save Edit",
                cancelEdit: "Cancel Edit",
                listView: "List View",
                gridView: "Grid View",
                slide: "Slide",
                slideNumber: "{slideNumber}",
                zoomImage: "Zoom Image",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                rotateRight: "Rotate Right",
                rotateLeft: "Rotate Left",
                listLabel: "Option List"
            }
        },
        filterMatchModeOptions: {
            text: [UT, zT, "notContains", "endsWith", QT, GT],
            numeric: [QT, GT, "lt", "lte", "gt", "gte"],
            date: ["dateIs", "dateIsNot", "dateBefore", "dateAfter"]
        },
        zIndex: {
            modal: 1100,
            overlay: 1e3,
            menu: 1e3,
            tooltip: 1100
        },
        theme: void 0,
        unstyled: !1,
        pt: void 0,
        ptOptions: {
            mergeSections: !0,
            mergeProps: !1
        },
        csp: {
            nonce: void 0
        }
    },
    $O = Symbol();
var WO = [],
    KO = {
        install: function(e, t) {
            !function(e, t) {
                var n = {
                    config: rt(t)
                };
                e.config.globalProperties.$primevue = n,
                e.provide($O, n),
                YS.clear(),
                WO.forEach(function(e) {
                    return null == e ? void 0 : e()
                }),
                WO = [],
                function(e, t) {
                    var n = ft(!1),
                        r = function() {
                            var e;
                            if ("none" !== (null === (e = t.config) || void 0 === e ? void 0 : e.theme) && !fI.isStyleNameLoaded("common")) {
                                var n,
                                    r,
                                    o = (null === (n = kI.getCommonTheme) || void 0 === n ? void 0 : n.call(kI)) || {},
                                    i = o.primitive,
                                    a = o.semantic,
                                    s = o.global,
                                    l = o.style,
                                    c = {
                                        nonce: null === (r = t.config) || void 0 === r || null === (r = r.csp) || void 0 === r ? void 0 : r.nonce
                                    };
                                kI.load(null == i ? void 0 : i.css, jO({
                                    name: "primitive-variables"
                                }, c)),
                                kI.load(null == a ? void 0 : a.css, jO({
                                    name: "semantic-variables"
                                }, c)),
                                kI.load(null == s ? void 0 : s.css, jO({
                                    name: "global-variables"
                                }, c)),
                                kI.loadStyle(jO({
                                    name: "global-style"
                                }, c), l),
                                fI.setLoadedStyleName("common")
                            }
                        };
                    YS.on("theme:change", function(t) {
                        n.value || (e.config.globalProperties.$primevue.config.theme = t, n.value = !0)
                    });
                    var o = Vr(t.config, function(e, t) {
                            DI.emit("config:change", {
                                newValue: e,
                                oldValue: t
                            })
                        }, {
                            immediate: !0,
                            deep: !0
                        }),
                        i = Vr(function() {
                            return t.config.ripple
                        }, function(e, t) {
                            DI.emit("config:ripple:change", {
                                newValue: e,
                                oldValue: t
                            })
                        }, {
                            immediate: !0,
                            deep: !0
                        }),
                        a = Vr(function() {
                            return t.config.theme
                        }, function(e, o) {
                            n.value || fI.setTheme(e),
                            t.config.unstyled || r(),
                            n.value = !1,
                            DI.emit("config:theme:change", {
                                newValue: e,
                                oldValue: o
                            })
                        }, {
                            immediate: !0,
                            deep: !1
                        }),
                        s = Vr(function() {
                            return t.config.unstyled
                        }, function(e, n) {
                            !e && t.config.theme && r(),
                            DI.emit("config:unstyled:change", {
                                newValue: e,
                                oldValue: n
                            })
                        }, {
                            immediate: !0,
                            deep: !0
                        });
                    WO.push(o),
                    WO.push(i),
                    WO.push(a),
                    WO.push(s)
                }(e, n)
            }(e, function(...e) {
                return pS(...e)
            }(HO, t))
        }
    },
    qO = Object.defineProperty,
    XO = Object.defineProperties,
    YO = Object.getOwnPropertyDescriptors,
    JO = Object.getOwnPropertySymbols,
    ZO = Object.prototype.hasOwnProperty,
    eL = Object.prototype.propertyIsEnumerable,
    tL = (e, t, n) => t in e ? qO(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    nL = XO(((e, t) => {
        for (var n in t || (t = {}))
            ZO.call(t, n) && tL(e, n, t[n]);
        if (JO)
            for (var n of JO(t))
                eL.call(t, n) && tL(e, n, t[n]);
        return e
    })({}, {
        primitive: {
            borderRadius: {
                none: "0",
                xs: "2px",
                sm: "4px",
                md: "6px",
                lg: "8px",
                xl: "12px"
            },
            emerald: {
                50: "#E8F6F1",
                100: "#C5EBE1",
                200: "#9EDFCF",
                300: "#76D3BD",
                400: "#58C9AF",
                500: "#3BBFA1",
                600: "#35AF94",
                700: "#2D9B83",
                800: "#268873",
                900: "#1A6657",
                950: "#0d3329"
            },
            green: {
                50: "#E8F5E9",
                100: "#C8E6C9",
                200: "#A5D6A7",
                300: "#81C784",
                400: "#66BB6A",
                500: "#4CAF50",
                600: "#43A047",
                700: "#388E3C",
                800: "#2E7D32",
                900: "#1B5E20",
                950: "#0e2f10"
            },
            lime: {
                50: "#F9FBE7",
                100: "#F0F4C3",
                200: "#E6EE9C",
                300: "#DCE775",
                400: "#D4E157",
                500: "#CDDC39",
                600: "#C0CA33",
                700: "#AFB42B",
                800: "#9E9D24",
                900: "#827717",
                950: "#413c0c"
            },
            red: {
                50: "#FFEBEE",
                100: "#FFCDD2",
                200: "#EF9A9A",
                300: "#E57373",
                400: "#EF5350",
                500: "#F44336",
                600: "#E53935",
                700: "#D32F2F",
                800: "#C62828",
                900: "#B71C1C",
                950: "#5c0e0e"
            },
            orange: {
                50: "#FFF3E0",
                100: "#FFE0B2",
                200: "#FFCC80",
                300: "#FFB74D",
                400: "#FFA726",
                500: "#FF9800",
                600: "#FB8C00",
                700: "#F57C00",
                800: "#EF6C00",
                900: "#E65100",
                950: "#732900"
            },
            amber: {
                50: "#FFF8E1",
                100: "#FFECB3",
                200: "#FFE082",
                300: "#FFD54F",
                400: "#FFCA28",
                500: "#FFC107",
                600: "#FFB300",
                700: "#FFA000",
                800: "#FF8F00",
                900: "#FF6F00",
                950: "#803800"
            },
            yellow: {
                50: "#FFFDE7",
                100: "#FFF9C4",
                200: "#FFF59D",
                300: "#FFF176",
                400: "#FFEE58",
                500: "#FFEB3B",
                600: "#FDD835",
                700: "#FBC02D",
                800: "#F9A825",
                900: "#F57F17",
                950: "#7b400c"
            },
            teal: {
                50: "#E0F2F1",
                100: "#B2DFDB",
                200: "#80CBC4",
                300: "#4DB6AC",
                400: "#26A69A",
                500: "#009688",
                600: "#00897B",
                700: "#00796B",
                800: "#00695C",
                900: "#004D40",
                950: "#002720"
            },
            cyan: {
                50: "#E0F7FA",
                100: "#B2EBF2",
                200: "#80DEEA",
                300: "#4DD0E1",
                400: "#26C6DA",
                500: "#00BCD4",
                600: "#00ACC1",
                700: "#0097A7",
                800: "#00838F",
                900: "#006064",
                950: "#003032"
            },
            sky: {
                50: "#E1F5FE",
                100: "#B3E5FC",
                200: "#81D4FA",
                300: "#4FC3F7",
                400: "#29B6F6",
                500: "#03A9F4",
                600: "#039BE5",
                700: "#0288D1",
                800: "#0277BD",
                900: "#01579B",
                950: "#012c4e"
            },
            blue: {
                50: "#E3F2FD",
                100: "#BBDEFB",
                200: "#90CAF9",
                300: "#64B5F6",
                400: "#42A5F5",
                500: "#2196F3",
                600: "#1E88E5",
                700: "#1976D2",
                800: "#1565C0",
                900: "#0D47A1",
                950: "#072451"
            },
            indigo: {
                50: "#E8EAF6",
                100: "#C5CAE9",
                200: "#9FA8DA",
                300: "#7986CB",
                400: "#5C6BC0",
                500: "#3F51B5",
                600: "#3949AB",
                700: "#303F9F",
                800: "#283593",
                900: "#1A237E",
                950: "#0d123f"
            },
            violet: {
                50: "#EDE7F6",
                100: "#D1C4E9",
                200: "#B39DDB",
                300: "#9575CD",
                400: "#7E57C2",
                500: "#673AB7",
                600: "#5E35B1",
                700: "#512DA8",
                800: "#4527A0",
                900: "#311B92",
                950: "#190e49"
            },
            purple: {
                50: "#F3E5F5",
                100: "#E1BEE7",
                200: "#CE93D8",
                300: "#BA68C8",
                400: "#AB47BC",
                500: "#9C27B0",
                600: "#8E24AA",
                700: "#7B1FA2",
                800: "#6A1B9A",
                900: "#4A148C",
                950: "#250a46"
            },
            fuchsia: {
                50: "#FDE6F3",
                100: "#FBC1E3",
                200: "#F897D1",
                300: "#F56DBF",
                400: "#F34DB2",
                500: "#F12DA5",
                600: "#E0289D",
                700: "#CC2392",
                800: "#B81E88",
                900: "#951777",
                950: "#4b0c3c"
            },
            pink: {
                50: "#FCE4EC",
                100: "#F8BBD0",
                200: "#F48FB1",
                300: "#F06292",
                400: "#EC407A",
                500: "#E91E63",
                600: "#D81B60",
                700: "#C2185B",
                800: "#AD1457",
                900: "#880E4F",
                950: "#440728"
            },
            rose: {
                50: "#FFF0F0",
                100: "#FFD9D9",
                200: "#FFC0C0",
                300: "#FFA7A7",
                400: "#FF8E8E",
                500: "#FF7575",
                600: "#FF5252",
                700: "#FF3838",
                800: "#F71C1C",
                900: "#D50000",
                950: "#3E0000"
            },
            slate: {
                50: "#f8fafc",
                100: "#f1f5f9",
                200: "#e2e8f0",
                300: "#cbd5e1",
                400: "#94a3b8",
                500: "#64748b",
                600: "#475569",
                700: "#334155",
                800: "#1e293b",
                900: "#0f172a",
                950: "#020617"
            },
            gray: {
                50: "#f9fafb",
                100: "#f3f4f6",
                200: "#e5e7eb",
                300: "#d1d5db",
                400: "#9ca3af",
                500: "#6b7280",
                600: "#4b5563",
                700: "#374151",
                800: "#1f2937",
                900: "#111827",
                950: "#030712"
            },
            zinc: {
                50: "#fafafa",
                100: "#f4f4f5",
                200: "#e4e4e7",
                300: "#d4d4d8",
                400: "#a1a1aa",
                500: "#71717a",
                600: "#52525b",
                700: "#3f3f46",
                800: "#27272a",
                900: "#18181b",
                950: "#09090b"
            },
            neutral: {
                50: "#fafafa",
                100: "#f5f5f5",
                200: "#e5e5e5",
                300: "#d4d4d4",
                400: "#a3a3a3",
                500: "#737373",
                600: "#525252",
                700: "#404040",
                800: "#262626",
                900: "#171717",
                950: "#0a0a0a"
            },
            stone: {
                50: "#fafaf9",
                100: "#f5f5f4",
                200: "#e7e5e4",
                300: "#d6d3d1",
                400: "#a8a29e",
                500: "#78716c",
                600: "#57534e",
                700: "#44403c",
                800: "#292524",
                900: "#1c1917",
                950: "#0c0a09"
            }
        },
        semantic: {
            transitionDuration: "0.2s",
            focusRing: {
                width: "0",
                style: "none",
                color: "unset",
                offset: "0"
            },
            disabledOpacity: "0.38",
            iconSize: "1rem",
            anchorGutter: "0",
            primary: {
                50: "{emerald.50}",
                100: "{emerald.100}",
                200: "{emerald.200}",
                300: "{emerald.300}",
                400: "{emerald.400}",
                500: "{emerald.500}",
                600: "{emerald.600}",
                700: "{emerald.700}",
                800: "{emerald.800}",
                900: "{emerald.900}",
                950: "{emerald.950}"
            },
            formField: {
                paddingX: "0.75rem",
                paddingY: "0.75rem",
                sm: {
                    fontSize: "0.875rem",
                    paddingX: "0.625rem",
                    paddingY: "0.625rem"
                },
                lg: {
                    fontSize: "1.125rem",
                    paddingX: "0.825rem",
                    paddingY: "0.825rem"
                },
                borderRadius: "{border.radius.sm}",
                focusRing: {
                    width: "2px",
                    style: "solid",
                    color: "{primary.color}",
                    offset: "-2px",
                    shadow: "none"
                },
                transitionDuration: "{transition.duration}"
            },
            list: {
                padding: "0.5rem 0",
                gap: "0",
                header: {
                    padding: "0.75rem 1rem"
                },
                option: {
                    padding: "0.75rem 1rem",
                    borderRadius: "{border.radius.none}"
                },
                optionGroup: {
                    padding: "0.75rem 1rem",
                    fontWeight: "700"
                }
            },
            content: {
                borderRadius: "{border.radius.sm}"
            },
            mask: {
                transitionDuration: "0.15s"
            },
            navigation: {
                list: {
                    padding: "0.5rem 0",
                    gap: "0"
                },
                item: {
                    padding: "0.75rem 1rem",
                    borderRadius: "{border.radius.none}",
                    gap: "0.5rem"
                },
                submenuLabel: {
                    padding: "0.75rem 1rem",
                    fontWeight: "700"
                },
                submenuIcon: {
                    size: "0.875rem"
                }
            },
            overlay: {
                select: {
                    borderRadius: "{border.radius.sm}",
                    shadow: "0 5px 5px -3px rgba(0,0,0,.2), 0 8px 10px 1px rgba(0,0,0,.14), 0 3px 14px 2px rgba(0,0,0,.12)"
                },
                popover: {
                    borderRadius: "{border.radius.sm}",
                    padding: "1rem",
                    shadow: "0 11px 15px -7px rgba(0,0,0,.2), 0 24px 38px 3px rgba(0,0,0,.14), 0 9px 46px 8px rgba(0,0,0,.12)"
                },
                modal: {
                    borderRadius: "{border.radius.sm}",
                    padding: "1.5rem",
                    shadow: "0 11px 15px -7px rgba(0,0,0,.2), 0 24px 38px 3px rgba(0,0,0,.14), 0 9px 46px 8px rgba(0,0,0,.12)"
                },
                navigation: {
                    shadow: "0 2px 4px -1px rgba(0,0,0,.2), 0 4px 5px 0 rgba(0,0,0,.14), 0 1px 10px 0 rgba(0,0,0,.12)"
                }
            },
            colorScheme: {
                light: {
                    focusRing: {
                        shadow: "0 0 1px 4px {surface.200}"
                    },
                    surface: {
                        0: "#ffffff",
                        50: "{slate.50}",
                        100: "{slate.100}",
                        200: "{slate.200}",
                        300: "{slate.300}",
                        400: "{slate.400}",
                        500: "{slate.500}",
                        600: "{slate.600}",
                        700: "{slate.700}",
                        800: "{slate.800}",
                        900: "{slate.900}",
                        950: "{slate.950}"
                    },
                    primary: {
                        color: "{primary.500}",
                        contrastColor: "#ffffff",
                        hoverColor: "{primary.400}",
                        activeColor: "{primary.300}"
                    },
                    highlight: {
                        background: "color-mix(in srgb, {primary.color}, transparent 88%)",
                        focusBackground: "color-mix(in srgb, {primary.color}, transparent 76%)",
                        color: "{primary.700}",
                        focusColor: "{primary.800}"
                    },
                    mask: {
                        background: "rgba(0,0,0,0.32)",
                        color: "{surface.200}"
                    },
                    formField: {
                        background: "{surface.0}",
                        disabledBackground: "{surface.300}",
                        filledBackground: "{surface.100}",
                        filledHoverBackground: "{surface.200}",
                        filledFocusBackground: "{surface.100}",
                        borderColor: "{surface.400}",
                        hoverBorderColor: "{surface.900}",
                        focusBorderColor: "{primary.color}",
                        invalidBorderColor: "{red.800}",
                        color: "{surface.900}",
                        disabledColor: "{surface.600}",
                        placeholderColor: "{surface.600}",
                        invalidPlaceholderColor: "{red.800}",
                        floatLabelColor: "{surface.600}",
                        floatLabelFocusColor: "{primary.600}",
                        floatLabelActiveColor: "{surface.600}",
                        floatLabelInvalidColor: "{form.field.invalid.placeholder.color}",
                        iconColor: "{surface.600}",
                        shadow: "none"
                    },
                    text: {
                        color: "{surface.900}",
                        hoverColor: "{surface.900}",
                        mutedColor: "{surface.600}",
                        hoverMutedColor: "{surface.600}"
                    },
                    content: {
                        background: "{surface.0}",
                        hoverBackground: "{surface.100}",
                        borderColor: "{surface.300}",
                        color: "{text.color}",
                        hoverColor: "{text.hover.color}"
                    },
                    overlay: {
                        select: {
                            background: "{surface.0}",
                            borderColor: "{surface.0}",
                            color: "{text.color}"
                        },
                        popover: {
                            background: "{surface.0}",
                            borderColor: "{surface.0}",
                            color: "{text.color}"
                        },
                        modal: {
                            background: "{surface.0}",
                            borderColor: "{surface.0}",
                            color: "{text.color}"
                        }
                    },
                    list: {
                        option: {
                            focusBackground: "{surface.100}",
                            selectedBackground: "{highlight.background}",
                            selectedFocusBackground: "{highlight.focus.background}",
                            color: "{text.color}",
                            focusColor: "{text.hover.color}",
                            selectedColor: "{highlight.color}",
                            selectedFocusColor: "{highlight.focus.color}",
                            icon: {
                                color: "{surface.600}",
                                focusColor: "{surface.600}"
                            }
                        },
                        optionGroup: {
                            background: "transparent",
                            color: "{text.color}"
                        }
                    },
                    navigation: {
                        item: {
                            focusBackground: "{surface.100}",
                            activeBackground: "{surface.200}",
                            color: "{text.color}",
                            focusColor: "{text.hover.color}",
                            activeColor: "{text.hover.color}",
                            icon: {
                                color: "{surface.600}",
                                focusColor: "{surface.600}",
                                activeColor: "{surface.600}"
                            }
                        },
                        submenuLabel: {
                            background: "transparent",
                            color: "{text.color}"
                        },
                        submenuIcon: {
                            color: "{surface.600}",
                            focusColor: "{surface.600}",
                            activeColor: "{surface.600}"
                        }
                    }
                },
                dark: {
                    focusRing: {
                        shadow: "0 0 1px 4px {surface.700}"
                    },
                    surface: {
                        0: "#ffffff",
                        50: "{zinc.50}",
                        100: "{zinc.100}",
                        200: "{zinc.200}",
                        300: "{zinc.300}",
                        400: "{zinc.400}",
                        500: "{zinc.500}",
                        600: "{zinc.600}",
                        700: "{zinc.700}",
                        800: "{zinc.800}",
                        900: "{zinc.900}",
                        950: "{zinc.950}"
                    },
                    primary: {
                        color: "{primary.400}",
                        contrastColor: "{surface.900}",
                        hoverColor: "{primary.300}",
                        activeColor: "{primary.200}"
                    },
                    highlight: {
                        background: "color-mix(in srgb, {primary.400}, transparent 84%)",
                        focusBackground: "color-mix(in srgb, {primary.400}, transparent 76%)",
                        color: "rgba(255,255,255,.87)",
                        focusColor: "rgba(255,255,255,.87)"
                    },
                    mask: {
                        background: "rgba(0,0,0,0.6)",
                        color: "{surface.200}"
                    },
                    formField: {
                        background: "{surface.950}",
                        disabledBackground: "{surface.700}",
                        filledBackground: "{surface.800}",
                        filledHoverBackground: "{surface.700}",
                        filledFocusBackground: "{surface.800}",
                        borderColor: "{surface.600}",
                        hoverBorderColor: "{surface.400}",
                        focusBorderColor: "{primary.color}",
                        invalidBorderColor: "{red.300}",
                        color: "{surface.0}",
                        disabledColor: "{surface.400}",
                        placeholderColor: "{surface.400}",
                        invalidPlaceholderColor: "{red.300}",
                        floatLabelColor: "{surface.400}",
                        floatLabelFocusColor: "{primary.color}",
                        floatLabelActiveColor: "{surface.400}",
                        floatLabelInvalidColor: "{form.field.invalid.placeholder.color}",
                        iconColor: "{surface.400}",
                        shadow: "none"
                    },
                    text: {
                        color: "{surface.0}",
                        hoverColor: "{surface.0}",
                        mutedColor: "{surface.400}",
                        hoverMutedColor: "{surface.400}"
                    },
                    content: {
                        background: "{surface.900}",
                        hoverBackground: "{surface.800}",
                        borderColor: "{surface.700}",
                        color: "{text.color}",
                        hoverColor: "{text.hover.color}"
                    },
                    overlay: {
                        select: {
                            background: "{surface.900}",
                            borderColor: "{surface.900}",
                            color: "{text.color}"
                        },
                        popover: {
                            background: "{surface.900}",
                            borderColor: "{surface.900}",
                            color: "{text.color}"
                        },
                        modal: {
                            background: "{surface.900}",
                            borderColor: "{surface.900}",
                            color: "{text.color}"
                        }
                    },
                    list: {
                        option: {
                            focusBackground: "{surface.800}",
                            selectedBackground: "{highlight.background}",
                            selectedFocusBackground: "{highlight.focus.background}",
                            color: "{text.color}",
                            focusColor: "{text.hover.color}",
                            selectedColor: "{highlight.color}",
                            selectedFocusColor: "{highlight.focus.color}",
                            icon: {
                                color: "{surface.400}",
                                focusColor: "{surface.400}"
                            }
                        },
                        optionGroup: {
                            background: "transparent",
                            color: "{text.muted.color}"
                        }
                    },
                    navigation: {
                        item: {
                            focusBackground: "{surface.800}",
                            activeBackground: "{surface.700}",
                            color: "{text.color}",
                            focusColor: "{text.hover.color}",
                            activeColor: "{text.hover.color}",
                            icon: {
                                color: "{surface.400}",
                                focusColor: "{surface.400}",
                                activeColor: "{surface.400}"
                            }
                        },
                        submenuLabel: {
                            background: "transparent",
                            color: "{text.muted.color}"
                        },
                        submenuIcon: {
                            color: "{surface.400}",
                            focusColor: "{surface.400}",
                            activeColor: "{surface.400}"
                        }
                    }
                }
            }
        }
    }), YO({
        components: {
            accordion: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                panel: {
                    borderWidth: "0",
                    borderColor: "{content.border.color}"
                },
                header: {
                    color: "{text.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{text.color}",
                    activeHoverColor: "{text.color}",
                    padding: "1.25rem",
                    fontWeight: "600",
                    borderRadius: "0",
                    borderWidth: "0",
                    borderColor: "{content.border.color}",
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    activeBackground: "{content.background}",
                    activeHoverBackground: "{content.background}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    },
                    toggleIcon: {
                        color: "{text.muted.color}",
                        hoverColor: "{text.muted.color}",
                        activeColor: "{text.muted.color}",
                        activeHoverColor: "{text.muted.color}"
                    },
                    first: {
                        topBorderRadius: "{content.border.radius}",
                        borderWidth: "0"
                    },
                    last: {
                        bottomBorderRadius: "{content.border.radius}",
                        activeBottomBorderRadius: "0"
                    }
                },
                content: {
                    borderWidth: "0",
                    borderColor: "{content.border.color}",
                    background: "{content.background}",
                    color: "{text.color}",
                    padding: "0 1.25rem 1.25rem 1.25rem"
                },
                css: "\n.p-accordionpanel {\n    box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);\n    transition: margin dt('accordion.transition.duration');\n}\n\n.p-accordionpanel-active {\n    margin: 1rem 0;\n}\n\n.p-accordionpanel:first-child {\n    border-top-left-radius: dt('content.border.radius');\n    border-top-right-radius: dt('content.border.radius');\n    margin-top: 0;\n}\n\n.p-accordionpanel:last-child {\n    border-bottom-left-radius: dt('content.border.radius');\n    border-bottom-right-radius: dt('content.border.radius');\n    margin-bottom: 0;\n}\n\n.p-accordionpanel:not(.p-disabled) .p-accordionheader:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            autocomplete: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}"
                },
                list: {
                    padding: "{list.padding}",
                    gap: "{list.gap}"
                },
                option: {
                    focusBackground: "{list.option.focus.background}",
                    selectedBackground: "{list.option.selected.background}",
                    selectedFocusBackground: "{list.option.selected.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    selectedColor: "{list.option.selected.color}",
                    selectedFocusColor: "{list.option.selected.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}"
                },
                optionGroup: {
                    background: "{list.option.group.background}",
                    color: "{list.option.group.color}",
                    fontWeight: "{list.option.group.font.weight}",
                    padding: "{list.option.group.padding}"
                },
                dropdown: {
                    width: "3rem",
                    sm: {
                        width: "2.5rem"
                    },
                    lg: {
                        width: "3.5rem"
                    },
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.border.color}",
                    activeBorderColor: "{form.field.border.color}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                chip: {
                    borderRadius: "{border.radius.sm}"
                },
                emptyMessage: {
                    padding: "{list.option.padding}"
                },
                colorScheme: {
                    light: {
                        chip: {
                            focusBackground: "{surface.300}",
                            focusColor: "{surface.950}"
                        },
                        dropdown: {
                            background: "{surface.100}",
                            hoverBackground: "{surface.200}",
                            activeBackground: "{surface.300}",
                            color: "{surface.600}",
                            hoverColor: "{surface.700}",
                            activeColor: "{surface.800}"
                        }
                    },
                    dark: {
                        chip: {
                            focusBackground: "{surface.600}",
                            focusColor: "{surface.0}"
                        },
                        dropdown: {
                            background: "{surface.800}",
                            hoverBackground: "{surface.700}",
                            activeBackground: "{surface.600}",
                            color: "{surface.300}",
                            hoverColor: "{surface.200}",
                            activeColor: "{surface.100}"
                        }
                    }
                },
                css: "\n.p-autocomplete-dropdown:focus-visible {\n    background: dt('autocomplete.dropdown.hover.background');\n    border-color: dt('autocomplete.dropdown.hover.border.color');\n    color: dt('autocomplete.dropdown.hover.color');\n}\n\n.p-variant-filled.p-autocomplete-input-multiple {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('autocomplete.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('autocomplete.focus.border.color'), dt('autocomplete.focus.border.color')), linear-gradient(to bottom, dt('autocomplete.border.color'), dt('autocomplete.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-autocomplete:not(.p-disabled):hover .p-variant-filled.p-autocomplete-input-multiple {\n    background: dt('autocomplete.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('autocomplete.focus.border.color'), dt('autocomplete.focus.border.color')), linear-gradient(to bottom, dt('autocomplete.hover.border.color'), dt('autocomplete.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-autocomplete:not(.p-disabled).p-focus .p-variant-filled.p-autocomplete-input-multiple {\n    outline: 0 none;\n    background: dt('autocomplete.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('autocomplete.focus.border.color'), dt('autocomplete.focus.border.color')), linear-gradient(to bottom, dt('autocomplete.border.color'), dt('autocomplete.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-autocomplete:not(.p-disabled).p-focus:hover .p-variant-filled.p-autocomplete-input-multiple {\n    background-image: linear-gradient(to bottom, dt('autocomplete.focus.border.color'), dt('autocomplete.focus.border.color')), linear-gradient(to bottom, dt('autocomplete.hover.border.color'), dt('autocomplete.hover.border.color'));\n}\n\n.p-autocomplete.p-invalid .p-autocomplete-input-multiple {\n    background-image: linear-gradient(to bottom, dt('autocomplete.invalid.border.color'), dt('autocomplete.invalid.border.color')), linear-gradient(to bottom, dt('autocomplete.invalid.border.color'), dt('autocomplete.invalid.border.color'));\n}\n\n.p-autocomplete.p-invalid.p-focus .p-autocomplete-input-multiple  {\n    background-image: linear-gradient(to bottom, dt('autocomplete.invalid.border.color'), dt('autocomplete.invalid.border.color')), linear-gradient(to bottom, dt('autocomplete.invalid.border.color'), dt('autocomplete.invalid.border.color'));\n}\n\n.p-autocomplete-option {\n    transition: none;\n}\n"
            },
            avatar: {
                root: {
                    width: "2rem",
                    height: "2rem",
                    fontSize: "1rem",
                    background: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}"
                },
                icon: {
                    size: "1rem"
                },
                group: {
                    borderColor: "{content.background}",
                    offset: "-0.75rem"
                },
                lg: {
                    width: "3rem",
                    height: "3rem",
                    fontSize: "1.5rem",
                    icon: {
                        size: "1.5rem"
                    },
                    group: {
                        offset: "-1rem"
                    }
                },
                xl: {
                    width: "4rem",
                    height: "4rem",
                    fontSize: "2rem",
                    icon: {
                        size: "2rem"
                    },
                    group: {
                        offset: "-1.5rem"
                    }
                },
                css: ""
            },
            badge: {
                root: {
                    borderRadius: "{border.radius.md}",
                    padding: "0 0.5rem",
                    fontSize: "0.75rem",
                    fontWeight: "700",
                    minWidth: "1.5rem",
                    height: "1.5rem"
                },
                dot: {
                    size: "0.5rem"
                },
                sm: {
                    fontSize: "0.625rem",
                    minWidth: "1.25rem",
                    height: "1.25rem"
                },
                lg: {
                    fontSize: "0.875rem",
                    minWidth: "1.75rem",
                    height: "1.75rem"
                },
                xl: {
                    fontSize: "1rem",
                    minWidth: "2rem",
                    height: "2rem"
                },
                colorScheme: {
                    light: {
                        primary: {
                            background: "{primary.color}",
                            color: "{primary.contrast.color}"
                        },
                        secondary: {
                            background: "{surface.100}",
                            color: "{surface.600}"
                        },
                        success: {
                            background: "{green.500}",
                            color: "{surface.0}"
                        },
                        info: {
                            background: "{sky.500}",
                            color: "{surface.0}"
                        },
                        warn: {
                            background: "{orange.500}",
                            color: "{surface.0}"
                        },
                        danger: {
                            background: "{red.500}",
                            color: "{surface.0}"
                        },
                        contrast: {
                            background: "{surface.950}",
                            color: "{surface.0}"
                        }
                    },
                    dark: {
                        primary: {
                            background: "{primary.color}",
                            color: "{primary.contrast.color}"
                        },
                        secondary: {
                            background: "{surface.800}",
                            color: "{surface.300}"
                        },
                        success: {
                            background: "{green.400}",
                            color: "{green.950}"
                        },
                        info: {
                            background: "{sky.400}",
                            color: "{sky.950}"
                        },
                        warn: {
                            background: "{orange.400}",
                            color: "{orange.950}"
                        },
                        danger: {
                            background: "{red.400}",
                            color: "{red.950}"
                        },
                        contrast: {
                            background: "{surface.0}",
                            color: "{surface.950}"
                        }
                    }
                },
                css: ""
            },
            blockui: {
                root: {
                    borderRadius: "{content.border.radius}"
                },
                css: ""
            },
            breadcrumb: {
                root: {
                    padding: "1rem",
                    background: "{content.background}",
                    gap: "0.5rem",
                    transitionDuration: "{transition.duration}"
                },
                item: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    borderRadius: "{content.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        hoverColor: "{navigation.item.icon.focus.color}"
                    },
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                separator: {
                    color: "{navigation.item.icon.color}"
                },
                css: ""
            },
            button: {
                root: {
                    borderRadius: "{form.field.border.radius}",
                    roundedBorderRadius: "2rem",
                    gap: "0.5rem",
                    paddingX: "1rem",
                    paddingY: "0.625rem",
                    iconOnlyWidth: "3rem",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}",
                        iconOnlyWidth: "2.5rem"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}",
                        iconOnlyWidth: "3.5rem"
                    },
                    label: {
                        fontWeight: "500"
                    },
                    raisedShadow: "0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12)",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        offset: "{focus.ring.offset}"
                    },
                    badgeSize: "1rem",
                    transitionDuration: "{form.field.transition.duration}"
                },
                colorScheme: {
                    light: {
                        root: {
                            primary: {
                                background: "{primary.color}",
                                hoverBackground: "{primary.hover.color}",
                                activeBackground: "{primary.active.color}",
                                borderColor: "{primary.color}",
                                hoverBorderColor: "{primary.hover.color}",
                                activeBorderColor: "{primary.active.color}",
                                color: "{primary.contrast.color}",
                                hoverColor: "{primary.contrast.color}",
                                activeColor: "{primary.contrast.color}",
                                focusRing: {
                                    color: "{primary.color}",
                                    shadow: "none"
                                }
                            },
                            secondary: {
                                background: "{surface.100}",
                                hoverBackground: "{surface.200}",
                                activeBackground: "{surface.300}",
                                borderColor: "{surface.100}",
                                hoverBorderColor: "{surface.200}",
                                activeBorderColor: "{surface.300}",
                                color: "{surface.600}",
                                hoverColor: "{surface.700}",
                                activeColor: "{surface.800}",
                                focusRing: {
                                    color: "{surface.600}",
                                    shadow: "none"
                                }
                            },
                            info: {
                                background: "{sky.500}",
                                hoverBackground: "{sky.400}",
                                activeBackground: "{sky.300}",
                                borderColor: "{sky.500}",
                                hoverBorderColor: "{sky.400}",
                                activeBorderColor: "{sky.300}",
                                color: "#ffffff",
                                hoverColor: "#ffffff",
                                activeColor: "#ffffff",
                                focusRing: {
                                    color: "{sky.500}",
                                    shadow: "none"
                                }
                            },
                            success: {
                                background: "{green.500}",
                                hoverBackground: "{green.400}",
                                activeBackground: "{green.300}",
                                borderColor: "{green.500}",
                                hoverBorderColor: "{green.400}",
                                activeBorderColor: "{green.300}",
                                color: "#ffffff",
                                hoverColor: "#ffffff",
                                activeColor: "#ffffff",
                                focusRing: {
                                    color: "{green.500}",
                                    shadow: "none"
                                }
                            },
                            warn: {
                                background: "{orange.500}",
                                hoverBackground: "{orange.400}",
                                activeBackground: "{orange.300}",
                                borderColor: "{orange.500}",
                                hoverBorderColor: "{orange.400}",
                                activeBorderColor: "{orange.300}",
                                color: "#ffffff",
                                hoverColor: "#ffffff",
                                activeColor: "#ffffff",
                                focusRing: {
                                    color: "{orange.500}",
                                    shadow: "none"
                                }
                            },
                            help: {
                                background: "{purple.500}",
                                hoverBackground: "{purple.400}",
                                activeBackground: "{purple.300}",
                                borderColor: "{purple.500}",
                                hoverBorderColor: "{purple.400}",
                                activeBorderColor: "{purple.300}",
                                color: "#ffffff",
                                hoverColor: "#ffffff",
                                activeColor: "#ffffff",
                                focusRing: {
                                    color: "{purple.500}",
                                    shadow: "none"
                                }
                            },
                            danger: {
                                background: "{red.500}",
                                hoverBackground: "{red.400}",
                                activeBackground: "{red.300}",
                                borderColor: "{red.500}",
                                hoverBorderColor: "{red.400}",
                                activeBorderColor: "{red.300}",
                                color: "#ffffff",
                                hoverColor: "#ffffff",
                                activeColor: "#ffffff",
                                focusRing: {
                                    color: "{red.500}",
                                    shadow: "none"
                                }
                            },
                            contrast: {
                                background: "{surface.950}",
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                borderColor: "{surface.950}",
                                hoverBorderColor: "{surface.800}",
                                activeBorderColor: "{surface.700}",
                                color: "{surface.0}",
                                hoverColor: "{surface.0}",
                                activeColor: "{surface.0}",
                                focusRing: {
                                    color: "{surface.950}",
                                    shadow: "none"
                                }
                            }
                        },
                        outlined: {
                            primary: {
                                hoverBackground: "{primary.50}",
                                activeBackground: "{primary.100}",
                                borderColor: "{primary.color}",
                                color: "{primary.color}"
                            },
                            secondary: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                borderColor: "{surface.600}",
                                color: "{surface.600}"
                            },
                            success: {
                                hoverBackground: "{green.50}",
                                activeBackground: "{green.100}",
                                borderColor: "{green.500}",
                                color: "{green.500}"
                            },
                            info: {
                                hoverBackground: "{sky.50}",
                                activeBackground: "{sky.100}",
                                borderColor: "{sky.500}",
                                color: "{sky.500}"
                            },
                            warn: {
                                hoverBackground: "{orange.50}",
                                activeBackground: "{orange.100}",
                                borderColor: "{orange.500}",
                                color: "{orange.500}"
                            },
                            help: {
                                hoverBackground: "{purple.50}",
                                activeBackground: "{purple.100}",
                                borderColor: "{purple.500}",
                                color: "{purple.500}"
                            },
                            danger: {
                                hoverBackground: "{red.50}",
                                activeBackground: "{red.100}",
                                borderColor: "{red.500}",
                                color: "{red.500}"
                            },
                            contrast: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                borderColor: "{surface.950}",
                                color: "{surface.950}"
                            },
                            plain: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                borderColor: "{surface.900}",
                                color: "{surface.900}"
                            }
                        },
                        text: {
                            primary: {
                                hoverBackground: "{primary.50}",
                                activeBackground: "{primary.100}",
                                color: "{primary.color}"
                            },
                            secondary: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                color: "{surface.600}"
                            },
                            success: {
                                hoverBackground: "{green.50}",
                                activeBackground: "{green.100}",
                                color: "{green.500}"
                            },
                            info: {
                                hoverBackground: "{sky.50}",
                                activeBackground: "{sky.100}",
                                color: "{sky.500}"
                            },
                            warn: {
                                hoverBackground: "{orange.50}",
                                activeBackground: "{orange.100}",
                                color: "{orange.500}"
                            },
                            help: {
                                hoverBackground: "{purple.50}",
                                activeBackground: "{purple.100}",
                                color: "{purple.500}"
                            },
                            danger: {
                                hoverBackground: "{red.50}",
                                activeBackground: "{red.100}",
                                color: "{red.500}"
                            },
                            contrast: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                color: "{surface.950}"
                            },
                            plain: {
                                hoverBackground: "{surface.50}",
                                activeBackground: "{surface.100}",
                                color: "{surface.900}"
                            }
                        },
                        link: {
                            color: "{primary.color}",
                            hoverColor: "{primary.color}",
                            activeColor: "{primary.color}"
                        }
                    },
                    dark: {
                        root: {
                            primary: {
                                background: "{primary.color}",
                                hoverBackground: "{primary.hover.color}",
                                activeBackground: "{primary.active.color}",
                                borderColor: "{primary.color}",
                                hoverBorderColor: "{primary.hover.color}",
                                activeBorderColor: "{primary.active.color}",
                                color: "{primary.contrast.color}",
                                hoverColor: "{primary.contrast.color}",
                                activeColor: "{primary.contrast.color}",
                                focusRing: {
                                    color: "{primary.color}",
                                    shadow: "none"
                                }
                            },
                            secondary: {
                                background: "{surface.800}",
                                hoverBackground: "{surface.700}",
                                activeBackground: "{surface.600}",
                                borderColor: "{surface.800}",
                                hoverBorderColor: "{surface.700}",
                                activeBorderColor: "{surface.600}",
                                color: "{surface.300}",
                                hoverColor: "{surface.200}",
                                activeColor: "{surface.100}",
                                focusRing: {
                                    color: "{surface.300}",
                                    shadow: "none"
                                }
                            },
                            info: {
                                background: "{sky.400}",
                                hoverBackground: "{sky.300}",
                                activeBackground: "{sky.200}",
                                borderColor: "{sky.400}",
                                hoverBorderColor: "{sky.300}",
                                activeBorderColor: "{sky.200}",
                                color: "{sky.950}",
                                hoverColor: "{sky.950}",
                                activeColor: "{sky.950}",
                                focusRing: {
                                    color: "{sky.400}",
                                    shadow: "none"
                                }
                            },
                            success: {
                                background: "{green.400}",
                                hoverBackground: "{green.300}",
                                activeBackground: "{green.200}",
                                borderColor: "{green.400}",
                                hoverBorderColor: "{green.300}",
                                activeBorderColor: "{green.200}",
                                color: "{green.950}",
                                hoverColor: "{green.950}",
                                activeColor: "{green.950}",
                                focusRing: {
                                    color: "{green.400}",
                                    shadow: "none"
                                }
                            },
                            warn: {
                                background: "{orange.400}",
                                hoverBackground: "{orange.300}",
                                activeBackground: "{orange.200}",
                                borderColor: "{orange.400}",
                                hoverBorderColor: "{orange.300}",
                                activeBorderColor: "{orange.200}",
                                color: "{orange.950}",
                                hoverColor: "{orange.950}",
                                activeColor: "{orange.950}",
                                focusRing: {
                                    color: "{orange.400}",
                                    shadow: "none"
                                }
                            },
                            help: {
                                background: "{purple.400}",
                                hoverBackground: "{purple.300}",
                                activeBackground: "{purple.200}",
                                borderColor: "{purple.400}",
                                hoverBorderColor: "{purple.300}",
                                activeBorderColor: "{purple.200}",
                                color: "{purple.950}",
                                hoverColor: "{purple.950}",
                                activeColor: "{purple.950}",
                                focusRing: {
                                    color: "{purple.400}",
                                    shadow: "none"
                                }
                            },
                            danger: {
                                background: "{red.400}",
                                hoverBackground: "{red.300}",
                                activeBackground: "{red.200}",
                                borderColor: "{red.400}",
                                hoverBorderColor: "{red.300}",
                                activeBorderColor: "{red.200}",
                                color: "{red.950}",
                                hoverColor: "{red.950}",
                                activeColor: "{red.950}",
                                focusRing: {
                                    color: "{red.400}",
                                    shadow: "none"
                                }
                            },
                            contrast: {
                                background: "{surface.0}",
                                hoverBackground: "{surface.100}",
                                activeBackground: "{surface.200}",
                                borderColor: "{surface.0}",
                                hoverBorderColor: "{surface.100}",
                                activeBorderColor: "{surface.200}",
                                color: "{surface.950}",
                                hoverColor: "{surface.950}",
                                activeColor: "{surface.950}",
                                focusRing: {
                                    color: "{surface.0}",
                                    shadow: "none"
                                }
                            }
                        },
                        outlined: {
                            primary: {
                                hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
                                borderColor: "{primary.700}",
                                color: "{primary.color}"
                            },
                            secondary: {
                                hoverBackground: "rgba(255,255,255,0.04)",
                                activeBackground: "rgba(255,255,255,0.16)",
                                borderColor: "{surface.700}",
                                color: "{surface.400}"
                            },
                            success: {
                                hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
                                borderColor: "{green.700}",
                                color: "{green.400}"
                            },
                            info: {
                                hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
                                borderColor: "{sky.700}",
                                color: "{sky.400}"
                            },
                            warn: {
                                hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
                                borderColor: "{orange.700}",
                                color: "{orange.400}"
                            },
                            help: {
                                hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
                                borderColor: "{purple.700}",
                                color: "{purple.400}"
                            },
                            danger: {
                                hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
                                borderColor: "{red.700}",
                                color: "{red.400}"
                            },
                            contrast: {
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                borderColor: "{surface.500}",
                                color: "{surface.0}"
                            },
                            plain: {
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                borderColor: "{surface.600}",
                                color: "{surface.0}"
                            }
                        },
                        text: {
                            primary: {
                                hoverBackground: "color-mix(in srgb, {primary.color}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {primary.color}, transparent 84%)",
                                color: "{primary.color}"
                            },
                            secondary: {
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                color: "{surface.400}"
                            },
                            success: {
                                hoverBackground: "color-mix(in srgb, {green.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {green.400}, transparent 84%)",
                                color: "{green.400}"
                            },
                            info: {
                                hoverBackground: "color-mix(in srgb, {sky.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {sky.400}, transparent 84%)",
                                color: "{sky.400}"
                            },
                            warn: {
                                hoverBackground: "color-mix(in srgb, {orange.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {orange.400}, transparent 84%)",
                                color: "{orange.400}"
                            },
                            help: {
                                hoverBackground: "color-mix(in srgb, {purple.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {purple.400}, transparent 84%)",
                                color: "{purple.400}"
                            },
                            danger: {
                                hoverBackground: "color-mix(in srgb, {red.400}, transparent 96%)",
                                activeBackground: "color-mix(in srgb, {red.400}, transparent 84%)",
                                color: "{red.400}"
                            },
                            contrast: {
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                color: "{surface.0}"
                            },
                            plain: {
                                hoverBackground: "{surface.800}",
                                activeBackground: "{surface.700}",
                                color: "{surface.0}"
                            }
                        },
                        link: {
                            color: "{primary.color}",
                            hoverColor: "{primary.color}",
                            activeColor: "{primary.color}"
                        }
                    }
                },
                css: "\n.p-button:focus-visible {\n    background: dt('button.primary.active.background');\n    border-color: dt('button.primary.active.background');\n}\n\n.p-button-secondary:focus-visible {\n    background: dt('button.secondary.active.background');\n    border-color: dt('button.secondary.active.background');\n}\n\n.p-button-success:focus-visible {\n    background: dt('button.success.active.background');\n    border-color: dt('button.success.active.background');\n}\n\n.p-button-info:focus-visible {\n    background: dt('button.info.active.background');\n    border-color: dt('button.info.active.background');\n}\n\n.p-button-warn:focus-visible {\n    background: dt('button.warn.active.background');\n    border-color: dt('button.warn.active.background');\n}\n\n.p-button-help:focus-visible {\n    background: dt('button.help.active.background');\n    border-color: dt('button.help.active.background');\n}\n\n.p-button-danger:focus-visible {\n    background: dt('button.danger.active.background');\n    border-color: dt('button.danger.active.background');\n}\n\n.p-button-contrast:focus-visible {\n    background: dt('button.contrast.active.background');\n    border-color: dt('button.contrast.active.background');\n}\n\n.p-button-link:focus-visible {\n    background: color-mix(in srgb, dt('primary.color'), transparent 84%);\n    border-color: transparent;\n}\n\n.p-button-text:focus-visible {\n    background: dt('button.text.primary.active.background');\n    border-color: transparent;\n}\n\n.p-button-secondary.p-button-text:focus-visible {\n    background: dt('button.text.secondary.active.background');\n    border-color: transparent;\n}\n\n.p-button-success.p-button-text:focus-visible {\n    background: dt('button.text.success.active.background');\n    border-color: transparent;\n}\n\n.p-button-info.p-button-text:focus-visible {\n    background: dt('button.text.info.active.background');\n    border-color: transparent;\n}\n\n.p-button-warn.p-button-text:focus-visible {\n    background: dt('button.text.warn.active.background');\n    border-color: transparent;\n}\n\n.p-button-help.p-button-text:focus-visible {\n    background: dt('button.text.help.active.background');\n    border-color: transparent;\n}\n\n.p-button-danger.p-button-text:focus-visible {\n    background: dt('button.text.danger.active.background');\n    border-color: transparent;\n}\n\n.p-button-contrast.p-button-text:focus-visible {\n    background: dt('button.text.contrast.active.background');\n    border-color: transparent;\n}\n\n.p-button-plain.p-button-text:focus-visible {\n    background: dt('button.text.plain.active.background');\n    border-color: transparent;\n}\n\n.p-button-outlined:focus-visible {\n    background: dt('button.outlined.primary.active.background');\n}\n\n.p-button-secondary.p-button-outlined:focus-visible {\n    background: dt('button.outlined.secondary.active.background');\n    border-color: dt('button.outlined.secondary.border.color');\n}\n\n.p-button-success.p-button-outlined:focus-visible {\n    background: dt('button.outlined.success.active.background');\n}\n\n.p-button-info.p-button-outlined:focus-visible {\n    background: dt('button.outlined.info.active.background');\n}\n\n.p-button-warn.p-button-outlined:focus-visible {\n    background: dt('button.outlined.warn.active.background');\n}\n\n.p-button-help.p-button-outlined:focus-visible {\n    background: dt('button.outlined.help.active.background');\n}\n\n.p-button-danger.p-button-outlined:focus-visible {\n    background: dt('button.outlined.danger.active.background');\n}\n\n.p-button-contrast.p-button-outlined:focus-visible {\n    background: dt('button.outlined.contrast.active.background');\n}\n\n.p-button-plain.p-button-outlined:focus-visible {\n    background: dt('button.outlined.plain.active.background');\n}\n"
            },
            datepicker: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                panel: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    shadow: "{overlay.popover.shadow}",
                    padding: "0.5rem"
                },
                header: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    padding: "0 0 0.5rem 0"
                },
                title: {
                    gap: "0.5rem",
                    fontWeight: "700"
                },
                dropdown: {
                    width: "3rem",
                    sm: {
                        width: "2.5rem"
                    },
                    lg: {
                        width: "3.5rem"
                    },
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.border.color}",
                    activeBorderColor: "{form.field.border.color}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                inputIcon: {
                    color: "{form.field.icon.color}"
                },
                selectMonth: {
                    hoverBackground: "{content.hover.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    padding: "0.5rem 0.75rem",
                    borderRadius: "{content.border.radius}"
                },
                selectYear: {
                    hoverBackground: "{content.hover.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    padding: "0.5rem 0.75rem",
                    borderRadius: "{content.border.radius}"
                },
                group: {
                    borderColor: "{content.border.color}",
                    gap: "{overlay.popover.padding}"
                },
                dayView: {
                    margin: "0.5rem 0 0 0"
                },
                weekDay: {
                    padding: "0.5rem",
                    fontWeight: "700",
                    color: "{content.color}"
                },
                date: {
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{primary.color}",
                    rangeSelectedBackground: "{highlight.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    selectedColor: "{primary.contrast.color}",
                    rangeSelectedColor: "{highlight.color}",
                    width: "2.5rem",
                    height: "2.5rem",
                    borderRadius: "50%",
                    padding: "0.125rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                monthView: {
                    margin: "0.5rem 0 0 0"
                },
                month: {
                    padding: "0.625rem",
                    borderRadius: "{content.border.radius}"
                },
                yearView: {
                    margin: "0.5rem 0 0 0"
                },
                year: {
                    padding: "0.625rem",
                    borderRadius: "{content.border.radius}"
                },
                buttonbar: {
                    padding: "0.5rem 0 0 0",
                    borderColor: "{content.border.color}"
                },
                timePicker: {
                    padding: "0.5rem 0 0 0",
                    borderColor: "{content.border.color}",
                    gap: "0.5rem",
                    buttonGap: "0.25rem"
                },
                colorScheme: {
                    light: {
                        dropdown: {
                            background: "{surface.100}",
                            hoverBackground: "{surface.200}",
                            activeBackground: "{surface.300}",
                            color: "{surface.600}",
                            hoverColor: "{surface.700}",
                            activeColor: "{surface.800}"
                        },
                        today: {
                            background: "{surface.200}",
                            color: "{surface.900}"
                        }
                    },
                    dark: {
                        dropdown: {
                            background: "{surface.800}",
                            hoverBackground: "{surface.700}",
                            activeBackground: "{surface.600}",
                            color: "{surface.300}",
                            hoverColor: "{surface.200}",
                            activeColor: "{surface.100}"
                        },
                        today: {
                            background: "{surface.700}",
                            color: "{surface.0}"
                        }
                    }
                },
                css: "\n.p-datepicker-header {\n    justify-content: start;\n}\n\n.p-datepicker-title {\n    order: 1;\n}\n\n.p-datepicker-prev-button {\n    order: 2;\n    margin-inline-start: auto;\n}\n\n.p-datepicker-next-button {\n    order: 2;\n    margin-inline-start: 0.5rem;\n}\n\n.p-datepicker-select-month:focus-visible {\n    background: dt('datepicker.select.month.hover.background');\n    color: dt('datepicker.select.month.hover.color');\n    outline: 0 none;\n}\n\n.p-datepicker-select-year:focus-visible {\n    background: dt('datepicker.select.year.hover.background');\n    color: dt('datepicker.select.year.hover.color');\n    outline: 0 none;\n}\n\n.p-datepicker-dropdown:focus-visible {\n    outline: 0 none;\n    background: dt('datepicker.dropdown.hover.background');\n    border-color: dt('datepicker.dropdown.hover.border.color');\n    color: dt('datepicker.dropdown.hover.color');\n}\n"
            },
            card: {
                root: {
                    background: "{content.background}",
                    borderRadius: "{content.border.radius}",
                    color: "{content.color}",
                    shadow: "0 2px 1px -1px rgba(0,0,0,.2), 0 1px 1px 0 rgba(0,0,0,.14), 0 1px 3px 0 rgba(0,0,0,.12)"
                },
                body: {
                    padding: "1.5rem",
                    gap: "0.75rem"
                },
                caption: {
                    gap: "0.5rem"
                },
                title: {
                    fontSize: "1.25rem",
                    fontWeight: "500"
                },
                subtitle: {
                    color: "{text.muted.color}"
                },
                css: ""
            },
            carousel: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                content: {
                    gap: "0.25rem"
                },
                indicatorList: {
                    padding: "1rem",
                    gap: "1rem"
                },
                indicator: {
                    width: "1.25rem",
                    height: "1.25rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                colorScheme: {
                    light: {
                        indicator: {
                            background: "{surface.200}",
                            hoverBackground: "{surface.300}",
                            activeBackground: "{primary.color}"
                        }
                    },
                    dark: {
                        indicator: {
                            background: "{surface.700}",
                            hoverBackground: "{surface.600}",
                            activeBackground: "{primary.color}"
                        }
                    }
                },
                css: "\n.p-carousel-indicator-button:hover {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 96%);\n}\n\n.p-carousel-indicator-button:focus-visible {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 96%);\n}\n\n.p-carousel-indicator-active .p-carousel-indicator-button:hover {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('carousel.indicator.active.background'), transparent 92%);\n}\n\n.p-carousel-indicator-active .p-carousel-indicator-button:focus-visible {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('carousel.indicator.active.background'), transparent 84%);\n}\n"
            },
            cascadeselect: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                dropdown: {
                    width: "2.5rem",
                    color: "{form.field.icon.color}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}"
                },
                list: {
                    padding: "{list.padding}",
                    gap: "{list.gap}",
                    mobileIndent: "1rem"
                },
                option: {
                    focusBackground: "{list.option.focus.background}",
                    selectedBackground: "{list.option.selected.background}",
                    selectedFocusBackground: "{list.option.selected.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    selectedColor: "{list.option.selected.color}",
                    selectedFocusColor: "{list.option.selected.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}",
                    icon: {
                        color: "{list.option.icon.color}",
                        focusColor: "{list.option.icon.focus.color}",
                        size: "0.875rem"
                    }
                },
                clearIcon: {
                    color: "{form.field.icon.color}"
                },
                css: "\n.p-cascadeselect.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('cascadeselect.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('cascadeselect.focus.border.color'), dt('cascadeselect.focus.border.color')), linear-gradient(to bottom, dt('cascadeselect.border.color'), dt('cascadeselect.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-cascadeselect.p-variant-filled:not(.p-disabled):hover {\n    background: dt('cascadeselect.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('cascadeselect.focus.border.color'), dt('cascadeselect.focus.border.color')), linear-gradient(to bottom, dt('cascadeselect.hover.border.color'), dt('cascadeselect.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-cascadeselect.p-variant-filled:not(.p-disabled).p-focus {\n    outline: 0 none;\n    background: dt('cascadeselect.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('cascadeselect.focus.border.color'), dt('cascadeselect.focus.border.color')), linear-gradient(to bottom, dt('cascadeselect.border.color'), dt('cascadeselect.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-cascadeselect.p-variant-filled:not(.p-disabled).p-focus:hover {\n    background-image: linear-gradient(to bottom, dt('cascadeselect.focus.border.color'), dt('cascadeselect.focus.border.color')), linear-gradient(to bottom, dt('cascadeselect.hover.border.color'), dt('cascadeselect.hover.border.color'));\n}\n\n.p-cascadeselect.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('cascadeselect.invalid.border.color'), dt('cascadeselect.invalid.border.color')), linear-gradient(to bottom, dt('cascadeselect.invalid.border.color'), dt('cascadeselect.invalid.border.color'));\n}\n\n.p-cascadeselect.p-variant-filled.p-invalid:not(.p-disabled).p-focus  {\n    background-image: linear-gradient(to bottom, dt('cascadeselect.invalid.border.color'), dt('cascadeselect.invalid.border.color')), linear-gradient(to bottom, dt('cascadeselect.invalid.border.color'), dt('cascadeselect.invalid.border.color'));\n}\n\n.p-cascadeselect-option {\n    transition: none;\n}\n"
            },
            checkbox: {
                root: {
                    borderRadius: "{border.radius.xs}",
                    width: "18px",
                    height: "18px",
                    background: "{form.field.background}",
                    checkedBackground: "{primary.color}",
                    checkedHoverBackground: "{primary.color}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    checkedBorderColor: "{primary.color}",
                    checkedHoverBorderColor: "{primary.color}",
                    checkedFocusBorderColor: "{primary.color}",
                    checkedDisabledBorderColor: "{form.field.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    shadow: "{form.field.shadow}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        width: "14px",
                        height: "14px"
                    },
                    lg: {
                        width: "22px",
                        height: "22px"
                    }
                },
                icon: {
                    size: "0.875rem",
                    color: "{form.field.color}",
                    checkedColor: "{primary.contrast.color}",
                    checkedHoverColor: "{primary.contrast.color}",
                    disabledColor: "{form.field.disabled.color}",
                    sm: {
                        size: "0.75rem"
                    },
                    lg: {
                        size: "1rem"
                    }
                },
                css: "\n.p-checkbox {\n    border-radius: 50%;\n    transition: box-shadow dt('checkbox.transition.duration');\n}\n\n.p-checkbox-box {\n    border-width: 2px;\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:hover) {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 96%);\n}\n\n.p-checkbox:not(.p-disabled):has(.p-checkbox-input:focus-visible) {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 88%);\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:hover) {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('checkbox.checked.background'), transparent 92%);\n}\n\n.p-checkbox-checked:not(.p-disabled):has(.p-checkbox-input:focus-visible) {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('checkbox.checked.background'), transparent 84%);\n}\n\n.p-checkbox-checked .p-checkbox-box:before  {\n    content: \"\";\n    position: absolute;\n    top: var(--p-md-check-icon-t);\n    left: 2px;\n    border-right: 2px solid transparent;\n    border-bottom: 2px solid transparent;\n    transform: rotate(45deg);\n    transform-origin: 0% 100%;\n    animation: p-md-check 125ms 50ms linear forwards;\n}\n\n.p-checkbox-checked .p-checkbox-icon {\n    display: none;\n}\n\n.p-checkbox {\n    --p-md-check-icon-t: 10px;\n    --p-md-check-icon-w: 6px;\n    --p-md-check-icon-h: 12px;\n}\n\n.p-checkbox-sm {\n    --p-md-check-icon-t: 8px;\n    --p-md-check-icon-w: 4px;\n    --p-md-check-icon-h: 10px;\n}\n\n.p-checkbox-lg {\n    --p-md-check-icon-t: 12px;\n    --p-md-check-icon-w: 8px;\n    --p-md-check-icon-h: 16px;\n}\n\n@keyframes p-md-check {\n    0%{\n      width: 0;\n      height: 0;\n      border-color: dt('checkbox.icon.checked.color');\n      transform: translate3d(0,0,0) rotate(45deg);\n    }\n    33%{\n      width: var(--p-md-check-icon-w);\n      height: 0;\n      transform: translate3d(0,0,0) rotate(45deg);\n    }\n    100%{\n      width: var(--p-md-check-icon-w);\n      height: var(--p-md-check-icon-h);\n      border-color: dt('checkbox.icon.checked.color');\n      transform: translate3d(0,calc(-1 * var(--p-md-check-icon-h)),0) rotate(45deg);\n    }\n}\n"
            },
            chip: {
                root: {
                    borderRadius: "2rem",
                    paddingX: "0.75rem",
                    paddingY: "0.75rem",
                    gap: "0.5rem",
                    transitionDuration: "{transition.duration}"
                },
                image: {
                    width: "2.25rem",
                    height: "2.25rem"
                },
                icon: {
                    size: "1rem"
                },
                removeIcon: {
                    size: "1rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}"
                    }
                },
                colorScheme: {
                    light: {
                        root: {
                            background: "{surface.200}",
                            color: "{surface.900}"
                        },
                        icon: {
                            color: "{surface.600}"
                        },
                        removeIcon: {
                            color: "{surface.600}",
                            focusRing: {
                                shadow: "0 0 1px 4px {surface.300}"
                            }
                        }
                    },
                    dark: {
                        root: {
                            background: "{surface.700}",
                            color: "{surface.0}"
                        },
                        icon: {
                            color: "{surface.0}"
                        },
                        removeIcon: {
                            color: "{surface.0}",
                            focusRing: {
                                shadow: "0 0 1px 4px {surface.600}"
                            }
                        }
                    }
                },
                css: ""
            },
            colorpicker: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                preview: {
                    width: "2rem",
                    height: "2rem",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                panel: {
                    shadow: "{overlay.popover.shadow}",
                    borderRadius: "{overlay.popover.borderRadius}"
                },
                colorScheme: {
                    light: {
                        panel: {
                            background: "{surface.800}",
                            borderColor: "{surface.900}"
                        },
                        handle: {
                            color: "{surface.0}"
                        }
                    },
                    dark: {
                        panel: {
                            background: "{surface.900}",
                            borderColor: "{surface.700}"
                        },
                        handle: {
                            color: "{surface.0}"
                        }
                    }
                },
                css: ""
            },
            confirmdialog: {
                icon: {
                    size: "2rem",
                    color: "{overlay.modal.color}"
                },
                content: {
                    gap: "1rem"
                },
                css: ""
            },
            confirmpopup: {
                root: {
                    background: "{overlay.popover.background}",
                    borderColor: "{overlay.popover.border.color}",
                    color: "{overlay.popover.color}",
                    borderRadius: "{overlay.popover.border.radius}",
                    shadow: "{overlay.popover.shadow}",
                    gutter: "10px",
                    arrowOffset: "1.25rem"
                },
                content: {
                    padding: "{overlay.popover.padding}",
                    gap: "1rem"
                },
                icon: {
                    size: "1.5rem",
                    color: "{overlay.popover.color}"
                },
                footer: {
                    gap: "0.5rem",
                    padding: "0 {overlay.popover.padding} {overlay.popover.padding} {overlay.popover.padding}"
                },
                css: ""
            },
            contextmenu: {
                root: {
                    background: "{content.background}",
                    borderColor: "transparent",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    shadow: "{overlay.navigation.shadow}",
                    transitionDuration: "{transition.duration}"
                },
                list: {
                    padding: "{navigation.list.padding}",
                    gap: "{navigation.list.gap}"
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    activeBackground: "{navigation.item.active.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    activeColor: "{navigation.item.active.color}",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{navigation.item.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}",
                        activeColor: "{navigation.item.icon.active.color}"
                    }
                },
                submenu: {
                    mobileIndent: "1rem"
                },
                submenuIcon: {
                    size: "{navigation.submenu.icon.size}",
                    color: "{navigation.submenu.icon.color}",
                    focusColor: "{navigation.submenu.icon.focus.color}",
                    activeColor: "{navigation.submenu.icon.active.color}"
                },
                separator: {
                    borderColor: "{content.border.color}"
                },
                css: ""
            },
            dataview: {
                root: {
                    borderColor: "transparent",
                    borderWidth: "0",
                    borderRadius: "0",
                    padding: "0"
                },
                header: {
                    background: "{content.background}",
                    color: "{content.color}",
                    borderColor: "{content.border.color}",
                    borderWidth: "0 0 1px 0",
                    padding: "0.75rem 1rem",
                    borderRadius: "0"
                },
                content: {
                    background: "{content.background}",
                    color: "{content.color}",
                    borderColor: "transparent",
                    borderWidth: "0",
                    padding: "0",
                    borderRadius: "0"
                },
                footer: {
                    background: "{content.background}",
                    color: "{content.color}",
                    borderColor: "{content.border.color}",
                    borderWidth: "1px 0 0 0",
                    padding: "0.75rem 1rem",
                    borderRadius: "0"
                },
                paginatorTop: {
                    borderColor: "{content.border.color}",
                    borderWidth: "0 0 1px 0"
                },
                paginatorBottom: {
                    borderColor: "{content.border.color}",
                    borderWidth: "1px 0 0 0"
                },
                css: ""
            },
            datatable: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                header: {
                    background: "{content.background}",
                    borderColor: "{datatable.border.color}",
                    color: "{content.color}",
                    borderWidth: "0 0 1px 0",
                    padding: "0.75rem 1rem",
                    sm: {
                        padding: "0.375rem 0.5rem"
                    },
                    lg: {
                        padding: "1rem 1.25rem"
                    }
                },
                headerCell: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    borderColor: "{datatable.border.color}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    selectedColor: "{highlight.color}",
                    gap: "0.5rem",
                    padding: "0.75rem 1rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "-1px",
                        shadow: "{focus.ring.shadow}"
                    },
                    sm: {
                        padding: "0.375rem 0.5rem"
                    },
                    lg: {
                        padding: "1rem 1.25rem"
                    }
                },
                columnTitle: {
                    fontWeight: "600"
                },
                row: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    selectedColor: "{highlight.color}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "-1px",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                bodyCell: {
                    borderColor: "{datatable.border.color}",
                    padding: "0.75rem 1rem",
                    sm: {
                        padding: "0.375rem 0.5rem"
                    },
                    lg: {
                        padding: "1rem 1.25rem"
                    }
                },
                footerCell: {
                    background: "{content.background}",
                    borderColor: "{datatable.border.color}",
                    color: "{content.color}",
                    padding: "0.75rem 1rem",
                    sm: {
                        padding: "0.375rem 0.5rem"
                    },
                    lg: {
                        padding: "1rem 1.25rem"
                    }
                },
                columnFooter: {
                    fontWeight: "600"
                },
                footer: {
                    background: "{content.background}",
                    borderColor: "{datatable.border.color}",
                    color: "{content.color}",
                    borderWidth: "0 0 1px 0",
                    padding: "0.75rem 1rem",
                    sm: {
                        padding: "0.375rem 0.5rem"
                    },
                    lg: {
                        padding: "1rem 1.25rem"
                    }
                },
                dropPoint: {
                    color: "{primary.color}"
                },
                columnResizer: {
                    width: "0.5rem"
                },
                resizeIndicator: {
                    width: "1px",
                    color: "{primary.color}"
                },
                sortIcon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    size: "0.875rem"
                },
                loadingIcon: {
                    size: "2rem"
                },
                rowToggleButton: {
                    hoverBackground: "{content.hover.background}",
                    selectedHoverBackground: "{content.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    selectedHoverColor: "{primary.color}",
                    size: "1.75rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                filter: {
                    inlineGap: "0.5rem",
                    overlaySelect: {
                        background: "{overlay.select.background}",
                        borderColor: "{overlay.select.border.color}",
                        borderRadius: "{overlay.select.border.radius}",
                        color: "{overlay.select.color}",
                        shadow: "{overlay.select.shadow}"
                    },
                    overlayPopover: {
                        background: "{overlay.popover.background}",
                        borderColor: "{overlay.popover.border.color}",
                        borderRadius: "{overlay.popover.border.radius}",
                        color: "{overlay.popover.color}",
                        shadow: "{overlay.popover.shadow}",
                        padding: "{overlay.popover.padding}",
                        gap: "0.5rem"
                    },
                    rule: {
                        borderColor: "{content.border.color}"
                    },
                    constraintList: {
                        padding: "{list.padding}",
                        gap: "{list.gap}"
                    },
                    constraint: {
                        focusBackground: "{list.option.focus.background}",
                        selectedBackground: "{list.option.selected.background}",
                        selectedFocusBackground: "{list.option.selected.focus.background}",
                        color: "{list.option.color}",
                        focusColor: "{list.option.focus.color}",
                        selectedColor: "{list.option.selected.color}",
                        selectedFocusColor: "{list.option.selected.focus.color}",
                        separator: {
                            borderColor: "{content.border.color}"
                        },
                        padding: "{list.option.padding}",
                        borderRadius: "{list.option.border.radius}"
                    }
                },
                paginatorTop: {
                    borderColor: "{datatable.border.color}",
                    borderWidth: "0 0 1px 0"
                },
                paginatorBottom: {
                    borderColor: "{datatable.border.color}",
                    borderWidth: "0 0 1px 0"
                },
                colorScheme: {
                    light: {
                        root: {
                            borderColor: "{content.border.color}"
                        },
                        row: {
                            stripedBackground: "{surface.50}"
                        },
                        bodyCell: {
                            selectedBorderColor: "{primary.100}"
                        }
                    },
                    dark: {
                        root: {
                            borderColor: "{surface.800}"
                        },
                        row: {
                            stripedBackground: "{surface.950}"
                        },
                        bodyCell: {
                            selectedBorderColor: "{primary.900}"
                        }
                    }
                },
                css: "\n.p-datatable-header-cell,\n.p-datatable-tbody > tr {\n    transition: none;\n}\n"
            },
            dialog: {
                root: {
                    background: "{overlay.modal.background}",
                    borderColor: "{overlay.modal.border.color}",
                    color: "{overlay.modal.color}",
                    borderRadius: "{overlay.modal.border.radius}",
                    shadow: "{overlay.modal.shadow}"
                },
                header: {
                    padding: "{overlay.modal.padding}",
                    gap: "0.5rem"
                },
                title: {
                    fontSize: "1.25rem",
                    fontWeight: "600"
                },
                content: {
                    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
                },
                footer: {
                    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}",
                    gap: "0.5rem"
                },
                css: ""
            },
            divider: {
                root: {
                    borderColor: "{content.border.color}"
                },
                content: {
                    background: "{content.background}",
                    color: "{text.color}"
                },
                horizontal: {
                    margin: "1rem 0",
                    padding: "0 1rem",
                    content: {
                        padding: "0 0.5rem"
                    }
                },
                vertical: {
                    margin: "0 1rem",
                    padding: "0.5rem 0",
                    content: {
                        padding: "0.5rem 0"
                    }
                },
                css: ""
            },
            dock: {
                root: {
                    background: "rgba(255, 255, 255, 0.1)",
                    borderColor: "rgba(255, 255, 255, 0.2)",
                    padding: "0.5rem",
                    borderRadius: "{border.radius.xl}"
                },
                item: {
                    borderRadius: "{content.border.radius}",
                    padding: "0.5rem",
                    size: "3rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                css: ""
            },
            drawer: {
                root: {
                    background: "{overlay.modal.background}",
                    borderColor: "{overlay.modal.border.color}",
                    color: "{overlay.modal.color}",
                    shadow: "{overlay.modal.shadow}"
                },
                header: {
                    padding: "{overlay.modal.padding}"
                },
                title: {
                    fontSize: "1.5rem",
                    fontWeight: "600"
                },
                content: {
                    padding: "0 {overlay.modal.padding} {overlay.modal.padding} {overlay.modal.padding}"
                },
                footer: {
                    padding: "{overlay.modal.padding}"
                },
                css: ""
            },
            editor: {
                toolbar: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    borderRadius: "{content.border.radius}"
                },
                toolbarItem: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{primary.color}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}",
                    padding: "{list.padding}"
                },
                overlayOption: {
                    focusBackground: "{list.option.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}"
                },
                content: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}"
                },
                css: "\n.p-editor .p-editor-toolbar {\n    padding: 0.75rem\n}\n"
            },
            fieldset: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    color: "{content.color}",
                    padding: "0 1.25rem 1.25rem 1.25rem",
                    transitionDuration: "{transition.duration}"
                },
                legend: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    borderRadius: "{content.border.radius}",
                    borderWidth: "1px",
                    borderColor: "transparent",
                    padding: "0.75rem 1rem",
                    gap: "0.5rem",
                    fontWeight: "600",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                toggleIcon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}"
                },
                content: {
                    padding: "0"
                },
                css: "\n.p-fieldset-toggle-button:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            fileupload: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    transitionDuration: "{transition.duration}"
                },
                header: {
                    background: "transparent",
                    color: "{text.color}",
                    padding: "1.25rem",
                    borderColor: "unset",
                    borderWidth: "0",
                    borderRadius: "0",
                    gap: "0.5rem"
                },
                content: {
                    highlightBorderColor: "{primary.color}",
                    padding: "0 1.25rem 1.25rem 1.25rem",
                    gap: "1rem"
                },
                file: {
                    padding: "1rem",
                    gap: "1rem",
                    borderColor: "{content.border.color}",
                    info: {
                        gap: "0.5rem"
                    }
                },
                fileList: {
                    gap: "0.5rem"
                },
                progressbar: {
                    height: "0.25rem"
                },
                basic: {
                    gap: "0.5rem"
                },
                css: ""
            },
            iftalabel: {
                root: {
                    color: "{form.field.float.label.color}",
                    focusColor: "{form.field.float.label.focus.color}",
                    invalidColor: "{form.field.float.label.invalid.color}",
                    transitionDuration: "0.2s",
                    positionX: "{form.field.padding.x}",
                    top: "0.5rem",
                    fontSize: "0.75rem",
                    fontWeight: "400"
                },
                input: {
                    paddingTop: "1.5rem",
                    paddingBottom: "0.5rem"
                },
                css: ""
            },
            floatlabel: {
                root: {
                    color: "{form.field.float.label.color}",
                    focusColor: "{form.field.float.label.focus.color}",
                    activeColor: "{form.field.float.label.active.color}",
                    invalidColor: "{form.field.float.label.invalid.color}",
                    transitionDuration: "0.2s",
                    positionX: "{form.field.padding.x}",
                    positionY: "{form.field.padding.y}",
                    fontWeight: "500",
                    active: {
                        fontSize: "0.75rem",
                        fontWeight: "400"
                    }
                },
                over: {
                    active: {
                        top: "-1.25rem"
                    }
                },
                in: {
                    input: {
                        paddingTop: "1.5rem",
                        paddingBottom: "0.5rem"
                    },
                    active: {
                        top: "0.5rem"
                    }
                },
                on: {
                    borderRadius: "{border.radius.xs}",
                    active: {
                        background: "{form.field.background}",
                        padding: "0 0.125rem"
                    }
                },
                css: ""
            },
            galleria: {
                root: {
                    borderWidth: "1px",
                    borderColor: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    transitionDuration: "{transition.duration}"
                },
                navButton: {
                    background: "rgba(255, 255, 255, 0.1)",
                    hoverBackground: "rgba(255, 255, 255, 0.2)",
                    color: "{surface.100}",
                    hoverColor: "{surface.0}",
                    size: "3rem",
                    gutter: "0.5rem",
                    prev: {
                        borderRadius: "50%"
                    },
                    next: {
                        borderRadius: "50%"
                    },
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                navIcon: {
                    size: "1.5rem"
                },
                thumbnailsContent: {
                    background: "{content.background}",
                    padding: "1rem 0.25rem"
                },
                thumbnailNavButton: {
                    size: "2rem",
                    borderRadius: "50%",
                    gutter: "0.5rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                thumbnailNavButtonIcon: {
                    size: "1rem"
                },
                caption: {
                    background: "rgba(0, 0, 0, 0.5)",
                    color: "{surface.100}",
                    padding: "1rem"
                },
                indicatorList: {
                    gap: "0.5rem",
                    padding: "1rem"
                },
                indicatorButton: {
                    width: "1rem",
                    height: "1rem",
                    activeBackground: "{primary.color}",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                insetIndicatorList: {
                    background: "rgba(0, 0, 0, 0.5)"
                },
                insetIndicatorButton: {
                    background: "rgba(255, 255, 255, 0.4)",
                    hoverBackground: "rgba(255, 255, 255, 0.6)",
                    activeBackground: "rgba(255, 255, 255, 0.9)"
                },
                closeButton: {
                    size: "3rem",
                    gutter: "0.5rem",
                    background: "rgba(255, 255, 255, 0.1)",
                    hoverBackground: "rgba(255, 255, 255, 0.2)",
                    color: "{surface.50}",
                    hoverColor: "{surface.0}",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                closeButtonIcon: {
                    size: "1.5rem"
                },
                colorScheme: {
                    light: {
                        thumbnailNavButton: {
                            hoverBackground: "{surface.100}",
                            color: "{surface.600}",
                            hoverColor: "{surface.700}"
                        },
                        indicatorButton: {
                            background: "{surface.200}",
                            hoverBackground: "{surface.300}"
                        }
                    },
                    dark: {
                        thumbnailNavButton: {
                            hoverBackground: "{surface.700}",
                            color: "{surface.400}",
                            hoverColor: "{surface.0}"
                        },
                        indicatorButton: {
                            background: "{surface.700}",
                            hoverBackground: "{surface.600}"
                        }
                    }
                },
                css: ""
            },
            iconfield: {
                icon: {
                    color: "{form.field.icon.color}"
                },
                css: ""
            },
            image: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                preview: {
                    icon: {
                        size: "1.5rem"
                    },
                    mask: {
                        background: "{mask.background}",
                        color: "{mask.color}"
                    }
                },
                toolbar: {
                    position: {
                        left: "auto",
                        right: "1rem",
                        top: "1rem",
                        bottom: "auto"
                    },
                    blur: "8px",
                    background: "rgba(255,255,255,0.1)",
                    borderColor: "rgba(255,255,255,0.2)",
                    borderWidth: "1px",
                    borderRadius: "30px",
                    padding: ".5rem",
                    gap: "0.5rem"
                },
                action: {
                    hoverBackground: "rgba(255,255,255,0.1)",
                    color: "{surface.50}",
                    hoverColor: "{surface.0}",
                    size: "3rem",
                    iconSize: "1.5rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                css: ""
            },
            imagecompare: {
                handle: {
                    size: "20px",
                    hoverSize: "40px",
                    background: "rgba(255,255,255,0.4)",
                    hoverBackground: "rgba(255,255,255,0.6)",
                    borderColor: "unset",
                    hoverBorderColor: "unset",
                    borderWidth: "0",
                    borderRadius: "50%",
                    transitionDuration: "{transition.duration}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "rgba(255,255,255,0.3)",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                css: ""
            },
            inlinemessage: {
                root: {
                    padding: "{form.field.padding.y} {form.field.padding.x}",
                    borderRadius: "{content.border.radius}",
                    gap: "0.5rem"
                },
                text: {
                    fontWeight: "500"
                },
                icon: {
                    size: "1rem"
                },
                colorScheme: {
                    light: {
                        info: {
                            background: "color-mix(in srgb, {blue.50}, transparent 5%)",
                            borderColor: "{blue.200}",
                            color: "{blue.600}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
                        },
                        success: {
                            background: "color-mix(in srgb, {green.50}, transparent 5%)",
                            borderColor: "{green.200}",
                            color: "{green.600}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
                        },
                        warn: {
                            background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
                            borderColor: "{yellow.200}",
                            color: "{yellow.600}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
                        },
                        error: {
                            background: "color-mix(in srgb, {red.50}, transparent 5%)",
                            borderColor: "{red.200}",
                            color: "{red.600}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
                        },
                        secondary: {
                            background: "{surface.100}",
                            borderColor: "{surface.200}",
                            color: "{surface.600}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
                        },
                        contrast: {
                            background: "{surface.900}",
                            borderColor: "{surface.950}",
                            color: "{surface.50}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
                        }
                    },
                    dark: {
                        info: {
                            background: "color-mix(in srgb, {blue.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
                            color: "{blue.500}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {blue.500}, transparent 96%)"
                        },
                        success: {
                            background: "color-mix(in srgb, {green.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
                            color: "{green.500}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {green.500}, transparent 96%)"
                        },
                        warn: {
                            background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
                            color: "{yellow.500}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {yellow.500}, transparent 96%)"
                        },
                        error: {
                            background: "color-mix(in srgb, {red.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
                            color: "{red.500}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {red.500}, transparent 96%)"
                        },
                        secondary: {
                            background: "{surface.800}",
                            borderColor: "{surface.700}",
                            color: "{surface.300}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.500}, transparent 96%)"
                        },
                        contrast: {
                            background: "{surface.0}",
                            borderColor: "{surface.100}",
                            color: "{surface.950}",
                            shadow: "0px 4px 8px 0px color-mix(in srgb, {surface.950}, transparent 96%)"
                        }
                    }
                },
                css: ""
            },
            inplace: {
                root: {
                    padding: "{form.field.padding.y} {form.field.padding.x}",
                    borderRadius: "{content.border.radius}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    },
                    transitionDuration: "{transition.duration}"
                },
                display: {
                    hoverBackground: "{content.hover.background}",
                    hoverColor: "{content.hover.color}"
                },
                css: ""
            },
            inputchips: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}"
                },
                chip: {
                    borderRadius: "{border.radius.sm}"
                },
                colorScheme: {
                    light: {
                        chip: {
                            focusBackground: "{surface.200}",
                            color: "{surface.800}"
                        }
                    },
                    dark: {
                        chip: {
                            focusBackground: "{surface.700}",
                            color: "{surface.0}"
                        }
                    }
                },
                css: ""
            },
            inputgroup: {
                addon: {
                    background: "{form.field.background}",
                    borderColor: "{form.field.border.color}",
                    color: "{form.field.icon.color}",
                    borderRadius: "{form.field.border.radius}",
                    padding: "0.75rem",
                    minWidth: "3rem"
                },
                css: "\n.p-inputgroup:has(.p-variant-filled) .p-inputgroupaddon {\n    border-block-start-color: dt('inputtext.filled.background');\n    border-inline-color: dt('inputtext.filled.background');\n    background: dt('inputtext.filled.background') no-repeat;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n}\n"
            },
            inputnumber: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                button: {
                    width: "3rem",
                    borderRadius: "{form.field.border.radius}",
                    verticalPadding: "{form.field.padding.y}"
                },
                colorScheme: {
                    light: {
                        button: {
                            background: "transparent",
                            hoverBackground: "{surface.100}",
                            activeBackground: "{surface.200}",
                            borderColor: "{form.field.border.color}",
                            hoverBorderColor: "{form.field.border.color}",
                            activeBorderColor: "{form.field.border.color}",
                            color: "{surface.400}",
                            hoverColor: "{surface.500}",
                            activeColor: "{surface.600}"
                        }
                    },
                    dark: {
                        button: {
                            background: "transparent",
                            hoverBackground: "{surface.800}",
                            activeBackground: "{surface.700}",
                            borderColor: "{form.field.border.color}",
                            hoverBorderColor: "{form.field.border.color}",
                            activeBorderColor: "{form.field.border.color}",
                            color: "{surface.400}",
                            hoverColor: "{surface.300}",
                            activeColor: "{surface.200}"
                        }
                    }
                },
                css: "\n.p-inputnumber-stacked .p-inputnumber-button-group {\n    top: 2px;\n    right: 2px;\n    height: calc(100% - 4px);\n}\n\n.p-inputnumber-horizontal:has(.p-variant-filled) .p-inputnumber-button {\n    border-block-start-color: dt('inputtext.filled.background');\n    border-inline-color: dt('inputtext.filled.background');\n    background: dt('inputtext.filled.background') no-repeat;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n.p-inputnumber-vertical:has(.p-variant-filled) .p-inputnumber-button {\n    border-block-color: dt('inputtext.filled.background');\n    border-inline-color: dt('inputtext.filled.background');\n    background: dt('inputtext.filled.background') no-repeat;\n}\n\n.p-inputnumber-vertical:has(.p-variant-filled) .p-inputnumber-increment-button {\n    border-block-end: 1px solid dt('inputtext.border.color')\n}\n"
            },
            inputotp: {
                root: {
                    gap: "0.5rem"
                },
                input: {
                    width: "3rem",
                    sm: {
                        width: "2.5rem"
                    },
                    lg: {
                        width: "3.5rem"
                    }
                },
                css: ""
            },
            inputtext: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                css: "\n.p-inputtext.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('inputtext.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('inputtext.focus.border.color'), dt('inputtext.focus.border.color')), linear-gradient(to bottom, dt('inputtext.border.color'), dt('inputtext.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-inputtext.p-variant-filled:enabled:hover {\n    background: dt('inputtext.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('inputtext.focus.border.color'), dt('inputtext.focus.border.color')), linear-gradient(to bottom, dt('inputtext.hover.border.color'), dt('inputtext.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-inputtext.p-variant-filled:enabled:focus {\n    outline: 0 none;\n    background: dt('inputtext.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('inputtext.focus.border.color'), dt('inputtext.focus.border.color')), linear-gradient(to bottom, dt('inputtext.border.color'), dt('inputtext.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-inputtext.p-variant-filled:enabled:hover:focus {\n    background-image: linear-gradient(to bottom, dt('inputtext.focus.border.color'), dt('inputtext.focus.border.color')), linear-gradient(to bottom, dt('inputtext.hover.border.color'), dt('inputtext.hover.border.color'));\n}\n\n.p-inputtext.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('inputtext.invalid.border.color'), dt('inputtext.invalid.border.color')), linear-gradient(to bottom, dt('inputtext.invalid.border.color'), dt('inputtext.invalid.border.color'));\n}\n\n.p-inputtext.p-variant-filled.p-invalid:enabled:focus {\n    background-image: linear-gradient(to bottom, dt('inputtext.invalid.border.color'), dt('inputtext.invalid.border.color')), linear-gradient(to bottom, dt('inputtext.invalid.border.color'), dt('inputtext.invalid.border.color'));\n}\n\n.p-inputtext.p-variant-filled:disabled {\n    background: dt('inputtext.disabled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('inputtext.border.color'), dt('inputtext.border.color')), linear-gradient(to bottom, dt('inputtext.border.color'), dt('inputtext.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n"
            },
            knob: {
                root: {
                    transitionDuration: "{transition.duration}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                value: {
                    background: "{primary.color}"
                },
                range: {
                    background: "{content.border.color}"
                },
                text: {
                    color: "{text.muted.color}"
                },
                css: ""
            },
            listbox: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    borderColor: "{form.field.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    shadow: "{form.field.shadow}",
                    borderRadius: "{form.field.border.radius}",
                    transitionDuration: "{form.field.transition.duration}"
                },
                list: {
                    padding: "{list.padding}",
                    gap: "{list.gap}",
                    header: {
                        padding: "{list.header.padding}"
                    }
                },
                option: {
                    focusBackground: "{list.option.focus.background}",
                    selectedBackground: "{list.option.selected.background}",
                    selectedFocusBackground: "{list.option.selected.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    selectedColor: "{list.option.selected.color}",
                    selectedFocusColor: "{list.option.selected.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}"
                },
                optionGroup: {
                    background: "{list.option.group.background}",
                    color: "{list.option.group.color}",
                    fontWeight: "{list.option.group.font.weight}",
                    padding: "{list.option.group.padding}"
                },
                checkmark: {
                    color: "{list.option.color}",
                    gutterStart: "-0.375rem",
                    gutterEnd: "0.375rem"
                },
                emptyMessage: {
                    padding: "{list.option.padding}"
                },
                colorScheme: {
                    light: {
                        option: {
                            stripedBackground: "{surface.50}"
                        }
                    },
                    dark: {
                        option: {
                            stripedBackground: "{surface.900}"
                        }
                    }
                },
                css: "\n.p-listbox-option {\n    transition: none;\n}\n"
            },
            megamenu: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    color: "{content.color}",
                    gap: "0.5rem",
                    verticalOrientation: {
                        padding: "{navigation.list.padding}",
                        gap: "{navigation.list.gap}"
                    },
                    horizontalOrientation: {
                        padding: "0.5rem 0.75rem",
                        gap: "0.5rem"
                    },
                    transitionDuration: "{transition.duration}"
                },
                baseItem: {
                    borderRadius: "{content.border.radius}",
                    padding: "{navigation.item.padding}"
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    activeBackground: "{navigation.item.active.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    activeColor: "{navigation.item.active.color}",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{navigation.item.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}",
                        activeColor: "{navigation.item.icon.active.color}"
                    }
                },
                overlay: {
                    padding: "0",
                    background: "{content.background}",
                    borderColor: "transparent",
                    borderRadius: "{content.border.radius}",
                    color: "{content.color}",
                    shadow: "{overlay.navigation.shadow}",
                    gap: "0.5rem"
                },
                submenu: {
                    padding: "{navigation.list.padding}",
                    gap: "{navigation.list.gap}"
                },
                submenuLabel: {
                    padding: "{navigation.submenu.label.padding}",
                    fontWeight: "{navigation.submenu.label.font.weight}",
                    background: "{navigation.submenu.label.background}",
                    color: "{navigation.submenu.label.color}"
                },
                submenuIcon: {
                    size: "{navigation.submenu.icon.size}",
                    color: "{navigation.submenu.icon.color}",
                    focusColor: "{navigation.submenu.icon.focus.color}",
                    activeColor: "{navigation.submenu.icon.active.color}"
                },
                separator: {
                    borderColor: "{content.border.color}"
                },
                mobileButton: {
                    borderRadius: "50%",
                    size: "2.5rem",
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    hoverBackground: "{content.hover.background}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                css: "\n.p-megamenu-button:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            menu: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    shadow: "{overlay.navigation.shadow}",
                    transitionDuration: "{transition.duration}"
                },
                list: {
                    padding: "{navigation.list.padding}",
                    gap: "{navigation.list.gap}"
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{navigation.item.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}"
                    }
                },
                submenuLabel: {
                    padding: "{navigation.submenu.label.padding}",
                    fontWeight: "{navigation.submenu.label.font.weight}",
                    background: "{navigation.submenu.label.background}",
                    color: "{navigation.submenu.label.color}"
                },
                separator: {
                    borderColor: "{content.border.color}"
                },
                css: "\n.p-menu-overlay {\n    border-color: transparent;\n}\n"
            },
            menubar: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    color: "{content.color}",
                    gap: "0.5rem",
                    padding: "0.5rem 0.75rem",
                    transitionDuration: "{transition.duration}"
                },
                baseItem: {
                    borderRadius: "{content.border.radius}",
                    padding: "{navigation.item.padding}"
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    activeBackground: "{navigation.item.active.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    activeColor: "{navigation.item.active.color}",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{navigation.item.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}",
                        activeColor: "{navigation.item.icon.active.color}"
                    }
                },
                submenu: {
                    padding: "{navigation.list.padding}",
                    gap: "{navigation.list.gap}",
                    background: "{content.background}",
                    borderColor: "transparent",
                    borderRadius: "{content.border.radius}",
                    shadow: "{overlay.navigation.shadow}",
                    mobileIndent: "1rem",
                    icon: {
                        size: "{navigation.submenu.icon.size}",
                        color: "{navigation.submenu.icon.color}",
                        focusColor: "{navigation.submenu.icon.focus.color}",
                        activeColor: "{navigation.submenu.icon.active.color}"
                    }
                },
                separator: {
                    borderColor: "{content.border.color}"
                },
                mobileButton: {
                    borderRadius: "50%",
                    size: "2.5rem",
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    hoverBackground: "{content.hover.background}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                css: "\n.p-menubar-button:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            message: {
                root: {
                    borderRadius: "{content.border.radius}",
                    borderWidth: "0",
                    transitionDuration: "{transition.duration}"
                },
                content: {
                    padding: "1rem 1.25rem",
                    gap: "0.5rem",
                    sm: {
                        padding: "0.625rem 0.625rem"
                    },
                    lg: {
                        padding: "0.825rem 0.825rem"
                    }
                },
                text: {
                    fontSize: "1rem",
                    fontWeight: "500",
                    sm: {
                        fontSize: "0.875rem"
                    },
                    lg: {
                        fontSize: "1.125rem"
                    }
                },
                icon: {
                    size: "1.25rem",
                    sm: {
                        size: "1rem"
                    },
                    lg: {
                        size: "1.5rem"
                    }
                },
                closeButton: {
                    width: "2rem",
                    height: "2rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        offset: "{focus.ring.offset}"
                    }
                },
                closeIcon: {
                    size: "1rem",
                    sm: {
                        size: "0.875rem"
                    },
                    lg: {
                        size: "1.125rem"
                    }
                },
                outlined: {
                    root: {
                        borderWidth: "1px"
                    }
                },
                simple: {
                    content: {
                        padding: "0"
                    }
                },
                colorScheme: {
                    light: {
                        info: {
                            background: "color-mix(in srgb, {blue.50}, transparent 5%)",
                            borderColor: "{blue.200}",
                            color: "{blue.600}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{blue.100}",
                                focusRing: {
                                    color: "{blue.600}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{blue.600}",
                                borderColor: "{blue.600}"
                            },
                            simple: {
                                color: "{blue.600}"
                            }
                        },
                        success: {
                            background: "color-mix(in srgb, {green.50}, transparent 5%)",
                            borderColor: "{green.200}",
                            color: "{green.600}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{green.100}",
                                focusRing: {
                                    color: "{green.600}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{green.600}",
                                borderColor: "{green.600}"
                            },
                            simple: {
                                color: "{green.600}"
                            }
                        },
                        warn: {
                            background: "color-mix(in srgb,{yellow.50}, transparent 5%)",
                            borderColor: "{yellow.200}",
                            color: "{yellow.900}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{yellow.100}",
                                focusRing: {
                                    color: "{yellow.600}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{yellow.900}",
                                borderColor: "{yellow.900}"
                            },
                            simple: {
                                color: "{yellow.900}"
                            }
                        },
                        error: {
                            background: "color-mix(in srgb, {red.50}, transparent 5%)",
                            borderColor: "{red.200}",
                            color: "{red.600}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{red.100}",
                                focusRing: {
                                    color: "{red.600}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{red.600}",
                                borderColor: "{red.600}"
                            },
                            simple: {
                                color: "{red.600}"
                            }
                        },
                        secondary: {
                            background: "{surface.100}",
                            borderColor: "{surface.200}",
                            color: "{surface.600}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{surface.200}",
                                focusRing: {
                                    color: "{surface.600}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{surface.600}",
                                borderColor: "{surface.600}"
                            },
                            simple: {
                                color: "{surface.600}"
                            }
                        },
                        contrast: {
                            background: "{surface.900}",
                            borderColor: "{surface.950}",
                            color: "{surface.50}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{surface.800}",
                                focusRing: {
                                    color: "{surface.50}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{surface.950}",
                                borderColor: "{surface.950}"
                            },
                            simple: {
                                color: "{surface.950}"
                            }
                        }
                    },
                    dark: {
                        info: {
                            background: "color-mix(in srgb, {blue.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
                            color: "{blue.500}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{blue.500}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{blue.500}",
                                borderColor: "{blue.500}"
                            },
                            simple: {
                                color: "{blue.500}"
                            }
                        },
                        success: {
                            background: "color-mix(in srgb, {green.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
                            color: "{green.500}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{green.500}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{green.500}",
                                borderColor: "{green.500}"
                            },
                            simple: {
                                color: "{green.500}"
                            }
                        },
                        warn: {
                            background: "color-mix(in srgb, {yellow.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
                            color: "{yellow.500}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{yellow.500}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{yellow.500}",
                                borderColor: "{yellow.500}"
                            },
                            simple: {
                                color: "{yellow.500}"
                            }
                        },
                        error: {
                            background: "color-mix(in srgb, {red.500}, transparent 84%)",
                            borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
                            color: "{red.500}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{red.500}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{red.500}",
                                borderColor: "{red.500}"
                            },
                            simple: {
                                color: "{red.500}"
                            }
                        },
                        secondary: {
                            background: "{surface.800}",
                            borderColor: "{surface.700}",
                            color: "{surface.300}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{surface.700}",
                                focusRing: {
                                    color: "{surface.300}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{surface.400}",
                                borderColor: "{surface.400}"
                            },
                            simple: {
                                color: "{surface.400}"
                            }
                        },
                        contrast: {
                            background: "{surface.0}",
                            borderColor: "{surface.100}",
                            color: "{surface.950}",
                            shadow: "none",
                            closeButton: {
                                hoverBackground: "{surface.100}",
                                focusRing: {
                                    color: "{surface.950}",
                                    shadow: "none"
                                }
                            },
                            outlined: {
                                color: "{surface.0}",
                                borderColor: "{surface.0}"
                            },
                            simple: {
                                color: "{surface.0}"
                            }
                        }
                    }
                },
                css: ""
            },
            metergroup: {
                root: {
                    borderRadius: "{content.border.radius}",
                    gap: "1rem"
                },
                meters: {
                    background: "{content.border.color}",
                    size: "0.5rem"
                },
                label: {
                    gap: "0.5rem"
                },
                labelMarker: {
                    size: "0.5rem"
                },
                labelIcon: {
                    size: "1rem"
                },
                labelList: {
                    verticalGap: "0.5rem",
                    horizontalGap: "1rem"
                },
                css: ""
            },
            multiselect: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                dropdown: {
                    width: "2.5rem",
                    color: "{form.field.icon.color}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}"
                },
                list: {
                    padding: "{list.padding}",
                    gap: "{list.gap}",
                    header: {
                        padding: "{list.header.padding}"
                    }
                },
                option: {
                    focusBackground: "{list.option.focus.background}",
                    selectedBackground: "{list.option.selected.background}",
                    selectedFocusBackground: "{list.option.selected.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    selectedColor: "{list.option.selected.color}",
                    selectedFocusColor: "{list.option.selected.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}",
                    gap: "0.75rem"
                },
                optionGroup: {
                    background: "{list.option.group.background}",
                    color: "{list.option.group.color}",
                    fontWeight: "{list.option.group.font.weight}",
                    padding: "{list.option.group.padding}"
                },
                chip: {
                    borderRadius: "{border.radius.sm}"
                },
                clearIcon: {
                    color: "{form.field.icon.color}"
                },
                emptyMessage: {
                    padding: "{list.option.padding}"
                },
                css: "\n.p-multiselect.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('multiselect.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('multiselect.focus.border.color'), dt('multiselect.focus.border.color')), linear-gradient(to bottom, dt('multiselect.border.color'), dt('multiselect.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-multiselect.p-variant-filled:not(.p-disabled):hover {\n    background: dt('multiselect.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('multiselect.focus.border.color'), dt('multiselect.focus.border.color')), linear-gradient(to bottom, dt('multiselect.hover.border.color'), dt('multiselect.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-multiselect.p-variant-filled:not(.p-disabled).p-focus {\n    outline: 0 none;\n    background: dt('multiselect.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('multiselect.focus.border.color'), dt('multiselect.focus.border.color')), linear-gradient(to bottom, dt('multiselect.border.color'), dt('multiselect.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-multiselect.p-variant-filled:not(.p-disabled).p-focus:hover {\n    background-image: linear-gradient(to bottom, dt('multiselect.focus.border.color'), dt('multiselect.focus.border.color')), linear-gradient(to bottom, dt('multiselect.hover.border.color'), dt('multiselect.hover.border.color'));\n}\n\n.p-multiselect.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('multiselect.invalid.border.color'), dt('multiselect.invalid.border.color')), linear-gradient(to bottom, dt('multiselect.invalid.border.color'), dt('multiselect.invalid.border.color'));\n}\n\n.p-multiselect.p-variant-filled.p-invalid:not(.p-disabled).p-focus  {\n    background-image: linear-gradient(to bottom, dt('multiselect.invalid.border.color'), dt('multiselect.invalid.border.color')), linear-gradient(to bottom, dt('multiselect.invalid.border.color'), dt('multiselect.invalid.border.color'));\n}\n\n.p-multiselect-option {\n    transition: none;\n}\n"
            },
            orderlist: {
                root: {
                    gap: "1.125rem"
                },
                controls: {
                    gap: "0.5rem"
                },
                css: ""
            },
            organizationchart: {
                root: {
                    gutter: "0.75rem",
                    transitionDuration: "{transition.duration}"
                },
                node: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    selectedColor: "{highlight.color}",
                    hoverColor: "{content.hover.color}",
                    padding: "1rem 1.25rem",
                    toggleablePadding: "1rem 1.25rem 1.5rem 1.25rem",
                    borderRadius: "{content.border.radius}"
                },
                nodeToggleButton: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    borderColor: "{content.border.color}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    size: "1.75rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                connector: {
                    color: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    height: "24px"
                },
                css: ""
            },
            overlaybadge: {
                root: {
                    outline: {
                        width: "2px",
                        color: "{content.background}"
                    }
                },
                css: ""
            },
            popover: {
                root: {
                    background: "{overlay.popover.background}",
                    borderColor: "{overlay.popover.border.color}",
                    color: "{overlay.popover.color}",
                    borderRadius: "{overlay.popover.border.radius}",
                    shadow: "{overlay.popover.shadow}",
                    gutter: "10px",
                    arrowOffset: "1.25rem"
                },
                content: {
                    padding: "{overlay.popover.padding}"
                },
                css: ""
            },
            paginator: {
                root: {
                    padding: "0.5rem 1rem",
                    gap: "0.25rem",
                    borderRadius: "{content.border.radius}",
                    background: "{content.background}",
                    color: "{content.color}",
                    transitionDuration: "{transition.duration}"
                },
                navButton: {
                    background: "transparent",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    selectedColor: "{highlight.color}",
                    width: "2.5rem",
                    height: "2.5rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                currentPageReport: {
                    color: "{text.muted.color}"
                },
                jumpToPageInput: {
                    maxWidth: "2.5rem"
                },
                css: ""
            },
            password: {
                meter: {
                    background: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    height: ".75rem"
                },
                icon: {
                    color: "{form.field.icon.color}"
                },
                overlay: {
                    background: "{overlay.popover.background}",
                    borderColor: "{overlay.popover.border.color}",
                    borderRadius: "{overlay.popover.border.radius}",
                    color: "{overlay.popover.color}",
                    padding: "{overlay.popover.padding}",
                    shadow: "{overlay.popover.shadow}"
                },
                content: {
                    gap: "0.5rem"
                },
                colorScheme: {
                    light: {
                        strength: {
                            weakBackground: "{red.500}",
                            mediumBackground: "{amber.500}",
                            strongBackground: "{green.500}"
                        }
                    },
                    dark: {
                        strength: {
                            weakBackground: "{red.400}",
                            mediumBackground: "{amber.400}",
                            strongBackground: "{green.400}"
                        }
                    }
                },
                css: ""
            },
            panel: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}"
                },
                header: {
                    background: "transparent",
                    color: "{text.color}",
                    padding: "1.25rem",
                    borderColor: "{content.border.color}",
                    borderWidth: "0",
                    borderRadius: "0"
                },
                toggleableHeader: {
                    padding: "0.5rem 1.25rem"
                },
                title: {
                    fontWeight: "600"
                },
                content: {
                    padding: "0 1.25rem 1.25rem 1.25rem"
                },
                footer: {
                    padding: "0 1.25rem 1.25rem 1.25rem"
                },
                css: ""
            },
            panelmenu: {
                root: {
                    gap: "0",
                    transitionDuration: "{transition.duration}"
                },
                panel: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    borderWidth: "0",
                    color: "{content.color}",
                    padding: "0",
                    borderRadius: "0",
                    first: {
                        borderWidth: "0",
                        topBorderRadius: "{content.border.radius}"
                    },
                    last: {
                        borderWidth: "0",
                        bottomBorderRadius: "{content.border.radius}"
                    }
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    gap: "0.5rem",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{content.border.radius}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}"
                    }
                },
                submenu: {
                    indent: "1rem"
                },
                submenuIcon: {
                    color: "{navigation.submenu.icon.color}",
                    focusColor: "{navigation.submenu.icon.focus.color}"
                },
                css: "\n.p-panelmenu-panel {\n    box-shadow: 0 0 0 1px dt('panelmenu.panel.border.color');\n    transition: margin dt('panelmenu.transition.duration');\n}\n\n.p-panelmenu-panel:has(.p-panelmenu-header-active) {\n    margin: 1rem 0;\n}\n\n.p-panelmenu-panel:first-child {\n    border-top-left-radius: dt('content.border.radius');\n    border-top-right-radius: dt('content.border.radius');\n    margin-top: 0;\n}\n\n.p-panelmenu-panel:last-child {\n    border-bottom-left-radius: dt('content.border.radius');\n    border-bottom-right-radius: dt('content.border.radius');\n    margin-bottom: 0;\n}\n\n.p-accordionpanel:not(.p-disabled) .p-accordionheader:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            picklist: {
                root: {
                    gap: "1.125rem"
                },
                controls: {
                    gap: "0.5rem"
                },
                css: ""
            },
            progressbar: {
                root: {
                    background: "{content.border.color}",
                    borderRadius: "{content.border.radius}",
                    height: "1rem"
                },
                value: {
                    background: "{primary.color}"
                },
                label: {
                    color: "{primary.contrast.color}",
                    fontSize: "0.75rem",
                    fontWeight: "600"
                },
                css: ""
            },
            progressspinner: {
                colorScheme: {
                    light: {
                        root: {
                            colorOne: "{red.500}",
                            colorTwo: "{blue.500}",
                            colorThree: "{green.500}",
                            colorFour: "{yellow.500}"
                        }
                    },
                    dark: {
                        root: {
                            colorOne: "{red.400}",
                            colorTwo: "{blue.400}",
                            colorThree: "{green.400}",
                            colorFour: "{yellow.400}"
                        }
                    }
                },
                css: ""
            },
            radiobutton: {
                root: {
                    width: "20px",
                    height: "20px",
                    background: "{form.field.background}",
                    checkedBackground: "{primary.contrast.color}",
                    checkedHoverBackground: "{primary.contrast.color}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    checkedBorderColor: "{primary.color}",
                    checkedHoverBorderColor: "{primary.color}",
                    checkedFocusBorderColor: "{primary.color}",
                    checkedDisabledBorderColor: "{form.field.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    shadow: "{form.field.shadow}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        width: "16px",
                        height: "16px"
                    },
                    lg: {
                        width: "24px",
                        height: "24px"
                    }
                },
                icon: {
                    size: "10px",
                    checkedColor: "{primary.color}",
                    checkedHoverColor: "{primary.color}",
                    disabledColor: "{form.field.disabled.color}",
                    sm: {
                        size: "8px"
                    },
                    lg: {
                        size: "12px"
                    }
                }
            },
            rating: {
                root: {
                    gap: "0.5rem",
                    transitionDuration: "{transition.duration}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                icon: {
                    size: "1.125rem",
                    color: "{text.muted.color}",
                    hoverColor: "{primary.color}",
                    activeColor: "{primary.color}"
                },
                css: "\n.p-rating:not(.p-disabled):not(.p-readonly) .p-rating-option:hover {\n    background: color-mix(in srgb, dt('rating.icon.color'), transparent 96%);\n    box-shadow: 0 0 1px 8px color-mix(in srgb, dt('rating.icon.color'), transparent 96%);\n}\n\n.p-rating:not(.p-disabled):not(.p-readonly) .p-rating-option-active:hover {\n    background: color-mix(in srgb, dt('rating.icon.active.color'), transparent 92%);\n    box-shadow: 0 0 1px 8px color-mix(in srgb, dt('rating.icon.active.color'), transparent 92%);\n}\n\n.p-rating-option.p-focus-visible {\n    background: color-mix(in srgb, dt('rating.icon.active.color'), transparent 84%);\n    box-shadow: 0 0 1px 8px color-mix(in srgb, dt('rating.icon.active.color'), transparent 84%);\n}\n"
            },
            ripple: {
                colorScheme: {
                    light: {
                        root: {
                            background: "rgba(0,0,0,0.1)"
                        }
                    },
                    dark: {
                        root: {
                            background: "rgba(255,255,255,0.3)"
                        }
                    }
                },
                css: ""
            },
            scrollpanel: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                bar: {
                    size: "9px",
                    borderRadius: "{border.radius.sm}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                colorScheme: {
                    light: {
                        bar: {
                            background: "{surface.200}"
                        }
                    },
                    dark: {
                        bar: {
                            background: "{surface.700}"
                        }
                    }
                },
                css: ""
            },
            select: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                dropdown: {
                    width: "2.5rem",
                    color: "{form.field.icon.color}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}"
                },
                list: {
                    padding: "{list.padding}",
                    gap: "{list.gap}",
                    header: {
                        padding: "{list.header.padding}"
                    }
                },
                option: {
                    focusBackground: "{list.option.focus.background}",
                    selectedBackground: "{list.option.selected.background}",
                    selectedFocusBackground: "{list.option.selected.focus.background}",
                    color: "{list.option.color}",
                    focusColor: "{list.option.focus.color}",
                    selectedColor: "{list.option.selected.color}",
                    selectedFocusColor: "{list.option.selected.focus.color}",
                    padding: "{list.option.padding}",
                    borderRadius: "{list.option.border.radius}"
                },
                optionGroup: {
                    background: "{list.option.group.background}",
                    color: "{list.option.group.color}",
                    fontWeight: "{list.option.group.font.weight}",
                    padding: "{list.option.group.padding}"
                },
                clearIcon: {
                    color: "{form.field.icon.color}"
                },
                checkmark: {
                    color: "{list.option.color}",
                    gutterStart: "-0.375rem",
                    gutterEnd: "0.375rem"
                },
                emptyMessage: {
                    padding: "{list.option.padding}"
                },
                css: "\n.p-select.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('select.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('select.focus.border.color'), dt('select.focus.border.color')), linear-gradient(to bottom, dt('select.border.color'), dt('select.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-select.p-variant-filled:not(.p-disabled):hover {\n    background: dt('select.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('select.focus.border.color'), dt('select.focus.border.color')), linear-gradient(to bottom, dt('select.hover.border.color'), dt('select.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-select.p-variant-filled:not(.p-disabled).p-focus {\n    outline: 0 none;\n    background: dt('select.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('select.focus.border.color'), dt('select.focus.border.color')), linear-gradient(to bottom, dt('select.border.color'), dt('select.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-select.p-variant-filled:not(.p-disabled).p-focus:hover {\n    background-image: linear-gradient(to bottom, dt('select.focus.border.color'), dt('select.focus.border.color')), linear-gradient(to bottom, dt('select.hover.border.color'), dt('select.hover.border.color'));\n}\n\n.p-select.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('select.invalid.border.color'), dt('select.invalid.border.color')), linear-gradient(to bottom, dt('select.invalid.border.color'), dt('select.invalid.border.color'));\n}\n\n.p-select.p-variant-filled.p-invalid:not(.p-disabled).p-focus  {\n    background-image: linear-gradient(to bottom, dt('select.invalid.border.color'), dt('select.invalid.border.color')), linear-gradient(to bottom, dt('select.invalid.border.color'), dt('select.invalid.border.color'));\n}\n\n.p-select-option {\n    transition: none;\n}\n"
            },
            selectbutton: {
                root: {
                    borderRadius: "{form.field.border.radius}"
                },
                colorScheme: {
                    light: {
                        root: {
                            invalidBorderColor: "{form.field.invalid.border.color}"
                        }
                    },
                    dark: {
                        root: {
                            invalidBorderColor: "{form.field.invalid.border.color}"
                        }
                    }
                },
                css: ""
            },
            skeleton: {
                root: {
                    borderRadius: "{content.border.radius}"
                },
                colorScheme: {
                    light: {
                        root: {
                            background: "{surface.200}",
                            animationBackground: "rgba(255,255,255,0.4)"
                        }
                    },
                    dark: {
                        root: {
                            background: "rgba(255, 255, 255, 0.06)",
                            animationBackground: "rgba(255, 255, 255, 0.04)"
                        }
                    }
                },
                css: ""
            },
            slider: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                track: {
                    background: "{content.border.color}",
                    borderRadius: "{border.radius.xs}",
                    size: "2px"
                },
                range: {
                    background: "{primary.color}"
                },
                handle: {
                    width: "18px",
                    height: "18px",
                    borderRadius: "50%",
                    background: "{primary.color}",
                    hoverBackground: "{primary.color}",
                    content: {
                        borderRadius: "50%",
                        background: "{primary.color}",
                        hoverBackground: "{primary.color}",
                        width: "18px",
                        height: "18px",
                        shadow: "0px 2px 1px -1px rgba(0, 0, 0, .2), 0px 1px 1px 0px rgba(0, 0, 0, .14), 0px 1px 3px 0px rgba(0, 0, 0, .12)"
                    },
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                css: "\n.p-slider-handle {\n    transition: box-shadow dt('slider.transition.duration');\n}\n\n.p-slider:not(.p-disabled) .p-slider-handle:hover {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('slider.handle.background'), transparent 92%);\n}\n\n.p-slider-handle:focus-visible,\n.p-slider:not(.p-disabled) .p-slider-handle:focus:hover {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('slider.handle.background'), transparent 84%);\n}\n"
            },
            speeddial: {
                root: {
                    gap: "0.5rem",
                    transitionDuration: "{transition.duration}"
                },
                css: ""
            },
            splitter: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    transitionDuration: "{transition.duration}"
                },
                gutter: {
                    background: "{content.border.color}"
                },
                handle: {
                    size: "24px",
                    background: "transparent",
                    borderRadius: "{content.border.radius}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                css: ""
            },
            splitbutton: {
                root: {
                    borderRadius: "{form.field.border.radius}",
                    roundedBorderRadius: "2rem",
                    raisedShadow: "0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)"
                },
                css: ""
            },
            stepper: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                separator: {
                    background: "{content.border.color}",
                    activeBackground: "{primary.color}",
                    margin: "0 0 0 1.625rem",
                    size: "2px"
                },
                step: {
                    padding: "0.5rem",
                    gap: "1rem"
                },
                stepHeader: {
                    padding: "0.75rem 1rem",
                    borderRadius: "{content.border.radius}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    },
                    gap: "0.5rem"
                },
                stepTitle: {
                    color: "{text.muted.color}",
                    activeColor: "{text.color}",
                    fontWeight: "500"
                },
                stepNumber: {
                    activeBackground: "{primary.color}",
                    activeBorderColor: "{primary.color}",
                    activeColor: "{primary.contrast.color}",
                    size: "2rem",
                    fontSize: "1.143rem",
                    fontWeight: "500",
                    borderRadius: "50%",
                    shadow: "none"
                },
                steppanels: {
                    padding: "0.875rem 0.5rem 1.125rem 0.5rem"
                },
                steppanel: {
                    background: "{content.background}",
                    color: "{content.color}",
                    padding: "0",
                    indent: "1rem"
                },
                colorScheme: {
                    light: {
                        stepNumber: {
                            background: "{surface.400}",
                            borderColor: "{surface.400}",
                            color: "{surface.0}"
                        }
                    },
                    dark: {
                        stepNumber: {
                            background: "{surface.200}",
                            borderColor: "{surface.200}",
                            color: "{surface.900}"
                        }
                    }
                },
                css: "\n.p-step-header:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            steps: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                separator: {
                    background: "{content.border.color}"
                },
                itemLink: {
                    borderRadius: "{content.border.radius}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    },
                    gap: "0.5rem"
                },
                itemLabel: {
                    color: "{text.muted.color}",
                    activeColor: "{primary.color}",
                    fontWeight: "500"
                },
                itemNumber: {
                    background: "{content.background}",
                    activeBackground: "{content.background}",
                    borderColor: "{content.border.color}",
                    activeBorderColor: "{content.border.color}",
                    color: "{text.muted.color}",
                    activeColor: "{primary.color}",
                    size: "2rem",
                    fontSize: "1.143rem",
                    fontWeight: "500",
                    borderRadius: "50%",
                    shadow: "0px 0.5px 0px 0px rgba(0, 0, 0, 0.06), 0px 1px 1px 0px rgba(0, 0, 0, 0.12)"
                },
                css: ""
            },
            tabmenu: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                tablist: {
                    borderWidth: "0 0 1px 0",
                    background: "{content.background}",
                    borderColor: "{content.border.color}"
                },
                item: {
                    background: "transparent",
                    hoverBackground: "transparent",
                    activeBackground: "transparent",
                    borderWidth: "0 0 1px 0",
                    borderColor: "{content.border.color}",
                    hoverBorderColor: "{content.border.color}",
                    activeBorderColor: "{primary.color}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{primary.color}",
                    padding: "1rem 1.125rem",
                    fontWeight: "600",
                    margin: "0 0 -1px 0",
                    gap: "0.5rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                itemIcon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{primary.color}"
                },
                activeBar: {
                    height: "1px",
                    bottom: "-1px",
                    background: "{primary.color}"
                },
                css: ""
            },
            tabs: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                tablist: {
                    borderWidth: "0 0 1px 0",
                    background: "{content.background}",
                    borderColor: "{content.border.color}"
                },
                tab: {
                    background: "transparent",
                    hoverBackground: "{content.hover.background}",
                    activeBackground: "transparent",
                    borderWidth: "0 0 1px 0",
                    borderColor: "{content.border.color}",
                    hoverBorderColor: "{content.border.color}",
                    activeBorderColor: "{primary.color}",
                    color: "{text.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{primary.color}",
                    padding: "1rem 1.25rem",
                    fontWeight: "600",
                    margin: "0 0 -1px 0",
                    gap: "0.5rem",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                tabpanel: {
                    background: "{content.background}",
                    color: "{content.color}",
                    padding: "1.25rem 1.25rem 1.25rem 1.25rem",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                navButton: {
                    background: "{content.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    width: "3rem",
                    shadow: "none",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    }
                },
                activeBar: {
                    height: "2px",
                    bottom: "-1px",
                    background: "{primary.color}"
                },
                css: "\n.p-tabs-scrollable .p-tab {\n    flex-grow: 0\n}\n\n.p-tab-active {\n    --p-ripple-background: color-mix(in srgb, dt('primary.color'), transparent 90%);\n}\n\n.p-tab:not(.p-disabled):focus-visible {\n    background: dt('navigation.item.active.background');\n}\n\n.p-tablist-nav-button:focus-visible {\n    background: dt('navigation.item.active.background');\n}\n"
            },
            tabview: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                tabList: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}"
                },
                tab: {
                    borderColor: "{content.border.color}",
                    activeBorderColor: "{primary.color}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    activeColor: "{primary.color}"
                },
                tabPanel: {
                    background: "{content.background}",
                    color: "{content.color}"
                },
                navButton: {
                    background: "{content.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}"
                },
                colorScheme: {
                    light: {
                        navButton: {
                            shadow: "0px 0px 10px 50px rgba(255, 255, 255, 0.6)"
                        }
                    },
                    dark: {
                        navButton: {
                            shadow: "0px 0px 10px 50px color-mix(in srgb, {content.background}, transparent 50%)"
                        }
                    }
                },
                css: ""
            },
            textarea: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                css: "\n.p-textarea.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('textarea.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('textarea.focus.border.color'), dt('textarea.focus.border.color')), linear-gradient(to bottom, dt('textarea.border.color'), dt('textarea.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-textarea.p-variant-filled:enabled:hover {\n    background: dt('textarea.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('textarea.focus.border.color'), dt('textarea.focus.border.color')), linear-gradient(to bottom, dt('textarea.hover.border.color'), dt('textarea.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-textarea.p-variant-filled:enabled:focus {\n    outline: 0 none;\n    background: dt('textarea.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('textarea.focus.border.color'), dt('textarea.focus.border.color')), linear-gradient(to bottom, dt('textarea.border.color'), dt('textarea.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-textarea.p-variant-filled:enabled:hover:focus {\n    background-image: linear-gradient(to bottom, dt('textarea.focus.border.color'), dt('textarea.focus.border.color')), linear-gradient(to bottom, dt('textarea.hover.border.color'), dt('textarea.hover.border.color'));\n}\n\n.p-textarea.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('textarea.invalid.border.color'), dt('textarea.invalid.border.color')), linear-gradient(to bottom, dt('textarea.invalid.border.color'), dt('textarea.invalid.border.color'));\n}\n\n.p-textarea.p-variant-filled.p-invalid:enabled:focus {\n    background-image: linear-gradient(to bottom, dt('textarea.invalid.border.color'), dt('textarea.invalid.border.color')), linear-gradient(to bottom, dt('textarea.invalid.border.color'), dt('textarea.invalid.border.color'));\n}\n"
            },
            tieredmenu: {
                root: {
                    background: "{content.background}",
                    borderColor: "{content.border.color}",
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    shadow: "{overlay.navigation.shadow}",
                    transitionDuration: "{transition.duration}"
                },
                list: {
                    padding: "{navigation.list.padding}",
                    gap: "{navigation.list.gap}"
                },
                item: {
                    focusBackground: "{navigation.item.focus.background}",
                    activeBackground: "{navigation.item.active.background}",
                    color: "{navigation.item.color}",
                    focusColor: "{navigation.item.focus.color}",
                    activeColor: "{navigation.item.active.color}",
                    padding: "{navigation.item.padding}",
                    borderRadius: "{navigation.item.border.radius}",
                    gap: "{navigation.item.gap}",
                    icon: {
                        color: "{navigation.item.icon.color}",
                        focusColor: "{navigation.item.icon.focus.color}",
                        activeColor: "{navigation.item.icon.active.color}"
                    }
                },
                submenu: {
                    mobileIndent: "1rem"
                },
                submenuIcon: {
                    size: "{navigation.submenu.icon.size}",
                    color: "{navigation.submenu.icon.color}",
                    focusColor: "{navigation.submenu.icon.focus.color}",
                    activeColor: "{navigation.submenu.icon.active.color}"
                },
                separator: {
                    borderColor: "{content.border.color}"
                },
                css: "\n.p-tieredmenu-overlay {\n    border-color: transparent;\n}\n"
            },
            tag: {
                root: {
                    fontSize: "0.875rem",
                    fontWeight: "700",
                    padding: "0.25rem 0.5rem",
                    gap: "0.25rem",
                    borderRadius: "{content.border.radius}",
                    roundedBorderRadius: "{border.radius.xl}"
                },
                icon: {
                    size: "0.75rem"
                },
                colorScheme: {
                    light: {
                        primary: {
                            background: "{primary.color}",
                            color: "{primary.contrast.color}"
                        },
                        secondary: {
                            background: "{surface.100}",
                            color: "{surface.600}"
                        },
                        success: {
                            background: "{green.500}",
                            color: "{surface.0}"
                        },
                        info: {
                            background: "{sky.500}",
                            color: "{surface.0}"
                        },
                        warn: {
                            background: "{orange.500}",
                            color: "{surface.0}"
                        },
                        danger: {
                            background: "{red.500}",
                            color: "{surface.0}"
                        },
                        contrast: {
                            background: "{surface.950}",
                            color: "{surface.0}"
                        }
                    },
                    dark: {
                        primary: {
                            background: "{primary.color}",
                            color: "{primary.contrast.color}"
                        },
                        secondary: {
                            background: "{surface.800}",
                            color: "{surface.300}"
                        },
                        success: {
                            background: "{green.400}",
                            color: "{green.950}"
                        },
                        info: {
                            background: "{sky.400}",
                            color: "{sky.950}"
                        },
                        warn: {
                            background: "{orange.400}",
                            color: "{orange.950}"
                        },
                        danger: {
                            background: "{red.400}",
                            color: "{red.950}"
                        },
                        contrast: {
                            background: "{surface.0}",
                            color: "{surface.950}"
                        }
                    }
                },
                css: ""
            },
            terminal: {
                root: {
                    background: "{form.field.background}",
                    borderColor: "{form.field.border.color}",
                    color: "{form.field.color}",
                    height: "18rem",
                    padding: "{form.field.padding.y} {form.field.padding.x}",
                    borderRadius: "{form.field.border.radius}"
                },
                prompt: {
                    gap: "0.25rem"
                },
                commandResponse: {
                    margin: "2px 0"
                },
                css: ""
            },
            timeline: {
                event: {
                    minHeight: "5rem"
                },
                horizontal: {
                    eventContent: {
                        padding: "1rem 0"
                    }
                },
                vertical: {
                    eventContent: {
                        padding: "0 1rem"
                    }
                },
                eventMarker: {
                    size: "1.5rem",
                    borderRadius: "50%",
                    borderWidth: "2px",
                    background: "{primary.color}",
                    content: {
                        borderRadius: "50%",
                        size: "0",
                        background: "{primary.color}",
                        insetShadow: "none"
                    }
                },
                eventConnector: {
                    color: "{content.border.color}",
                    size: "2px"
                },
                colorScheme: {
                    light: {
                        eventMarker: {
                            borderColor: "{surface.0}"
                        }
                    },
                    dark: {
                        eventMarker: {
                            borderColor: "{surface.900}"
                        }
                    }
                },
                css: ""
            },
            togglebutton: {
                root: {
                    padding: "0.75rem 1rem",
                    borderRadius: "{form.field.border.radius}",
                    gap: "0.5rem",
                    fontWeight: "500",
                    background: "{form.field.background}",
                    borderColor: "{form.field.border.color}",
                    color: "{form.field.color}",
                    hoverColor: "{form.field.color}",
                    checkedColor: "{form.field.color}",
                    checkedBorderColor: "{form.field.border.color}",
                    disabledBackground: "{form.field.disabled.background}",
                    disabledBorderColor: "{form.field.disabled.background}",
                    disabledColor: "{form.field.disabled.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    focusRing: {
                        width: "0",
                        style: "none",
                        offset: "0",
                        color: "unset",
                        shadow: "none"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        padding: "0.625rem 0.75rem"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        padding: "0.875rem 1.25rem"
                    }
                },
                icon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.muted.color}",
                    checkedColor: "{text.muted.color}",
                    disabledColor: "{form.field.disabled.color}"
                },
                content: {
                    checkedBackground: "transparent",
                    checkedShadow: "none",
                    padding: "0",
                    borderRadius: "0",
                    sm: {
                        padding: "0"
                    },
                    lg: {
                        padding: "0"
                    }
                },
                colorScheme: {
                    light: {
                        root: {
                            hoverBackground: "{surface.100}",
                            checkedBackground: "{surface.200}"
                        }
                    },
                    dark: {
                        root: {
                            hoverBackground: "{surface.800}",
                            checkedBackground: "{surface.700}"
                        }
                    }
                },
                css: "\n.p-togglebutton:focus-visible {\n    background: dt('togglebutton.hover.background');\n}\n"
            },
            toggleswitch: {
                root: {
                    width: "2.75rem",
                    height: "1rem",
                    borderRadius: "30px",
                    gap: "0px",
                    shadow: "none",
                    focusRing: {
                        width: "0",
                        style: "none",
                        color: "unset",
                        offset: "0",
                        shadow: "none"
                    },
                    borderWidth: "1px",
                    borderColor: "transparent",
                    hoverBorderColor: "transparent",
                    checkedBorderColor: "transparent",
                    checkedHoverBorderColor: "transparent",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    transitionDuration: "{form.field.transition.duration}",
                    slideDuration: "0.2s"
                },
                handle: {
                    borderRadius: "50%",
                    size: "1.5rem"
                },
                colorScheme: {
                    light: {
                        root: {
                            background: "{surface.300}",
                            disabledBackground: "{surface.400}",
                            hoverBackground: "{surface.300}",
                            checkedBackground: "{primary.200}",
                            checkedHoverBackground: "{primary.200}"
                        },
                        handle: {
                            background: "{surface.0}",
                            disabledBackground: "{surface.200}",
                            hoverBackground: "{surface.0}",
                            checkedBackground: "{primary.color}",
                            checkedHoverBackground: "{primary.color}",
                            color: "{text.muted.color}",
                            hoverColor: "{text.color}",
                            checkedColor: "{primary.contrast.color}",
                            checkedHoverColor: "{primary.contrast.color}"
                        }
                    },
                    dark: {
                        root: {
                            background: "{surface.700}",
                            disabledBackground: "{surface.600}",
                            hoverBackground: "{surface.700}",
                            checkedBackground: "{primary.color}",
                            checkedHoverBackground: "{primary.color}"
                        },
                        handle: {
                            background: "{surface.400}",
                            disabledBackground: "{surface.500}",
                            hoverBackground: "{surface.300}",
                            checkedBackground: "{primary.200}",
                            checkedHoverBackground: "{primary.200}",
                            color: "{surface.800}",
                            hoverColor: "{surface.900}",
                            checkedColor: "{primary.contrast.color}",
                            checkedHoverColor: "{primary.contrast.color}"
                        }
                    }
                },
                css: "\n.p-toggleswitch-handle {\n    box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-handle {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 96%), 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-handle {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('text.color'), transparent 88%), 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-handle {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('toggleswitch.handle.checked.background'), transparent 92%), 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n\n.p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible).p-toggleswitch-checked .p-toggleswitch-handle {\n    box-shadow: 0 0 1px 10px color-mix(in srgb, dt('toggleswitch.handle.checked.background'), transparent 84%), 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n}\n"
            },
            tree: {
                root: {
                    background: "{content.background}",
                    color: "{content.color}",
                    padding: "1rem",
                    gap: "2px",
                    indent: "2rem",
                    transitionDuration: "{transition.duration}"
                },
                node: {
                    padding: "0.5rem 0.75rem",
                    borderRadius: "{border.radius.xs}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    color: "{text.color}",
                    hoverColor: "{text.hover.color}",
                    selectedColor: "{highlight.color}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "-1px",
                        shadow: "{focus.ring.shadow}"
                    },
                    gap: "0.5rem"
                },
                nodeIcon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    selectedColor: "{highlight.color}"
                },
                nodeToggleButton: {
                    borderRadius: "50%",
                    size: "2rem",
                    hoverBackground: "{content.hover.background}",
                    selectedHoverBackground: "{content.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    selectedHoverColor: "{primary.color}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                loadingIcon: {
                    size: "2rem"
                },
                filter: {
                    margin: "0 0 0.75rem 0"
                },
                css: "\n.p-tree-node-content {\n    transition: none;\n}\n"
            },
            treeselect: {
                root: {
                    background: "{form.field.background}",
                    disabledBackground: "{form.field.disabled.background}",
                    filledBackground: "{form.field.filled.background}",
                    filledHoverBackground: "{form.field.filled.hover.background}",
                    filledFocusBackground: "{form.field.filled.focus.background}",
                    borderColor: "{form.field.border.color}",
                    hoverBorderColor: "{form.field.hover.border.color}",
                    focusBorderColor: "{form.field.focus.border.color}",
                    invalidBorderColor: "{form.field.invalid.border.color}",
                    color: "{form.field.color}",
                    disabledColor: "{form.field.disabled.color}",
                    placeholderColor: "{form.field.placeholder.color}",
                    invalidPlaceholderColor: "{form.field.invalid.placeholder.color}",
                    shadow: "{form.field.shadow}",
                    paddingX: "{form.field.padding.x}",
                    paddingY: "{form.field.padding.y}",
                    borderRadius: "{form.field.border.radius}",
                    focusRing: {
                        width: "{form.field.focus.ring.width}",
                        style: "{form.field.focus.ring.style}",
                        color: "{form.field.focus.ring.color}",
                        offset: "{form.field.focus.ring.offset}",
                        shadow: "{form.field.focus.ring.shadow}"
                    },
                    transitionDuration: "{form.field.transition.duration}",
                    sm: {
                        fontSize: "{form.field.sm.font.size}",
                        paddingX: "{form.field.sm.padding.x}",
                        paddingY: "{form.field.sm.padding.y}"
                    },
                    lg: {
                        fontSize: "{form.field.lg.font.size}",
                        paddingX: "{form.field.lg.padding.x}",
                        paddingY: "{form.field.lg.padding.y}"
                    }
                },
                dropdown: {
                    width: "2.5rem",
                    color: "{form.field.icon.color}"
                },
                overlay: {
                    background: "{overlay.select.background}",
                    borderColor: "{overlay.select.border.color}",
                    borderRadius: "{overlay.select.border.radius}",
                    color: "{overlay.select.color}",
                    shadow: "{overlay.select.shadow}"
                },
                tree: {
                    padding: "{list.padding}"
                },
                emptyMessage: {
                    padding: "{list.option.padding}"
                },
                chip: {
                    borderRadius: "{border.radius.sm}"
                },
                clearIcon: {
                    color: "{form.field.icon.color}"
                },
                css: "\n.p-treeselect.p-variant-filled {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n    border: 1px solid transparent;\n    background: dt('treeselect.filled.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('treeselect.focus.border.color'), dt('treeselect.focus.border.color')), linear-gradient(to bottom, dt('treeselect.border.color'), dt('treeselect.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    transition: background-size 0.3s cubic-bezier(0.64, 0.09, 0.08, 1);\n}\n\n.p-treeselect.p-variant-filled:not(.p-disabled):hover {\n    background: dt('treeselect.filled.hover.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('treeselect.focus.border.color'), dt('treeselect.focus.border.color')), linear-gradient(to bottom, dt('treeselect.hover.border.color'), dt('treeselect.hover.border.color'));\n    background-size: 0 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-treeselect.p-variant-filled:not(.p-disabled).p-focus {\n    outline: 0 none;\n    background: dt('treeselect.filled.focus.background') no-repeat;\n    background-image: linear-gradient(to bottom, dt('treeselect.focus.border.color'), dt('treeselect.focus.border.color')), linear-gradient(to bottom, dt('treeselect.border.color'), dt('treeselect.border.color'));\n    background-size: 100% 2px, 100% 1px;\n    background-position: 50% 100%, 50% 100%;\n    background-origin: border-box;\n    border-color: transparent;\n}\n\n.p-treeselect.p-variant-filled:not(.p-disabled).p-focus:hover {\n    background-image: linear-gradient(to bottom, dt('treeselect.focus.border.color'), dt('treeselect.focus.border.color')), linear-gradient(to bottom, dt('treeselect.hover.border.color'), dt('treeselect.hover.border.color'));\n}\n\n.p-treeselect.p-variant-filled.p-invalid {\n    background-image: linear-gradient(to bottom, dt('treeselect.invalid.border.color'), dt('treeselect.invalid.border.color')), linear-gradient(to bottom, dt('treeselect.invalid.border.color'), dt('treeselect.invalid.border.color'));\n}\n\n.p-treeselect.p-variant-filled.p-invalid:not(.p-disabled).p-focus  {\n    background-image: linear-gradient(to bottom, dt('treeselect.invalid.border.color'), dt('treeselect.invalid.border.color')), linear-gradient(to bottom, dt('treeselect.invalid.border.color'), dt('treeselect.invalid.border.color'));\n}\n"
            },
            treetable: {
                root: {
                    transitionDuration: "{transition.duration}"
                },
                header: {
                    background: "{content.background}",
                    borderColor: "{treetable.border.color}",
                    color: "{content.color}",
                    borderWidth: "0 0 1px 0",
                    padding: "0.75rem 1rem"
                },
                headerCell: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    borderColor: "{treetable.border.color}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    selectedColor: "{highlight.color}",
                    gap: "0.5rem",
                    padding: "0.75rem 1rem",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "-1px",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                columnTitle: {
                    fontWeight: "600"
                },
                row: {
                    background: "{content.background}",
                    hoverBackground: "{content.hover.background}",
                    selectedBackground: "{highlight.background}",
                    color: "{content.color}",
                    hoverColor: "{content.hover.color}",
                    selectedColor: "{highlight.color}",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "-1px",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                bodyCell: {
                    borderColor: "{treetable.border.color}",
                    padding: "0.75rem 1rem",
                    gap: "0.5rem"
                },
                footerCell: {
                    background: "{content.background}",
                    borderColor: "{treetable.border.color}",
                    color: "{content.color}",
                    padding: "0.75rem 1rem"
                },
                columnFooter: {
                    fontWeight: "600"
                },
                footer: {
                    background: "{content.background}",
                    borderColor: "{treetable.border.color}",
                    color: "{content.color}",
                    borderWidth: "0 0 1px 0",
                    padding: "0.75rem 1rem"
                },
                columnResizer: {
                    width: "0.5rem"
                },
                resizeIndicator: {
                    width: "1px",
                    color: "{primary.color}"
                },
                sortIcon: {
                    color: "{text.muted.color}",
                    hoverColor: "{text.hover.muted.color}",
                    size: "0.875rem"
                },
                loadingIcon: {
                    size: "2rem"
                },
                nodeToggleButton: {
                    hoverBackground: "{content.hover.background}",
                    selectedHoverBackground: "{content.background}",
                    color: "{text.muted.color}",
                    hoverColor: "{text.color}",
                    selectedHoverColor: "{primary.color}",
                    size: "1.75rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        color: "{focus.ring.color}",
                        offset: "{focus.ring.offset}",
                        shadow: "{focus.ring.shadow}"
                    }
                },
                paginatorTop: {
                    borderColor: "{content.border.color}",
                    borderWidth: "0 0 1px 0"
                },
                paginatorBottom: {
                    borderColor: "{content.border.color}",
                    borderWidth: "0 0 1px 0"
                },
                colorScheme: {
                    light: {
                        root: {
                            borderColor: "{content.border.color}"
                        },
                        bodyCell: {
                            selectedBorderColor: "{primary.100}"
                        }
                    },
                    dark: {
                        root: {
                            borderColor: "{surface.800}"
                        },
                        bodyCell: {
                            selectedBorderColor: "{primary.900}"
                        }
                    }
                }
            },
            toast: {
                root: {
                    width: "25rem",
                    borderRadius: "{content.border.radius}",
                    borderWidth: "0",
                    transitionDuration: "{transition.duration}"
                },
                icon: {
                    size: "1.25rem"
                },
                content: {
                    padding: "{overlay.popover.padding}",
                    gap: "0.5rem"
                },
                text: {
                    gap: "0.5rem"
                },
                summary: {
                    fontWeight: "500",
                    fontSize: "1rem"
                },
                detail: {
                    fontWeight: "500",
                    fontSize: "0.875rem"
                },
                closeButton: {
                    width: "2rem",
                    height: "2rem",
                    borderRadius: "50%",
                    focusRing: {
                        width: "{focus.ring.width}",
                        style: "{focus.ring.style}",
                        offset: "{focus.ring.offset}"
                    }
                },
                closeIcon: {
                    size: "1rem"
                },
                colorScheme: {
                    light: {
                        root: {
                            blur: "0"
                        },
                        info: {
                            background: "{blue.50}",
                            borderColor: "{blue.200}",
                            color: "{blue.600}",
                            detailColor: "{surface.700}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{blue.100}",
                                focusRing: {
                                    color: "{blue.600}",
                                    shadow: "none"
                                }
                            }
                        },
                        success: {
                            background: "{green.50}",
                            borderColor: "{green.200}",
                            color: "{green.600}",
                            detailColor: "{surface.700}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{green.100}",
                                focusRing: {
                                    color: "{green.600}",
                                    shadow: "none"
                                }
                            }
                        },
                        warn: {
                            background: "{yellow.50}",
                            borderColor: "{yellow.200}",
                            color: "{yellow.900}",
                            detailColor: "{surface.700}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{yellow.100}",
                                focusRing: {
                                    color: "{yellow.600}",
                                    shadow: "none"
                                }
                            }
                        },
                        error: {
                            background: "{red.50}",
                            borderColor: "{red.200}",
                            color: "{red.600}",
                            detailColor: "{surface.700}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{red.100}",
                                focusRing: {
                                    color: "{red.600}",
                                    shadow: "none"
                                }
                            }
                        },
                        secondary: {
                            background: "{surface.100}",
                            borderColor: "{surface.200}",
                            color: "{surface.600}",
                            detailColor: "{surface.700}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{surface.200}",
                                focusRing: {
                                    color: "{surface.600}",
                                    shadow: "none"
                                }
                            }
                        },
                        contrast: {
                            background: "{surface.900}",
                            borderColor: "{surface.950}",
                            color: "{surface.50}",
                            detailColor: "{surface.0}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{surface.800}",
                                focusRing: {
                                    color: "{surface.50}",
                                    shadow: "none"
                                }
                            }
                        }
                    },
                    dark: {
                        root: {
                            blur: "10px"
                        },
                        info: {
                            background: "color-mix(in srgb, {blue.500}, transparent 36%)",
                            borderColor: "color-mix(in srgb, {blue.700}, transparent 64%)",
                            color: "{surface.0}",
                            detailColor: "{blue.100}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{blue.500}",
                                    shadow: "none"
                                }
                            }
                        },
                        success: {
                            background: "color-mix(in srgb, {green.500}, transparent 36%)",
                            borderColor: "color-mix(in srgb, {green.700}, transparent 64%)",
                            color: "{surface.0}",
                            detailColor: "{green.100}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{green.500}",
                                    shadow: "none"
                                }
                            }
                        },
                        warn: {
                            background: "color-mix(in srgb, {yellow.500}, transparent 36%)",
                            borderColor: "color-mix(in srgb, {yellow.700}, transparent 64%)",
                            color: "{surface.0}",
                            detailColor: "{yellow.50}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{yellow.500}",
                                    shadow: "none"
                                }
                            }
                        },
                        error: {
                            background: "color-mix(in srgb, {red.500}, transparent 36%)",
                            borderColor: "color-mix(in srgb, {red.700}, transparent 64%)",
                            color: "{surface.0}",
                            detailColor: "{red.100}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "rgba(255, 255, 255, 0.05)",
                                focusRing: {
                                    color: "{red.500}",
                                    shadow: "none"
                                }
                            }
                        },
                        secondary: {
                            background: "{surface.800}",
                            borderColor: "{surface.700}",
                            color: "{surface.300}",
                            detailColor: "{surface.0}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{surface.700}",
                                focusRing: {
                                    color: "{surface.300}",
                                    shadow: "none"
                                }
                            }
                        },
                        contrast: {
                            background: "{surface.0}",
                            borderColor: "{surface.100}",
                            color: "{surface.950}",
                            detailColor: "{surface.950}",
                            shadow: "0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)",
                            closeButton: {
                                hoverBackground: "{surface.100}",
                                focusRing: {
                                    color: "{surface.950}",
                                    shadow: "none"
                                }
                            }
                        }
                    }
                },
                css: ""
            },
            toolbar: {
                root: {
                    color: "{content.color}",
                    borderRadius: "{content.border.radius}",
                    gap: "0.5rem",
                    padding: "1rem"
                },
                colorScheme: {
                    light: {
                        root: {
                            background: "{surface.100}",
                            borderColor: "{surface.100}"
                        }
                    },
                    dark: {
                        root: {
                            background: "{surface.800}",
                            borderColor: "{surface.800}"
                        }
                    }
                },
                css: ""
            },
            tooltip: {
                root: {
                    background: "{surface.600}",
                    color: "{surface.0}",
                    maxWidth: "12.5rem",
                    gutter: "0.25rem",
                    shadow: "{overlay.popover.shadow}",
                    padding: "0.5rem 0.75rem",
                    borderRadius: "{overlay.popover.border.radius}"
                },
                css: ""
            },
            virtualscroller: {
                loader: {
                    mask: {
                        background: "{content.background}",
                        color: "{text.muted.color}"
                    },
                    icon: {
                        size: "2rem"
                    }
                },
                css: ""
            }
        }
    }));
const rL = "[A-Za-z$_][0-9A-Za-z$_]*",
    oL = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends", "using"],
    iL = ["true", "false", "null", "undefined", "NaN", "Infinity"],
    aL = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"],
    sL = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"],
    lL = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"],
    cL = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"],
    uL = [].concat(lL, aL, sL);
var dL = yn({
        props: {
            code: {
                type: String,
                required: !0
            },
            language: {
                type: String,
                default: ""
            },
            autodetect: {
                type: Boolean,
                default: !0
            },
            ignoreIllegals: {
                type: Boolean,
                default: !0
            }
        },
        setup: function(e) {
            var t = ft(e.language);
            Vr(function() {
                return e.language
            }, function(e) {
                t.value = e
            });
            var n = Ho(function() {
                    return e.autodetect || !t.value
                }),
                r = Ho(function() {
                    return !n.value && !jP.getLanguage(t.value)
                });
            return {
                className: Ho(function() {
                    return r.value ? "" : "hljs " + t.value
                }),
                highlightedCode: Ho(function() {
                    var o;
                    if (r.value)
                        return e.code.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
                    if (n.value) {
                        var i = jP.highlightAuto(e.code);
                        return t.value = null !== (o = i.language) && void 0 !== o ? o : "", i.value
                    }
                    return (i = jP.highlight(e.code, {
                        language: t.value,
                        ignoreIllegals: e.ignoreIllegals
                    })).value
                })
            }
        },
        render: function() {
            return $o("pre", {}, [$o("code", {
                class: this.className,
                innerHTML: this.highlightedCode
            })])
        }
    }),
    pL = {
        install: function(e) {
            e.component("highlightjs", dL)
        },
        component: dL
    };
jP.registerLanguage("javascript", function(e) {
    const t = e.regex,
        n = rL,
        r = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (e, t) => {
                const n = e[0].length + e.index,
                    r = e.input[n];
                if ("<" === r || "," === r)
                    return void t.ignoreMatch();
                let o;
                ">" === r && (((e, {after: t}) => {
                    const n = "</" + e[0].slice(1);
                    return -1 !== e.input.indexOf(n, t)
                })(e, {
                    after: n
                }) || t.ignoreMatch());
                const i = e.input.substring(n);
                ((o = i.match(/^\s*=/)) || (o = i.match(/^\s+extends\s+/)) && 0 === o.index) && t.ignoreMatch()
            }
        },
        o = {
            $pattern: rL,
            keyword: oL,
            literal: iL,
            built_in: uL,
            "variable.language": cL
        },
        i = "[0-9](_?[0-9])*",
        a = `\\.(${i})`,
        s = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",
        l = {
            className: "number",
            variants: [{
                begin: `(\\b(${s})((${a})|\\.)?|(${a}))[eE][+-]?(${i})\\b`
            }, {
                begin: `\\b(${s})\\b((${a})\\b|\\.)?|(${a})\\b`
            }, {
                begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
            }, {
                begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
            }, {
                begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
            }, {
                begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"
            }, {
                begin: "\\b0[0-7]+n?\\b"
            }],
            relevance: 0
        },
        c = {
            className: "subst",
            begin: "\\$\\{",
            end: "\\}",
            keywords: o,
            contains: []
        },
        u = {
            begin: ".?html`",
            end: "",
            starts: {
                end: "`",
                returnEnd: !1,
                contains: [e.BACKSLASH_ESCAPE, c],
                subLanguage: "xml"
            }
        },
        d = {
            begin: ".?css`",
            end: "",
            starts: {
                end: "`",
                returnEnd: !1,
                contains: [e.BACKSLASH_ESCAPE, c],
                subLanguage: "css"
            }
        },
        p = {
            begin: ".?gql`",
            end: "",
            starts: {
                end: "`",
                returnEnd: !1,
                contains: [e.BACKSLASH_ESCAPE, c],
                subLanguage: "graphql"
            }
        },
        h = {
            className: "string",
            begin: "`",
            end: "`",
            contains: [e.BACKSLASH_ESCAPE, c]
        },
        f = {
            className: "comment",
            variants: [e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                relevance: 0,
                contains: [{
                    begin: "(?=@[A-Za-z]+)",
                    relevance: 0,
                    contains: [{
                        className: "doctag",
                        begin: "@[A-Za-z]+"
                    }, {
                        className: "type",
                        begin: "\\{",
                        end: "\\}",
                        excludeEnd: !0,
                        excludeBegin: !0,
                        relevance: 0
                    }, {
                        className: "variable",
                        begin: n + "(?=\\s*(-)|$)",
                        endsParent: !0,
                        relevance: 0
                    }, {
                        begin: /(?=[^\n])\s/,
                        relevance: 0
                    }]
                }]
            }), e.C_BLOCK_COMMENT_MODE, e.C_LINE_COMMENT_MODE]
        },
        g = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, u, d, p, h, {
            match: /\$\d+/
        }, l];
    c.contains = g.concat({
        begin: /\{/,
        end: /\}/,
        keywords: o,
        contains: ["self"].concat(g)
    });
    const m = [].concat(f, c.contains),
        b = m.concat([{
            begin: /(\s*)\(/,
            end: /\)/,
            keywords: o,
            contains: ["self"].concat(m)
        }]),
        A = {
            className: "params",
            begin: /(\s*)\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: o,
            contains: b
        },
        y = {
            variants: [{
                match: [/class/, /\s+/, n, /\s+/, /extends/, /\s+/, t.concat(n, "(", t.concat(/\./, n), ")*")],
                scope: {
                    1: "keyword",
                    3: "title.class",
                    5: "keyword",
                    7: "title.class.inherited"
                }
            }, {
                match: [/class/, /\s+/, n],
                scope: {
                    1: "keyword",
                    3: "title.class"
                }
            }]
        },
        v = {
            relevance: 0,
            match: t.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
            className: "title.class",
            keywords: {
                _: [...aL, ...sL]
            }
        },
        _ = {
            variants: [{
                match: [/function/, /\s+/, n, /(?=\s*\()/]
            }, {
                match: [/function/, /\s*(?=\()/]
            }],
            className: {
                1: "keyword",
                3: "title.function"
            },
            label: "func.def",
            contains: [A],
            illegal: /%/
        },
        x = {
            match: t.concat(/\b/, (w = [...lL, "super", "import"].map(e => `${e}\\s*\\(`), t.concat("(?!", w.join("|"), ")")), n, t.lookahead(/\s*\(/)),
            className: "title.function",
            relevance: 0
        };
    var w;
    const C = {
            begin: t.concat(/\./, t.lookahead(t.concat(n, /(?![0-9A-Za-z$_(])/))),
            end: n,
            excludeBegin: !0,
            keywords: "prototype",
            className: "property",
            relevance: 0
        },
        E = {
            match: [/get|set/, /\s+/, n, /(?=\()/],
            className: {
                1: "keyword",
                3: "title.function"
            },
            contains: [{
                begin: /\(\)/
            }, A]
        },
        S = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>",
        I = {
            match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(S)],
            keywords: "async",
            className: {
                1: "keyword",
                3: "title.function"
            },
            contains: [A]
        };
    return {
        name: "JavaScript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: o,
        exports: {
            PARAMS_CONTAINS: b,
            CLASS_REFERENCE: v
        },
        illegal: /#(?![$_A-z])/,
        contains: [e.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
        }), {
            label: "use_strict",
            className: "meta",
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/
        }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, u, d, p, h, f, {
            match: /\$\d+/
        }, l, v, {
            scope: "attr",
            match: n + t.lookahead(":"),
            relevance: 0
        }, I, {
            begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            relevance: 0,
            contains: [f, e.REGEXP_MODE, {
                className: "function",
                begin: S,
                returnBegin: !0,
                end: "\\s*=>",
                contains: [{
                    className: "params",
                    variants: [{
                        begin: e.UNDERSCORE_IDENT_RE,
                        relevance: 0
                    }, {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: !0
                    }, {
                        begin: /(\s*)\(/,
                        end: /\)/,
                        excludeBegin: !0,
                        excludeEnd: !0,
                        keywords: o,
                        contains: b
                    }]
                }]
            }, {
                begin: /,/,
                relevance: 0
            }, {
                match: /\s+/,
                relevance: 0
            }, {
                variants: [{
                    begin: "<>",
                    end: "</>"
                }, {
                    match: /<[A-Za-z0-9\\._:-]+\s*\/>/
                }, {
                    begin: r.begin,
                    "on:begin": r.isTrulyOpeningTag,
                    end: r.end
                }],
                subLanguage: "xml",
                contains: [{
                    begin: r.begin,
                    end: r.end,
                    skip: !0,
                    contains: ["self"]
                }]
            }]
        }, _, {
            beginKeywords: "while if switch catch for"
        }, {
            begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            returnBegin: !0,
            label: "func.def",
            contains: [A, e.inherit(e.TITLE_MODE, {
                begin: n,
                className: "title.function"
            })]
        }, {
            match: /\.\.\./,
            relevance: 0
        }, C, {
            match: "\\$" + n,
            relevance: 0
        }, {
            match: [/\bconstructor(?=\s*\()/],
            className: {
                1: "title.function"
            },
            contains: [A]
        }, x, {
            relevance: 0,
            match: /\b[A-Z][A-Z_0-9]+\b/,
            className: "variable.constant"
        }, y, E, {
            match: /\$[(.]/
        }]
    }
});
const hL = function(...e) {
        return pS(...e)
    }(nL, {
        semantic: {
            primary: {
                50: "#eff6ff",
                100: "#dbeafe",
                200: "#bfdbfe",
                300: "#93c5fd",
                400: "#60a5fa",
                500: "#3b82f6",
                600: "#2563eb",
                700: "#1d4ed8",
                800: "#1e40af",
                900: "#1e3a8a",
                950: "#172554"
            }
        }
    }),
    fL = ((...e) => {
        const t = (Gi || (Gi = Lr(Qi))).createApp(...e),
            {mount: n} = t;
        return t.mount = e => {
            const r = function(e) {
                return g(e) ? document.querySelector(e) : e
            }(e);
            if (!r)
                return;
            const o = t._component;
            f(o) || o.render || o.template || (o.template = r.innerHTML),
            1 === r.nodeType && (r.textContent = "");
            const i = n(r, !1, function(e) {
                return e instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && e instanceof MathMLElement ? "mathml" : void 0
            }(r));
            return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), i
        }, t
    })(zO);
fL.use(KO, {
    theme: {
        preset: hL
    }
}),
fL.use(pL),
fL.mount("#app");
