<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BelowJS - Drag & Drop Viewer</title>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåä</text></svg>">

  <!-- Import map for CDN -->
  <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.170.0",
            "belowjs": "./browser/belowjs.js",
            "@gltf-transform/core": "https://esm.sh/@gltf-transform/core@4",
            "@gltf-transform/extensions": "https://esm.sh/@gltf-transform/extensions@4",
            "@gltf-transform/functions": "https://esm.sh/@gltf-transform/functions@4",
            "meshoptimizer": "https://esm.sh/meshoptimizer@0.21.0",
            "three/examples/jsm/loaders/KTX2Loader.js": "https://unpkg.com/three@0.170.0/examples/jsm/loaders/KTX2Loader.js",
            "ktx2-encoder": "https://unpkg.com/ktx2-encoder@0.5.1/dist/web/index.js?v=20260127",
            "ktx2-encoder/gltf-transform": "https://unpkg.com/ktx2-encoder@0.5.1/dist/gltf-transform/index.js?v=20260127",
            "ktx-parse": "https://unpkg.com/ktx-parse@0.7.1/dist/ktx-parse.esm.js"
        }
    }
    </script>

  <!-- Load Draco encoder (browser build) -->
  <script src="https://unpkg.com/draco3dgltf@1.5.7/draco_encoder_gltf_nodejs.js"></script>
  <!-- Load Draco decoder (browser build) -->
  <script src="https://unpkg.com/draco3dgltf@1.5.7/draco_decoder_gltf_nodejs.js"></script>

  <link rel="stylesheet" href="./browser/belowjs.css">

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0f172a;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* Drag and drop overlay */
    .drag-drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      z-index: 2000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .drag-drop-overlay.visible {
      opacity: 1;
    }

    .drag-drop-overlay .panel {
      border: 2px dashed #475569;
      border-radius: 16px;
      padding: 28px 32px;
      text-align: center;
      background: rgba(2, 6, 23, 0.35);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
      width: min(720px, calc(100% - 80px));
    }

    /* (removed unused drag-drop-hint and animation) */

    /* Empty state styling */
    .empty-state {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #e2e8f0;
      z-index: 1000;
      pointer-events: none;
    }

    .empty-state h2 {
      font-size: 2.5em;
      margin: 0 0 16px 0;
      font-weight: 300;
    }

    .empty-state p {
      font-size: 1.2em;
      margin: 8px 0;
      opacity: 0.8;
    }

    .file-select-button {
      display: inline-block;
      margin-top: 24px;
      padding: 12px 24px;
      background: rgba(59, 130, 246, 0.8);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      pointer-events: auto;
      transition: background 0.3s ease;
    }

    .file-select-button:hover {
      background: rgba(59, 130, 246, 1);
    }

    #fileInput {
      display: none;
    }

    /* Loaded state hint */
    .loaded-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.8);
      color: #94a3b8;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .loaded-hint.visible {
      opacity: 0.7;
    }

    /* Camera snippet */
    .camera-snippet {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1001;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      width: 336px;
      pointer-events: auto;
    }

    .camera-snippet .copy-btn {
      background: rgba(59, 130, 246, 0.9);
      color: #ffffff;
      border: none;
      border-radius: 6px;
      font-size: 11px;
      /* smaller button */
      padding: 4px 8px;
      /* smaller padding */
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .camera-snippet .copy-btn:hover {
      background: rgba(59, 130, 246, 1);
    }

    /* Compact ghost-style copy button inside card (bottom-right) */
    .camera-snippet .copy-fab {
      position: absolute;
      right: 8px;
      bottom: 8px;
      background: rgba(30, 41, 59, 0.7);
      color: #cbd5e1;
      border: 1px solid #334155;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1;
      padding: 6px 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      backdrop-filter: saturate(1.2) blur(1px);
    }

    .camera-snippet .copy-fab:hover {
      background: rgba(59, 130, 246, 0.9);
      border-color: #1d4ed8;
      color: #ffffff;
    }

    .camera-snippet pre {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.4;
      color: #e2e8f0;
      white-space: pre;
      overflow-x: auto;
      font-variant-numeric: tabular-nums;
    }

    /* Model stats */
    .model-stats {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1001;
      background: rgba(15, 23, 42, 0.85);
      color: #e2e8f0;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      box-sizing: border-box;
      width: 240px;
      min-width: 240px;
      max-width: 240px;
    }

    .model-stats .row {
      position: relative;
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      column-gap: 12px;
      font-size: 12px;
      padding: 3px 0;
      padding-right: 20px;
    }

    .model-stats .label {
      color: #94a3b8;
    }

    .model-stats .value {
      color: #e2e8f0;
      font-variant-numeric: tabular-nums;
      justify-self: end;
    }

    .model-stats .value.warn {
      color: #f59e0b;
    }

    /* Warning icon shown via inline span */
    .model-stats .value .warn-icon {
      display: none;
      margin-right: 6px;
    }

    .model-stats .value.warn .warn-icon {
      display: inline;
    }

    /* Optimise/Download/Swap buttons */
    .model-stats .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #334155;
    }

    .model-stats .actions.texture-actions {
      flex-direction: row;
    }

    .model-stats .action-btn {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .model-stats .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .model-stats .action-btn.primary {
      background: rgba(59, 130, 246, 0.9);
      color: #ffffff;
    }

    .model-stats .action-btn.primary:hover:not(:disabled) {
      background: rgba(59, 130, 246, 1);
    }

    .model-stats .action-btn.secondary {
      background: rgba(30, 41, 59, 0.8);
      color: #e2e8f0;
      border: 1px solid #475569;
    }

    .model-stats .action-btn.secondary:hover:not(:disabled) {
      background: rgba(51, 65, 85, 0.9);
    }

    .model-stats .action-btn.success {
      background: rgba(34, 197, 94, 0.9);
      color: #ffffff;
    }

    .model-stats .action-btn.success:hover:not(:disabled) {
      background: rgba(34, 197, 94, 1);
    }

    /* Progress indicator */
    .model-stats .progress-text {
      font-size: 11px;
      color: #94a3b8;
      text-align: center;
      margin-top: 8px;
    }

    /* View indicator */
    .model-stats .view-indicator {
      font-size: 10px;
      color: #60a5fa;
      text-align: center;
      margin-top: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-note.error {
      color: #fca5a5;
    }

    .model-stats .view-toggle {
      background: none;
      border: none;
      padding: 0;
      color: #60a5fa;
      font-size: 12px;
      cursor: pointer;
      text-decoration: underline;
    }

    /* Optimization loading overlay */
    .optimize-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .optimize-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .optimize-overlay .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid #334155;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .status-note {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-top: 8px;
      font-size: 12px;
      color: #cbd5f5;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .optimize-overlay .status {
      margin-top: 24px;
      font-size: 18px;
      color: #e2e8f0;
      text-align: center;
    }

    .optimize-overlay .step {
      margin-top: 8px;
      font-size: 14px;
      color: #94a3b8;
    }

    .optimize-overlay .warning {
      margin-top: 24px;
      font-size: 12px;
      color: #f59e0b;
      max-width: 300px;
      text-align: center;
      line-height: 1.5;
    }

    .optimize-overlay .warning a {
      color: #93c5fd;
      text-decoration: underline;
    }

    .optimize-overlay .warning a:hover {
      color: #bfdbfe;
    }
  </style>
</head>

<body>
  <!-- Drag & Drop viewer -->

  <!-- Drag and drop overlay (hidden by default) -->
  <div class="drag-drop-overlay" id="dragOverlay">
    <div class="panel">
      <div class="dd-title">Drop .glb or .gltf files to load</div>
      <div class="dd-sub">For GLTF, include textures and .bin files</div>
    </div>
  </div>

  <!-- Empty state when no model loaded -->
  <div class="empty-state" id="emptyState">
    <h2>Below Optimiser</h2>
    <p>Drag & drop a .glb or .gltf file</p>
    <button class="file-select-button" onclick="document.getElementById('fileInput').click()">Choose files</button>
    <input type="file" id="fileInput" accept=".glb,.gltf,.bin,.png,.jpg,.jpeg,.webp" multiple />
  </div>

  <!-- Survey/Dive toggle -->
  <div id="modeToggleContainer" style="position: fixed; top: 20px; right: 20px; z-index: 1001;">
    <div class="semantic-toggle">
      <input type="checkbox" id="modeToggleSwitch" class="mode-toggle__switch">
      <div class="toggle-slider-bg"></div>
      <div class="toggle-option left">
        <div class="toggle-icon">üîç</div>
        <div class="toggle-text">Survey</div>
      </div>
      <div class="toggle-option right">
        <div class="toggle-icon">üî¶</div>
        <div class="toggle-text">Dive</div>
      </div>
    </div>
  </div>

  <!-- Loaded state hint (hidden by default) -->
  <div class="loaded-hint" id="loadedHint">Drop another model to replace</div>

  <!-- Optimization loading overlay -->
  <div class="optimize-overlay" id="optimizeOverlay">
    <div class="spinner"></div>
    <div class="step" id="optimizeStep">Initialising...</div>
    <div class="warning" id="optimizeWarning">
      Experimental: browser optimisation can crash on large models due to browser memory limits.<br>
      Keep this tab focussed while optimising.<br>
      For a faster, more robust experience, use the CLI on
      <a href="https://github.com/patrick-morrison/below-optimiser" target="_blank"
        rel="noopener noreferrer">GitHub</a>.
    </div>
  </div>

  <!-- Model stats panel -->
  <div class="model-stats" id="modelStats" aria-live="polite">
    <div class="row"><span class="label">triangles</span><span class="value" id="statTris"><span
          class="warn-icon">‚ö†</span>‚Äî</span></div>
    <div class="row"><span class="label">disk</span><span class="value" id="statDisk"><span
          class="warn-icon">‚ö†</span>‚Äî</span></div>
    <div class="row"><span class="label">vram</span><span class="value" id="statVram"><span
          class="warn-icon">‚ö†</span>‚Äî</span></div>
    <div class="row"><span class="label">draws</span><span class="value" id="statDraws">‚Äî</span></div>
    <div class="actions" id="actionButtons" style="display: none;">
      <button class="action-btn primary" id="optimiseBtn">Optimise</button>
      <button class="action-btn success" id="downloadBtn" style="display: none;">Download</button>
    </div>
    <div class="actions texture-actions" id="textureButtons" style="display: none; margin-top: 0; padding-top: 8px;">
      <button class="action-btn secondary" id="downloadTexturesBtn" style="font-size: 11px; padding: 6px 10px;">‚Üì
        Textures</button>
      <button class="action-btn secondary" id="uploadTexturesBtn" style="font-size: 11px; padding: 6px 10px;">‚Üë
        Textures</button>
      <input type="file" id="textureInput" accept="image/*" multiple style="display: none;">
    </div>
    <div class="progress-text" id="progressText" style="display: none;"></div>
    <div class="status-note" id="modelStatus" style="display: none;">
      <span id="statusMessageText"></span>
      <button class="view-toggle" id="viewToggle" type="button" style="display: none;"></button>
    </div>
  </div>

  <!-- Camera preset snippet (lower-right) -->
  <div class="camera-snippet" id="cameraSnippet" aria-live="polite">
    <pre id="camCode">desktop: {
  camera: { x: 0, y: 5, z: 10 },
  target: { x: 0, y: 0, z: 0 }
},</pre>
    <button id="copyCamBtn" class="copy-fab" aria-label="Copy snippet" title="Copy">‚ßâ Copy</button>
  </div>

  <script type="module">
    import { ModelViewer } from 'belowjs';
    import { WebIO } from '@gltf-transform/core';
    import * as THREE from 'three';
    import { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';
    import { ALL_EXTENSIONS } from '@gltf-transform/extensions';
    import {
      dedup, weld, join, simplify, textureCompress,
      draco
    } from '@gltf-transform/functions';
    import { KHRDracoMeshCompression, KHRTextureBasisu } from '@gltf-transform/extensions';
    import { MeshoptSimplifier } from 'meshoptimizer';
    import { ktx2 } from 'ktx2-encoder/gltf-transform';

    // Drag & Drop viewer

    // No initial models - starts empty
    const models = {};

    // State for optimization
    let originalArrayBuffer = null;
    let optimizedArrayBuffer = null;
    let isShowingOptimized = false;
    let isOptimizing = false;
    let originalFileName = 'model.glb';
    let hasNewTextures = false;
    let canvasHandlersAttached = false;
    let currentProgressText = '';

    // UI elements for optimization
    const actionButtons = document.getElementById('actionButtons');
    const optimiseBtn = document.getElementById('optimiseBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const textureButtons = document.getElementById('textureButtons');
    const downloadTexturesBtn = document.getElementById('downloadTexturesBtn');
    const uploadTexturesBtn = document.getElementById('uploadTexturesBtn');
    const textureInput = document.getElementById('textureInput');
    const progressText = document.getElementById('progressText');
    const statusMessageText = document.getElementById('statusMessageText');
    const viewToggle = document.getElementById('viewToggle');
    const modelStatus = document.getElementById('modelStatus');
    const optimizeOverlay = document.getElementById('optimizeOverlay');
    const optimizeStep = document.getElementById('optimizeStep');
    const optimizeWarning = document.getElementById('optimizeWarning');

    // Initialize gltf-transform IO
    let io = null;
    let ioReadOnly = null; // Lightweight IO for reading only
    let meshoptSimplifier = null;
    let dracoEncoder = null;
    let dracoDecoder = null;
    let ktx2Loader = null;
    let ktx2Renderer = null;
    let ktx2Scene = null;
    let ktx2Camera = null;
    let ktx2Quad = null;

    // Lightweight initialization for read-only operations (texture extraction, etc.)
    async function initReadOnlyIO() {
      if (ioReadOnly) return ioReadOnly;

      // Create a basic WebIO for read/write operations (textures, updates)
      ioReadOnly = new WebIO().registerExtensions(ALL_EXTENSIONS);

      if (!dracoDecoder && typeof DracoDecoderModule === 'function') {
        setProgress('Initializing Draco decoder...');
        await new Promise(requestAnimationFrame);
        dracoDecoder = await withTimeout(
          Promise.resolve(DracoDecoderModule({
            locateFile: (file) => (file.endsWith('.wasm')
              ? 'https://unpkg.com/draco3dgltf@1.5.7/' + file
              : file)
          })),
          60000,
          'Draco decoder init'
        );
      }

      if (dracoDecoder) {
        ioReadOnly.registerDependencies({
          'draco3d.decoder': dracoDecoder
        });
      }

      return ioReadOnly;
    }

    async function ensureDracoDecoder() {
      if (dracoDecoder) return;
      if (typeof DracoDecoderModule !== 'function') {
        throw new Error('Draco decoder not available. Ensure draco3dgltf UMD is loaded.');
      }
      setProgress('Initializing Draco decoder...');
      await new Promise(requestAnimationFrame);
      dracoDecoder = await withTimeout(
        Promise.resolve(DracoDecoderModule({
          locateFile: (file) => (file.endsWith('.wasm')
            ? 'https://unpkg.com/draco3dgltf@1.5.7/' + file
            : file)
        })),
        60000,
        'Draco decoder init'
      );
    }

    async function ensureDracoEncoderForWrite(targetIO) {
      if (!dracoEncoder) {
        if (typeof DracoEncoderModule !== 'function') {
          throw new Error('Draco encoder not available. Ensure draco3dgltf UMD is loaded.');
        }
        setProgress('Initializing Draco encoder...');
        await new Promise(requestAnimationFrame);
        dracoEncoder = await withTimeout(
          Promise.resolve(DracoEncoderModule({
            locateFile: (file) => (file.endsWith('.wasm')
              ? 'https://unpkg.com/draco3dgltf@1.5.7/' + file
              : file)
          })),
          60000,
          'Draco encoder init'
        );
      }

      if (targetIO && dracoEncoder) {
        targetIO.registerDependencies({
          'draco3d.encoder': dracoEncoder
        });
      }
    }

    // Full initialization for optimization (includes Draco encoder, meshoptimizer)
    async function initGltfTransform() {
      if (io) return;

      setProgress('Initializing Draco encoder...');
      await new Promise(requestAnimationFrame);
      if (typeof DracoEncoderModule === 'function') {
        // Use the global DracoEncoderModule from draco3dgltf UMD build
        dracoEncoder = await withTimeout(
          Promise.resolve(DracoEncoderModule({
            locateFile: (file) => (file.endsWith('.wasm')
              ? 'https://unpkg.com/draco3dgltf@1.5.7/' + file
              : file)
          })),
          60000,
          'Draco encoder init'
        );
      } else {
        throw new Error('Draco encoder not available. Ensure draco3dgltf UMD is loaded.');
      }

      await ensureDracoDecoder();

      io = new WebIO()
        .registerExtensions([...ALL_EXTENSIONS, KHRDracoMeshCompression])
        .registerDependencies({
          'draco3d.encoder': dracoEncoder,
          'draco3d.decoder': dracoDecoder
        });

      // Initialize meshoptimizer simplifier
      setProgress('Initializing meshoptimizer...');
      await new Promise(requestAnimationFrame);
      await withTimeout(MeshoptSimplifier.ready, 60000, 'Meshoptimizer init');
      meshoptSimplifier = MeshoptSimplifier;
    }

    function setProgress(text) {
      if (text) {
        currentProgressText = text;
        progressText.textContent = text;
        progressText.style.display = 'block';
        optimizeStep.textContent = text;
      } else {
        currentProgressText = '';
        progressText.style.display = 'none';
      }
    }

    function showOptimizeOverlay(show) {
      if (show) {
        optimizeOverlay.classList.add('visible');
      } else {
        optimizeOverlay.classList.remove('visible');
      }
    }

    function setOptimizeWarningVisible(show) {
      if (!optimizeWarning) return;
      optimizeWarning.style.display = show ? 'block' : 'none';
    }

    function updateViewToggle() {
      if (!optimizedArrayBuffer) {
        viewToggle.style.display = 'none';
        return;
      }

      viewToggle.style.display = 'inline';
      viewToggle.textContent = isShowingOptimized ? 'See original' : 'View optimised';
    }

    function updateModelStatus() {
      const hasOptimized = !!optimizedArrayBuffer;
      let text = '';

      if (hasNewTextures && hasOptimized) {
        text = 'New texture + optimised';
      } else if (hasNewTextures) {
        text = 'New texture';
      } else if (hasOptimized) {
        text = 'Optimised';
      }

      if (text) {
        statusMessageText.textContent = text;
        modelStatus.style.display = 'flex';
      } else {
        modelStatus.style.display = 'none';
      }

      const hasChanges = hasNewTextures || hasOptimized;
      downloadBtn.style.display = hasModel ? 'block' : 'none';
      downloadBtn.disabled = !hasChanges;
      if (hasOptimized) {
        downloadBtn.textContent = 'Download (Optimised)';
      } else if (hasNewTextures) {
        downloadBtn.textContent = 'Download (Updated)';
      } else {
        downloadBtn.textContent = 'Download';
      }

      if (hasOptimized) {
        statusMessageText.textContent = 'Optimised.';
      } else if (hasNewTextures) {
        statusMessageText.textContent = 'Textures updated.';
      } else {
        statusMessageText.textContent = 'Model ready.';
      }
      updateViewToggle();
    }

    function showStatusMessage(text, isError = false) {
      statusMessageText.textContent = text;
      modelStatus.style.display = 'flex';
      modelStatus.classList.toggle('error', isError);
    }

    async function reloadCurrentView() {
      if (isOptimizing) return;
      const buffer = (isShowingOptimized && optimizedArrayBuffer) ? optimizedArrayBuffer : originalArrayBuffer;
      if (!buffer) return;
      await loadModelFromArrayBuffer(buffer, false);
      updateModelStatus();
    }

    function attachCanvasHandlers() {
      if (canvasHandlersAttached) return;
      const canvas = viewerContainer.querySelector('canvas');
      if (!canvas) return;
      canvasHandlersAttached = true;

      canvas.addEventListener('webglcontextlost', (event) => {
        event.preventDefault();
        showStatusMessage('WebGL context lost. Restoring...', true);
      }, { passive: false });

      canvas.addEventListener('webglcontextrestored', async () => {
        showStatusMessage('Restoring view...', false);
        await reloadCurrentView();
      });
    }

    function isImageFile(file) {
      return file && file.type && file.type.startsWith('image/');
    }

    function isModelFile(file) {
      if (!file || !file.name) return false;
      const name = file.name.toLowerCase();
      return name.endsWith('.glb') || name.endsWith('.gltf');
    }

    function normalizeName(value) {
      let name = (value || '')
        .toLowerCase()
        .replace(/\.[^.]+$/, '')
        .replace(/[_\-\s]+/g, ' ')
        .trim();

      name = name
        .replace(/\s*\(\d+\)\s*$/, '')
        .replace(/\s*\[\d+\]\s*$/, '')
        .replace(/\s*[-_]?\d+\s*$/, '')
        .replace(/\s+(copy|final)\s*$/, '')
        .trim();

      return name;
    }

    function getTextureIndexFromFilename(filename) {
      const base = (filename || '')
        .toLowerCase()
        .replace(/\.[^.]+$/, '')
        .trim();
      const match = base.match(/^texture\s*[-_]?\s*(\d+)/);
      if (!match) return null;
      const index = Number(match[1]);
      return Number.isFinite(index) ? index : null;
    }

    function detectTextureSlot(filename) {
      const name = normalizeName(filename);
      const slotMap = [
        { key: 'normal', slot: 'normal' },
        { key: 'nrm', slot: 'normal' },
        { key: 'nor', slot: 'normal' },
        { key: 'roughness', slot: 'roughness' },
        { key: 'rough', slot: 'roughness' },
        { key: 'metallic', slot: 'metallic' },
        { key: 'metal', slot: 'metallic' },
        { key: 'orm', slot: 'occlusionRoughnessMetallic' },
        { key: 'occlusion', slot: 'occlusion' },
        { key: 'ao', slot: 'occlusion' },
        { key: 'emissive', slot: 'emissive' },
        { key: 'emission', slot: 'emissive' },
        { key: 'basecolor', slot: 'baseColor' },
        { key: 'base color', slot: 'baseColor' },
        { key: 'albedo', slot: 'baseColor' },
        { key: 'diffuse', slot: 'baseColor' },
        { key: 'color', slot: 'baseColor' }
      ];

      for (const entry of slotMap) {
        if (name.includes(entry.key)) return entry.slot;
      }

      return 'baseColor';
    }

    function findMaterialForFile(materials, filename) {
      if (materials.length === 0) return null;
      if (materials.length === 1) return materials[0];

      const fileName = normalizeName(filename);
      let best = null;
      let bestScore = 0;

      for (const material of materials) {
        const matName = normalizeName(material.getName());
        if (!matName) continue;
        if (fileName.includes(matName) && matName.length > bestScore) {
          best = material;
          bestScore = matName.length;
        }
      }

      return best;
    }

    function findTextureForFile(textures, filename) {
      if (textures.length === 0) return null;
      if (textures.length === 1) return textures[0];

      const fileName = normalizeName(filename);
      let best = null;
      let bestScore = 0;

      for (const texture of textures) {
        const texName = normalizeName(texture.getName());
        if (!texName) continue;
        if (fileName === texName) return texture;
        if (fileName.includes(texName) || texName.includes(fileName)) {
          const score = Math.min(fileName.length, texName.length);
          if (score > bestScore) {
            best = texture;
            bestScore = score;
          }
        }
      }

      return best;
    }

    function findTexturesForFile(textures, filename) {
      if (textures.length === 0) return [];
      const fileName = normalizeName(filename);
      return textures.filter((texture) => normalizeName(texture.getName()) === fileName);
    }

    function getTextureUsageMap(materials) {
      const usage = new Map();
      const mark = (texture, isColor) => {
        if (!texture) return;
        const prev = usage.get(texture);
        if (prev === 'color') return;
        usage.set(texture, isColor ? 'color' : 'data');
      };

      materials.forEach((material) => {
        if (!material) return;
        mark(material.getBaseColorTexture?.(), true);
        mark(material.getEmissiveTexture?.(), true);
        mark(material.getNormalTexture?.(), false);
        mark(material.getMetallicRoughnessTexture?.(), false);
        mark(material.getOcclusionTexture?.(), false);
      });

      return usage;
    }

    async function getMaxTextureDimension(textures) {
      let maxDim = null;
      for (const texture of textures) {
        const image = texture.getImage();
        if (!image) continue;
        const mimeType = texture.getMimeType() || 'image/png';
        try {
          const blob = new Blob([image], { type: mimeType });
          const bitmap = await createImageBitmap(blob);
          const dim = Math.max(bitmap.width, bitmap.height);
          if (typeof bitmap.close === 'function') bitmap.close();
          maxDim = maxDim == null ? dim : Math.max(maxDim, dim);
        } catch (err) {
          console.warn('Texture decode failed for size check:', err);
        }
      }
      return maxDim;
    }

    function withTimeout(promise, ms, label) {
      if (!ms) return promise;
      return new Promise((resolve, reject) => {
        const t = setTimeout(() => {
          reject(new Error(`${label} timed out after ${Math.round(ms / 1000)}s`));
        }, ms);
        promise
          .then((result) => {
            clearTimeout(t);
            resolve(result);
          })
          .catch((err) => {
            clearTimeout(t);
            reject(err);
          });
      });
    }

    function initKtx2Decoder() {
      if (ktx2Loader) return ktx2Loader;

      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      canvas.style.display = 'none';
      document.body.appendChild(canvas);

      ktx2Renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        preserveDrawingBuffer: true
      });
      ktx2Renderer.setClearColor(0x000000, 0);
      ktx2Renderer.setSize(1, 1, false);

      ktx2Scene = new THREE.Scene();
      ktx2Camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const geometry = new THREE.PlaneGeometry(2, 2);
      const material = new THREE.MeshBasicMaterial({
        transparent: true
      });
      ktx2Quad = new THREE.Mesh(geometry, material);
      ktx2Scene.add(ktx2Quad);

      ktx2Loader = new KTX2Loader();
      ktx2Loader.setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/libs/basis/');
      ktx2Loader.detectSupport(ktx2Renderer);

      return ktx2Loader;
    }

    async function decodeKtx2ToPng(imageData, colorSpace = 'data') {
      const loader = initKtx2Decoder();
      const blob = new Blob([imageData], { type: 'image/ktx2' });
      const url = URL.createObjectURL(blob);

      try {
        const texture = await loader.loadAsync(url);
        const width = texture?.image?.width || 1;
        const height = texture?.image?.height || 1;

        ktx2Renderer.toneMapping = THREE.NoToneMapping;
        const outputColorSpace = colorSpace === 'color'
          ? (THREE.SRGBColorSpace || THREE.LinearSRGBColorSpace)
          : (THREE.NoColorSpace || THREE.LinearSRGBColorSpace || THREE.SRGBColorSpace);
        if ('outputColorSpace' in ktx2Renderer) {
          ktx2Renderer.outputColorSpace = outputColorSpace;
        }
        if ('colorSpace' in texture) {
          texture.colorSpace = outputColorSpace;
        }

        ktx2Renderer.setSize(width, height, false);
        ktx2Quad.material.map = texture;
        ktx2Quad.material.needsUpdate = true;

        const renderTarget = new THREE.WebGLRenderTarget(width, height, {
          format: THREE.RGBAFormat,
          type: THREE.UnsignedByteType
        });

        ktx2Renderer.setRenderTarget(renderTarget);
        ktx2Renderer.clear();
        ktx2Renderer.render(ktx2Scene, ktx2Camera);

        const buffer = new Uint8Array(width * height * 4);
        ktx2Renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);

        ktx2Renderer.setRenderTarget(null);
        renderTarget.dispose();

        // Flip Y axis
        const rowSize = width * 4;
        const flipped = new Uint8ClampedArray(buffer.length);
        for (let y = 0; y < height; y++) {
          const srcStart = y * rowSize;
          const dstStart = (height - 1 - y) * rowSize;
          flipped.set(buffer.subarray(srcStart, srcStart + rowSize), dstStart);
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          throw new Error('Canvas 2D context not available.');
        }
        const image = new ImageData(flipped, width, height);
        ctx.putImageData(image, 0, 0);

        const pngBlob = await new Promise((resolve, reject) => {
          canvas.toBlob((result) => {
            if (result) resolve(result);
            else reject(new Error('Failed to encode PNG.'));
          }, 'image/png');
        });

        texture.dispose();
        return pngBlob;
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    // The optimization pipeline matching the shell script
    async function optimizeModel(arrayBuffer) {
      await new Promise(requestAnimationFrame);
      await initGltfTransform();

      setProgress('Reading model...');
      const gltfDocument = await io.readBinary(new Uint8Array(arrayBuffer));

      // Get initial stats
      const root = gltfDocument.getRoot();
      let totalTris = 0;
      for (const mesh of root.listMeshes()) {
        for (const prim of mesh.listPrimitives()) {
          const indices = prim.getIndices();
          if (indices) {
            totalTris += indices.getCount() / 3;
          } else {
            const pos = prim.getAttribute('POSITION');
            if (pos) totalTris += pos.getCount() / 3;
          }
        }
      }

      const transforms = [];

      // Always run dedup/weld/join; simplify only if needed
      transforms.push({
        label: 'Removing duplicates...',
        transform: dedup()
      });

      transforms.push({
        label: 'Welding vertices...',
        transform: weld()
      });

      transforms.push({
        label: 'Joining meshes...',
        transform: join()
      });

      // Simplify only if over target polycount
      if (totalTris > 1200000) {
        setProgress(`High polygon count (${Math.round(totalTris).toLocaleString()} tris). Running simplification...`);
        const targetRatio = 1200000 / totalTris;
        transforms.push({
          label: `Simplifying to ~1.2M triangles (ratio: ${targetRatio.toFixed(3)})...`,
          transform: simplify({
            simplifier: meshoptSimplifier,
            ratio: Math.max(targetRatio, 0.1),
            error: 0.005,
            lockBorder: true
          })
        });
      }

      const texturesList = root.listTextures();
      const hasTextures = texturesList.length > 0;

      if (hasTextures) {
        const supportedMimeTypes = new Set(['image/jpeg', 'image/png', 'image/webp']);
        const ktx2Candidates = texturesList.filter((t) => {
          const type = t.getMimeType();
          return type && supportedMimeTypes.has(type);
        });
        let maxTextureDimension = null;
        if (typeof createImageBitmap === 'function') {
          try {
            maxTextureDimension = await getMaxTextureDimension(texturesList);
          } catch (err) {
            console.warn('Texture size check failed, skipping resize:', err);
          }
        }

        if (maxTextureDimension && maxTextureDimension > 8192) {
          transforms.push({
            label: 'Resizing textures to 8192x8192...',
            transform: textureCompress({
              resize: [8192, 8192]
            })
          });
        }

        // Step 6: KTX2/ETC1S texture compression with quality 64 (shell script line 318)
        transforms.push({
          label: 'Converting textures to KTX2/ETC1S...',
          transform: ktx2({
            isUASTC: false, // ETC1S mode
            enableDebug: true, // Enable debug to see what's happening
            generateMipmap: true,
            quality: 64, // Match shell script quality
            encoderPath: 'https://unpkg.com/ktx2-encoder@0.5.1/dist/basis/?v=20260127',
            wasmUrl: 'https://unpkg.com/ktx2-encoder@0.5.1/dist/basis/basis_encoder.wasm?v=20260127',
            jsUrl: 'https://unpkg.com/ktx2-encoder@0.5.1/dist/basis/basis_encoder.js?v=20260127'
          }),
          postCheck: () => {
            const failed = ktx2Candidates.filter((t) => t.getMimeType() !== 'image/ktx2');
            if (failed.length > 0) {
              throw new Error(`KTX2 conversion failed for ${failed.length} texture(s).`);
            }
          }
        });
      }

      // Step 7: Draco compression with 20-bit quantization (shell script lines 322-330)
      transforms.push({
        label: 'Applying 20-bit Draco compression...',
        transform: draco({
          method: 'sequential', // Preserves vertex order (important for multi-texture models)
          encodeSpeed: 0,
          decodeSpeed: 0,
          quantizePosition: 20,
          quantizeNormal: 20,
          quantizeColor: 20,
          quantizeTexcoord: 20,
          quantizeGeneric: 20
        })
      });

      // Apply transforms sequentially to show accurate progress
      for (const step of transforms) {
        setProgress(step.label);
        await new Promise(requestAnimationFrame);
        if (step.timeoutMs) {
          await withTimeout(gltfDocument.transform(step.transform), step.timeoutMs, step.label);
        } else {
          await gltfDocument.transform(step.transform);
        }
        if (step.postCheck) {
          step.postCheck();
        }
      }

      // Write to GLB
      setProgress('Writing GLB...');
      const optimizedGlb = await io.writeBinary(gltfDocument);

      setProgress(null);
      return optimizedGlb.buffer;
    }

    async function runOptimization() {
      if (!originalArrayBuffer || isOptimizing) return;

      isOptimizing = true;
      optimiseBtn.disabled = true;
      optimiseBtn.textContent = 'Optimising...';
      showOptimizeOverlay(true);
      setOptimizeWarningVisible(true);
      setProgress('Preparing optimisation...');
      await new Promise(requestAnimationFrame);
      await new Promise((resolve) => setTimeout(resolve, 0));

      try {
        optimizedArrayBuffer = await optimizeModel(originalArrayBuffer);

        // Show the optimized model
        await loadModelFromArrayBuffer(optimizedArrayBuffer, true);
        isShowingOptimized = true;

        // Update UI
        optimiseBtn.style.display = 'none';
        downloadBtn.style.display = 'block';
        updateViewToggle();
        updateModelStatus();

      } catch (err) {
        console.error('Optimisation failed:', err);
        alert('Optimisation failed: ' + err.message);
        optimiseBtn.textContent = 'Optimise';
        optimiseBtn.disabled = false;
        showStatusMessage(`Optimisation failed: ${err.message}`, true);
      } finally {
        isOptimizing = false;
        showOptimizeOverlay(false);
        setOptimizeWarningVisible(false);
        if (!optimizedArrayBuffer) {
          optimiseBtn.textContent = 'Optimise';
          optimiseBtn.disabled = false;
        }
      }
    }

    async function toggleView() {
      if (!originalArrayBuffer || !optimizedArrayBuffer) return;

      isShowingOptimized = !isShowingOptimized;
      const buffer = isShowingOptimized ? optimizedArrayBuffer : originalArrayBuffer;
      await loadModelFromArrayBuffer(buffer, false);
      updateViewToggle();
    }

    function downloadOptimized() {
      const hasOptimized = !!optimizedArrayBuffer;
      const hasUpdated = !!originalArrayBuffer && hasNewTextures;
      if (!hasOptimized && !hasUpdated) return;

      const buffer = hasOptimized ? optimizedArrayBuffer : originalArrayBuffer;
      const blob = new Blob([buffer], { type: 'model/gltf-binary' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const baseName = originalFileName.replace(/\.(glb|gltf)$/i, '');
      a.download = hasOptimized ? `${baseName}-optimised.glb` : `${baseName}-edited.glb`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Event listeners for buttons
    optimiseBtn.addEventListener('click', runOptimization);
    downloadBtn.addEventListener('click', downloadOptimized);
    viewToggle.addEventListener('click', toggleView);

    // Helper to load model from ArrayBuffer
    async function loadModelFromArrayBuffer(arrayBuffer, updateDiskSize = true) {
      const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
      const url = URL.createObjectURL(blob);

      if (updateDiskSize) {
        lastBlobSize = arrayBuffer.byteLength;
      }

      try {
        if (hasModel) {
          viewer.belowViewer.clearModels();
        }
        await viewer.belowViewer.loadModel(url, { autoFrame: !hasModel });
        hasModel = true;

        attachCanvasHandlers();

        updateCameraSnippet();

        // Update stats
        const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
        const stats = collectModelStats(modelRoot);
        updateStatsDisplay(stats);
        updateModelStatus();
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    // Reset optimization state when loading new model
    function resetOptimizationState() {
      originalArrayBuffer = null;
      optimizedArrayBuffer = null;
      isShowingOptimized = false;
      hasNewTextures = false;

      optimiseBtn.textContent = 'Optimise';
      optimiseBtn.disabled = false;
      optimiseBtn.style.display = 'block';
      downloadBtn.style.display = 'none';
      modelStatus.style.display = 'none';
      setProgress(null);
      updateModelStatus();
    }

    // Create fullscreen viewer container
    const viewerContainer = document.createElement('div');
    viewerContainer.style.position = 'fixed';
    viewerContainer.style.inset = '0';
    viewerContainer.style.zIndex = '0';
    document.body.appendChild(viewerContainer);

    // Move mode toggle into viewer container for proper layering and fullscreen support
    const modeToggle = document.getElementById('modeToggleContainer');
    if (modeToggle) {
      viewerContainer.appendChild(modeToggle);
    }

    // Configure viewer with dark theme and standalone mode toggle
    const viewer = new ModelViewer(viewerContainer, {
      models: models,
      autoLoadFirst: false,
      showDiveToggle: false,
      enableVR: true,
      enableVRAudio: false,
      enableFullscreen: true,
      enableScreenshot: true,
      showInfo: false,
      showLoadingIndicator: true,
      // No initial model - starts empty
      viewerConfig: {
        scene: {
          background: { type: 'color', value: '#0f172a' }
        }
      }
    });

    const dragOverlay = document.getElementById('dragOverlay');
    const emptyState = document.getElementById('emptyState');
    const loadedHint = document.getElementById('loadedHint');
    const fileInput = document.getElementById('fileInput');
    const cameraSnippet = document.getElementById('cameraSnippet');
    const camCode = document.getElementById('camCode');
    const copyCamBtn = document.getElementById('copyCamBtn');
    const statTris = document.getElementById('statTris');
    const statDisk = document.getElementById('statDisk');
    const statVram = document.getElementById('statVram');
    const statDraws = document.getElementById('statDraws');
    let dragCounter = 0;
    let hasModel = false;
    let lastBlobSize = null; // bytes

    // Format a number to 2 decimals, keep trailing zeros to avoid width changes
    const fmt = (n) => Number(n).toFixed(2);
    const fmtInt = (n) => new Intl.NumberFormat().format(n | 0);
    const fmtBytes = (bytes) => {
      if (bytes == null) return '‚Äî';
      const units = ['B', 'KB', 'MB', 'GB'];
      let i = 0; let v = bytes;
      while (v >= 1000 && i < units.length - 1) { v /= 1000; i++; }
      return `${v.toFixed(1)} ${units[i]}`;
    };

    function vramForTexture(tex) {
      // Exact path for KTX2 compressed textures loaded via KTX2Loader
      const img = tex?.image;
      // three.js KTX2 loader uses CompressedTexture with mipmaps on the texture
      if ((tex?.isCompressedTexture || Array.isArray(tex?.mipmaps)) && tex.mipmaps && tex.mipmaps.length > 0) {
        let bytes = 0;
        for (const level of tex.mipmaps) {
          if (level?.data?.byteLength) bytes += level.data.byteLength;
        }
        return { bytes, exact: true };
      }
      // Non-compressed textures: estimate
      try {
        const w = img?.width || tex.source?.data?.width || img?.videoWidth || 0;
        const h = img?.height || tex.source?.data?.height || img?.videoHeight || 0;
        if (!w || !h) return { bytes: 0, exact: false };
        const base = w * h * 4;
        const mipOverhead = 1.33;
        return { bytes: Math.round(base * mipOverhead), exact: false };
      } catch { return { bytes: 0, exact: false }; }
    }

    function collectModelStats(root) {
      let tris = 0;
      let meshes = 0;
      let textures = new Set();
      let vramGeom = 0;
      let vramTex = 0;
      let texExactCount = 0;
      let draws = 0;

      root.traverse((obj) => {
        if (obj.isMesh) {
          meshes++;
          const geom = obj.geometry;
          if (geom) {
            // Triangle count
            const index = geom.index;
            if (index) {
              tris += index.count / 3;
            } else if (geom.attributes?.position) {
              tris += geom.attributes.position.count / 3;
            }
            // VRAM for geometry: sum unique underlying arrays (avoid double counting interleaved/shared buffers)
            const seenArrays = new Set();
            const addArray = (arr) => {
              if (!arr) return;
              if (!seenArrays.has(arr)) {
                seenArrays.add(arr);
                vramGeom += arr.byteLength || 0;
              }
            };
            for (const key in geom.attributes) {
              const attr = geom.attributes[key];
              if (!attr) continue;
              // InterleavedBufferAttribute stores data on attr.data.array
              if (attr.isInterleavedBufferAttribute) {
                addArray(attr.data && attr.data.array);
              } else {
                addArray(attr.array);
              }
            }
            if (geom.index) {
              addArray(geom.index.array);
            }
          }
          // Materials -> textures
          const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
          mats.forEach((m) => {
            if (!m) return;
            for (const prop in m) {
              const val = m[prop];
              if (val && val.isTexture) textures.add(val);
            }
          });
          // Draw calls: for non-instanced meshes, one draw per geometry group (or 1 if none)
          const groupCount = (geom && geom.groups && geom.groups.length) ? geom.groups.length : 1;
          draws += groupCount;
        }
      });

      // VRAM for textures (exact for compressed KTX2)
      textures.forEach((t) => {
        const { bytes, exact } = vramForTexture(t);
        vramTex += bytes;
        if (exact) texExactCount++;
      });

      return { tris: Math.round(tris), meshes, textures: textures.size, vramGeom, vramTex, texExactCount, draws };
    }

    function updateStatsDisplay({ tris, vramGeom, vramTex, draws }) {
      const totalVRAM = vramGeom + vramTex;
      statVram.textContent = fmtBytes(totalVRAM);
      statDisk.textContent = lastBlobSize != null ? fmtBytes(lastBlobSize) : '‚Äî';
      statDraws.textContent = fmtInt(draws);
      statTris.textContent = fmtInt(tris);

      // Thresholds
      const TRI_LIMIT = 1_500_000;
      const DISK_LIMIT = 100 * 1000 * 1000; // 100 MB (decimal)
      const VRAM_LIMIT = 400 * 1000 * 1000; // 400 MB (decimal)

      // Helpers to set warning state
      const setWarn = (elValue, isWarn) => {
        if (isWarn) elValue.classList.add('warn');
        else elValue.classList.remove('warn');
      };

      setWarn(statTris, tris > TRI_LIMIT);
      setWarn(statDisk, (lastBlobSize ?? 0) > DISK_LIMIT);
      setWarn(statVram, totalVRAM > VRAM_LIMIT);
    }

    // Build the desktop camera/target snippet string
    function buildDesktopSnippet() {
      const camera = viewer?.belowViewer?.cameraManager?.getCamera?.();
      const controls = viewer?.belowViewer?.cameraManager?.getControls?.();
      if (!camera || !controls) return `desktop: {\n  camera: { x: 0, y: 5, z: 10 },\n  target: { x: 0, y: 0, z: 0 }\n},`;
      const cx = fmt(camera.position.x);
      const cy = fmt(camera.position.y);
      const cz = fmt(camera.position.z);
      const tx = fmt(controls.target.x);
      const ty = fmt(controls.target.y);
      const tz = fmt(controls.target.z);
      return `desktop: {\n  camera: { x: ${cx}, y: ${cy}, z: ${cz} },\n  target: { x: ${tx}, y: ${ty}, z: ${tz} }\n},`;
    }

    // Update the UI with current camera values
    function updateCameraSnippet() {
      camCode.textContent = buildDesktopSnippet();
    }

    // Copy to clipboard handler
    async function doCopy(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      }
      // Feedback
      cameraSnippet.style.boxShadow = '0 0 0 2px rgba(59,130,246,0.45), 0 8px 24px rgba(0,0,0,0.35)';
      const prev = copyCamBtn.textContent;
      copyCamBtn.textContent = 'Copied';
      setTimeout(() => {
        copyCamBtn.textContent = prev;
        cameraSnippet.style.boxShadow = '0 8px 24px rgba(0,0,0,0.35)';
      }, 900);
    }

    copyCamBtn.addEventListener('click', async () => {
      await doCopy(camCode.textContent);
    });

    // Copy is handled via the button

    // Handle file input selection
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await loadModelFile(e.target.files);
      }
    });

    // Texture management functions
    async function downloadTextures() {
      if (!originalArrayBuffer) return;

      showOptimizeOverlay(true);
      setProgress('Extracting textures...');

      try {
        const readIO = await initReadOnlyIO();
        const gltfDocument = await readIO.readBinary(new Uint8Array(originalArrayBuffer));
        const root = gltfDocument.getRoot();
        const textures = root.listTextures();
        const materials = root.listMaterials();
        const textureUsage = getTextureUsageMap(materials);

        if (textures.length === 0) {
          alert('No textures found in model');
          return;
        }

        // Create a zip-like download with all textures
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i];
          const image = texture.getImage();
          if (!image) continue;

          const mimeType = texture.getMimeType() || 'image/png';
          const name = texture.getName() || `texture_${i}`;

          let blob;
          let ext;

          if (mimeType === 'image/ktx2') {
            setProgress(`Decoding KTX2 texture ${i + 1} of ${textures.length}...`);
            try {
              const usage = textureUsage.get(texture) || 'data';
              blob = await decodeKtx2ToPng(image, usage);
              ext = 'png';
            } catch (decodeError) {
              console.warn('KTX2 decode failed, downloading original:', decodeError);
              blob = new Blob([image], { type: mimeType });
              ext = 'ktx2';
            }
          } else {
            blob = new Blob([image], { type: mimeType });
            ext = mimeType.split('/')[1] || 'png';
          }

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${name}.${ext}`;
          a.click();
          URL.revokeObjectURL(url);

          await new Promise(r => setTimeout(r, 100)); // Delay between downloads
        }
      } catch (err) {
        console.error('Failed to extract textures:', err);
        alert('Failed to extract textures: ' + err.message);
      } finally {
        showOptimizeOverlay(false);
      }
    }

    async function uploadTextures() {
      textureInput.click();
    }

    async function applyUploadedTextures(files) {
      const sourceBuffer = (isShowingOptimized && optimizedArrayBuffer)
        ? optimizedArrayBuffer
        : originalArrayBuffer;
      if (!sourceBuffer || files.length === 0) return;

      showOptimizeOverlay(true);
      setOptimizeWarningVisible(false);
      setProgress('Applying new textures...');

      try {
        const readIO = await initReadOnlyIO();
        const gltfDocument = await readIO.readBinary(new Uint8Array(sourceBuffer));
        const root = gltfDocument.getRoot();
        const textures = root.listTextures();
        const materials = root.listMaterials();
        const unmatchedFiles = [];
        const textureUsage = getTextureUsageMap(materials);

        // Match uploaded files to textures by name
        for (const file of files) {
          const fileName = file.name.replace(/\.[^.]+$/, ''); // Remove extension
          const textureIndex = getTextureIndexFromFilename(file.name);
          const indexedTexture = textureIndex != null ? textures[textureIndex] : null;
          const exactMatches = indexedTexture ? [indexedTexture] : findTexturesForFile(textures, file.name);
          const bestMatch = (exactMatches.length > 0) ? null : findTextureForFile(textures, file.name);

          if (exactMatches.length > 0 || bestMatch) {
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const targets = exactMatches.length > 0 ? exactMatches : [bestMatch];
            targets.forEach((texture) => {
              if (!texture) return;
              texture.setImage(uint8Array);
              texture.setMimeType(file.type);
            });
            const count = targets.length;
            setProgress(`Updated texture${count > 1 ? 's' : ''}: ${fileName}`);

            const anyUsed = targets.some((texture) => textureUsage.has(texture));
            if (!anyUsed) {
              const targetMaterial = findMaterialForFile(materials, file.name);
              const slot = detectTextureSlot(file.name);
              const fallbackTexture = targets.find(Boolean);

              if (targetMaterial && fallbackTexture) {
                switch (slot) {
                  case 'normal':
                    targetMaterial.setNormalTexture(fallbackTexture);
                    break;
                  case 'metallic':
                  case 'roughness':
                    targetMaterial.setMetallicRoughnessTexture(fallbackTexture);
                    break;
                  case 'occlusion':
                    targetMaterial.setOcclusionTexture(fallbackTexture);
                    break;
                  case 'emissive':
                    targetMaterial.setEmissiveTexture(fallbackTexture);
                    break;
                  case 'occlusionRoughnessMetallic':
                    targetMaterial.setOcclusionTexture(fallbackTexture);
                    targetMaterial.setMetallicRoughnessTexture(fallbackTexture);
                    break;
                  case 'baseColor':
                  default:
                    targetMaterial.setBaseColorTexture(fallbackTexture);
                    break;
                }
                textureUsage.set(fallbackTexture, textureUsage.get(fallbackTexture) || (slot === 'baseColor' || slot === 'emissive' ? 'color' : 'data'));
                setProgress(`Applied ${slot} texture to: ${targetMaterial.getName() || 'Material'}`);
              }
            }
          } else {
            unmatchedFiles.push(file);
          }
        }

        // If no matching texture, map intelligently to materials/slots
        if (unmatchedFiles.length > 0) {
          for (const file of unmatchedFiles) {
            const fileName = file.name.replace(/\.[^.]+$/, '');
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const mimeType = file.type || 'image/png';

            const newTexture = gltfDocument.createTexture(fileName)
              .setImage(uint8Array)
              .setMimeType(mimeType);

            const targetMaterial = findMaterialForFile(materials, file.name);
            const slot = detectTextureSlot(file.name);

            if (!targetMaterial) {
              setProgress(`Skipped texture (no match): ${fileName}`);
              continue;
            }

            switch (slot) {
              case 'normal':
                targetMaterial.setNormalTexture(newTexture);
                break;
              case 'metallic':
                targetMaterial.setMetallicRoughnessTexture(newTexture);
                break;
              case 'roughness':
                targetMaterial.setMetallicRoughnessTexture(newTexture);
                break;
              case 'occlusion':
                targetMaterial.setOcclusionTexture(newTexture);
                break;
              case 'emissive':
                targetMaterial.setEmissiveTexture(newTexture);
                break;
              case 'occlusionRoughnessMetallic':
                targetMaterial.setOcclusionTexture(newTexture);
                targetMaterial.setMetallicRoughnessTexture(newTexture);
                break;
              case 'baseColor':
              default:
                targetMaterial.setBaseColorTexture(newTexture);
                break;
            }

            setProgress(`Applied ${slot} texture to: ${targetMaterial.getName() || 'Material'}`);
          }
        }

        // Update KHR_texture_basisu usage based on current texture types
        const hasKtx2 = root.listTextures().some((t) => t.getMimeType() === 'image/ktx2');
        const basisuExt = gltfDocument.getRoot().listExtensionsUsed()
          .find((ext) => ext.extensionName === KHRTextureBasisu.EXTENSION_NAME);
        if (basisuExt) {
          basisuExt.setRequired(hasKtx2);
          if (!hasKtx2 && typeof gltfDocument.disposeExtension === 'function') {
            gltfDocument.disposeExtension(KHRTextureBasisu.EXTENSION_NAME);
          }
        }

        // Ensure Draco encoder is available if the document uses it
        const usesDraco = gltfDocument.getRoot().listExtensionsUsed()
          .some((ext) => ext.extensionName === KHRDracoMeshCompression.EXTENSION_NAME);
        if (usesDraco) {
          await ensureDracoEncoderForWrite(readIO);
        }

        // Write updated model back to originalArrayBuffer
        const updatedGlb = await readIO.writeBinary(gltfDocument);
        const updatedBuffer = updatedGlb.buffer;
        const wasViewingOptimized = !!(isShowingOptimized && optimizedArrayBuffer);
        hasNewTextures = true;

        if (wasViewingOptimized) {
          optimizedArrayBuffer = updatedBuffer;
        } else {
          originalArrayBuffer = updatedBuffer;
          if (optimizedArrayBuffer) {
            optimizedArrayBuffer = null;
            isShowingOptimized = false;
            optimiseBtn.style.display = 'block';
            optimiseBtn.textContent = 'Optimise';
            optimiseBtn.disabled = false;
            downloadBtn.style.display = 'none';
            updateViewToggle();
          }
        }

        updateModelStatus();

        // Reload the model
        const bufferToLoad = wasViewingOptimized ? updatedBuffer : originalArrayBuffer;
        await loadModelFromArrayBuffer(bufferToLoad, true);

      } catch (err) {
        console.error('Failed to apply textures:', err);
        alert('Failed to apply textures: ' + err.message);
      } finally {
        showOptimizeOverlay(false);
      }
    }

    // Event listeners for texture buttons
    downloadTexturesBtn.addEventListener('click', downloadTextures);
    uploadTexturesBtn.addEventListener('click', uploadTextures);
    textureInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await applyUploadedTextures(e.target.files);
      }
    });

    // Function to load model file(s) and update UI state
    // Supports: single GLB, single GLTF, or GLTF + associated files
    async function loadModelFile(files) {
      // Handle FileList or single File
      const fileList = files instanceof FileList ? Array.from(files) : [files];

      if (fileList.length === 0) return;

      // Find the main model file
      const mainFile = fileList.find(f =>
        f.name.toLowerCase().endsWith('.glb') ||
        f.name.toLowerCase().endsWith('.gltf')
      );

      if (!mainFile) {
        alert('Please select a .glb or .gltf file');
        return;
      }

      // Reset optimization state for new model
      resetOptimizationState();
      originalFileName = mainFile.name;

      // Show loading overlay
      showOptimizeOverlay(true);
      setOptimizeWarningVisible(false);
      setProgress('Loading model...');

      try {
        let arrayBuffer;

        if (mainFile.name.toLowerCase().endsWith('.glb')) {
          // Direct GLB load - no gltf-transform needed!
          arrayBuffer = await mainFile.arrayBuffer();
        } else {
          // GLTF with associated files - need gltf-transform to convert to GLB
          const readIO = await initReadOnlyIO();
          setProgress('Reading GLTF...');

          // Build resource map from associated files
          const resources = {};
          for (const file of fileList) {
            if (file !== mainFile) {
              const buffer = await file.arrayBuffer();
              resources[file.name] = new Uint8Array(buffer);
            }
          }

          // Read the GLTF JSON
          const gltfText = await mainFile.text();
          const gltfJson = JSON.parse(gltfText);

          // Use WebIO to read the GLTF with resources
          const jsonDoc = { json: gltfJson, resources };
          const gltfDocument = await readIO.readJSON(jsonDoc);

          // Convert to GLB
          setProgress('Converting to GLB...');
          const glbData = await readIO.writeBinary(gltfDocument);
          arrayBuffer = glbData.buffer;

          setProgress(null);
        }

        // Store original for optimization
        originalArrayBuffer = arrayBuffer;
        lastBlobSize = arrayBuffer.byteLength;

        // Load into viewer
        const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
        const url = URL.createObjectURL(blob);

        try {
          if (hasModel) {
            viewer.belowViewer.clearModels();
          }
          await viewer.belowViewer.loadModel(url, { autoFrame: true });

          // Hide empty state and show loaded hint
          emptyState.style.display = 'none';
          loadedHint.classList.add('visible');
          hasModel = true;

          // Show action buttons
          actionButtons.style.display = 'flex';
          textureButtons.style.display = 'flex';

          updateCameraSnippet();

          // Compute and show stats
          const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
          const stats = collectModelStats(modelRoot);
          updateStatsDisplay(stats);
          setProgress(null);
        } finally {
          URL.revokeObjectURL(url);
        }
      } catch (err) {
        console.error('Failed to load model:', err);
        alert('Failed to load the model: ' + err.message);
      } finally {
        showOptimizeOverlay(false);
      }
    }

    // Show overlay when dragging files over the page
    window.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      dragOverlay.classList.add('visible');
    });

    // Restore view when returning to the tab
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible') {
        await reloadCurrentView();
      }
    });

    window.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    // Hide overlay when dragging away
    window.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        dragOverlay.classList.remove('visible');
      }
    });

    // Handle file drop with validation and error handling
    window.addEventListener('drop', async (e) => {
      e.preventDefault();
      dragCounter = 0;
      dragOverlay.classList.remove('visible');

      if (e.dataTransfer.files.length === 0) return;

      const files = Array.from(e.dataTransfer.files);
      const modelFiles = files.filter(isModelFile);
      const imageFiles = files.filter(isImageFile);

      if (modelFiles.length > 0) {
        await loadModelFile(e.dataTransfer.files);
        return;
      }

      if (imageFiles.length > 0) {
        if (!originalArrayBuffer) {
          alert('Load a model before dropping textures.');
          return;
        }
        await applyUploadedTextures(imageFiles);
      }
    });

    // Subscribe to camera changes to keep snippet live-updated
    if (viewer?.belowViewer?.on) {
      viewer.belowViewer.on('camera-change', updateCameraSnippet);
    }

    // Initial update
    updateCameraSnippet();

    // Periodically refresh stats (in case textures finish loading later)
    setInterval(() => {
      if (!hasModel) return;
      const modelRoot = viewer.belowViewer.loadedModels?.[0]?.model || viewer.belowViewer.sceneManager.scene;
      const stats = collectModelStats(modelRoot);
      updateStatsDisplay(stats);
    }, 2000);
  </script>
</body>

</html>
